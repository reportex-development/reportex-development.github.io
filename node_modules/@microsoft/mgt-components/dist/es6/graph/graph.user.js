/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { findPeople, PersonType } from './graph.people';
import { schemas } from './cacheStores';
/**
 * Defines the time it takes for objects in the cache to expire
 */
export const getUserInvalidationTime = () => CacheService.config.users.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether or not the cache is enabled
 */
export const getIsUsersCacheEnabled = () => CacheService.config.users.isEnabled && CacheService.config.isEnabled;
/**
 * async promise, returns Graph User data relating to the user logged in
 *
 * @returns {(Promise<User>)}
 * @memberof Graph
 */
export function getMe(graph, requestedProps) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
            const me = yield cache.getValue('me');
            if (me && getUserInvalidationTime() > Date.now() - me.timeCached) {
                const cachedData = JSON.parse(me.user);
                const uniqueProps = requestedProps
                    ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop))
                    : null;
                // if requestedProps doesn't contain any unique props other than "@odata.context"
                if (!uniqueProps || uniqueProps.length <= 1) {
                    return cachedData;
                }
            }
        }
        let apiString = 'me';
        if (requestedProps) {
            apiString = apiString + '?$select=' + requestedProps.toString();
        }
        const response = graph.api(apiString).middlewareOptions(prepScopes('user.read')).get();
        if (getIsUsersCacheEnabled()) {
            cache.putValue('me', { user: JSON.stringify(yield response) });
        }
        return response;
    });
}
/**
 * async promise, returns all Graph users associated with the userPrincipleName provided
 *
 * @param {string} userPrincipleName
 * @returns {(Promise<User>)}
 * @memberof Graph
 */
export function getUser(graph, userPrincipleName, requestedProps) {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'user.readbasic.all';
        let cache;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
            // check cache
            const user = yield cache.getValue(userPrincipleName);
            // is it stored and is timestamp good?
            if (user && getUserInvalidationTime() > Date.now() - user.timeCached) {
                const cachedData = user.user ? JSON.parse(user.user) : null;
                const uniqueProps = requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;
                // return without any worries
                if (!uniqueProps || uniqueProps.length <= 1) {
                    return cachedData;
                }
            }
        }
        let apiString = `/users/${userPrincipleName}`;
        if (requestedProps) {
            apiString = apiString + '?$select=' + requestedProps.toString();
        }
        // else we must grab it
        const response = yield graph.api(apiString).middlewareOptions(prepScopes(scopes)).get();
        if (getIsUsersCacheEnabled()) {
            cache.putValue(userPrincipleName, { user: JSON.stringify(response) });
        }
        return response;
    });
}
/**
 * Returns a Promise of Graph Users array associated with the user ids array
 *
 * @export
 * @param {IGraph} graph
 * @param {string[]} userIds, an array of string ids
 * @returns {Promise<User[]>}
 */
export function getUsersForUserIds(graph, userIds) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!userIds || userIds.length === 0) {
            return [];
        }
        const batch = graph.createBatch();
        const peopleDict = {};
        const notInCache = [];
        let cache;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.users);
        }
        for (const id of userIds) {
            peopleDict[id] = null;
            let user = null;
            if (getIsUsersCacheEnabled()) {
                user = yield cache.getValue(id);
            }
            if (user && getUserInvalidationTime() > Date.now() - user.timeCached) {
                peopleDict[id] = user.user ? JSON.parse(user.user) : null;
            }
            else if (id !== '') {
                batch.get(id, `/users/${id}`, ['user.readbasic.all']);
                notInCache.push(id);
            }
        }
        try {
            const responses = yield batch.executeAll();
            // iterate over userIds to ensure the order of ids
            for (const id of userIds) {
                const response = responses.get(id);
                if (response && response.content) {
                    peopleDict[id] = response.content;
                    if (getIsUsersCacheEnabled()) {
                        cache.putValue(id, { user: JSON.stringify(response.content) });
                    }
                }
            }
            return Promise.all(Object.values(peopleDict));
        }
        catch (_) {
            // fallback to making the request one by one
            try {
                // call getUser for all the users that weren't cached
                userIds.filter(id => notInCache.includes(id)).forEach(id => (peopleDict[id] = getUser(graph, id)));
                if (getIsUsersCacheEnabled()) {
                    // store all users that weren't retrieved from the cache, into the cache
                    userIds
                        .filter(id => notInCache.includes(id))
                        .forEach((id) => __awaiter(this, void 0, void 0, function* () { return cache.putValue(id, { user: JSON.stringify(yield peopleDict[id]) }); }));
                }
                return Promise.all(Object.values(peopleDict));
            }
            catch (_) {
                return [];
            }
        }
    });
}
/**
 * Returns a Promise of Graph Users array associated with the people queries array
 *
 * @export
 * @param {IGraph} graph
 * @param {string[]} peopleQueries, an array of string ids
 * @returns {Promise<User[]>}
 */
export function getUsersForPeopleQueries(graph, peopleQueries) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!peopleQueries || peopleQueries.length === 0) {
            return [];
        }
        const batch = graph.createBatch();
        const people = [];
        let cacheRes;
        let cache;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
        }
        for (const personQuery of peopleQueries) {
            if (getIsUsersCacheEnabled()) {
                cacheRes = yield cache.getValue(personQuery);
            }
            if (getIsUsersCacheEnabled() && cacheRes && getUserInvalidationTime() > Date.now() - cacheRes.timeCached) {
                people.push(JSON.parse(cacheRes.results[0]));
            }
            else if (personQuery !== '') {
                batch.get(personQuery, `/me/people?$search="${personQuery}"`, ['people.read']);
            }
        }
        try {
            const responses = yield batch.executeAll();
            for (const personQuery of peopleQueries) {
                const response = responses.get(personQuery);
                if (response && response.content && response.content.value && response.content.value.length > 0) {
                    people.push(response.content.value[0]);
                    if (getIsUsersCacheEnabled()) {
                        cache.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(response.content.value[0])] });
                    }
                }
            }
            return people;
        }
        catch (_) {
            try {
                return Promise.all(peopleQueries
                    .filter(personQuery => personQuery && personQuery !== '')
                    .map((personQuery) => __awaiter(this, void 0, void 0, function* () {
                    const personArray = yield findPeople(graph, personQuery, 1);
                    if (personArray && personArray.length) {
                        if (getIsUsersCacheEnabled()) {
                            cache.putValue(personQuery, { maxResults: 1, results: [JSON.stringify(personArray[0])] });
                        }
                        return personArray[0];
                    }
                })));
            }
            catch (_) {
                return [];
            }
        }
    });
}
/**
 * Search Microsoft Graph for Users in the organization
 *
 * @export
 * @param {IGraph} graph
 * @param {string} query - the string to search for
 * @param {number} [top=10] - maximum number of results to return
 * @returns {Promise<User[]>}
 */
export function findUsers(graph, query, top = 10) {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'User.ReadBasic.All';
        const item = { maxResults: top, results: null };
        let cache;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
            const result = yield cache.getValue(query);
            if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
                return result.results.map(userStr => JSON.parse(userStr));
            }
        }
        let graphResult;
        try {
            graphResult = yield graph
                .api('users')
                .header('ConsistencyLevel', 'eventual')
                .count(true)
                .search(`"displayName:${query}" OR "mail:${query}"`)
                .top(top)
                .middlewareOptions(prepScopes(scopes))
                .get();
        }
        catch (_a) { }
        if (getIsUsersCacheEnabled() && graphResult) {
            item.results = graphResult.value.map(userStr => JSON.stringify(userStr));
            cache.putValue(query, item);
        }
        return graphResult ? graphResult.value : null;
    });
}
/**
 * async promise, returns all matching Graph users who are member of the specified group
 *
 * @param {string} query
 * @param {string} groupId - the group to query
 * @param {number} [top=10] - number of people to return
 * @param {PersonType} [personType=PersonType.person] - the type of person to search for
 * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members
 * @returns {(Promise<User[]>)}
 */
export function findGroupMembers(graph, query, groupId, top = 10, personType = PersonType.person, transitive = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = ['user.read.all', 'people.read'];
        const item = { maxResults: top, results: null };
        let cache;
        const key = `${groupId || '*'}:${query || '*'}:${personType}:${transitive}`;
        if (getIsUsersCacheEnabled()) {
            cache = CacheService.getCache(schemas.users, schemas.users.stores.usersQuery);
            const result = yield cache.getValue(key);
            if (result && getUserInvalidationTime() > Date.now() - result.timeCached) {
                return result.results.map(userStr => JSON.parse(userStr));
            }
        }
        let filter = '';
        if (query) {
            filter = `startswith(displayName,'${query}') or startswith(givenName,'${query}') or startswith(surname,'${query}') or startswith(mail,'${query}') or startswith(userPrincipalName,'${query}')`;
        }
        let apiUrl = `/groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}`;
        if (personType === PersonType.person) {
            apiUrl += `/microsoft.graph.user`;
        }
        else if (personType === PersonType.group) {
            apiUrl += `/microsoft.graph.group`;
            if (query) {
                filter = `startswith(displayName,'${query}') or startswith(mail,'${query}')`;
            }
        }
        const graphResult = yield graph
            .api(apiUrl)
            .count(true)
            .top(top)
            .filter(filter)
            .header('ConsistencyLevel', 'eventual')
            .middlewareOptions(prepScopes(...scopes))
            .get();
        if (getIsUsersCacheEnabled() && graphResult) {
            item.results = graphResult.value.map(userStr => JSON.stringify(userStr));
            cache.putValue(key, item);
        }
        return graphResult ? graphResult.value : null;
    });
}
//# sourceMappingURL=graph.user.js.map