"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

;

(function () {
  'use strict';
  /**
   * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
   *
   * @codingstandard ftlabs-jsv2
   * @copyright The Financial Times Limited [All Rights Reserved]
   * @license MIT License (see LICENSE.txt)
   */

  /*jslint browser:true, node:true*/

  /*global define, Event, Node*/

  /**
   * Instantiate fast-clicking listeners on the specified layer.
   *
   * @constructor
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */

  function FastClick(layer, options) {
    var oldOnClick;
    options = options || {};
    /**
     * Whether a click is currently being tracked.
     *
     * @type boolean
     */

    this.trackingClick = false;
    /**
     * Timestamp for when click tracking started.
     *
     * @type number
     */

    this.trackingClickStart = 0;
    /**
     * The element being tracked for a click.
     *
     * @type EventTarget
     */

    this.targetElement = null;
    /**
     * X-coordinate of touch start event.
     *
     * @type number
     */

    this.touchStartX = 0;
    /**
     * Y-coordinate of touch start event.
     *
     * @type number
     */

    this.touchStartY = 0;
    /**
     * ID of the last touch, retrieved from Touch.identifier.
     *
     * @type number
     */

    this.lastTouchIdentifier = 0;
    /**
     * Touchmove boundary, beyond which a click will be cancelled.
     *
     * @type number
     */

    this.touchBoundary = options.touchBoundary || 10;
    /**
     * The FastClick layer.
     *
     * @type Element
     */

    this.layer = layer;
    /**
     * The minimum time between tap(touchstart and touchend) events
     *
     * @type number
     */

    this.tapDelay = options.tapDelay || 200;
    /**
     * The maximum time for a tap
     *
     * @type number
     */

    this.tapTimeout = options.tapTimeout || 700;

    if (FastClick.notNeeded(layer)) {
      return;
    } // Some old versions of Android don't have Function.prototype.bind


    function bind(method, context) {
      return function () {
        return method.apply(context, arguments);
      };
    }

    var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
    var context = this;

    for (var i = 0, l = methods.length; i < l; i++) {
      context[methods[i]] = bind(context[methods[i]], context);
    } // Set up event handlers as required


    if (deviceIsAndroid) {
      layer.addEventListener('mouseover', this.onMouse, true);
      layer.addEventListener('mousedown', this.onMouse, true);
      layer.addEventListener('mouseup', this.onMouse, true);
    }

    layer.addEventListener('click', this.onClick, true);
    layer.addEventListener('touchstart', this.onTouchStart, false);
    layer.addEventListener('touchmove', this.onTouchMove, false);
    layer.addEventListener('touchend', this.onTouchEnd, false);
    layer.addEventListener('touchcancel', this.onTouchCancel, false); // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
    // layer when they are cancelled.

    if (!Event.prototype.stopImmediatePropagation) {
      layer.removeEventListener = function (type, callback, capture) {
        var rmv = Node.prototype.removeEventListener;

        if (type === 'click') {
          rmv.call(layer, type, callback.hijacked || callback, capture);
        } else {
          rmv.call(layer, type, callback, capture);
        }
      };

      layer.addEventListener = function (type, callback, capture) {
        var adv = Node.prototype.addEventListener;

        if (type === 'click') {
          adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
            if (!event.propagationStopped) {
              callback(event);
            }
          }), capture);
        } else {
          adv.call(layer, type, callback, capture);
        }
      };
    } // If a handler is already declared in the element's onclick attribute, it will be fired before
    // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
    // adding it as listener.


    if (typeof layer.onclick === 'function') {
      // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
      // - the old one won't work if passed to addEventListener directly.
      oldOnClick = layer.onclick;
      layer.addEventListener('click', function (event) {
        oldOnClick(event);
      }, false);
      layer.onclick = null;
    }
  }
  /**
  * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  *
  * @type boolean
  */


  var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
  /**
   * Android requires exceptions.
   *
   * @type boolean
   */

  var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
  /**
   * iOS requires exceptions.
   *
   * @type boolean
   */

  var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
  /**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */

  var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);
  /**
   * iOS 6.0-7.* requires the target element to be manually derived
   *
   * @type boolean
   */

  var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);
  /**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */

  var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
  /**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */

  FastClick.prototype.needsClick = function (target) {
    switch (target.nodeName.toLowerCase()) {
      // Don't send a synthetic click to disabled inputs (issue #62)
      case 'button':
      case 'select':
      case 'textarea':
        if (target.disabled) {
          return true;
        }

        break;

      case 'input':
        // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
        if (deviceIsIOS && target.type === 'file' || target.disabled) {
          return true;
        }

        break;

      case 'label':
      case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames

      case 'video':
        return true;
    }

    return /\bneedsclick\b/.test(target.className);
  };
  /**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */


  FastClick.prototype.needsFocus = function (target) {
    switch (target.nodeName.toLowerCase()) {
      case 'textarea':
        return true;

      case 'select':
        return !deviceIsAndroid;

      case 'input':
        switch (target.type) {
          case 'button':
          case 'checkbox':
          case 'file':
          case 'image':
          case 'radio':
          case 'submit':
            return false;
        } // No point in attempting to focus disabled inputs


        return !target.disabled && !target.readOnly;

      default:
        return /\bneedsfocus\b/.test(target.className);
    }
  };
  /**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */


  FastClick.prototype.sendClick = function (targetElement, event) {
    var clickEvent, touch; // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)

    if (document.activeElement && document.activeElement !== targetElement) {
      document.activeElement.blur();
    }

    touch = event.changedTouches[0]; // Synthesise a click event, with an extra attribute so it can be tracked

    clickEvent = document.createEvent('MouseEvents');
    clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    clickEvent.forwardedTouchEvent = true;
    targetElement.dispatchEvent(clickEvent);
  };

  FastClick.prototype.determineEventType = function (targetElement) {
    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
      return 'mousedown';
    }

    return 'click';
  };
  /**
   * @param {EventTarget|Element} targetElement
   */


  FastClick.prototype.focus = function (targetElement) {
    var length; // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.

    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
      length = targetElement.value.length;
      targetElement.setSelectionRange(length, length);
    } else {
      targetElement.focus();
    }
  };
  /**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */


  FastClick.prototype.updateScrollParent = function (targetElement) {
    var scrollParent, parentElement;
    scrollParent = targetElement.fastClickScrollParent; // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
    // target element was moved to another parent.

    if (!scrollParent || !scrollParent.contains(targetElement)) {
      parentElement = targetElement;

      do {
        if (parentElement.scrollHeight > parentElement.offsetHeight) {
          scrollParent = parentElement;
          targetElement.fastClickScrollParent = parentElement;
          break;
        }

        parentElement = parentElement.parentElement;
      } while (parentElement);
    } // Always update the scroll top tracker if possible.


    if (scrollParent) {
      scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
    }
  };
  /**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */


  FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {
    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    if (eventTarget.nodeType === Node.TEXT_NODE) {
      return eventTarget.parentNode;
    }

    return eventTarget;
  };
  /**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchStart = function (event) {
    var targetElement, touch, selection; // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).

    if (event.targetTouches.length > 1) {
      return true;
    }

    targetElement = this.getTargetElementFromEventTarget(event.target);
    touch = event.targetTouches[0];

    if (deviceIsIOS) {
      // Only trusted events will deselect text on iOS (issue #49)
      selection = window.getSelection();

      if (selection.rangeCount && !selection.isCollapsed) {
        return true;
      }

      if (!deviceIsIOS4) {
        // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
        // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
        // with the same identifier as the touch event that previously triggered the click that triggered the alert.
        // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
        // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
        // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
        // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
        // random integers, it's safe to to continue if the identifier is 0 here.
        if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
          event.preventDefault();
          return false;
        }

        this.lastTouchIdentifier = touch.identifier; // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
        // 1) the user does a fling scroll on the scrollable layer
        // 2) the user stops the fling scroll with another tap
        // then the event.target of the last 'touchend' event will be the element that was under the user's finger
        // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
        // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).

        this.updateScrollParent(targetElement);
      }
    }

    this.trackingClick = true;
    this.trackingClickStart = event.timeStamp;
    this.targetElement = targetElement;
    this.touchStartX = touch.pageX;
    this.touchStartY = touch.pageY; // Prevent phantom clicks on fast double-tap (issue #36)

    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      event.preventDefault();
    }

    return true;
  };
  /**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.touchHasMoved = function (event) {
    var touch = event.changedTouches[0],
        boundary = this.touchBoundary;

    if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
      return true;
    }

    return false;
  };
  /**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchMove = function (event) {
    if (!this.trackingClick) {
      return true;
    } // If the touch has moved, cancel the click tracking


    if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
      this.trackingClick = false;
      this.targetElement = null;
    }

    return true;
  };
  /**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */


  FastClick.prototype.findControl = function (labelElement) {
    // Fast path for newer browsers supporting the HTML5 control attribute
    if (labelElement.control !== undefined) {
      return labelElement.control;
    } // All browsers under test that support touch events also support the HTML5 htmlFor attribute


    if (labelElement.htmlFor) {
      return document.getElementById(labelElement.htmlFor);
    } // If no for attribute exists, attempt to retrieve the first labellable descendant element
    // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label


    return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
  };
  /**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchEnd = function (event) {
    var forElement,
        trackingClickStart,
        targetTagName,
        scrollParent,
        touch,
        targetElement = this.targetElement;

    if (!this.trackingClick) {
      return true;
    } // Prevent phantom clicks on fast double-tap (issue #36)


    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      this.cancelNextClick = true;
      return true;
    }

    if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
      return true;
    } // Reset to prevent wrong click cancel on input (issue #156).


    this.cancelNextClick = false;
    this.lastClickTime = event.timeStamp;
    trackingClickStart = this.trackingClickStart;
    this.trackingClick = false;
    this.trackingClickStart = 0; // On some iOS devices, the targetElement supplied with the event is invalid if the layer
    // is performing a transition or scroll, and has to be re-detected manually. Note that
    // for this to function correctly, it must be called *after* the event target is checked!
    // See issue #57; also filed as rdar://13048589 .

    if (deviceIsIOSWithBadTarget) {
      touch = event.changedTouches[0]; // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null

      targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
      targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
    }

    targetTagName = targetElement.tagName.toLowerCase();

    if (targetTagName === 'label') {
      forElement = this.findControl(targetElement);

      if (forElement) {
        this.focus(targetElement);

        if (deviceIsAndroid) {
          return false;
        }

        targetElement = forElement;
      }
    } else if (this.needsFocus(targetElement)) {
      // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
      // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
      if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
        this.targetElement = null;
        return false;
      }

      this.focus(targetElement);
      this.sendClick(targetElement, event); // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
      // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)

      if (!deviceIsIOS || targetTagName !== 'select') {
        this.targetElement = null;
        event.preventDefault();
      }

      return false;
    }

    if (deviceIsIOS && !deviceIsIOS4) {
      // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
      // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
      scrollParent = targetElement.fastClickScrollParent;

      if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
        return true;
      }
    } // Prevent the actual click from going though - unless the target node is marked as requiring
    // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.


    if (!this.needsClick(targetElement)) {
      event.preventDefault();
      this.sendClick(targetElement, event);
    }

    return false;
  };
  /**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */


  FastClick.prototype.onTouchCancel = function () {
    this.trackingClick = false;
    this.targetElement = null;
  };
  /**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onMouse = function (event) {
    // If a target element was never set (because a touch event was never fired) allow the event
    if (!this.targetElement) {
      return true;
    }

    if (event.forwardedTouchEvent) {
      return true;
    } // Programmatically generated events targeting a specific element should be permitted


    if (!event.cancelable) {
      return true;
    } // Derive and check the target element to see whether the mouse event needs to be permitted;
    // unless explicitly enabled, prevent non-touch click events from triggering actions,
    // to prevent ghost/doubleclicks.


    if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
      // Prevent any user-added listeners declared on FastClick element from being fired.
      if (event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      } else {
        // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        event.propagationStopped = true;
      } // Cancel the event


      event.stopPropagation();
      event.preventDefault();
      return false;
    } // If the mouse event is permitted, return true for the action to go through.


    return true;
  };
  /**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onClick = function (event) {
    var permitted; // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.

    if (this.trackingClick) {
      this.targetElement = null;
      this.trackingClick = false;
      return true;
    } // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.


    if (event.target.type === 'submit' && event.detail === 0) {
      return true;
    }

    permitted = this.onMouse(event); // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.

    if (!permitted) {
      this.targetElement = null;
    } // If clicks are permitted, return true for the action to go through.


    return permitted;
  };
  /**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */


  FastClick.prototype.destroy = function () {
    var layer = this.layer;

    if (deviceIsAndroid) {
      layer.removeEventListener('mouseover', this.onMouse, true);
      layer.removeEventListener('mousedown', this.onMouse, true);
      layer.removeEventListener('mouseup', this.onMouse, true);
    }

    layer.removeEventListener('click', this.onClick, true);
    layer.removeEventListener('touchstart', this.onTouchStart, false);
    layer.removeEventListener('touchmove', this.onTouchMove, false);
    layer.removeEventListener('touchend', this.onTouchEnd, false);
    layer.removeEventListener('touchcancel', this.onTouchCancel, false);
  };
  /**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */


  FastClick.notNeeded = function (layer) {
    var metaViewport;
    var chromeVersion;
    var blackberryVersion;
    var firefoxVersion; // Devices that don't support touch don't need FastClick

    if (typeof window.ontouchstart === 'undefined') {
      return true;
    } // Chrome version - zero for other browsers


    chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

    if (chromeVersion) {
      if (deviceIsAndroid) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          } // Chrome 32 and above with width=device-width or less don't need FastClick


          if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        } // Chrome desktop doesn't need FastClick (issue #15)

      } else {
        return true;
      }
    }

    if (deviceIsBlackBerry10) {
      blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/); // BlackBerry 10.3+ does not require Fastclick library.
      // https://github.com/ftlabs/fastclick/issues/251

      if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport) {
          // user-scalable=no eliminates click delay.
          if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
            return true;
          } // width=device-width (or less than device-width) eliminates click delay.


          if (document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        }
      }
    } // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)


    if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
      return true;
    } // Firefox version - zero for other browsers


    firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

    if (firefoxVersion >= 27) {
      // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
      metaViewport = document.querySelector('meta[name=viewport]');

      if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
        return true;
      }
    } // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
    // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx


    if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
      return true;
    }

    return false;
  };
  /**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */


  FastClick.attach = function (layer, options) {
    return new FastClick(layer, options);
  };

  if (typeof define === 'function' && _typeof(define.amd) === 'object' && define.amd) {
    // AMD. Register as an anonymous module.
    define(function () {
      return FastClick;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = FastClick.attach;
    module.exports.FastClick = FastClick;
  } else {
    window.FastClick = FastClick;
  }
})();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! appspace-authentication-library v1.4.0-cc3f62f | (c) Appspace | https://docs.appspace.com/faq/legal/ */
!function (e) {
  ("object" != (typeof exports === "undefined" ? "undefined" : _typeof(exports)) || "undefined" == typeof module) && "function" == typeof define && define.amd ? define(e) : e();
}(function () {
  "use strict";

  function e(t) {
    var n = this.constructor;
    return this.then(function (e) {
      return n.resolve(t()).then(function () {
        return e;
      });
    }, function (e) {
      return n.resolve(t()).then(function () {
        return n.reject(e);
      });
    });
  }

  function a(e) {
    return e && void 0 !== e.length;
  }

  function n() {}

  function i(e) {
    if (!(this instanceof i)) throw new TypeError("Promises must be constructed via new");
    if ("function" != typeof e) throw new TypeError("not a function");
    this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], u(e, this);
  }

  function o(n, r) {
    for (; 3 === n._state;) {
      n = n._value;
    }

    0 !== n._state ? (n._handled = !0, i._immediateFn(function () {
      var e,
          t = 1 === n._state ? r.onFulfilled : r.onRejected;

      if (null !== t) {
        try {
          e = t(n._value);
        } catch (e) {
          return void c(r.promise, e);
        }

        s(r.promise, e);
      } else (1 === n._state ? s : c)(r.promise, n._value);
    })) : n._deferreds.push(r);
  }

  function s(t, e) {
    try {
      if (e === t) throw new TypeError("A promise cannot be resolved with itself.");

      if (e && ("object" == _typeof(e) || "function" == typeof e)) {
        var n = e.then;
        if (e instanceof i) return t._state = 3, t._value = e, void p(t);
        if ("function" == typeof n) return void u((r = n, o = e, function () {
          r.apply(o, arguments);
        }), t);
      }

      t._state = 1, t._value = e, p(t);
    } catch (e) {
      c(t, e);
    }

    var r, o;
  }

  function c(e, t) {
    e._state = 2, e._value = t, p(e);
  }

  function p(e) {
    2 === e._state && 0 === e._deferreds.length && i._immediateFn(function () {
      e._handled || i._unhandledRejectionFn(e._value);
    });

    for (var t = 0, n = e._deferreds.length; t < n; t++) {
      o(e, e._deferreds[t]);
    }

    e._deferreds = null;
  }

  function u(e, t) {
    var n = !1;

    try {
      e(function (e) {
        n || (n = !0, s(t, e));
      }, function (e) {
        n || (n = !0, c(t, e));
      });
    } catch (e) {
      if (n) return;
      n = !0, c(t, e);
    }
  }

  var t = setTimeout;
  i.prototype["catch"] = function (e) {
    return this.then(null, e);
  }, i.prototype.then = function (r, e) {
    var t = new this.constructor(n);
    return o(this, new function (e, t, n) {
      this.onFulfilled = "function" == typeof r ? r : null, this.onRejected = "function" == typeof t ? t : null, this.promise = n;
    }(0, e, t)), t;
  }, i.prototype["finally"] = e, i.all = function (t) {
    return new i(function (o, i) {
      if (!a(t)) return i(new TypeError("Promise.all accepts an array"));
      var s = Array.prototype.slice.call(t);
      if (0 === s.length) return o([]);

      for (var c = s.length, e = 0; s.length > e; e++) {
        !function t(n, e) {
          try {
            if (e && ("object" == _typeof(e) || "function" == typeof e)) {
              var r = e.then;
              if ("function" == typeof r) return r.call(e, function (e) {
                t(n, e);
              }, i), 0;
            }

            s[n] = e, 0 == --c && o(s);
          } catch (e) {
            i(e);
          }
        }(e, s[e]);
      }
    });
  }, i.resolve = function (t) {
    return t && "object" == _typeof(t) && t.constructor === i ? t : new i(function (e) {
      e(t);
    });
  }, i.reject = function (n) {
    return new i(function (e, t) {
      t(n);
    });
  }, i.race = function (o) {
    return new i(function (e, t) {
      if (!a(o)) return t(new TypeError("Promise.race accepts an array"));

      for (var n = 0, r = o.length; n < r; n++) {
        i.resolve(o[n]).then(e, t);
      }
    });
  }, i._immediateFn = "function" == typeof setImmediate ? function (e) {
    setImmediate(e);
  } : function (e) {
    t(e, 0);
  }, i._unhandledRejectionFn = function (e) {
    void 0 !== console && console && console.warn("Possible Unhandled Promise Rejection:", e);
  };

  var r = function () {
    if ("undefined" != typeof self) return self;
    if ("undefined" != typeof window) return window;
    if ("undefined" != typeof global) return global;
    throw Error("unable to locate global object");
  }();

  "Promise" in r ? r.Promise.prototype["finally"] || (r.Promise.prototype["finally"] = e) : r.Promise = i;
}), function r(o, i, s) {
  function c(n, e) {
    if (!i[n]) {
      if (!o[n]) {
        var t = "function" == typeof require && require;
        if (!e && t) return t(n, !0);
        if (a) return a(n, !0);
        t = new Error("Cannot find module '" + n + "'");
        throw t.code = "MODULE_NOT_FOUND", t;
      }

      t = i[n] = {
        exports: {}
      };
      o[n][0].call(t.exports, function (e) {
        var t = o[n][1][e];
        return c(t || e);
      }, t, t.exports, r, o, i, s);
    }

    return i[n].exports;
  }

  for (var a = "function" == typeof require && require, e = 0; e < s.length; e++) {
    c(s[e]);
  }

  return c;
}({
  1: [function (e, t, n) {
    function c(e) {
      this.message = e;
    }

    (c.prototype = new Error()).name = "InvalidCharacterError", t.exports = "undefined" != typeof window && window.atob && window.atob.bind(window) || function (e) {
      var t = String(e).replace(/=+$/, "");
      if (t.length % 4 == 1) throw new c("'atob' failed: The string to be decoded is not correctly encoded.");

      for (var n, r, o = 0, i = 0, s = ""; r = t.charAt(i++); ~r && (n = o % 4 ? 64 * n + r : r, o++ % 4) && (s += String.fromCharCode(255 & n >> (-2 * o & 6)))) {
        r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r);
      }

      return s;
    };
  }, {}],
  2: [function (e, t, n) {
    var r = e("./atob");

    t.exports = function (e) {
      var t = e.replace(/-/g, "+").replace(/_/g, "/");

      switch (t.length % 4) {
        case 0:
          break;

        case 2:
          t += "==";
          break;

        case 3:
          t += "=";
          break;

        default:
          throw "Illegal base64url string!";
      }

      try {
        return decodeURIComponent(r(t).replace(/(.)/g, function (e, t) {
          t = t.charCodeAt(0).toString(16).toUpperCase();
          return t.length < 2 && (t = "0" + t), "%" + t;
        }));
      } catch (e) {
        return r(t);
      }
    };
  }, {
    "./atob": 1
  }],
  3: [function (e, t, n) {
    "use strict";

    function r(e) {
      this.message = e;
    }

    var o = e("./base64_url_decode");
    (r.prototype = new Error()).name = "InvalidTokenError", t.exports = function (e, t) {
      if ("string" != typeof e) throw new r("Invalid token specified");
      var n = !0 === (t = t || {}).header ? 0 : 1;

      try {
        return JSON.parse(o(e.split(".")[n]));
      } catch (e) {
        throw new r("Invalid token specified: " + e.message);
      }
    }, t.exports.InvalidTokenError = r;
  }, {
    "./base64_url_decode": 2
  }],
  4: [function (n, e, t) {
    (function (e) {
      var t = n("./lib/index");
      "function" == typeof e.window.define && e.window.define.amd ? e.window.define("jwt_decode", function () {
        return t;
      }) : e.window && (e.window.jwt_decode = t);
    }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {
    "./lib/index": 3
  }]
}, {}, [4]), function () {
  "use strict";

  window.appspace = window.appspace || {};
}(), window.appspace.CacsTokenInfo = function (e) {
  e = e || {}, this.token = e.token, this.serviceUrls = e.serviceUrls, this.expireTimestamp = e.expireTimestamp;
}, window.appspace.CloudTokenInfo = function (e) {
  e = e || {}, this.clientToken = e.clientToken, this.expireTimestamp = e.expireTimestamp, this.serviceUrls = e.serviceUrls, this.acsUrl = e.acsUrl, this.scope = e.scope;
}, window.appspace.ConstellationTokens = function (e, t, n) {
  this.accessToken = e, this.refreshToken = t, this.idToken = n;
}, function () {
  "use strict";

  var e = {
    parseConstellationTokensFromQueryString: function parseConstellationTokensFromQueryString() {
      var e = this.Appspace.WindowHelper.getQueryString();

      if (e) {
        for (var t = {}, n = e.substr(1).split("&"), r = 0; r < n.length; r++) {
          var o = n[r].split("=");
          t[o[0].toLowerCase()] = decodeURI(o[1]);
        }

        return this.parseConstellationTokens(t);
      }
    },
    parseConstellationTokens: function parseConstellationTokens(e) {
      if (e) {
        for (var t = new this.Appspace.ConstellationTokens(), n = Object.keys(e), r = 0; r < n.length; r++) {
          var o = n[r],
              i = e[o];

          switch (o.toLowerCase()) {
            case "accesstoken":
              t.accessToken = i;
              break;

            case "refreshtoken":
              t.refreshToken = i;
              break;

            case "idtoken":
              t.idToken = i;
          }
        }

        return t;
      }
    },
    parseJwtToken: function parseJwtToken(e) {
      return e ? this.Appspace.JwtHelper.decode(e) : void 0;
    }
  };
  window.appspace.AuthenticationHelper = e, window.appspace.AuthenticationHelper.Appspace = window.appspace;
}(), function () {
  "use strict";

  var e = {
    TO_MILLISECONDS: 1e3,
    parseTimestamp: function parseTimestamp(e) {
      if (!e || e < 0) throw new Error("Ticks cannot be undefined or less than or equals to zero.");
      return new Date(e * this.TO_MILLISECONDS).getTime();
    },
    isExpired: function isExpired(e) {
      return !e || e < Date.now();
    }
  };
  window.appspace.DateHelper = e;
}(), function () {
  "use strict";

  window.appspace.HttpHelper = {
    trimEndUrl: function trimEndUrl(e) {
      return (e || "").replace(/\/$/, "");
    },
    trimStartUrl: function trimStartUrl(e) {
      return (e || "").replace(/^\//, "");
    },
    combineUrl: function combineUrl(e, t) {
      return this.trimEndUrl(e) + "/" + this.trimStartUrl(t);
    },
    parseConfiguration: function parseConfiguration(e) {
      e = e || {};
      return e.headers = e.headers || {}, e;
    }
  };
}(), function () {
  var e = {
    decode: function decode(e) {
      try {
        return jwt_decode(e);
      } catch (e) {
        return;
      }
    }
  };
  window.appspace.JwtHelper = e;
}(), function () {
  "use strict";

  var e = {
    getQueryString: function getQueryString() {
      return window.location.search;
    }
  };
  window.appspace.WindowHelper = e;
}(), function () {
  "use strict";

  function e(e) {
    this.options = e || {}, this.AUTHORIZATION_HEADER_KEY = "Authorization", this.CLOUD_SERVICE_HEADER_KEY = "x-appspace-cacs-token", this.CLOUD_CLIENT_HEADER_KEY = "x-appspace-client-token", this.CREATE_CLOUD_TOKEN_ENDPOINT = "/api/v3/authorization/cloud/token", this.BEARER_KEY = "Bearer", this.GRANT_TYPE_REFRESH = "refreshToken", this.CREATE_TOKEN_ENDPOINT = "/api/v3/authorization/token", this.NON_EXISTENT_REFRESH_TOKEN = 401, this.EXPIRED_REFRESH_TOKEN = 403, this.EXPIRED_REFRESH_TOKEN_STATUS_CODES = [this.NON_EXISTENT_REFRESH_TOKEN, this.EXPIRED_REFRESH_TOKEN], this.constellationTokens, this.cloudTokenInfo, this.constellationBaseUrl, this.cacsTokenInfo, this.accountId;
  }

  e.prototype.setOptions = function (e) {
    this.options = e || {};
  }, e.prototype.setConstellationTokens = function (e) {
    if (!(e && e.accessToken && e.refreshToken && e.idToken)) throw new Error("Missing accessToken or refreshToken or idToken.");
    this.constellationTokens = e;
    e = this.Appspace.AuthenticationHelper.parseJwtToken(e.idToken);
    if (!e || !e.instanceUrl) throw new Error("Unable to decode instance URL from idToken.");
    this.constellationBaseUrl = this.Appspace.HttpHelper.trimEndUrl(e.instanceUrl), this.accountId = e.accountId;
  }, e.prototype.requestConstellationService = function (t, n) {
    var e = this.getConfigurationError() || this.getConstellationConfigurationError(t);
    return e ? Promise.reject(e) : this.getTokens().then(function (e) {
      return (n = this.Appspace.HttpHelper.parseConfiguration(n)).headers[this.AUTHORIZATION_HEADER_KEY] = this.BEARER_KEY + " " + e.accessToken, this.requestConstellationServiceDirect(t, n);
    }.bind(this), function (e) {
      return Promise.reject(this.constellationTokens ? e : new Error("Missing constellation tokens."));
    }.bind(this));
  }, e.prototype.getServiceUrl = function (t, e) {
    return this.getCloudClientToken(e).then(function (e) {
      return e.serviceUrls = e.serviceUrls || {}, Promise.resolve(e.serviceUrls[t]);
    }, function (e) {
      return Promise.reject(e);
    });
  }, e.prototype.getConstellationBaseUrl = function () {
    return this.getTokens().then(function () {
      return Promise.resolve(this.constellationBaseUrl);
    }.bind(this), function (e) {
      return Promise.reject(e);
    });
  }, e.prototype.getAccountId = function () {
    return this.getTokens().then(function () {
      return Promise.resolve(this.accountId);
    }.bind(this), function (e) {
      return Promise.reject(e);
    });
  }, e.prototype.requestCloudService = function (t, n, r, e) {
    var o = this.getConfigurationError();
    return o ? Promise.reject(o) : t ? this.getCacsToken(e).then(function (e) {
      (r = this.Appspace.HttpHelper.parseConfiguration(r)).headers[this.CLOUD_SERVICE_HEADER_KEY] = e.token;
      e = e.serviceUrls[t];
      return e && (r.url = this.Appspace.HttpHelper.combineUrl(e, n)), r.url ? Promise.resolve(r) : Promise.reject(new Error("Url is not configured."));
    }.bind(this), function (e) {
      return Promise.reject(this.cacsTokenInfo ? e : new Error("Missing CACS token info."));
    }.bind(this)).then(this.options.requestClient.bind(this)) : Promise.reject(new Error("Service name cannot be undefined."));
  }, e.prototype.getConfigurationError = function () {
    if (!this.options.requestClient) return new Error("Missing request client.");
  }, e.prototype.getConstellationConfigurationError = function (e) {
    if (!e) return new Error("Missing relative service URL.");
  }, e.prototype.isAccessTokenValid = function (e) {
    if (!e) throw new Error("Token cannot be undefined.");
    e = this.Appspace.AuthenticationHelper.parseJwtToken(e.accessToken);
    if (!e || !e.exp) throw new Error("Unable to decode expiry date from accessToken.");
    return !this.Appspace.DateHelper.isExpired(this.Appspace.DateHelper.parseTimestamp(e.exp));
  }, e.prototype.refreshToken = function (e) {
    var t = this.Appspace.AuthenticationHelper.parseJwtToken(e.idToken);
    if (!t || !t.subjectType || !t.subjectId) throw new Error("Unable to decode subject information from idToken.");
    e = this.Appspace.HttpHelper.parseConfiguration({
      method: "POST",
      data: {
        subjectType: t.subjectType,
        subjectId: t.subjectId,
        grantType: this.GRANT_TYPE_REFRESH,
        refreshToken: e.refreshToken
      }
    });
    return this.requestConstellationServiceDirect(this.CREATE_TOKEN_ENDPOINT, e).then(function (e) {
      try {
        return Promise.resolve(this.onTokenResponse(e));
      } catch (e) {
        return Promise.reject(e);
      }
    }.bind(this), function (e) {
      return -1 !== this.EXPIRED_REFRESH_TOKEN_STATUS_CODES.indexOf((e || {}).status) && this.options.requestConstellationTokens ? this.requestTokens() : Promise.reject(e);
    }.bind(this));
  }, e.prototype.requestTokens = function () {
    return this.options.requestConstellationTokens ? this.options.requestConstellationTokens().then(function (e) {
      try {
        var t = this.onTokenResponse(e);
        return this.setConstellationTokens(t), Promise.resolve(t);
      } catch (e) {
        return Promise.reject(e);
      }
    }.bind(this)) : Promise.reject(new Error("Unable to request tokens."));
  }, e.prototype.onTokenResponse = function (e) {
    if (!e || 0 == Object.keys(e).length) throw new Error("Received empty response upon tokens refresh.");
    e = this.Appspace.AuthenticationHelper.parseConstellationTokens(e);
    if (!e) throw new Error("Unable to parse tokens after refresh.");
    if (!this.isAccessTokenValid(e)) throw new Error("Retrieved token is invalid.");
    return this.constellationTokens = e, this.options.onConstellationTokensRefreshed && this.options.onConstellationTokensRefreshed(this.constellationTokens), e;
  }, e.prototype.getTokens = function () {
    if (!this.constellationTokens) return this.requestTokens();

    try {
      return this.isAccessTokenValid(this.constellationTokens) ? Promise.resolve(this.constellationTokens) : this.refreshToken(this.constellationTokens);
    } catch (e) {
      return Promise.reject(e);
    }
  }, e.prototype.getCacsToken = function (e) {
    return this.cacsTokenInfo && !this.Appspace.DateHelper.isExpired(this.cacsTokenInfo.expireTimestamp) ? Promise.resolve(this.cacsTokenInfo) : this.getCloudClientToken(e).then(function (e) {
      var t = this.Appspace.HttpHelper.parseConfiguration({
        method: "POST",
        url: e.acsUrl,
        data: {
          scope: e.scope
        }
      });
      return n = e, t.headers[this.CLOUD_CLIENT_HEADER_KEY] = e.clientToken, Promise.resolve(t);
    }.bind(this), function (e) {
      return Promise.reject(this.cloudTokenInfo ? e : new Error("Missing client token."));
    }.bind(this)).then(this.options.requestClient.bind(this)).then(function (e) {
      var t = new window.appspace.CacsTokenInfo(e);
      if (!e || 0 == Object.keys(e).length) return Promise.reject(new Error("Received empty response for CACS tokens."));
      if (!t.token) return Promise.reject(new Error("CACS token cannot be undefined."));
      e = this.Appspace.AuthenticationHelper.parseJwtToken(t.token);
      return e ? (t.expireTimestamp = this.Appspace.DateHelper.parseTimestamp(e.exp), this.Appspace.DateHelper.isExpired(t.expireTimestamp) ? Promise.reject(new Error("CACS token has already expired.")) : (t.serviceUrls = n.serviceUrls, this.cacsTokenInfo = t, Promise.resolve(this.cacsTokenInfo))) : Promise.reject(new Error("Unable to parse CACS tokens."));
    }.bind(this));
    var n;
  }, e.prototype.getCloudClientToken = function (e) {
    if (this.cloudTokenInfo && !this.Appspace.DateHelper.isExpired(this.cloudTokenInfo.expireTimestamp)) return Promise.resolve(this.cloudTokenInfo);
    if (!e) return Promise.reject(new Error("Context is required to get cloud client token."));
    e = {
      method: "POST",
      data: {
        context: e
      }
    };
    return this.requestConstellationService(this.CREATE_CLOUD_TOKEN_ENDPOINT, e).then(function (e) {
      var t = new window.appspace.CloudTokenInfo(e);
      if (!e || 0 == Object.keys(e).length) return Promise.reject(new Error("Received empty response for cloud tokens."));
      if (!t.clientToken) return Promise.reject(new Error("Client token cannot be undefined."));
      if (!t.acsUrl) return Promise.reject(new Error("ACS url cannot be undefined."));
      e = this.Appspace.AuthenticationHelper.parseJwtToken(t.clientToken);
      return e ? e.cloud_acs_scope ? (t.scope = e.cloud_acs_scope, t.expireTimestamp = this.Appspace.DateHelper.parseTimestamp(e.exp), this.Appspace.DateHelper.isExpired(t.expireTimestamp) ? Promise.reject(new Error("Cloud token has already expired.")) : (t.serviceUrls = t.serviceUrls || {}, this.cloudTokenInfo = t, Promise.resolve(this.cloudTokenInfo))) : Promise.reject(new Error("The scope for the token cannot be undefined.")) : Promise.reject(new Error("Unable to parse cloud tokens."));
    }.bind(this));
  }, e.prototype.requestConstellationServiceDirect = function (e, t) {
    return t.url = this.Appspace.HttpHelper.combineUrl(this.constellationBaseUrl, e), this.options.requestClient(t);
  }, window.appspace.AuthenticationClient = e, window.appspace.AuthenticationClient.prototype.Appspace = window.appspace;
}();
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function CardApiAuthenticationLibrary(t, e, i) {
  this.isAuthenticationClientExists() && (this.constellationTokens, this.requestClient = t, this.onConstellationTokensRefreshed = e, this.requestConstellationTokens = i, this.authenticationClient = new this.Appspace.AuthenticationClient({
    requestClient: this.requestClient,
    onConstellationTokensRefreshed: function (t) {
      this.constellationTokens = t, this.onConstellationTokensRefreshed && this.onConstellationTokensRefreshed(this.constellationTokens);
    }.bind(this),
    requestConstellationTokens: this.requestConstellationTokens
  }));
}

!function () {
  "use strict";

  window.appspace = window.appspace || {};
}(), CardApiAuthenticationLibrary.prototype.getConstellationTokensFromQueryString = function () {
  return this.isAuthenticationHelperExists() ? this.Appspace.AuthenticationHelper.parseConstellationTokensFromQueryString() : void 0;
}, CardApiAuthenticationLibrary.prototype.isAuthenticationHelperExists = function () {
  return Boolean(this.Appspace && this.Appspace.AuthenticationHelper);
}, CardApiAuthenticationLibrary.prototype.isAuthenticationClientExists = function () {
  return Boolean(this.Appspace && this.Appspace.AuthenticationClient);
}, CardApiAuthenticationLibrary.prototype.setConstellationTokens = function (t) {
  this.constellationTokens = this.parseConstellationTokens(t);
}, CardApiAuthenticationLibrary.prototype.parseConstellationTokens = function (t) {
  return this.isAuthenticationHelperExists() ? this.Appspace.AuthenticationHelper.parseConstellationTokens(t) : void 0;
}, CardApiAuthenticationLibrary.prototype.requestConstellationService = function (t, e) {
  var i = this.validateClient();
  return i ? $.Deferred().reject(i) : this.authenticationClient.requestConstellationService(t, e);
}, CardApiAuthenticationLibrary.prototype.getServiceUrl = function (t, e) {
  var i = this.validateClient();
  return i ? $.Deferred().reject(i) : this.authenticationClient.getServiceUrl(t, e);
}, CardApiAuthenticationLibrary.prototype.getConstellationBaseUrl = function () {
  var t = this.validateClient();
  return t ? $.Deferred().reject(t) : this.authenticationClient.getConstellationBaseUrl();
}, CardApiAuthenticationLibrary.prototype.getAccountId = function () {
  var t = this.validateClient();
  return t ? $.Deferred().reject(t) : this.authenticationClient.getAccountId();
}, CardApiAuthenticationLibrary.prototype.requestCloudService = function (t, e, i, n) {
  var o = this.validateClient();
  return o ? $.Deferred().reject(o) : this.authenticationClient.requestCloudService(t, e, i, n);
}, CardApiAuthenticationLibrary.prototype.validateClient = function () {
  return this.isAuthenticationClientExists() ? this.constellationTokens ? void this.authenticationClient.setConstellationTokens(this.constellationTokens) : new Error("Constellation tokens are empty") : new Error("Authentication Client doesn't exist");
}, CardApiAuthenticationLibrary.prototype.Appspace = window.appspace, function () {
  var t = {
    CONTENT_PREPEND_KEY: "*content$",
    JOIN_KEY: ">>",
    SPLIT_KEY_INDEX: 1,
    SPLIT_COLLECTION_INDEX: 0,
    SPLIT_KEY_COLLECTION_LENGTH: 2,
    getCollectionName: function getCollectionName() {
      var t = this.getCurrentHref(),
          e = t.lastIndexOf("/index.html");
      return 0 < e ? t.substring(0, e) : t;
    },
    getLocalStorageId: function getLocalStorageId(t, e) {
      return this.CONTENT_PREPEND_KEY + t + this.JOIN_KEY + e;
    },
    getInfoFromLocalStorageId: function getInfoFromLocalStorageId(t) {
      if (t) {
        var e = t.indexOf(this.CONTENT_PREPEND_KEY);

        if (-1 !== e) {
          e = t.substring(e + this.CONTENT_PREPEND_KEY.length).split(this.JOIN_KEY);
          if (e.length === this.SPLIT_KEY_COLLECTION_LENGTH) return {
            key: e[this.SPLIT_KEY_INDEX],
            collection: e[this.SPLIT_COLLECTION_INDEX]
          };
        }
      }
    },
    getCurrentHref: function getCurrentHref() {
      return window.location.href;
    }
  };
  window.appspace.StorageHelper = t;
}();
/*! CardAPI v1.5.0-9a47354 | (c) Appspace | https://docs.appspace.com/faq/legal/ */

function CardApi(type) {
  var schemaUpdateCallback = null;
  var modelUpdateCallback = null;
  var modeChangeCallback = null;
  var messagesCallback = null;
  var postMessageCallback;
  var deviceCapabilitiesCallback = null;
  var schema = {
    inputs: []
  };
  var model = {
    inputs: []
  };
  var mode = "tv";
  var cardId;
  var themeProperty = {};
  var me = this;
  var hasNotifiedLoaded = false;
  var hasNotifiedComplete = false;
  var hasNotifiedError = false;
  var fontLookupCache = {};
  var self = this;
  var config = {};
  var apiSupported = [];
  var apiInitDefer = $.Deferred();
  var deferCache = {};
  var timeoutCache = {};
  var deferRunningId = 0;
  var appWindow, appOrigin;
  var mouseMoveEvent = "mousemove";
  var hideMouseTimer;
  var authenticationLibrary = new CardApiAuthenticationLibrary(requestClient, onConstellationTokensRefreshed, requestConstellationTokens);
  var cachedUrlParameters = {};
  var DEFAULT_REQUEST_TIMEOUT = 10000;
  var KEY_VALUE_PAIR_SPLIT_LENGTH = 2;
  var KEY_VALUE_PAIR_SEPARATOR = '=';
  var QUERY_STRING_URL_SEPARATOR = '?';
  var QUERY_STRING_OBJECT_SEPARATOR = '&';
  var QUERY_STRING_SEPARTOR_EXCLUDE_LENGTH = 1;
  var SETUP_PASSPORT_API = 'api.setuppassport';
  var GET_PASSPORT_API = 'api.getpassports';
  var supportedApiResponse = [SETUP_PASSPORT_API, GET_PASSPORT_API];
  var CURSOR = {
    SHOW: "auto",
    HIDE: "none"
  };
  var REGEX_REPLACEMENT_FLAG = 'ig';
  var initPromise = $.Deferred();
  this.PLAYBACKCONTEXT = {
    EDIT: "editing",
    THEME: "themeediting",
    SCREENSHOT: "screenshot",
    THEMESCREENSHOT: "themescreenshot",
    DEVICE: "device",
    NONE: "none"
  };

  function requestClient(configuration) {
    var promise = $.Deferred();
    httpRequest(configuration.url, configuration).then(function (response) {
      if (!response) {
        promise.reject('Empty response');
        return;
      }

      promise.resolve(response.data);
    }, promise.reject);
    return promise.promise();
  }

  function onConstellationTokensRefreshed(tokens) {
    raiseMessage({
      message: 'onconstellationtokensrefresh',
      tokens: tokens,
      cardId: cardId
    });
  } // Gets a parameter from the current url query string


  function getLocationParameterByName(name) {
    return cachedUrlParameters[name.toLowerCase()] || '';
  }

  function setHideMouseTimeout() {
    clearTimeout(hideMouseTimer);
    hideMouseTimer = null;
    setCursorVisibility(CURSOR.SHOW); // Set the mouse to hide within 1 sec if it's activated

    hideMouseTimer = setTimeout(hideMouse, 1000);
  }

  ;

  function hideMouse() {
    setCursorVisibility(CURSOR.HIDE);
  }

  function setCursorVisibility(visible) {
    document.body.style.cursor = visible;
  }

  this.cacheUrlParameters = function () {
    var href = window.location.href; // plus 1 to exclude separator

    var queryString = href.substring(href.indexOf(QUERY_STRING_URL_SEPARATOR) + QUERY_STRING_SEPARTOR_EXCLUDE_LENGTH);

    if (!queryString) {
      return;
    } // e.g. ?hello=world&hello2=world2


    var keyValuePairs = queryString.split(QUERY_STRING_OBJECT_SEPARATOR);

    for (var i = 0; i < keyValuePairs.length; i++) {
      var keyValuePairRaw = keyValuePairs[i];

      if (!keyValuePairRaw) {
        continue;
      } // e.g. hello=world or hello2=world2


      var keyValuePair = keyValuePairRaw.split(KEY_VALUE_PAIR_SEPARATOR);

      if (keyValuePair.length !== KEY_VALUE_PAIR_SPLIT_LENGTH) {
        continue;
      }

      cachedUrlParameters[keyValuePair[0].toLowerCase()] = decodeURIComponent(keyValuePair[1]);
    }
  }; // Initializes the Card API and registers with the host


  this.init = function () {
    var constellationTokens = authenticationLibrary.getConstellationTokensFromQueryString();
    authenticationLibrary.setConstellationTokens(constellationTokens); // Get the card id

    cardId = getLocationParameterByName("cardId"); // Attempt to get the current mode from url query string

    mode = getLocationParameterByName("mode");
    var modelJsonResponse; // Attempt to load the default model

    $.getJSON("model.json", function (data) {
      modelJsonResponse = data; // Check has it already been updated, if not use the default

      if (model.inputs.length == 0) {
        self.onModelUpdate(data);
      }
    }).always(function () {
      // Let parent know we have initiaized the api
      raiseMessage({
        message: "onapiready",
        cardId: cardId,
        runtimeConfiguration: (modelJsonResponse || {}).runtimeConfiguration
      });
    });
    $.getJSON("schema.json", function (data) {
      // Check has it already been updated, if not use the default
      if (schema.inputs.length) {
        return;
      }

      self.onSchemaUpdate(data);
    }); // Create IE + others compatible event handler

    var addEventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
    var addEventName = window[addEventMethod];
    var removeEventMethod = window.removeEventListener ? "removeEventListener" : "detachEvent";
    var removeEventName = window[removeEventMethod];
    var messageEvent = addEventMethod === "attachEvent" ? "onmessage" : "message"; // Set up parent window event listener for commands

    removeEventName(messageEvent, this.onParentMessage, false);
    addEventName(messageEvent, this.onParentMessage, false);
    initPromise.resolve();

    if (this.isEditing()) {
      return;
    } // Hide mouse by default if it's not editing


    removeEventName(mouseMoveEvent, setHideMouseTimeout, false);
    addEventName(mouseMoveEvent, setHideMouseTimeout, false);
    hideMouse();
  };

  this.isReady = function () {
    var promises = [initPromise];

    if (this.getPlaybackContext() === this.PLAYBACKCONTEXT.DEVICE) {
      promises.push(apiInitDefer);
    } // .apply is used to convert array to separate arguments


    return $.when.apply($, promises);
  };
  /***************** Parent Window Handlers *****************/


  this.onParentMessage = function (event) {
    if (!event || !event.data) {
      return;
    }

    if (postMessageCallback) {
      postMessageCallback(event.data);
    }

    if (!event.data.message) {
      return;
    } // If somone has subscribed, we forward them the message


    if (messagesCallback) {
      messagesCallback(event.data);
    }

    var eventType = event.data.message.toLowerCase();

    switch (eventType) {
      case "api.init":
        config = event.data.config;

        if (model.inputs && model.inputs.length > 0) {
          self.onModelUpdate(model);
        }

        if (schema.inputs && schema.inputs.length > 0) {
          self.onSchemaUpdate(schema);
        }

        if (config.constellationTokens) {
          self.onInjectConstellationTokens(config.constellationTokens);
        }

        self.onDeviceCapabilitiesUpdate(config.deviceCapabilities);
        apiSupported = config.apiSupported || [];

        if (apiInitDefer.state() == 'resolved') {
          return;
        }

        apiInitDefer.resolve();
        break;

      case "onmodechange":
        me.onModeChange(event.data.mode);
        break;

      case "onschemaupdate":
        me.onSchemaUpdate(event.data.schema);
        break;

      case "onmodelupdate":
        me.onModelUpdate(event.data.model);
        break;

      case "onexecutescript":
        me.onExecuteScript(event.data.script);
        break;

      case "oninjectcssclass":
        me.onInjectCssClass(event.data.className, event.data.css);
        break;

      case "oninjectthemeproperty":
        me.onInjectThemeProperty(event.data.name, event.data.value);
        break;

      case "api.response":
        me.processApiResponse(event.data);
        break;

      case "appspaceapp.webview.postmessage.init":
        appWindow = event.source;
        appOrigin = event.origin; // send on api ready

        raiseMessage({
          message: "onapiready",
          cardId: cardId
        });
        break;

      case "appspaceapp.mswebview.postmessage.init":
        msMessaging = [];
        raiseMessage({
          message: "onapiready",
          cardId: cardId
        });
        break;

      case "oninjectconstellationtokens":
        me.onInjectConstellationTokens(event.data.tokens);
        break;

      case "api.requestconstellationtokens.response":
        me.processConstellationTokensResponse(event.data);
        break;

      default:
        me.processPostMessageResponse(event.data);
        break;
    }
  };

  this.processApiResponse = function (response) {
    var defer = deferCache[response.requestId];

    if (defer) {
      switch (response.event) {
        case "done":
          defer.resolve(response.result, response);
          break;

        case "fail":
          defer.reject(response.result, response);
          break;
      }

      deferCache[response.requestId] = undefined;
    }
  };

  this.processPostMessageResponse = function (eventData) {
    if (!eventData || !eventData.message) {
      return;
    }

    var eventBlock = eventData.message.toLowerCase().split('.');
    var apiName = eventBlock.slice(0, eventBlock.length - 1).join('.');

    if (supportedApiResponse.indexOf(apiName) < 0) {
      return;
    }

    var response = eventData.callback;
    var id = response.$requestId;
    var defer = deferCache[id];

    if (!defer) {
      return;
    }

    if (response.errorMessage) {
      defer.reject(response.errorMessage);
      return;
    }

    delete deferCache[id];
    defer.resolve(response.result);
  };

  function requestPostMessage(requestName, configuration) {
    var defer = $.Deferred();
    apiInitDefer.promise().then(function () {
      if (!isApiSupported(requestName)) {
        return defer.reject('Api [' + requestName + '] is not supported in the current environment.');
      }

      configuration = configuration || {};
      configuration.message = requestName;
      configuration.callback = configuration.callback || {};
      deferRunningId++;
      deferCache[deferRunningId] = defer;
      configuration.callback.$requestId = deferRunningId;
      raiseMessage(configuration);
    });
    return defer.promise();
  }

  function isApiSupported(apiName) {
    return apiName && apiSupported && apiSupported.indexOf(apiName) >= 0;
  }

  function postMessageXhr(url, settings) {
    return postMessageUrlRequest(url, settings, 'api.xhr');
  }

  function postMessageHttpRequest(url, settings) {
    var checkConfig = config || {};
    checkConfig.api = checkConfig.api || {}; // if App doesn't support httprequest, use api.xhr

    return checkConfig.api.httprequest ? postMessageUrlRequest(url, settings, 'api.httprequest') : postMessageXhr(url, settings);
  }

  function sendAndCacheRequest(message, timeout, callback) {
    // Create promise for tracking the api request
    var defer = $.Deferred(); // Increment the defer id

    deferRunningId++; // Add to the cache

    deferCache[deferRunningId] = defer; // Add to the timeout cache

    if (timeout) {
      timeoutCache[deferRunningId] = setTimeout(function () {
        defer.reject(timeout.message);
      }, timeout.duration);
    }

    message.$requestId = deferRunningId;
    message.callback = callback || {};
    message.callback.$requestId = message.$requestId; // Pass the request to our api

    raiseMessage(message);
    return defer.promise();
  }

  function postMessageUrlRequest(url, settings, method) {
    return sendAndCacheRequest({
      message: method,
      url: url,
      settings: settings
    });
  }

  function requestConstellationTokens() {
    return sendAndCacheRequest({
      message: "api.requestconstellationtokens",
      context: me.getPlaybackContext()
    }, {
      error: 'Request timeout reached before receiving a response',
      duration: DEFAULT_REQUEST_TIMEOUT
    });
  }

  function httpRequest(url, settings) {
    var promise = $.Deferred();

    var getResolveObject = function getResolveObject(data, status, headers) {
      var headersData = {};
      var allHeaders = (headers || '').trim().split(/\r\n|\r|\n/);

      for (var i = 0; i < allHeaders.length; i++) {
        if (!allHeaders[i]) {
          continue;
        }

        var headerData = allHeaders[i].split(':');

        if (headerData.length !== 2) {
          continue;
        }

        headersData[headerData[0].toLowerCase()] = headerData[1].trim();
      }

      return {
        url: url,
        data: data,
        status: status,
        headers: headersData
      };
    };

    if (!config || !config.api || !config.api.xhr) {
      $.ajax(url, settings).then(function (data, status, xhr) {
        promise.resolve(getResolveObject(data, xhr.status, xhr.getAllResponseHeaders()));
      }, function (xhr) {
        promise.reject(getResolveObject(xhr.responseText, xhr.status, xhr.getAllResponseHeaders()));
      });
    } else {
      postMessageHttpRequest(url, settings).then(function (data, response) {
        promise.resolve(getResolveObject(data, response.xhr.status, response.responseHeaders));
      }, function (data, response) {
        promise.reject(getResolveObject(data, response.xhr.status, response.responseHeaders));
      });
    }

    return promise.promise();
  }

  this.api = {
    xhr: function xhr(url, settings) {
      // If api is not implemented, use ajax
      if (!config || !config.api || !config.api.xhr) {
        var jqxhr = $.ajax(url, settings);
        return jqxhr;
      }

      return postMessageXhr(url, settings);
    },
    // Existing xhr method gives inconsistent result between ajax call & post messaging api.xhr call
    // This method is to standardize both results
    httpRequest: httpRequest,
    // Update a specific model input
    updateModelInput: function updateModelInput(input) {
      raiseMessage({
        message: "api.updatemodelinput",
        input: input
      });
    },
    // Update custom data in the model
    updateModelCustomData: function updateModelCustomData(customData) {
      raiseMessage({
        message: "api.updatemodelcustomdata",
        customData: customData
      });
    },
    // Update runtime configurations in the model
    updateModelRuntimeConfiguration: function updateModelRuntimeConfiguration(runtimeConfiguration) {
      raiseMessage({
        message: "api.updateruntimeconfiguration",
        runtimeConfiguration: runtimeConfiguration
      });
    },
    // get passports
    getPassports: function getPassports(criteria) {
      return requestPostMessage(GET_PASSPORT_API, {
        criteria: criteria
      });
    },
    // Request constellation service (e.g. maps) helper
    requestConstellationService: function requestConstellationService(serviceRelativeUrl, requestConfiguration) {
      try {
        return authenticationLibrary.requestConstellationService(serviceRelativeUrl, requestConfiguration);
      } catch (error) {
        return $.Deferred().reject(error.message);
      }
    },
    // Get the service url.
    getServiceUrl: function (serviceName) {
      try {
        return authenticationLibrary.getServiceUrl(serviceName, this.getPlaybackContext());
      } catch (error) {
        // eslint-disable-next-line new-cap
        return $.Deferred().reject(error);
      }
    }.bind(this),
    // Get the constellation base URL
    getConstellationBaseUrl: function () {
      try {
        return authenticationLibrary.getConstellationBaseUrl();
      } catch (error) {
        // eslint-disable-next-line new-cap
        return $.Deferred().reject(error);
      }
    }.bind(this),
    // Get the account ID
    getAccountId: function () {
      try {
        return authenticationLibrary.getAccountId();
      } catch (error) {
        // eslint-disable-next-line new-cap
        return $.Deferred().reject(error);
      }
    }.bind(this),
    // Request cloud service i.e. webex service.
    requestCloudService: function (serviceName, serviceRelativeUrl, requestConfiguration) {
      try {
        return authenticationLibrary.requestCloudService(serviceName, serviceRelativeUrl, requestConfiguration, this.getPlaybackContext());
      } catch (error) {
        return $.Deferred().reject(error);
      }
    }.bind(this),
    navigate: function navigate(state, parameters, closeAllModals) {
      return raiseMessage({
        message: 'console.command',
        command: 'goto.state',
        data: {
          state: state,
          stateParams: parameters,
          closeAllModals: closeAllModals
        }
      });
    },
    // Setup Passport from console.
    setupPassport: function (criteria) {
      // backward compatible
      if (!isApiSupported(SETUP_PASSPORT_API)) {
        this.api.navigate('passport.home', undefined, true);
        return $.Deferred().resolve();
      }

      return requestPostMessage(SETUP_PASSPORT_API, {
        criteria: criteria
      });
    }.bind(this)
  }; // Gets the input model for a specific property

  function getModelProperty(propertyName) {
    if (!propertyName || !model || !model.inputs) {
      return null;
    }

    propertyName = propertyName.toLowerCase();

    for (var i = 0; i < model.inputs.length; i++) {
      var input = model.inputs[i];

      if (input.name.toLowerCase() == propertyName) {
        return input;
      }
    }

    return null;
  }

  ; // Gets the input model for a specific property (e.g. headline.value.html)

  function resolveModelProperty(propertyName) {
    if (!model || !model.inputs) {
      return null;
    } // Split the property name into segments


    var segments = propertyName.split("."); // Get the model property, which should be the first segment

    var property = getModelProperty(segments.shift());

    if (!property) {
      return null;
    }

    var obj = getObjectPath(property, segments);
    return obj !== undefined ? obj : "";
  }

  ;

  function getObjectPath(initialObject, path) {
    return path.reduce(function (currentObject, currentPath) {
      return (currentObject || {})[currentPath];
    }, initialObject);
  }

  function substituteModelValue(objectValue) {
    if (!objectValue) {
      return objectValue;
    } // Model properties are $ {model.propertyname.subprop} in the value


    var modelRegex = new RegExp("\\$" + "{model\.([^}]*)}", "g");
    var regexResult;
    var result = {}; // find all words that matches $ {model.xxx} pattern and save the model result

    while (regexResult = modelRegex.exec(objectValue)) {
      // if we already have a result of this match, continue to the next 1
      if (result[regexResult[0]]) {
        continue;
      }

      var prop = resolveModelProperty(regexResult[1]);
      result[regexResult[0]] = prop;
    } // replace the matching results to the final value


    for (var key in result) {
      if (result[key] == null) {
        continue;
      }

      objectValue = objectValue.split(key).join(result[key]);
    }

    return objectValue;
  }

  function substitutePropertyValue(objectValue) {
    if (!objectValue) {
      return objectValue;
    } // replace all $ {property.xxx} in the value regardless of casing


    for (var propertyName in config.properties) {
      objectValue = objectValue.replace(getPropertyReplacementRegex(propertyName), config.properties[propertyName]);
    }

    return objectValue;
  }

  function getPropertyReplacementRegex(propertyName) {
    // need to separate $ and { because of gulp
    return new RegExp('\\$' + '{property\\.' + propertyName + '}', REGEX_REPLACEMENT_FLAG);
  }

  function enumerateObjectProperties(obj, substituteCallback) {
    switch (_typeof(obj)) {
      case "number":
      case "boolean":
        return obj;

      case "string":
        return substituteCallback(obj);

      case "object":
        // Scan through child
        for (var p in obj) {
          obj[p] = enumerateObjectProperties(obj[p], substituteCallback);
        }

        return obj;
    }
  } // Provides an  updated schema


  this.onSchemaUpdate = function (newSchema) {
    if (!newSchema || !newSchema.inputs) {
      return;
    }

    schema = newSchema;

    if (!schemaUpdateCallback) {
      return;
    }

    schemaUpdateCallback(schema);
  }; // Provides an updated model


  this.onModelUpdate = function (newModel) {
    if (!newModel || !newModel.inputs) {
      return;
    }

    model = newModel;

    if (config && config.properties) {
      // Process device properties for substituion
      enumerateObjectProperties(model, substitutePropertyValue);
    } // Process model properties for substituion


    enumerateObjectProperties(model, substituteModelValue); // scan through model for fonts to install

    installFontsFromModel().always(function () {
      if (modelUpdateCallback) {
        modelUpdateCallback(model);
      }
    });
  }; // Updated the mode


  this.onModeChange = function (m) {
    mode = m;

    if (modeChangeCallback) {
      modeChangeCallback(m);
    }
  }; // Execute Script


  this.onExecuteScript = function (script) {
    // Executes a script
    return eval(script);
  }; // Injects a custom class and adds to the head


  this.onInjectCssClass = function (className, css) {
    className = className.toLowerCase();
    var found = false; // Iterate through the existing classes and update if already exists

    for (var k = 0; k < document.styleSheets.length; k++) {
      var sheet = document.styleSheets[k];
      var rules = sheet.cssRules || sheet.rules;

      for (var i = 0; i < rules.length; i++) {
        var rule = document.styleSheets[k].cssRules[i];
        var selector = rule.selectorText.toLowerCase();

        if (selector == className || selector == +className) {
          rule.style.cssText = css; // Found and updated

          found = true;
        }
      }
    } // Check did we find the class and update?


    if (found) {
      // Exit as there is no need to add a new stle
      return;
    } // Create style class and inject into the head


    $("<style type='text/css'> " + className + " {" + css + "} </style>").appendTo("head");
  }; // Injects a custom property for the theme


  this.onInjectThemeProperty = function (propertyName, value) {
    themeProperty[propertyName] = value;
  };

  this.onInjectConstellationTokens = function (tokens) {
    authenticationLibrary.setConstellationTokens(tokens);
  };

  this.onDeviceCapabilitiesUpdate = function (capabilities) {
    if (!deviceCapabilitiesCallback) {
      return;
    }

    deviceCapabilitiesCallback(capabilities);
  };

  this.processConstellationTokensResponse = function (response) {
    if (!response || !response.callback) {
      return;
    }

    response = response.callback;
    var id = response.$requestId;
    var timeout = timeoutCache[id];

    if (timeout) {
      clearTimeout(timeout);
      delete timeoutCache[id];
    }

    var defer = deferCache[id];

    if (!defer) {
      return;
    }

    if (response.errorMessage) {
      defer.reject(response.errorMessage);
      return;
    }

    defer.resolve(response.result);
    delete deferCache[id];
  };

  function installFontsFromModel() {
    var defered = $.Deferred();
    var promises = []; // Find all input type for font upload

    for (var i = 0; i < model.inputs.length; i++) {
      var input = model.inputs[i];

      if (input.type == "fontupload" && input.value) {
        // Scan each file uploaded and load the referenced font
        for (var k = 0; k < input.value.length; k++) {
          var fontObj = input.value[k];

          if (fontObj.originalName) {
            var family = fontObj.originalName.split(".")[0];
            var font = {
              family: family,
              url: fontObj.path
            };
            var p = loadFont(font);
            promises.push(p);
          }
        }
      }
    } // Wait for all fonts to load


    $.when.apply($, promises).done(function () {
      // Wait for all promises to complete
      defered.resolve();
    });
    return defered.promise();
  }

  function loadFont(font) {
    var defered = $.Deferred();

    if (isFontAvailable(font.family)) {
      defered.resolve();
      return defered.promise();
    } // Create a sheet dynamicaly to load font


    var sheet = createSheet();
    var rule = "@font-face {font-family:'" + font.family + "'; src:url('" + font.url + "')}";
    sheet.insertRule(rule, 0); // Wait until font loads

    var loadTime = new Date().getTime();
    var intervalTimer = setInterval(function () {
      if (isFontAvailable(font.family)) {
        // Font loaded
        clearTimeout(intervalTimer);
        defered.resolve();
      } else {// Not loaded yet
      } // Check if it took longer than 3 seconds to load


      if (new Date().getTime() - loadTime > 3000) {
        clearTimeout(intervalTimer);
        defered.resolve();
      }
    }, 10);
    return defered.promise();
  } // Create a style sheet


  function createSheet() {
    var style = document.createElement("style"); // style.setAttribute("", "")

    style.appendChild(document.createTextNode(""));
    document.head.appendChild(style);
    return style.sheet;
  } // Check font exist by looking for size differences


  function isFontAvailable(fontName) {
    if (fontLookupCache[fontName]) {
      return true;
    }

    var sampleText = "abcdefghijklmnopqrstuvwxyz0123456789";
    var canvas = document.createElement("canvas");
    var context = canvas.getContext("2d"); // Set default font to monospace so we can determine base size

    context.font = "72px monospace";
    var baseSize = context.measureText(sampleText).width; // Now check for our font, and fallback to monospace if it doesnt exist

    context.font = "72px '" + fontName + "', monospace";
    var fontSize = context.measureText(sampleText).width; // If they are the same then the font doesnt exist

    if (fontSize != baseSize) {
      fontLookupCache[fontName] = true;
      return true;
    } else {
      return false;
    }
  }
  /***************** Raise Notifications *****************/


  this.postMessage = raiseMessage;

  function raiseMessage(message) {
    if (appOrigin && appWindow) {
      appWindow.postMessage(message, appOrigin);
    } else if (msMessaging) {
      msMessaging.push(message);
    } else if (window && window.parent && window.parent.postMessage) {
      window.parent.postMessage(message, "*");
    }
  } // Let the host know that your card has loaded


  this.notifyOnLoad = function (p) {
    // Have we already sent this notification
    if (hasNotifiedLoaded) {
      return;
    }

    hasNotifiedLoaded = true;
    raiseMessage({
      message: "loaded",
      cardId: cardId
    });
  }; // Let the host know your card has completed playbacl


  this.notifyOnComplete = function (p) {
    // Have we already sent this notification
    if (hasNotifiedComplete) {
      return;
    }

    hasNotifiedComplete = true;
    raiseMessage({
      message: "complete",
      cardId: cardId
    });
  }; // Let the host know your card has had an error during load or playback


  this.notifyOnError = function (p) {
    // Have we already sent this notification
    if (hasNotifiedError) {
      return;
    }

    hasNotifiedError = true;
    raiseMessage({
      message: "error",
      cardId: cardId
    });
  };
  /***************** Subscribe to Events *****************/
  // Subscribe to schema changes


  this.subscribeSchemaUpdate = function (callback) {
    schemaUpdateCallback = callback;
  }; // Subscribes to model changes


  this.subscribeModelUpdate = function (callback) {
    modelUpdateCallback = callback;
  }; // Subscribes to mode changes


  this.subscribeModeChange = function (callback) {
    modeChangeCallback = callback;
  }; // Subscribes to messages


  this.subscribeToMessages = function (callback) {
    messagesCallback = callback;
  }; // Subscribes to post messages


  this.subscribeToPostMessages = function (callback) {
    postMessageCallback = callback;
  };

  this.subscribeToDeviceCapabilities = function (callback) {
    deviceCapabilitiesCallback = callback;
  }; // Returns the card schema


  this.getSchema = function () {
    return schema;
  }; // Returns the card model


  this.getModel = function () {
    return model;
  }; // Returns the template config


  this.getConfig = function () {
    return config;
  }; // Returns the display mode of the card


  this.getMode = function () {
    return mode;
  }; // Returns a theme property


  this.getThemeProperty = function (propertyName) {
    return themeProperty[propertyName];
  }; // Returns true or false depending on whether the card is currently being edited


  this.isEditing = function () {
    if (getLocationParameterByName("editing") == "true" || getLocationParameterByName('context') == "theme") {
      return true;
    } else {
      return false;
    }
  }; // Returns true or false depending on whether the card is in preview mode


  this.isPreview = function () {
    return getLocationParameterByName("isPreview") == "true";
  };

  this.getPlaybackContext = function () {
    // From appspace 7.1, the context is injected in the query param
    var context = getLocationParameterByName('context');

    if (context) {
      switch (context.toLowerCase()) {
        case 'theme':
          return this.PLAYBACKCONTEXT.THEME;

        case 'edit':
          return this.PLAYBACKCONTEXT.EDIT;

        case 'screenshot':
          return this.PLAYBACKCONTEXT.SCREENSHOT;

        case 'themescreenshot':
          return this.PLAYBACKCONTEXT.THEMESCREENSHOT;

        case 'device':
          return this.PLAYBACKCONTEXT.DEVICE;
      }
    }

    if (this.isEditing() && getLocationParameterByName('action') === 'screenshot') {
      return this.PLAYBACKCONTEXT.THEMESCREENSHOT;
    }

    if (this.isEditing()) {
      return this.PLAYBACKCONTEXT.EDIT;
    }

    if (getLocationParameterByName('action') === 'screenshot') {
      return this.PLAYBACKCONTEXT.SCREENSHOT;
    }

    if (getLocationParameterByName('playback') === 'device') {
      return this.PLAYBACKCONTEXT.DEVICE;
    }

    return this.PLAYBACKCONTEXT.NONE;
  }; // Gets the input model for a specific property


  this.getModelProperty = getModelProperty;
} // Creates a global instance of the CardAPI


var $cardApi = new CardApi();
$cardApi.cacheUrlParameters(); // global function for ms-webview post messaging

function globalMsPostMessaging(message) {
  // '{"message":"abcd"}'
  var messageObject = JSON.parse(message);
  var event = {
    data: messageObject
  };
  $cardApi.onParentMessage(event);
}

var msMessaging; // global function for ms-webview retrieve messaging

function globalMsRetrieveMessaging() {
  var message = '[]';

  if (msMessaging) {
    message = JSON.stringify(msMessaging);
    msMessaging = [];
  }

  return message;
} // export to global


window.msPostMessaging = globalMsPostMessaging;
window.msRetrieveMessaging = globalMsRetrieveMessaging;
/*! appspace-ui v1.0.0-767a955 | (c) Appspace | https://docs.appspace.com/faq/legal/ */
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, subClass.__proto__ = superClass;
}

!function ($angular) {
  var angular = window.angular;
  angular.module("templates", []), angular.module("core.ui", ["ngSanitize", "ngAnimate", "ngTagsInput", "ui.bootstrap", "dndLists", "core.ui", "templates", "ui.tree", "ngLoad", "ngError", "growlNotifications", "ui.toggle", "chart.js"]);
}(), $.FroalaEditor.DEFAULTS.key = "gB2F2C2F2E2C6zA3B2A1A1F4F1F1A10A1D6mc1VYJZa1c2a1THYBUZY==", window.angular.module("core.ui").factory("AsComponentUtil", function () {
  function AsComponentUtil() {}

  return AsComponentUtil.prototype = {
    getColorPickerSettings: function getColorPickerSettings(initialColor) {
      initialColor || (initialColor = null);
      var settings = {
        color: initialColor,
        preferredFormat: "hex8",
        chooseText: "OK",
        cancelText: "Cancel",
        showPalette: !0,
        showInitial: !0,
        showInput: !0,
        allowEmpty: !0,
        showAlpha: !0
      };
      return $(".sp-input").attr("maxlength", 9), settings;
    },
    resetColorPickerAlpha: function resetColorPickerAlpha(colorEl, color, prevColor) {
      var curColor = {
        hex: null,
        alpha: 0
      };
      return color && (curColor = {
        hex: color.toHexString(),
        alpha: color.getAlpha()
      }).hex != prevColor.hex && curColor.alpha < .1 && curColor.alpha == prevColor.alpha && (color = color.setAlpha(1), colorEl.spectrum("set", color), curColor.alpha = 1), curColor;
    },
    generateGuid: function generateGuid() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = 16 * Math.random() | 0,
            v = "x" == c ? r : 3 & r | 8;
        return v.toString(16);
      });
    }
  }, AsComponentUtil;
}), window.angular.module("core.ui").directive("asuiOnEnter", function () {
  return function (scope, element, attrs) {
    element.bind("keydown keypress", function (event) {
      13 === event.which && (scope.$apply(function () {
        scope.$eval(attrs.asuiOnEnter);
      }), event.preventDefault());
    });
  };
}), window.angular.module("core.ui").directive("asuiSelectableItem", ["$timeout", function ($timeout) {
  return {
    restrict: "A",
    scope: {
      item: "=",
      onSelectionClick: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", scope.onDestroy), scope.$watch("item.isSelected", scope.onItemSelectedChange), scope.$watch("item.isSelectable", scope.onItemSelectedChange);
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      var selectionBox = null,
          checkBox = null,
          overlay = null,
          el = $element[0],
          updateTimeout = null;

      function onElementClick(event) {
        $scope.$apply(function () {
          $scope.onSelectionClick({
            event: event
          });
        });
      }

      function destroySelectionBox() {
        selectionBox && (checkBox[0].removeEventListener("click", onElementClick, !1), checkBox = null, overlay[0].removeEventListener("click", onElementClick, !1), overlay = null, selectionBox.remove(), selectionBox = null);
      }

      function createSelectionBox() {
        selectionBox || (selectionBox = $("<div class='asui-selectable-item'><div class='asui-selectable-item-inner'><div class='asui-selectable-item-overlay'/><div class='asui-selectable-item-check'><i class='icon icon-check-circle'></i></div><div></div>"), $element.append(selectionBox), checkBox = selectionBox.find(".asui-selectable-item-check"), (overlay = selectionBox.find(".asui-selectable-item-overlay"))[0].addEventListener("click", onElementClick, !1), checkBox[0].addEventListener("click", onElementClick, !1));
      }

      function updateSelection() {
        updateTimeout = 0, void 0 != $scope.item.isSelected ? $scope.item.isSelected ? (createSelectionBox(), $(el).addClass("asui-selectable-item-selected"), $(el).removeClass("asui-selectable-item-unselected"), $scope.item.isSelectable || $(el).addClass("asui-selectable-item-selected-nonselectable")) : $scope.item.isSelectable ? (createSelectionBox(), $(el).addClass("asui-selectable-item-unselected"), $(el).removeClass("asui-selectable-item-selected-nonselectable"), $(el).removeClass("asui-selectable-item-selected")) : destroySelectionBox() : destroySelectionBox();
      }

      function cancelUpdateTimeout() {
        updateTimeout && (clearTimeout(updateTimeout), updateTimeout = 0);
      }

      $scope.onDestroy = function () {
        destroySelectionBox(), cancelUpdateTimeout();
      }, $scope.onItemSelectedChange = function () {
        cancelUpdateTimeout(), updateTimeout = setTimeout(updateSelection, 0);
      };
    }]
  };
}]), window.angular.module("core.ui").directive("asuiTemplate", ["$compile", "$sce", function ($compile, $sce) {
  return {
    restrict: "EA",
    replace: !0,
    transclude: !0,
    link: function link(scope, ele, attrs, ctrl, transclude) {
      scope.$watch(attrs.template, function (html) {
        ele.empty(), transclude(function (transcludeEl) {
          ele.append(transcludeEl);
        }), ele.append(html), $compile(ele.contents())(scope);
      });
    }
  };
}]), window.angular.module("core.ui").constant("Constants", {
  ContentType: {
    Undefined: 0,
    Image: 1,
    Video: 2,
    Audio: 3,
    Script: 4,
    Slide_Show: 5,
    ASTexture: 6,
    Flash: 7,
    Mtg: 8,
    PDF: 9,
    Television: 10,
    Dynamic_Media: 11,
    Digital_Television: 12,
    Web_Page: 13,
    External_Content: 14,
    PowerPoint: 15,
    Nexus_Remote_Desktop: 16,
    HTML_Text: 17,
    Card: 18,
    Zip: 99,
    Folder: 100
  }
}), window.angular.module("core.ui").factory("ContentUtil", ["Constants", function (Constants) {
  function ContentUtil() {}

  function getContentExtension(filename) {
    var segs = filename.split(".");
    return segs[segs.length - 1];
  }

  function getContentType(filename) {
    var ext = getContentExtension(filename),
        type = null;

    for (var key in knownContentTypes) {
      var contentType = knownContentTypes[key];

      for (var se in contentType) {
        if (se == ext.toLowerCase()) {
          type = key;
          break;
        }
      }

      if (type) break;
    }

    switch (type) {
      case "image":
        return Constants.ContentType.Image;

      case "video":
        return Constants.ContentType.Video;

      case "audio":
        return Constants.ContentType.Audio;

      case "flash":
        return Constants.ContentType.Flash;

      case "pdf":
        return Constants.ContentType.PDF;

      case "powerpoint":
        return Constants.ContentType.PowerPoint;

      case "zip":
        return Constants.ContentType.Zip;

      case "html text":
        return Constants.ContentType.HTML_Text;

      case "web page":
        return Constants.ContentType.Web_Page;

      case "external content":
        return Constants.ContentType.External_Content;

      default:
        return Constants.ContentType.Undefined;
    }
  }

  function getMediaIconByType(type) {
    var icon = null;

    switch (type) {
      case Constants.ContentType.Video:
        icon = "images/content-type/video.svg";
        break;

      case Constants.ContentType.Image:
        icon = "images/content-type/image.svg";
        break;

      case Constants.ContentType.Audio:
        icon = "images/content-type/audio.svg";
        break;

      case Constants.ContentType.Flash:
        icon = "images/content-type/flash.svg";
        break;

      case Constants.ContentType.Web_Page:
        icon = "images/content-type/html.svg";
        break;

      case Constants.ContentType.PDF:
        icon = "images/content-type/pdf.svg";
        break;

      case Constants.ContentType.PowerPoint:
        icon = "images/content-type/ppt.svg";
        break;

      case Constants.ContentType.Dynamic_Media:
        icon = "images/content-type/dynamic-media.svg";
        break;

      case Constants.ContentType.External_Content:
        icon = "images/content-type/external-feeds.svg";
        break;

      case Constants.ContentType.HTML_Text:
        icon = "images/content-type/rich-text-01.svg";
        break;

      case Constants.ContentType.Zip:
        icon = "images/content-type/zip-file.svg";
    }

    return icon;
  }

  ContentUtil.prototype = {
    getKnownContentTypes: function getKnownContentTypes() {
      return knownContentTypes;
    },
    getContentType: getContentType,
    getContentExtension: getContentExtension,
    getMediaIconByType: getMediaIconByType,
    getMediaIconByFilename: function getMediaIconByFilename(filename) {
      return getMediaIconByType(getContentType(filename));
    }
  };
  var knownContentTypes = {
    image: {
      bmp: !0,
      png: !0,
      dds: !0,
      jpeg: !0,
      svg: !0,
      tga: !0,
      jpg: !0,
      gif: !0,
      tif: !0,
      tiff: !0,
      ico: !0
    },
    video: {
      mov: !0,
      wmv: !0,
      avi: !0,
      mpg: !0,
      mpeg: !0,
      flv: !0,
      m4v: !0,
      mp4: !0,
      ts: !0,
      m2t: !0,
      m2ts: !0,
      m2v: !0,
      mkv: !0,
      vob: !0,
      asf: !0,
      ogm: !0,
      ogv: !0,
      divx: !0
    },
    audio: {
      m4a: !0,
      m4b: !0,
      wma: !0,
      webm: !0,
      wav: !0,
      flac: !0,
      aac: !0,
      amr: !0,
      oga: !0,
      ogg: !0,
      mp1: !0,
      mp2: !0,
      mp3: !0
    },
    "html text": {
      htmltext: !0
    },
    flash: {
      swf: !0
    },
    "web page": {
      wpg: !0
    },
    pdf: {
      pdf: !0
    },
    powerpoint: {
      pptx: !0,
      pptm: !0,
      pps: !0,
      ppsx: !0,
      ppt: !0
    },
    zip: {
      zip: !0,
      rar: !0
    },
    "external content": {
      cfg: !0
    }
  };
  return ContentUtil;
}]), window.angular.module("core.ui").factory("CssUtil", ["Constants", function (Constants) {
  var customStyleElement = null;
  return {
    updateClass: function updateClass(name, rules, merge) {
      if (!1 !== merge) {
        for (var style = getStyleElement(), classRule = null, i = 0; i < style.sheet.rules.length; i++) {
          var rule = style.sheet.rules[i];

          if (rule.selectorText == name) {
            classRule = rule;
            break;
          }
        }

        classRule || createClass(name, rules);
      } else createClass(name, rules);
    },
    createClass: createClass,
    getClass: function getClass(name) {
      for (var styles = document.getElementsByTagName("style"), styleIndex = 0; styleIndex < styles.length; styleIndex++) {
        for (var style = styles[styleIndex], i = 0; i < style.sheet.rules.length; i++) {
          var rule = style.sheet.rules[i];
          if (rule.selectorText == name) return rule.style;
        }
      }

      return null;
    }
  };

  function getStyleElement() {
    return customStyleElement || ((customStyleElement = document.createElement("style")).type = "text/css", customStyleElement.id = "cssUtilCustomStyle", document.getElementsByTagName("head")[0].appendChild(customStyleElement)), customStyleElement;
  }

  function createClass(name, rules) {
    for (var style = getStyleElement(), i = 0; i < style.sheet.rules.length; i++) {
      if (style.sheet.rules[i].selectorText == name) {
        style.sheet.deleteRule(i);
        break;
      }
    }

    return style.sheet.insertRule(name + "{" + rules + "}", 0), style.sheet.rules[0];
  }
}]), window.angular.module("core.ui").directive("customTransclude", function () {
  return {
    link: function link(scope, element, attrs, ctrls, transcludeFn) {
      if (!transcludeFn) throw "Illegal use of custom-transclude directive! No parent directive that requires transclusion was found";
      transcludeFn(scope, function (clone) {
        element.empty().append(clone);
      });
    }
  };
}), window.angular.module("core.ui").directive("emitLastRepeaterElement", function () {
  return function (scope) {
    scope.$last && (scope.OnLastRepeaterElement ? scope.OnLastRepeaterElement() : scope.$emit("LastRepeaterElement"));
  };
}), window.angular.module("core.ui").directive("emitRepeaterElementRender", function () {
  return function (scope, element) {
    scope.$emit("RepeaterElementRender", {
      element: element,
      index: scope.$index
    });
  };
}), window.angular.module("core.ui").factory("fileConverter", function ($q) {
  return FileReader.prototype.readAsBinaryString || (FileReader.prototype.readAsBinaryString = function (fileData) {
    var binary = "",
        pt = this,
        localreader = new FileReader();
    localreader.onload = function (e) {
      for (var bytes = new Uint8Array(localreader.result), length = bytes.byteLength, i = 0; i < length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }

      pt.content = binary, $(pt).trigger("onload");
    }, localreader.readAsArrayBuffer(fileData);
  }), {
    fixWorkbookDates: fixWorkbookDates,
    excelToJson: function excelToJson(file, options) {
      var defer = $q.defer(),
          reader = new FileReader();
      return reader.onload = function (e) {
        var bstr = "";
        bstr = e ? e.target.result : this.content;
        var workbook = XLSX.read(bstr, {
          type: "binary",
          cellDates: !0
        });

        if (fixWorkbookDates(workbook), workbook && workbook.Sheets && workbook.SheetNames.length > 0) {
          var data = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]], options);
          defer.resolve(data);
        } else defer.reject("Failed to convert excel to json");
      }, reader.readAsBinaryString(file), defer.promise;
    },
    excelToWorkbook: function excelToWorkbook(file) {
      var bstr = "",
          defer = $q.defer(),
          reader = new FileReader();
      return reader.onload = function (e) {
        bstr = e ? e.target.result : this.content;
        var workbook = XLSX.read(bstr, {
          type: "binary",
          cellDates: !0
        });
        fixWorkbookDates(workbook), workbook && workbook.Sheets && workbook.SheetNames.length > 0 ? defer.resolve(workbook) : defer.reject("Failed to convert excel to a workbook");
      }, reader.readAsBinaryString(file), defer.promise;
    }
  };

  function fixWorkbookDates(workbook) {
    if (!workbook || !workbook.Sheets || 0 == workbook.SheetNames.length) return !1;

    for (var sheetName in workbook.Sheets) {
      var sheet = workbook.Sheets[sheetName];

      for (var cellIndex in sheet) {
        var cell = sheet[cellIndex];
        "d" == cell.t && (cell.v = moment(cell.v).add(1, "minute").startOf("minute").toDate());
      }
    }
  }
}), window.angular.module("core.ui").factory("fileUtil", function ($q, $rootScope) {
  return FileReader.prototype.readAsBinaryString || (FileReader.prototype.readAsBinaryString = function (fileData) {
    var binary = "",
        pt = this,
        localreader = new FileReader();
    localreader.onload = function (e) {
      for (var bytes = new Uint8Array(localreader.result), length = bytes.byteLength, i = 0; i < length; i++) {
        binary += String.fromCharCode(bytes[i]);
      }

      pt.content = binary, $(pt).trigger("onload");
    }, localreader.readAsArrayBuffer(fileData);
  }), {
    readTextFile: function readTextFile(filename) {
      var defer = $q.defer(),
          input = $("<input/>")[0];
      return input.type = "file", input.onchange = function (event) {
        var files = event.target.files;

        if (files.length > 0) {
          var file = files[0],
              reader = new FileReader();
          reader.onload = function (theFile) {
            var text = reader.result;
            $rootScope.$evalAsync(function () {
              defer.resolve(text);
            });
          }, reader.onerror = function () {
            $rootScope.$evalAsync(function () {
              defer.reject("Read error");
            });
          }, reader.readAsText(file);
        } else $rootScope.$evalAsync(function () {
          defer.reject("No file selected");
        });

        input.remove();
      }, $("body")[0].appendChild(input), setTimeout(function () {
        $(input).click(), input.remove();
      }, 200), defer.promise;
    },
    saveToFile: function saveToFile(data, filename) {
      var dataStream = "data:text/json;charset=utf-8," + encodeURIComponent(data),
          a = document.createElement("a");
      a.style.position = "absolute", a.style.top = -100, a.target = "_blank", a.href = dataStream, a.download = filename, document.body.appendChild(a), a.click(), document.body.removeChild(a);
    }
  };
}), window.angular.module("core.ui").directive("selectOnFocus", ["$timeout", function ($timeout) {
  return {
    restrict: "A",
    link: function link(scope, element, attrs) {
      var focusedElement = null;
      element.on("focus", function () {
        var self = this;
        focusedElement != self && (focusedElement = self, $timeout(function () {
          self.select();
        }));
      }), element.on("blur", function () {
        focusedElement = null;
      });
    }
  };
}]), window.angular.module("core.ui").directive("uibPopoverOnTruncate", ["$timeout", function ($timeout) {
  return {
    restrict: "A",
    link: function link(scope, element, attrs) {
      attrs.popoverTrigger = "'none'", attrs.popoverIsOpen = "showPopover";
      var timeoutHandler = null;

      function cancelTimeout() {
        timeoutHandler && ($timeout.cancel(timeoutHandler), timeoutHandler = 0);
      }

      element.on("mouseenter", function () {
        cancelTimeout(), timeoutHandler = $timeout(function () {
          element[0].scrollWidth > element[0].clientWidth && (scope.showPopover = !0);
        }, 150);
      }), element.on("mouseleave", function () {
        cancelTimeout(), timeoutHandler = $timeout(function () {
          scope.showPopover = !1;
        }, 150);
      }), element.on("blur", function () {
        cancelTimeout(), timeoutHandler = $timeout(function () {
          scope.showPopover = !1;
        }, 150);
      });
    }
  };
}]), window.angular.module("core.ui").directive("asuiViewOverlay", function () {
  return {
    controller: function controller($scope, $compile) {
      $scope.mode = "initializing", $scope.compileLoadingMask = function (html) {
        return $compile(html)($scope);
      };
    },
    link: {
      pre: function pre(scope, element, attr) {
        var loaderDiv,
            keys = {
          37: 1,
          38: 1,
          39: 1,
          40: 1
        },
            unload = function unload() {
          for (var childeren = $(element[0]).children(), i = 0; i < childeren.length; i++) {
            $(childeren[i]).removeClass("asui-view-hide-content");
          }

          window.onmousewheel = document.onmousewheel = null, window.onwheel = null, window.ontouchmove = null, document.onkeydown = null, loaderDiv && (loaderDiv.empty(), loaderDiv.remove(), loaderDiv = null);
        };

        scope.$on("view-loaded", function (event) {
          scope.mode = null, scope.processMode(), event.stopPropagation();
        }), scope.$on("view-overlay", function (event, mode) {
          scope.mode = mode, scope.processMode(), event.stopPropagation();
        }), scope.$on("$destroy", function () {
          unload();
        });

        var preventDefault = function preventDefault(e) {
          (e = e || window.event).preventDefault && e.preventDefault(), e.returnValue = !1;
        },
            preventDefaultForScrollKeys = function preventDefaultForScrollKeys(e) {
          if (keys[e.keyCode]) return preventDefault(e), !1;
        };

        scope.processMode = function () {
          switch (scope.mode) {
            case null:
            case "hide":
              unload();
              break;

            case "initializing":
            case "loading":
            case "saving":
            case "deleting":
            case "processing":
              displayLoader();
          }
        };

        var displayLoader = function displayLoader() {
          unload(), window.onwheel = preventDefault, window.onmousewheel = document.onmousewheel = preventDefault, window.ontouchmove = preventDefault, document.onkeydown = preventDefaultForScrollKeys;
          var loaderClass = "";

          switch (scope.mode) {
            case "initializing":
              loaderClass = "asui-view-overlay-initializing";
              break;

            case "loading":
              loaderClass = "asui-view-overlay-loading";
              break;

            case "saving":
              loaderClass = "asui-view-overlay-saving";
              break;

            case "deleting":
              loaderClass = "asui-view-overlay-deleting";
              break;

            case "processing":
              loaderClass = "asui-view-overlay-processing";
          }

          var html = '<div><asui-loading-mask class="view-overlay ' + loaderClass + '" show="true"></asui-loading-mask></div>';
          loaderDiv = scope.compileLoadingMask(html), element.append(loaderDiv[0]);

          for (var childeren = $(element[0]).children(), i = 0; i < childeren.length; i++) {
            var child = $(childeren[i]);
            child.get(0) != loaderDiv.get(0) && child.addClass("asui-view-hide-content");
          }
        };
      },
      post: function post(scope, element, attr) {
        scope.processMode();
      }
    }
  };
}), window.angular.module("core.ui").directive("asuiCardChannelGroup", function () {
  return {
    restrict: "E",
    templateUrl: "card-channel-group/card-channel-group.template",
    scope: {
      ngModel: "=",
      iconOnly: "=",
      iconSize: "@",
      contextMenu: "=",
      onMenuClick: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("ngModel", scope.onModelUpdate, !0), scope.$watch("Thumbnail", scope.onThumbnailUpdate);
    },
    controller: ["$scope", "$element", "$filter", "$sce", "$compile", function ($scope, $element, $filter, $sce, $compile) {
      $scope.contextMenuOptions = {
        placement: "bottom-right"
      }, $scope.imgLoaded = !1, $scope.imgLoading = !1, $scope.lineCount = 1;

      var parseHtml = function parseHtml(html) {
        if (!html) return html;
        var elem = $compile(html = "<unsafe>" + html + "</unsafe>")($scope);
        return elem.length > 0 ? $sce.trustAsHtml(elem[0].outerHTML) : $sce.trustAsHtml(html);
      };

      $scope.onImgError = function () {
        $scope.imgLoaded = !1, $scope.imgLoading = !1;
      }, $scope.onThumbnailUpdate = function (newVal, oldVal) {
        $scope.imgLoaded = !1, $scope.imgLoading = !!newVal;
      }, $scope.onImgLoad = function () {
        $scope.imgLoaded = !0;
      }, $scope.onModelUpdate = function (m) {
        m && ($scope.Name = m.encodedName || parseHtml(m.name), $scope.tooltip = $("<div>" + $scope.Name + "</div>").text(), $scope.LastUpdate = $filter("timeago")(m.updatedAt), $scope.PublishedTo = parseHtml(m.publishedTo), $scope.Thumbnail = m.thumbnail, $scope.ThumbnailSref = m.thumbnailSref, m.totalChannels ? $scope.ItemCount = m.totalChannels + " channels" : $scope.ItemCount = null, $scope.Color = m.color, $scope.PublishedTo || ($scope.lineCount = 2));
      }, $scope.onMenuItemClick = function (target, group, value) {
        $scope.onMenuClick && $scope.onMenuClick({
          group: group,
          value: value
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCardChannel", function () {
  return {
    restrict: "E",
    templateUrl: "card-channel/card-channel.template",
    scope: {
      ngModel: "=",
      iconOnly: "=",
      iconSize: "@",
      contextMenu: "=",
      onMenuClick: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("ngModel", scope.onModelUpdate, !0), scope.$watch("Thumbnail", scope.onThumbnailUpdate);
    },
    controller: ["$scope", "$element", "$filter", "$sce", "$compile", function ($scope, $element, $filter, $sce, $compile) {
      $scope.contextMenuOptions = {
        placement: "bottom-right"
      }, $scope.icon = "icon-channel-filled", $scope.iconHeader = "icon-channel-filled", $scope.iconColor = "", $scope.lineCount = 1, $scope.imgLoaded = !1, $scope.imgLoading = !1;

      var parseHtml = function parseHtml(html) {
        if (!html) return html;
        var elem = $compile(html = "<unsafe>" + html + "</unsafe>")($scope);
        return elem.length > 0 ? $sce.trustAsHtml(elem[0].outerHTML) : $sce.trustAsHtml(html);
      };

      $scope.onImgLoad = function () {
        $scope.imgLoaded = !0;
      }, $scope.onImgError = function () {
        $scope.imgLoaded = !1, $scope.imgLoading = !1;
      }, $scope.onThumbnailUpdate = function (newVal, oldVal) {
        $scope.imgLoaded = !1, $scope.imgLoading = !!newVal;
      }, $scope.onModelUpdate = function (m) {
        if (m) {
          switch ($scope.Thumbnail = m.thumbnail, $scope.ThumbnailSref = m.thumbnailSref, m.type) {
            case 1:
            case "playlist":
              $scope.Type = "Playlist", $scope.icon = "icon-playlist" + ("xs" == $scope.iconSize ? "-filled" : ""), $scope.iconHeader = "icon-playlist-filled", $scope.iconColor = "#77ABD7", $scope.iconTypeColor = "#77ABD7";
              break;

            case 2:
            case "live":
              $scope.Type = "Live", $scope.icon = "icon-live-stream" + ("xs" == $scope.iconSize ? "-filled" : ""), $scope.iconHeader = "icon-live-stream-filled", $scope.iconColor = "#F26F72", $scope.iconTypeColor = "#F26F72";
              break;

            case 3:
            case "sign":
            case "advanced":
              $scope.Type = "Advanced", $scope.icon = "icon-signs" + ("xs" == $scope.iconSize ? "-filled" : ""), $scope.iconHeader = "icon-signs-filled", $scope.iconColor = "#B9D9E3", $scope.iconTypeColor = "#B9D9E3";
              break;

            default:
              $scope.Type = m.type ? m.type : "Channel", $scope.icon = "icon-channel" + ("xs" == $scope.iconSize ? "-filled" : ""), $scope.iconHeader = "icon-channel-filled", $scope.iconColor = "#77ABD7", $scope.iconTypeColor = $scope.iconColor;
          }

          if (m.icon && ($scope.Type = m.type ? m.type : "Channel", $scope.icon = m.icon, $scope.iconHeader = $scope.icon, $scope.iconColor = m.color ? m.color : "#77ABD7", $scope.iconTypeColor = $scope.iconColor), m.color && ($scope.iconColor = $scope.iconTypeColor = m.color), $scope.Name = m.encodedName || parseHtml(m.name), $scope.tooltip = $("<div>" + $scope.Name + "</div>").text(), $scope.LastUpdate = $filter("timeago")(m.updatedAt), m.secondaryFooter ? $scope.secondaryFooter = m.secondaryFooter : $scope.ItemCount = null, $scope.ChannelGroups = angular.copy(m.channelGroups), $scope.ChannelGroups) for (var i = 0; i < $scope.ChannelGroups.length; i++) {
            var cg = $scope.ChannelGroups[i];
            cg.Name = parseHtml(cg.name);
          }
          $scope.PublishedTo = parseHtml(m.publishedTo), $scope.PublishedTo || $scope.ChannelGroups && $scope.ChannelGroups.length ? $scope.PublishedTo && $scope.ChannelGroups && $scope.ChannelGroups.length || ($scope.lineCount = 2) : $scope.lineCount = 3;
        }
      }, $scope.onMenuItemClick = function (target, group, value) {
        $scope.onMenuClick && $scope.onMenuClick({
          group: group,
          value: value
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCardContent", function () {
  return {
    restrict: "E",
    templateUrl: "card-content/card-content.template",
    scope: {
      ngModel: "=",
      iconOnly: "=",
      iconSize: "@",
      loadingSpinner: "@",
      contextMenu: "=",
      onMenuClick: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("ngModel.name", scope.onNameUpdate), scope.$watch("ngModel.thumbnailURL", scope.onThumbnailUpdate), scope.$watch(["ngModel.duration", "ngModel.type"], scope.onModelUpdate);
    },
    controller: ["$scope", "$filter", "$sce", "$compile", "$element", function ($scope, $filter, $sce, $compile, $element) {
      $scope.contextMenuOptions = {
        trigger: "left"
      }, $scope.loadingThumbnail = !1, $scope.onImgLoad = function () {
        $scope.loadingThumbnail = !1, $element.find(".card-thumbnail img"), $element.find(".card-thumbnail img").css("display", "inline"), $element.find(".card-thumbnail .content-type-icon").css("display", "none");
      }, $scope.onImgError = function () {
        $scope.loadingThumbnail = !1, $element.find(".card-thumbnail img").css("display", "none"), $element.find(".card-thumbnail .content-type-icon").css("display", "inline");
      }, $scope.onNameUpdate = function (value) {
        $scope.Name = $scope.ngModel.encodedName || function (html) {
          if (!html || -1 == html.indexOf("<")) return html;
          var elem = $compile(html = "<unsafe>" + html + "</unsafe>")($scope);
          return elem.length > 0 ? $sce.trustAsHtml(elem[0].outerHTML) : $sce.trustAsHtml(html);
        }(value), $scope.tooltip = $("<div>" + $scope.Name + "</div>").text();
      }, $scope.onThumbnailUpdate = function (value) {
        value ? $scope.loadingThumbnail = !0 : ($element.find(".card-thumbnail img").css("display", "none"), $element.find(".card-thumbnail .content-type-icon").css("display", "inline"));
      }, $scope.onModelUpdate = function (m) {
        if ($scope.ngModel) {
          switch ($scope.ngModel.duration ? $scope.Duration = isNaN($scope.ngModel.duration) ? $scope.ngModel.duration : $filter("contentDuration")($scope.ngModel.duration) : 0 === $scope.ngModel.duration ? $scope.Duration = 0 : $scope.Duration = null, $scope.ngModel.type) {
            case 1:
            case "1":
            case "image":
              $scope.icon = "icon-image-filled";
              break;

            case 2:
            case "2":
            case "video":
              $scope.icon = "icon-video-filled";
              break;

            case 3:
            case "3":
            case "audio":
              $scope.icon = "icon-filled-audio";
              break;

            case 4:
            case "4":
            case "script":
              $scope.icon = "icon-script-filled";
              break;

            case 7:
            case "7":
            case "flash":
              $scope.icon = "icon-flash-filled";
              break;

            case 18:
            case "18":
            case "card":
              $scope.icon = "icon-card";
              break;

            case 13:
            case "13":
            case "web":
            case "html":
              $scope.icon = "icon-card-web";
              break;

            case 11:
            case "11":
            case "dynamic":
              $scope.icon = "icon-dynamic-filled";
              break;

            case 17:
            case "17":
            case "richtext":
            case "text":
              $scope.icon = "icon-txt-filled";
              break;

            case 9:
            case "9":
            case "pdf":
              $scope.icon = "icon-pdf";
              break;

            case 15:
            case "15":
            case "ppt":
              $scope.icon = "icon-ppt-filled";
              break;

            case 14:
            case "14":
            case "external":
              $scope.icon = "icon-external-filled";
              break;

            case 90:
            case "90":
            case "document":
              $scope.icon = "icon-document-filled";
              break;

            case 91:
            case "91":
            case "spreadsheet":
              $scope.icon = "icon-spreadsheet-filled";
              break;

            case 99:
            case "99":
            case "zip":
              $scope.icon = "icon-zip";
              break;

            default:
              $scope.icon = "icon-generic-filled";
          }

          $scope.iconColor = "#eef4f9", $scope.ngModel.thumbnailURL || $scope.$evalAsync(function () {
            $element.find(".content-type-icon").css("display", "initial");
          });
        }
      }, $scope.onMenuItemClick = function (value) {
        $scope.onMenuClick && $scope.onMenuClick({
          value: value
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCardDevice", function () {
  return {
    restrict: "E",
    templateUrl: "card-device/card-device.template",
    scope: {
      ngModel: "=",
      iconOnly: "=",
      iconSquare: "=",
      iconSize: "@"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("ngModel", scope.onModelUpdate, !0);
    },
    controller: ["$scope", "$element", "$filter", "$sce", "$compile", function ($scope, $element, $filter, $sce, $compile) {
      $scope.onModelUpdate = function (m) {
        if (m) if ($scope.ThumbnailSref = m.thumbnailSref, $scope.Color = m.color, m.thumbnail) $scope.Thumbnail = m.thumbnail;else {
          var iconUrl = "generic-device";
          if (m.type) switch (m.type.toLowerCase()) {
            case "android":
              iconUrl = "android";
              break;

            case "chromeos":
              iconUrl = "chrome";
              break;

            case "brightsign":
              iconUrl = "brightsign";
              break;

            case "intel":
              iconUrl = "intel";
              break;

            case "surevue":
              iconUrl = "mediavue";
              break;

            case "samsungtv":
              iconUrl = "samsung";
              break;

            case "tizentv":
              iconUrl = "tizen";
              break;

            case "uwp":
            case "windows":
              iconUrl = "windows";
              break;

            case "ios":
              iconUrl = "ios";
              break;

            case "macos":
              iconUrl = "macos";
              break;

            case "pwa":
            case "html5client":
              iconUrl = "pwa";
              break;

            case "lgwebos":
              iconUrl = "lg";
              break;

            case "directx":
              iconUrl = "directx";
              break;

            case "mersive":
              iconUrl = "mersive";
              break;

            case "dmp-4310":
            case "edge340":
            case "edge300":
            case "dmp-4400":
            case "cisco":
              iconUrl = "cisco";
              break;

            case "cre":
            case "webexshare":
            case "webexphone":
            case "webexunknown":
            case "webexboard":
            case "webexcontrolhubdevice":
              iconUrl = "cisco-webex";
              break;

            case "crestron":
              iconUrl = "crestron";
              break;

            case "linux":
              iconUrl = "linux-ubuntu";
              break;

            case "devicegroup":
              iconUrl = "generic-device-group";
              break;

            default:
              iconUrl = "generic-device";
          }
          var shape = "circle";
          $scope.iconSquare && (shape = "square"), $scope.Thumbnail = "images/device-icons/" + shape + "/" + iconUrl + "-" + shape + ".svg";
        }
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCardDeviceGroup", function () {
  return {
    restrict: "E",
    templateUrl: "card-device-group/card-device-group.template",
    scope: {
      iconSize: "@"
    }
  };
}), window.angular.module("core.ui").directive("asuiCardNetwork", function () {
  return {
    restrict: "E",
    templateUrl: "card-network/card-network.template",
    scope: {
      iconSize: "@"
    }
  };
}), window.angular.module("core.ui").directive("asuiCardUser", function () {
  return {
    restrict: "E",
    templateUrl: "card-user/card-user.template",
    scope: {
      ngModel: "=",
      iconOnly: "=",
      iconSize: "@"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("ngModel", scope.onModelUpdate, !0), scope.$watch("Thumbnail", scope.onThumbnailUpdate);
    },
    controller: ["$scope", "$element", "$filter", "$sce", "$compile", function ($scope, $element, $filter, $sce, $compile) {
      $scope.imgLoaded = !1, $scope.onThumbnailUpdate = function (newVal) {
        newVal || ($scope.imgLoaded = !1);
      }, $scope.onModelUpdate = function (m) {
        if (!m) return $scope.Thumbnail = null, $scope.ThumbnailSref = null, void ($scope.imgLoaded = !1);
        if ($scope.Name = function (html) {
          if (!html) return html;
          var elem = $compile(html = "<unsafe>" + html + "</unsafe>")($scope);
          return elem.length > 0 ? $sce.trustAsHtml(elem[0].outerHTML) : $sce.trustAsHtml(html);
        }(m.name), m.name || !m.firstName && !m.lastName || (m.name = m.firstName ? m.firstName : "", m.name += m.lastName ? " " + m.lastName : ""), m.name && m.name.length > 0) {
          if ($scope.Initial = m.name[0], $scope.DoubleInitial = m.name[0], m.firstName && m.lastName) $scope.DoubleInitial = m.firstName[0] + m.lastName[0];else {
            var split = m.name.split(" ");
            split.length > 1 && ($scope.DoubleInitial = split[0][0] + split[1][0]);
          }
        } else $scope.Initial = "U";
        m.icon && m.icon.length > 0 && ($scope.Initial = m.icon), $scope.Thumbnail = m.thumbnail, $scope.ThumbnailSref = m.thumbnailSref, $scope.Color = m.color;
      }, $scope.onImageLoad = function (e) {
        e && e.target && e.target.naturalWidth > 0 ? $scope.imgLoaded = !0 : $scope.imgLoaded = !1;
      }, $scope.onImageError = function () {
        $scope.imgLoaded = !1;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCardUserGroup", function () {
  return {
    restrict: "E",
    templateUrl: "card-user-group/card-user-group.template",
    scope: {
      iconSize: "@"
    }
  };
}), window.angular.module("core.ui").component("asuiAccordion", {
  bindings: {
    options: "<"
  },
  transclude: !0,
  templateUrl: "component-accordion/accordion.template",
  controller: function controller() {
    var $ctrl = this;

    $ctrl.$onChanges = function () {
      $ctrl.options;
    };
  }
}), window.angular.module("core.ui").directive("asuiBadge", function () {
  return {
    restrict: "E",
    templateUrl: "component-badge/badge.template",
    scope: {
      type: "@",
      size: "@",
      count: "@"
    },
    link: function link(scope, element, $sce) {
      $(element.parentNode).on("mouseover", scope.onMouseOver), $(element.parentNode).on("mouseout", scope.onMouseOut), element.on("$destroy", function () {
        $(element.parentNode).off("mouseover", scope.onMouseOver), $(element.parentNode).off("mouseout", scope.onMouseOut);
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", function ($scope, $location, $element, $timeout) {
      $scope.onMouseOver = function () {
        $scope.onHover = !0;
      }, $scope.onMouseOut = function () {
        $scope.onHover = !1;
      };
    }]
  };
}), window.angular.module("core.ui").component("asuiBreadcrumbs", {
  bindings: {
    items: "<",
    onItemClick: "&"
  },
  templateUrl: "component-breadcrumbs/breadcrumbs.template",
  controller: function controller($interval, $state) {
    var $ctrl = this,
        currentState = null,
        checkStateInterval = $interval(function () {
      currentState != $state.current.name && function () {
        if ($ctrl.items && $ctrl.items.length) {
          currentState = $state.current.name;

          for (var i = 0; i < $ctrl.items.length; i++) {
            var item = $ctrl.items[i];
            if (item.contextMenu) for (var k = 0; k < item.items.length; k++) {
              var cmItem = item.items[k];

              if (cmItem.value === currentState) {
                item.contextMenu.model[0].value = currentState;
                break;
              }
            }
          }
        }
      }();
    }, 50);

    function initContextMenu(item) {
      return {
        selectedInputs: {},
        model: [{
          name: item.label,
          value: item.selected ? item.selected : item.items[0].value
        }],
        menuGroups: [{
          name: item.label,
          type: "singleselect",
          items: item.items
        }],
        options: {
          isOpen: !1
        }
      };
    }

    $ctrl.$onChanges = function () {
      if ($ctrl.items) for (var i = 0; i < $ctrl.items.length; i++) {
        var item = $ctrl.items[i];
        item.items && item.items.length && (item.contextMenu = initContextMenu(item));
      }
    }, $ctrl.$onDestroy = function () {
      $interval.cancel(checkStateInterval);
    }, $ctrl.onContextMenuClick = function (target, group, value) {
      $ctrl.onItemClick({
        item: {
          value: value,
          group: group
        }
      });
    }, $ctrl.onClick = function (item) {
      $ctrl.onItemClick({
        item: item
      });
    };
  }
}), window.angular.module("core.ui").directive("asuiCarouselCard", function () {
  return {
    restrict: "E",
    templateUrl: "component-carousel/carousel.card.template",
    scope: {
      item: "=",
      onComplete: "&",
      onError: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.destroy();
      }), scope.init();
    },
    controller: function controller($scope, $interval, $element, CarouselItemApi, $sce, $httpParamSerializer) {
      var resizeTimer;
      $scope.$sce = $sce, $scope.resolvedSrc = "";
      var iframe,
          containerWidth,
          containerHeight,
          containerRatio,
          currentInterval = 0,
          currentScale = 1,
          cardHeight = 1080,
          cardWidth = 1920,
          cardRatio = cardWidth / cardHeight,
          lastRefresh = null,
          api = null;

      function play() {
        api.play(), new Date().getTime() - lastRefresh.getTime() > 3e3 && (iframe[0].src = iframe[0].src);
      }

      function pause() {
        api.pause();
      }

      function stop() {
        api.stop();
      }

      function getElapsed() {
        return api.getElapsed();
      }

      function getDuration() {
        return api.getDuration();
      }

      function clearTimer() {
        resizeTimer && ($interval.cancel(resizeTimer), resizeTimer = 0);
      }

      function startTimer(interval) {
        resizeTimer && currentInterval == interval || (clearTimer(), resizeTimer = $interval(checkScale, interval), currentInterval = interval);
      }

      function getUniformFillScale() {
        return cardRatio >= containerRatio ? containerHeight / cardHeight : containerWidth / cardWidth;
      }

      function checkScale() {
        containerWidth = 0 | $element.parent().width(), containerHeight = 0 | $element.parent().height(), containerRatio = containerWidth / containerHeight;
        var requiredScale = 1;

        switch ($scope.item.aspect) {
          case "uniform":
            requiredScale = cardRatio >= containerRatio ? containerWidth / cardWidth : containerHeight / cardHeight;
            break;

          case "fill":
            requiredScale = 0;
            break;

          case "uniformfill":
          default:
            requiredScale = getUniformFillScale();
        }

        requiredScale != currentScale ? (currentScale = requiredScale, requiredScale ? (iframe[0].style.transform = "translate(-50%, -50%) scale(" + requiredScale + ")", iframe[0].style.position = "", startTimer(100)) : (iframe[0].style.transform = "none", iframe[0].style.position = "initial", iframe[0].style.width = "100%", iframe[0].style.height = "100%", clearTimer())) : startTimer(500);
      }

      function refresh() {
        lastRefresh = new Date();
        var url = $scope.item.src || "";
        $scope.item.urlParameters && Object.keys($scope.item.urlParameters).length > 0 && (url += (url.indexOf("?") > 0 ? "&" : "?") + $httpParamSerializer($scope.item.urlParameters)), $scope.resolvedSrc != url && ($scope.resolvedSrc = url);
      }

      function onCardEvent(event) {
        switch (event.data.message) {
          case "complete":
            api.isPlaying() && !$scope.item.duration && $scope.onComplete();
            break;

          case "error":
            api.isPlaying() ? $scope.onComplete() : $scope.onError();
        }
      }

      $scope.init = function () {
        (api = new CarouselItemApi($scope.item)).onComplete($scope.onComplete), iframe = $element.find("iframe"), checkScale(), startTimer(100), refresh(), $scope.item.$refresh = refresh;
        var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
        (0, window[eventMethod])("attachEvent" == eventMethod ? "onmessage" : "message", onCardEvent, !1), $scope.item.api = {
          play: play,
          pause: pause,
          stop: stop,
          getElapsed: getElapsed,
          getDuration: getDuration
        };
      }, $scope.destroy = function () {
        clearTimer();
        var eventMethod = window.addEventListener ? "removeEventListener" : "detachEvent";
        (0, window[eventMethod])("detachEvent" == eventMethod ? "onmessage" : "message", onCardEvent);
      };
    }
  };
}), window.angular.module("core.ui").factory("CarouselItemApi", function ($timeout) {
  function CarouselItemApi(item) {
    this.timer = 0, this.isPlayingFlag = !1, this.onCompleteCb = null, this.elapsed = 0, this.timerStart = 0, this.item = item;
  }

  return CarouselItemApi.prototype = {
    getItemsPromise: null,
    timer: 0,
    isPlayingFlag: !1,
    onCompleteCb: null,
    elapsed: 0,
    timerStart: 0,
    item: null
  }, CarouselItemApi.prototype.getItem = function () {
    return this.item;
  }, CarouselItemApi.prototype.play = function () {
    if (!this.isPlayingFlag) {
      var remaining = this.item.duration - this.elapsed;
      this.item.duration > 0 && this.startTimer(remaining), this.isPlayingFlag = !0, this.timerStart = new Date().getTime();
    }
  }, CarouselItemApi.prototype.pause = function () {
    this.isPlayingFlag && (this.clearTimer(), this.isPlayingFlag = !1, this.elapsed = this.elapsed + (new Date().getTime() - this.timerStart) / 1e3);
  }, CarouselItemApi.prototype.stop = function () {
    this.isPlayingFlag = !1, this.clearTimer(), this.elapsed = 0, this.timerStart = 0;
  }, CarouselItemApi.prototype.getElapsed = function () {
    return this.isPlayingFlag ? this.elapsed + (new Date().getTime() - this.timerStart) / 1e3 : this.elapsed;
  }, CarouselItemApi.prototype.isPlaying = function () {
    return this.isPlayingFlag;
  }, CarouselItemApi.prototype.getDuration = function () {
    return this.item.duration;
  }, CarouselItemApi.prototype.onComplete = function (callback) {
    this.onCompleteCb = callback;
  }, CarouselItemApi.prototype.clearTimer = function () {
    this.timer && ($timeout.cancel(this.timer), this.timer = 0);
  }, CarouselItemApi.prototype.startTimer = function (interval) {
    this.timer = $timeout(this.onTimerComplete.bind(this), 1e3 * interval);
  }, CarouselItemApi.prototype.onTimerComplete = function () {
    this.timer = 0, this.elapsed = 0, this.isPlayingFlag = !1, this.onCompleteCb && this.onCompleteCb(this.item);
  }, CarouselItemApi;
}), window.angular.module("core.ui").directive("asuiCarousel", function () {
  return {
    restrict: "E",
    scope: {
      items: "=",
      options: "=",
      onApiReady: "&",
      onComplete: "&"
    },
    transclude: !0,
    templateUrl: "component-carousel/carousel.template",
    link: function link(scope, element, $sce) {
      scope.owlCarousel = null, scope.localItems = [], scope.$watch("items", scope.onItemsChange, !0), element.on("$destroy", function () {
        scope.onDestroy();
      }), scope.OnLastRepeaterElement = function () {
        var options;
        (options = angular.copy(scope.options)).onChange = scope.onChange, options.onChanged = scope.onChanged, options.onResized = scope.onResized, options.onTranslated = scope.onTranslated, scope.owlCarousel = element.find(".owl-carousel").owlCarousel(options), angular.isDefined(scope.onApiReady) && scope.onApiReady({
          api: {
            play: scope.play,
            isPlaying: scope.isPlaying,
            pause: scope.pause,
            next: scope.next,
            previous: scope.previous,
            loadItem: scope.loadItem,
            getCurrentItem: scope.getCurrentItem,
            trigger: scope.getCarouselApi().trigger
          }
        });
      }, scope.onInit();
    },
    controller: function controller($scope, $element, $sce, $interval, CarouselItemApi) {
      var isPlaying = !1,
          currentItem = null,
          playingItem = null,
          layoutIntervalId = 0;

      function checkCarouselLayout() {
        if ($scope.localItems && $scope.localItems.length > 0 && $scope.options && 1 === $scope.options.items) {
          var items = $element.find(".owl-item");
          items.length > 0 && items.width() != $element.find(".owl-stage-outer").width() && $scope.getCarouselApi().trigger("refresh.owl.carousel");
        }
      }

      function destroyOwl() {
        try {
          $scope.owlCarousel.owlCarousel("destroy");
        } catch (e) {}

        $element.find(".owl-stage").remove();
      }

      function playItem() {
        var item = $scope.getCurrentItem();
        return !!item && (item.api && item.api.play ? item.api.play() : (item.api = new CarouselItemApi(item), item.api.onComplete($scope.onItemComplete), item.api.play()), playingItem = item, !0);
      }

      function updateLocalItemState(e) {
        var elementWidth = $element.width(),
            lazyLoading = !1;
        $scope.options && !0 === $scope.options.lazyLoading && (lazyLoading = !0), $scope.$evalAsync(function () {
          var activeStart = e.item.index;
          currentItem = e.item.index;

          for (var activeEnd = activeStart + e.page.size, i = 0; i < $scope.localItems.length; i++) {
            var item = $scope.localItems[i];
            i == e.item.index ? item.$isCurrent = !0 : item.$isCurrent = !1, i >= activeStart && i < activeEnd ? (item.$isActive = !0, item.$showPlaceHolder = !1) : ((i > activeEnd ? i - activeEnd : activeStart - i) <= e.page.size && ("image" == item.type || "video" == item.type) && (item.$showPlaceHolder = !1), item.$isActive = !1), lazyLoading || (item.$showPlaceHolder = !1), $scope.options.itemHeight ? item.$style = {
              height: $scope.options.itemHeight + "px"
            } : $scope.options.itemAspectRatio && elementWidth > 0 && (item.$style = {
              height: elementWidth / $scope.options.itemAspectRatio + "px"
            });
          }
        });
      }

      $scope.onInit = function () {
        layoutIntervalId = $interval(checkCarouselLayout, 250);
      }, $scope.onDestroy = function () {
        layoutIntervalId > 0 && ($interval.cancel(layoutIntervalId), layoutIntervalId = 0), destroyOwl();
      }, $scope.getCarouselApi = function () {
        return {
          trigger: function trigger() {
            $scope.owlCarousel.trigger.apply($scope.owlCarousel, arguments);
          }
        };
      }, $scope.$sce = $sce, $scope.onChange = function (e) {
        $scope.options && $scope.options.onChange && (e.item && null != e.item.index && (e.currentItem = $scope.localItems[e.item.index]), e.property && "position" == e.property.name && (e.nextItem = $scope.localItems[e.property.value]), $scope.options.onChange(e));
      }, $scope.onItemsChange = function (val) {
        if (val) {
          for (var items = angular.copy(val), runningId = new Date().getTime(), i = 0; i < items.length; i++) {
            var item = items[i];
            item.$index = i, item.$refresh = angular.noop, item.$showPlaceHolder = !0, item.trustedSrc = $sce.trustAsResourceUrl(item.src), $scope.options && ($scope.options.itemAspect && void 0 === item.aspect && (item.aspect = $scope.options.itemAspect), $scope.options.itemDuration && void 0 === item.duration && "video" != item.type.toLowerCase() && (item.duration = $scope.options.itemDuration)), item.id ? item.$$id = item.id : item.Id ? item.$$id = item.Id : item.$$id = runningId + i;
          }

          $scope.localItems = items;
        } else val = [];

        destroyOwl();
      }, $scope.onChanged = function (e) {
        if ($scope.owlCarousel && e.item && "position" == e.property.name) {
          var item = $scope.localItems[e.item.index],
              animateIn = item.animateIn ? item.animateIn : $scope.options.animateIn,
              animateOut = item.animateOut ? item.animateOut : $scope.options.animateOut,
              owl = $scope.owlCarousel.data("owl.carousel");
          owl.settings.animateIn = animateIn, owl.settings.animateOut = animateOut;
        }

        updateLocalItemState(e), $scope.options && $scope.options.onChanged && $scope.options.onChanged(e);
      }, $scope.onResized = function (e) {
        updateLocalItemState(e), $scope.options && $scope.options.onResized && $scope.options.onResized(e);
      }, $scope.onTranslated = function (e) {
        !function (e) {
          var lazyLoading = !0,
              lazyUnloading = !0;
          $scope.options && !1 === $scope.options.lazyLoading && (lazyLoading = !1), $scope.options && !1 === $scope.options.lazyUnloading && (lazyUnloading = !1), lazyLoading && lazyUnloading && $scope.$evalAsync(function () {
            var activeStart = e.item.index;
            currentItem = e.item.index;

            for (var activeEnd = activeStart + e.page.size, i = 0; i < $scope.localItems.length; i++) {
              var item = $scope.localItems[i];
              if (i >= activeStart && i < activeEnd) item.$showPlaceHolder = !1;else {
                var distance = 0;
                distance = i > activeEnd ? i - activeEnd : activeStart - i, item.$activeDisatnce = distance, distance <= e.page.size && ("image" == item.type || "video" == item.type) ? item.$showPlaceHolder = !1 : item.$showPlaceHolder = !0;
              }
            }
          });
        }(e), $scope.options && $scope.options.onTranslated && $scope.options.onTranslated(e), playingItem && playingItem.api && playingItem.api.stop && playingItem.api.stop(), isPlaying && playItem();
      }, $scope.onError = function (item) {
        item.onError = !0;
      }, $scope.onItemComplete = function (item) {
        if (isPlaying) {
          if (item == $scope.getCurrentItem()) {
            if (item == $scope.localItems[$scope.localItems.length - 1]) return isPlaying = !1, playingItem = null, $scope.onComplete && $scope.onComplete(), !0;
            $scope.next();
          }

          return !0;
        }
      }, $scope.play = function () {
        isPlaying || playItem() && (isPlaying = !0);
      }, $scope.pause = function () {
        isPlaying && (isPlaying = !1, function () {
          if (!playingItem || !playingItem.api) return !1;
          playingItem.api.pause();
        }());
      }, $scope.isPlaying = function () {
        return isPlaying;
      }, $scope.getCurrentItem = function () {
        return $scope.localItems && currentItem >= 0 && currentItem < $scope.localItems.length ? $scope.localItems[currentItem] : null;
      }, $scope.loadItem = function (offset) {}, $scope.next = function () {
        $scope.getCarouselApi().trigger("next.owl.carousel", [500]);
      }, $scope.previous = function () {
        $scope.getCarouselApi().trigger("prev.owl.carousel", [500]);
      };
    }
  };
}), window.angular.module("core.ui").directive("asuiCarouselVideo", function () {
  return {
    restrict: "E",
    templateUrl: "component-carousel/carousel.video.template",
    scope: {
      item: "=",
      hideControls: "=?",
      isCurrent: "=?",
      isActive: "=?",
      onError: "&",
      onComplete: "&"
    },
    link: function link(scope, element) {
      scope.$watch("isCurrent", function (val) {
        !1 === val && scope.pauseVideo();
      }, !0), scope.$watch("isActive", function (val) {
        !1 === val ? scope.pauseVideo() : scope.resetVideo();
      }, !0), element.on("$destroy", function () {
        scope.destroy();
      });
      var video = element.find("video");
      video.length && (video[0].onended = scope.onVideoEnd, video[0].onerror = scope.onVideoError), scope.init();
    },
    controller: function controller($scope, $timeout, $element, $sce, CarouselItemApi) {
      var clockApi;
      $scope.showPlayButton = !0, $scope.src = $sce.trustAsResourceUrl($scope.item.src);
      var video = $element.find("video")[0];

      function play() {
        clockApi.play(), video.play(), $scope.showPlayButton = !1;
      }

      function pause() {
        clockApi.pause(), video.pause(), $scope.showPlayButton = !0;
      }

      function stop() {
        clockApi.stop(), $scope.resetVideo(), $scope.showPlayButton = !0;
      }

      function getElapsed() {
        return video.currentTime;
      }

      function getDuration() {
        return video.duration;
      }

      $scope.destroy = function () {
        video.onended = null, video.onerror = null, $scope.item.api = null;
      }, $scope.init = function () {
        $scope.item.api = {
          play: play,
          pause: pause,
          stop: stop,
          getElapsed: getElapsed,
          getDuration: getDuration
        }, clockApi = new CarouselItemApi($scope.item), $scope.item.duration && clockApi.onComplete($scope.onVideoEnd);
      }, $scope.onPlayClick = function () {
        play();
      }, $scope.onVideoClick = function () {
        $scope.hideControls || pause();
      }, $scope.onVideoEnd = function () {
        $scope.$evalAsync(function () {
          var processed = !1;
          $scope.onComplete && (processed = $scope.onComplete()), processed || $scope.resetVideo();
        });
      }, $scope.onVideoError = function () {
        $scope.$evalAsync(function () {
          $scope.onError && $scope.onError();
        });
      }, $scope.pauseVideo = function () {
        pause();
      }, $scope.resetVideo = function () {
        video.currentTime = 0, video.pause(), $scope.showPlayButton = !0;
      };
    }
  };
}), window.angular.module("core.ui").directive("asuiCarouselWeb", function () {
  return {
    restrict: "E",
    templateUrl: "component-carousel/carousel.web.template",
    scope: {
      src: "@",
      onError: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {}), scope.$watch("src", scope.onSrcUpdate);
    },
    controller: function controller($scope, $timeout, $element, $sce) {
      $scope.$sce = $sce, $scope.resolvedSrc = "", $scope.onSrcUpdate = function () {
        $scope.src && $scope.src.toLowerCase().indexOf(".wpg") === $scope.src.length - 4 ? $.get($scope.src, function (data) {
          if (data) {
            var rows = CSV.parse(data);
            2 == rows.length && function (data) {
              if (data.length >= 2) {
                var url = data[1];

                if (0 === url.indexOf("C:\\FastNetV2\\UG Media")) {
                  var segs = $scope.src.split("://");
                  url = segs[0] + "://" + segs[1].split("/")[0] + "/app/fastnetdata/ug%20media" + (url = (url = url.replace("C:\\FastNetV2\\UG Media", "")).split("\\").join("/"));
                }

                $scope.resolvedSrc = url;
              }
            }(rows[1]);
          }
        }) : $scope.resolvedSrc = $scope.src;
      };
    }
  };
}), window.angular.module("core.ui").directive("asuiChartDonut", function () {
  return {
    restrict: "E",
    templateUrl: "component-chart-donut/chart-donut.template",
    scope: {
      centerLabel: "=",
      data: "=",
      colors: "=",
      options: "="
    },
    link: function link(scope, element) {
      scope.chartData = [], scope.chartLabels = [], scope.chartOptions = null, scope.chartColors = ["#77ADD7", "#9DCBDA", "#E67F83", "#90A9E8", "#FFD98B", "#FFA885"], scope.colors && (scope.chartColors = scope.colors), scope.options && (scope.chartOptions = scope.options), scope.$watch("data", function (val) {
        if (scope.data) {
          scope.chartLabels = [], scope.chartData = [];

          for (var i = 0; i < scope.data.length; i++) {
            var data = scope.data[i];
            scope.chartLabels.push(data.label), scope.chartData.push(data.value);
          }
        }
      }, !0);
    }
  };
}), function ($angular) {
  $angular.module("core.ui").directive("asuiCheckbox", function () {
    return {
      restrict: "E",
      templateUrl: "component-checkbox/checkbox.template",
      scope: {
        ngModel: "=",
        items: "=",
        options: "=",
        onClick: "&"
      },
      link: function link(scope) {
        scope.$watch("items", function () {
          scope.localItems = $angular.copy(scope.items);
        }, !0), scope.$watch("ngModel", function () {
          scope.updateCheckedItems();
        }, !0), scope.init();
      },
      controller: ["$scope", function ($scope) {
        $scope.localItems = [], $scope.init = function () {
          $scope.updateCheckedItems();
        }, $scope.updateCheckedItems = function () {
          if ($scope.ngModel && $scope.localItems) for (var i = 0; i < $scope.localItems.length; i++) {
            var item = $scope.localItems[i];
            item.checked = !1;

            for (var k = 0; k < $scope.ngModel.length; k++) {
              if ($scope.ngModel[k] == item.value) {
                item.checked = !0;
                break;
              }
            }
          }
        }, $scope.onCheckboxClick = function () {
          !function () {
            $scope.ngModel = [];

            for (var i = 0; i < $scope.localItems.length; i++) {
              var item = $scope.localItems[i];
              item.checked && $scope.ngModel.push(item.value);
            }
          }(), $scope.onClick({
            value: $scope.ngModel
          });
        };
      }]
    };
  });
}(window.angular), window.angular.module("core.ui").directive("asuiCodeView", function () {
  return {
    restrict: "E",
    templateUrl: "component-codeview/codeview.template",
    scope: {
      id: "@",
      options: "=?",
      ngModel: "=",
      onChange: "&",
      onEditorLoad: "&"
    },
    link: function link(scope, element) {
      scope.init(), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("ngModel", scope.onModelUpdate, !0), scope.$watch("options.mode", scope.onModeUpdate, !0);
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      var editor = null,
          isVisible = !1,
          interval = 0;

      function checkSize() {
        if (editor) {
          var visible = $($element).is(":visible");
          isVisible != visible && visible && editor.refresh(), isVisible = visible;
        }
      }

      function onTextChange() {
        var textValue = editor.getValue();
        $scope.ngModel != textValue && ($scope.ngModel = textValue, $scope.onChange({
          value: textValue
        }));
      }

      $scope.destroy = function () {
        interval && clearInterval(interval);
      }, $scope.init = function () {
        "string" != typeof $scope.ngModel && ($scope.ngModel = "");
        var options = {
          indentWithTabs: !0,
          autocorrect: !0,
          lineNumbers: !0,
          lineWrapping: !0,
          mode: "text/html",
          autoCloseTags: !0,
          tabMode: "indent"
        };

        for (var key in $scope.options) {
          options[key] = $scope.options[key];
        }

        var el = $element.find("textarea")[0];
        editor && editor.toTextArea(), editor = CodeMirror.fromTextArea(el, options), $scope.ngModel && editor.setValue($scope.ngModel), editor.on("change", onTextChange), $scope.onEditorLoad({
          editor: editor
        }), interval = setInterval(checkSize, 100);
      }, $scope.onModeUpdate = function (val) {
        $scope.init();
      }, $scope.onModelUpdate = function (newVal) {
        null !== newVal && void 0 !== newVal || (newVal = ""), newVal != editor.getValue() && (editor.setValue(newVal), editor.setCursor(editor.lineCount(), 0));
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiColorPicker", function () {
  return {
    restrict: "E",
    replace: "true",
    templateUrl: "component-colorpicker/colorpicker.template",
    scope: {
      ngModel: "=",
      options: "=?",
      onChange: "&",
      onMove: "&",
      onCancel: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("options", scope.onOptionsUpdate), scope.$watch("ngModel", scope.onModelUpdate), scope.init();
    },
    controller: ["$scope", "$location", "$element", "$timeout", "AsComponentUtil", function ($scope, $location, $element, $timeout, AsComponentUtil) {
      var componentUtil = new AsComponentUtil();
      var colorEl = null,
          prevColor = {
        hex: null,
        alpha: 0
      };

      function updateLocalModel() {
        $scope.localModal = $scope.ngModel;
      }

      function colorToString(color) {
        return color ? 1 != color.getAlpha() ? color.toRgbString() : color.toHexString() : "transparent";
      }

      function colorPickerMoveEvent(color) {
        if (!$scope.onMove) return;
        var val = null;
        color && (val = colorToString(color)), $scope.$evalAsync(function () {
          $scope.onMove({
            value: val
          });
        });
      }

      function triggerOnShowEvent() {
        prevColor = {
          alpha: 0,
          hex: null
        };
        var color = tinycolor(colorEl.spectrum("get"));
        color && (prevColor = {
          hex: color.toHexString(),
          alpha: color.getAlpha()
        });
      }

      function triggerOnHideEvent() {
        var color = tinycolor(colorEl.spectrum("get")),
            curColor_hex = color.toHexString(),
            curColor_alpha = color.getAlpha();
        prevColor.alpha == curColor_alpha && prevColor.hex == curColor_hex && (prevColor = componentUtil.resetColorPickerAlpha(colorEl, color, prevColor), color && (color = colorToString(color)), $scope.$evalAsync(function () {
          $scope.onCancel({
            value: color
          });
        }));
      }

      function triggerOnChangeEvent(color) {
        color && (color = colorToString(color)), $scope.$evalAsync(function () {
          $scope.ngModel = color, $scope.onChange({
            value: color
          });
        });
      }

      $scope.localModal = null, $scope.init = function () {
        if ($scope.options && $scope.options.defaultColor && (null === $scope.ngModel || "" === $scope.ngModel || jQuery.isEmptyObject($scope.ngModel))) {
          $scope.ngModel = $scope.options.defaultColor, updateLocalModel();
          var color = tinycolor($scope.options.defaultColor);
          prevColor = {
            hex: color.toHexString(),
            alpha: color.getAlpha()
          };
        }
      }, $scope.destroy = function () {
        colorEl && (colorEl.detach(), colorEl.spectrum("destroy"));
      }, $scope.onModelUpdate = function (m) {
        colorEl || function () {
          colorEl = $($element.find("input")[0]);
          var settings = componentUtil.getColorPickerSettings($scope.ngModel);
          $scope.options && (settings.palette = $scope.options.palette, settings.allowEmpty = $scope.options.allowEmpty, settings.showAlpha = $scope.options.allowTransparency), settings.move = colorPickerMoveEvent, settings.hide = triggerOnHideEvent, settings.change = triggerOnChangeEvent, settings.show = triggerOnShowEvent, colorEl.spectrum(settings);
        }(), $scope.ngModel && colorEl.spectrum("set", m), updateLocalModel();
      }, $scope.onOptionsUpdate = function () {
        $scope.options && $scope.init();
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCommandBar", function () {
  return {
    restrict: "E",
    replace: "true",
    transclude: !0,
    templateUrl: "component-commandbar/commandbar.template",
    scope: {
      id: "@",
      options: "=",
      onApiReady: "&",
      onOpen: "&",
      onClose: "&"
    },
    link: function link(scope, form) {
      scope.form = form, scope.$watch("options", scope.onOptionsUpdate, !0), scope.api = {
        reset: scope.onCloseClick
      }, scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      $scope.isOpen = !1;
      var previousTrigger = null;

      function onTriggerClick() {
        if ($scope.$evalAsync(function () {
          $scope.isOpen = !$scope.isOpen, $scope.isOpen && $scope.onOpen ? $scope.onOpen() : !$scope.isOpen && $scope.onClose && $scope.onClose();
        }), $scope.$digest(), previousTrigger) {
          var triggerLeftPos = previousTrigger[0].getBoundingClientRect().left + $(window).scrollLeft(),
              elemLeftPos = (previousTrigger[0].getBoundingClientRect().top, $(window).scrollTop(), $($element)[0].getBoundingClientRect().left + $(window).scrollLeft()),
              elemWidth = ($($element)[0].getBoundingClientRect().top, $(window).scrollTop(), $($element)[0].getBoundingClientRect().right + $(window).scrollLeft() - elemLeftPos);
          $scope.$digest();
          var hoffset = (triggerLeftPos - elemLeftPos) / elemWidth;
          hoffset >= 1 ? hoffset = 1 : hoffset <= 0 && (hoffset = 0);
          var elementPlacement = hoffset * elemWidth - 15,
              horzAdjustment = 0;
          elementPlacement < 0 && (horzAdjustment = +elementPlacement), elementPlacement > elemWidth && (horzAdjustment = elemWidth - 15), $($element.find(".trigger-pointer")[0]).css("left", "calc(" + 100 * hoffset + "% - " + horzAdjustment + "px)");
        }
      }

      $scope.onOptionsUpdate = function () {
        previousTrigger && previousTrigger.off && (previousTrigger.off("click", onTriggerClick), previousTrigger = null), $scope.options && $scope.options.triggerElement ? ($scope.isOpen = !1, (previousTrigger = $("#" + $scope.options.triggerElement)) && previousTrigger.on("click", onTriggerClick)) : $scope.isOpen = !0;
      }, $scope.onCloseClick = function () {
        $scope.isOpen = !1, $scope.onClose && $scope.onClose();
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiContentTile", function () {
  return {
    restrict: "E",
    replace: "true",
    transclude: !0,
    templateUrl: "component-contenttile/content-tile.template",
    link: function link(scope) {
      scope.init();
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      $scope.init = function () {
        var img = $element.find("img");
        if (img.length > 0) return $(img).hide(), void (img[0].onload = function () {
          $(img).show();
        });
        var vid = $element.find("video");
        return vid.length > 0 ? ($(vid).hide(), $(vid)[0].play(), $(vid)[0].volume = 0, void (vid[0].oncanplay = function () {
          $(vid).show();
        })) : void 0;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiContextMenuNested", function (contextMenuService) {
  return {
    restrict: "A",
    scope: {
      cmnModel: "=",
      cmnOptions: "=",
      onCmnItemSelect: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.unregister();
      }), scope.init();
    },
    controller: function controller($scope, $element) {
      function buildCallback($trigger, e) {
        if ($scope.cmnOptions && $scope.cmnOptions.modelCallback) {
          var m = $scope.cmnOptions.modelCallback($trigger, e);
          return {
            callback: $scope.onMenuClick,
            items: m
          };
        }

        return {
          callback: $scope.onMenuClick,
          items: $scope.cmnModel
        };
      }

      $scope.init = function () {
        contextMenuService.registerContextMenu($($element), buildCallback, $scope.cmnOptions);
      }, $scope.unregister = function () {
        contextMenuService.unregisterContextMenu($($element), buildCallback, $scope.cmnOptions);
      }, $scope.onMenuClick = function (key) {
        $scope.onCmnItemSelect && $scope.$evalAsync(function () {
          $scope.onCmnItemSelect({
            key: key
          });
        });
      };
    }
  };
}), function ($angular) {
  var angular = window.angular;
  angular.module("core.ui").factory("contextMenuService", function () {
    var registeredElements = [],
        contextMenuCreated = !1;
    return angular.forEach(["right", "left", "hover"], function (trigger) {
      var cmOptions = {
        selector: ".asui-cmn-" + trigger,
        trigger: trigger,
        animation: {
          duration: 100,
          show: "slideDown",
          hide: "slideUp"
        },
        build: build
      };
      $.contextMenu(cmOptions);
    }), {
      unregisterContextMenu: function unregisterContextMenu(el) {
        if (el = $(el)[0]) for (var i = 0; i < registeredElements.length; i++) {
          var re = registeredElements[i];
          if (re.element === el) return registeredElements.splice(i, 1), re;
        }
        return null;
      },
      registerContextMenu: function registerContextMenu(element, buildCallback, options) {
        var clickClass = "asui-cmn-";
        options && options.trigger ? clickClass += options.trigger : clickClass += "right";
        $(element).hasClass(clickClass) || $(element).addClass(clickClass);
        $(element).hasClass("asui-cmn-element") || $(element).addClass("asui-cmn-element");
        var el = findElement(element);
        el ? el.build = buildCallback : registeredElements.push({
          element: $(element)[0],
          build: buildCallback
        });
        contextMenuCreated || (contextMenuCreated = !0);
      }
    };

    function build($trigger, e) {
      var el = findElement($(e.target));

      if (el) {
        var res = el.build($trigger, e);
        if (res && res.items && !jQuery.isEmptyObject(res.items)) return el.build($trigger, e);
      }

      return !1;
    }

    function findElement(el) {
      if (el = function (elm, className) {
        if ($(elm).hasClass(className)) return $(elm)[0];
        var gridItems = $(elm).closest("." + className);
        return gridItems.length > 0 ? gridItems[0] : null;
      }(el = $(el)[0], "asui-cmn-element")) for (var i = 0; i < registeredElements.length; i++) {
        var re = registeredElements[i];
        if (re.element === el) return re;
      }
      return null;
    }
  });
}(), window.angular.module("core.ui").directive("asuiContextMenu", function () {
  return {
    restrict: "E",
    replace: "true",
    transclude: !0,
    templateUrl: "component-contextmenu/contextmenu.template",
    scope: {
      selectedInputs: "=?",
      ngModel: "=",
      options: "=",
      menuGroups: "=",
      onItemClick: "&"
    },
    link: function link(scope, element) {
      scope.$watch("options", scope.onOptionsUpdate, !0), scope.$watch("isOpen", scope.onOpened, !0), scope.$watch("ngModel", scope.onModelUpdate, !0), element.on("$destroy", function () {
        scope.destroy();
      });
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      function outsideClickHandler(e) {
        if ($scope.isOpen) {
          if ($element.is(e.target) || $element.has(e.target).length) return;
          $scope.isOpen = !1, $scope.$apply();
        }
      }

      function findOptionFromValue(group, value) {
        for (var i = 0; i < $scope.menuGroups.length; i++) {
          var mg = $scope.menuGroups[i];
          if (mg.name == group) for (var k = 0; k < mg.items.length; k++) {
            var item = mg.items[k];
            if (item.value == value) return item;
          }
        }

        return null;
      }

      $scope.isOpen = !1, $scope.selectedInputs = {}, $scope.onOptionsUpdate = function () {
        $scope.options && !0 === $scope.options.isOpen && ($scope.isOpen = !0);
      }, $scope.destroy = function () {
        document.body.removeEventListener("click", outsideClickHandler, !0);
      }, $scope.onModelUpdate = function (m) {
        if ($scope.selectedInputs = {}, m) for (var i = 0; i < m.length; i++) {
          if (m[i].value instanceof Array) {
            $scope.selectedInputs[m[i].name] = [];

            for (var k = 0; k < m[i].value.length; k++) {
              var item = findOptionFromValue(m[i].name, m[i].value[k]);
              item && $scope.selectedInputs[m[i].name].push(item);
            }
          } else $scope.selectedInputs[m[i].name] = findOptionFromValue(m[i].name, m[i].value);
        }
      }, $scope.onOpened = function (isOpen) {
        document.body.removeEventListener("click", outsideClickHandler, !0), isOpen && document.body.addEventListener("click", outsideClickHandler, !0);
      }, $scope.onContextMenuClick = function ($event) {
        event.stopPropagation();
      }, $scope.itemClick = function (event, group, val) {
        event.stopPropagation(), "multiselect" !== group.type && ($scope.isOpen = !1);

        var modelChanged = function (group, val) {
          if (!group.type || "list" === group.type) return !0;
          var gm = null;
          $scope.ngModel || ($scope.ngModel = []);

          for (var i = 0; i < $scope.ngModel.length; i++) {
            var m = $scope.ngModel[i];

            if (m.name == group.name) {
              gm = m;
              break;
            }
          }

          if (null === gm && (gm = {
            name: group.name,
            value: null
          }, $scope.ngModel.push(gm)), "singleselect" === group.type) return gm.value = val, !0;

          if ("multiselect" === group.type) {
            if (!gm.value || 0 === gm.value.length) return gm.value = [val], !0;

            for (var k = 0; k < gm.value.length; k++) {
              var v = gm.value[k];
              if (v == val) return gm.value.splice(k, 1), !0;
            }

            if (group.maxSelection && gm.value.length < group.maxSelection) return gm.value.push(val), !0;
          }

          return !1;
        }(group, val);

        $scope.onItemClick && modelChanged && $scope.onItemClick({
          target: $element[0],
          group: group.name,
          value: val
        });
      }, $scope.isChecked = function (group, val) {
        var checked = !1;
        if (("singleselect" === group.type || "multiselect" === group.type) && $scope.ngModel) for (var i = 0; i < $scope.ngModel.length; i++) {
          var m = $scope.ngModel[i];
          if ("singleselect" === group.type) m.value == val && (checked = !0);else if (m.value && m.value.length > 0) for (var k = 0; k < m.value.length; k++) {
            if (m.value[k] == val) {
              checked = !0;
              break;
            }
          }
        }
        return checked;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiCopy", function () {
  return {
    restrict: "E",
    templateUrl: "component-copy/copy.template",
    scope: {
      label: "@",
      copyText: "@",
      copyCallback: "&"
    },
    link: function link() {},
    controller: ["$scope", "$element", function ($scope, $element) {
      $scope.isOpen = !1;
      var timeout = null;

      function setClipboard(value) {
        var tempInput = document.createElement("input");
        tempInput.style = "position: absolute; left: -1000px; top: -1000px", tempInput.value = value, document.body.appendChild(tempInput), tempInput.select(), document.execCommand("copy"), document.body.removeChild(tempInput), showTooltip("Copied!");
      }

      function showTooltip(msg) {
        $scope.$evalAsync(function () {
          $scope.popoverText = msg, $scope.isOpen = !0, timeout && (clearTimeout(timeout), timeout = null), timeout = setTimeout(function () {
            $scope.$evalAsync(function () {
              $scope.isOpen = !1;
            });
          }, 1e3);
        });
      }

      $scope.onClick = function () {
        $scope.copyText ? setClipboard($scope.copyText) : $scope.copyCallback && $scope.copyCallback().then(function (res) {
          $scope.copyText = res, setClipboard($scope.copyText);
        }, function (err) {
          showTooltip(err);
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiDatePicker", function () {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: "component-datepicker/datepicker.template",
    scope: {
      ngModel: "=",
      placeholder: "@",
      options: "=?",
      onChange: "&"
    },
    link: function link(scope, element) {
      scope.$watch("options.allowInputToggle", scope.onOptions), scope.$watch("options.useCurrent", scope.onOptions), scope.$watch("options.format", scope.onOptions), scope.$watch("options.disableManualInput", scope.onOptions), scope.$watch("options.readOnly", scope.onOptions), scope.$watch("options.minDate", scope.onOptions), scope.$watch("ngModel", scope.onModel, !0), element.on("$destroy", function () {
        scope.destroy();
      });
    },
    controller: ["$scope", "$element", "$timeout", "$filter", function ($scope, $element, $timeout, $filter) {
      var currentValue = null,
          calEl = null,
          format = "MMMM D, YYYY";

      function destroyCalendar() {
        calEl && (calEl.off("dp.change", onDPChange), calEl = null), currentValue = null;
      }

      function onDPChange(e) {
        $scope.$evalAsync(function () {
          var same = !1;
          $scope.ngModel && (same = $filter("datetime")($scope.ngModel, format) === $filter("datetime")(e.date, format)), same || ($scope.ngModel = e.date ? e.date : null, $scope.onChange({
            date: e.date ? e.date : null
          }));
        });
      }

      function updateDTValue() {
        var dtEl = calEl.data("DateTimePicker");
        dtEl && ($scope.ngModel ? $scope.ngModel != currentValue && (dtEl.date($scope.ngModel), currentValue = $scope.ngModel) : dtEl.date(null));
      }

      $scope.destroy = function () {
        destroyCalendar();
      }, $scope.onOptions = function () {
        $scope.init();
      }, $scope.init = function () {
        var dpOptions = {},
            options = {};
        $scope.options && (options = $scope.options), dpOptions.allowInputToggle = void 0 === options.allowInputToggle || options.allowInputToggle, dpOptions.useCurrent = void 0 !== options.useCurrent && options.useCurrent, format = options.format && "dt" !== options.format ? "d" === options.format || "t" === options.format ? $filter("datetime")(new Date(1, 1, 2050), options.format, !0) : options.format : "MMMM D, YYYY [at] h:mma", dpOptions.format = format, dpOptions.icons = void 0 !== dpOptions.icons ? dpOptions.icons : {
          time: "fa fa-clock-o",
          date: "fa fa-calendar",
          up: "fa fa-arrow-up",
          down: "fa fa-arrow-down",
          next: "fa fa-angle-right",
          previous: "fa fa-angle-left"
        }, options.disableManualInput && (dpOptions.ignoreReadonly = !0), options.readOnly && ($scope.readonly = !0), options.minDate && ("string" == typeof options.minDate ? (dpOptions.minDate = moment(options.minDate, format), console.log(dpOptions.minDate)) : dpOptions.minDate = moment(options.minDate.startOf("day")));
        var isReadOnly = $scope.readonly || options.disableManualInput,
            isDisabled = $scope.readonly,
            cal = $('<input class="datepicker-input dog" type="text" />');
        cal[0].readOnly = isReadOnly, cal[0].disabled = isDisabled, cal[0].placeholder = $scope.ngModel ? "" : $scope.placeholder, $scope.showIcon() && cal.addClass("has-calendar-icon"), $($element.find(".datepicker-input")).replaceWith(cal), destroyCalendar(), calEl = cal.datetimepicker(dpOptions), updateDTValue(), calEl.on("dp.change", onDPChange);
      }, $scope.onModel = function () {
        calEl || $scope.init(), updateDTValue();
      }, $scope.showIcon = function () {
        return !$scope.options || !1 !== $scope.options.showIcon;
      }, $scope.clearInput = function ($event) {
        $scope.ngModel = null;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiDateRangePicker", function () {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: "component-daterangepicker/daterangepicker.template",
    scope: {
      ngModel: "=",
      placeholder: "@",
      options: "=?",
      onChange: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("ngModel", scope.onModel, !0);
    },
    controller: ["$scope", "$location", "$element", "$q", "$timeout", "$filter", function ($scope, $location, $element, $q, $timeout, $filter) {
      var format = null,
          filterFormat = null,
          timePicker = !1,
          drops = "down",
          opens = "right",
          inputEl = null,
          calEl = null,
          datePicker = null,
          presetRanges = {
        today: {
          label: "Today",
          value: [moment().startOf("day"), moment().endOf("day")]
        },
        yesterday: {
          label: "Yesterday",
          value: [moment().subtract(1, "days").startOf("day"), moment().subtract(1, "days").endOf("day")]
        },
        last7days: {
          label: "Last 7 days",
          value: [moment().subtract(6, "days").startOf("day"), moment().endOf("day")]
        },
        last30days: {
          label: "Last 30 days",
          value: [moment().subtract(29, "days").startOf("day"), moment().endOf("day")]
        },
        last90days: {
          label: "Last 90 days",
          value: [moment().subtract(89, "days").startOf("day"), moment().endOf("day")]
        },
        last12months: {
          label: "Last 12 months",
          value: [moment().subtract(1, "years").add(1, "days").startOf("day"), moment().endOf("day")]
        },
        currentmonth: {
          label: "Current month",
          value: [moment().startOf("month").startOf("day"), moment().endOf("day")]
        },
        currentyear: {
          label: "Current year",
          value: [moment().startOf("year").startOf("day"), moment().endOf("day")]
        },
        previousyear: {
          label: "Previous year",
          value: [moment().subtract(1, "year").startOf("year").startOf("day"), moment().subtract(1, "year").endOf("year").endOf("day")]
        }
      };

      function destroyPicker() {
        calEl && (calEl.on("hide.daterangepicker", onCalendarHide), calEl.on("apply.daterangepicker", onCalendarApply), datePicker && (datePicker.remove(), datePicker = null), calEl = null);
      }

      function onDateChange(start, end) {
        $scope.$evalAsync(function () {
          $scope.ngModel = {
            startDate: start,
            endDate: end
          }, $scope.onChange && $scope.onChange({
            value: $scope.ngModel
          });
        });
      }

      function onCalendarApply(ev, picker) {
        onDateChange(picker.startDate, picker.endDate);
        var range = {
          startDate: picker.startDate,
          endDate: picker.endDate
        },
            val = $filter("daterange")(range.startDate, range.endDate, filterFormat);
        inputEl.val(val);
      }

      function onCalendarCancel(event) {
        $scope.options && "clear" === $scope.options.cancelAction && $scope.clearInput(event);
      }

      function onCalendarHide() {
        $scope.$evalAsync(function () {
          if ($scope.ngModel && null !== $scope.ngModel.startDate && null !== $scope.ngModel.endDate) datePicker.setStartDate($scope.ngModel.startDate), datePicker.setEndDate($scope.ngModel.endDate);else {
            var curDate = moment().startOf("day");
            datePicker.setStartDate(curDate), datePicker.setEndDate(curDate.endOf("day")), inputEl.val("");
          }
        });
      }

      $scope.destroy = function () {
        destroyPicker();
      }, $scope.init = function () {
        if (!datePicker) {
          destroyPicker();
          var o = $scope.options;
          o && (o.format && (format = o.format), !0 === o.timePicker && (timePicker = o.timePicker), o.drops && (drops = o.drops), o.opens && (opens = o.opens)), !(filterFormat = format) && $scope.options && (filterFormat = !0 === $scope.options.timePicker ? "dt" : "d");
          var options = {
            timePicker: timePicker,
            autoApply: !0,
            autoUpdateInput: !1,
            drops: drops,
            opens: opens,
            locale: {
              format: format
            }
          };

          if (o) {
            if (null !== o.autoApply && (options.autoApply = o.autoApply), o.minDate && ("string" == typeof o.minDate ? options.minDate = moment(o.minDate, "MM/DD/YYYY") : options.minDate = moment(o.minDate)), o.maxDate && ("string" == typeof o.maxDate ? options.maxDate = moment(o.maxDate, "MM/DD/YYYY") : options.maxDate = moment(o.maxDate)), o.presetRanges && Array.isArray(o.presetRanges)) {
              var ranges = {};
              o.presetRanges.forEach(function (name) {
                var range = presetRanges[name.toLowerCase()];
                range && (ranges[range.label] = range.value);
              }), options.ranges = ranges;
            }

            null !== o.showCustomRangeLabel && void 0 !== o.showCustomRangeLabel && (options.showCustomRangeLabel = o.showCustomRangeLabel), null !== o.alwaysShowCalendars && void 0 !== o.alwaysShowCalendars && (options.alwaysShowCalendars = o.alwaysShowCalendars), o.parentEl && (options.parentEl = o.parentEl), "clear" === o.cancelAction && (options.locale.cancelLabel = "Clear"), $scope.ngModel && ($scope.ngModel.startDate && (options.startDate = $scope.ngModel.startDate), $scope.ngModel.endDate && (options.endDate = $scope.ngModel.endDate));
          }

          for (var key in $scope.options) {
            options[key] = $scope.options[key];
          }

          inputEl = $($element).find("input"), calEl = $(inputEl), o && !0 === o.autoApply ? calEl.daterangepicker(options, onDateChange) : calEl.daterangepicker(options, null), datePicker = calEl.data("daterangepicker"), calEl.on("hide.daterangepicker", onCalendarHide), calEl.on("apply.daterangepicker", onCalendarApply), calEl.on("cancel.daterangepicker", onCalendarCancel);
        }
      }, $scope.clearInput = function ($event) {
        inputEl.val(""), $scope.onKeyUp(), onCalendarHide(), $event.preventDefault(), onDateChange(null, null);
      }, $scope.onCalendarClick = function () {
        calEl.click();
      }, $scope.onKeyUp = function (event) {
        var val = inputEl.val();
        val && 0 !== val.length || ($scope.ngModel = null);
      }, $scope.onModel = function () {
        if ($scope.init(), datePicker) if ($scope.ngModel && $scope.ngModel.startDate && $scope.ngModel.endDate) {
          datePicker.setStartDate($scope.ngModel.startDate), datePicker.setEndDate($scope.ngModel.endDate);
          var range = {
            startDate: $scope.ngModel.startDate,
            endDate: $scope.ngModel.endDate
          },
              val = $filter("daterange")(range.startDate, range.endDate, filterFormat);
          inputEl.val(val);
        } else onCalendarHide();
      }, $scope.showIcon = function () {
        return !$scope.options || !1 !== $scope.options.showIcon;
      }, $scope.getPlaceholderText = function () {
        var placeholder = "";
        return $scope.ngModel && !jQuery.isEmptyObject($scope.ngModel) || (placeholder = $scope.placeholder), $scope.ngModel && null === $scope.ngModel.startDate && null === $scope.ngModel.endDate && (placeholder = $scope.placeholder), placeholder;
      };
    }]
  };
}), function ($angular) {
  var angular = window.angular;
  angular.module("core.ui").component("asuiDayparting", {
    bindings: {
      options: "<",
      model: "<",
      onApiReady: "&",
      onChange: "&"
    },
    templateUrl: "component-dayparting/dayparting.template",
    controller: ["$scope", "$element", function ($scope, $element) {
      var $ctrl = this;
      $ctrl.gridLoading = !0;
      var mouseDown = null,
          dragEvent = null;

      function removeEventListeners() {
        var el = $element[0];
        el.removeEventListener("mousedown", onMouseDown, !1), el.removeEventListener("mouseup", onMouseUp, !1), el.removeEventListener("mouseover", onMouseOver, !1), el.removeEventListener("mouseleave", onMouseLeave, !1);
      }

      function generateDataGrid(interval) {
        var colCount = 24,
            headerSpan = 3,
            format = "ha",
            minWidth = 30;
        if (interval) switch (interval) {
          case "min30":
            colCount = 48, headerSpan = 2, minWidth = 15;
            break;

          case "min15":
            colCount = 96, headerSpan = 4, minWidth = 10;
            break;

          case "min1":
            colCount = 1440, headerSpan = 10, format = "h:mma", minWidth = 10;
        }
        $ctrl.minSlotWidth = minWidth + "px", $ctrl.minHeaderWidth = minWidth * headerSpan + "px", $ctrl.headers = [];
        var startTime = moment().startOf("day"),
            headerCount = colCount / headerSpan,
            minuteInterval = 1440 / headerCount,
            i = null;

        for (i = 0; i < headerCount; i++) {
          var header = {
            id: "header_" + i,
            label: startTime.format(format)
          };
          $ctrl.headers.push(header), startTime.add(minuteInterval, "minutes");
        }

        for (minuteInterval = 1440 / colCount, i = 0; i < $ctrl.dataGrid.length; i++) {
          for (var day = $ctrl.dataGrid[i], startMin = 0, slots = [], k = 0; k < colCount; k++) {
            var slot = {
              id: day.id + "_" + k,
              index: k,
              day: day.id,
              dayIndex: i,
              selected: !1,
              startTime: startMin,
              endTime: startMin + minuteInterval
            };
            startMin = slot.endTime, slots.push(slot);
          }

          day.slots = slots;
        }

        $ctrl.gridLoading = !1;
      }

      function updateDataGrid() {
        var dayLookup = {};

        if ($ctrl.model) {
          var i = 0,
              k = 0,
              day = null;

          for (i = 0; i < $ctrl.model.length; i++) {
            var m = $ctrl.model[i];

            for (k = 0; k < m.days.length; k++) {
              day = m.days[k].toLowerCase();
              var dayPart = {
                startTime: toMinutes(m.startTime),
                endTime: toMinutes(m.endTime, !0)
              };
              dayLookup[day] ? dayLookup[day].dayPartings.push(dayPart) : dayLookup[day] = {
                day: day,
                dayPartings: [dayPart]
              };
            }
          }

          $scope.$evalAsync(function () {
            for (resetSlots(), i = 0; i < $ctrl.dataGrid.length; i++) {
              if (day = $ctrl.dataGrid[i], dayLookup[day.id]) {
                var dayPartings = dayLookup[day.id].dayPartings;

                for (k = 0; k < dayPartings.length; k++) {
                  for (var dp = dayPartings[k], n = 0; n < day.slots.length; n++) {
                    var slot = day.slots[n];
                    slot.startTime >= dp.startTime && slot.startTime < dp.endTime ? (slot.selected = !0, slot.endTime > dp.endTime && (slot.partials || (slot.partials = []), slot.partials.push({
                      duration: dp.endTime - slot.startTime,
                      start: 0
                    }))) : dp.startTime > slot.startTime && dp.endTime <= slot.endTime && (slot.selected = !0, slot.partials || (slot.partials = []), slot.partials.push({
                      duration: dp.endTime - dp.startTime,
                      start: dp.startTime - slot.startTime
                    }));
                  }
                }
              }
            }

            toggleEverydaySlot(), function () {
              for (var i = 0; i < $ctrl.dataGrid.length; i++) {
                var day = $ctrl.dataGrid[i],
                    daySelected = !0;

                if ("everyday" !== day.id) {
                  for (var k = 0; k < day.slots.length; k++) {
                    var slot = day.slots[k];

                    if (!slot.selected || slot.selected && slot.partials && slot.partials.length > 0) {
                      daySelected = !1;
                      break;
                    }
                  }

                  day.selected = daySelected;
                }
              }
            }();
          });
        }
      }

      function fireOnChange() {
        $ctrl.onChange && $ctrl.onChange({
          value: $ctrl.model
        });
      }

      function getEveryday() {
        for (var i = 0; i < $ctrl.dataGrid.length; i++) {
          var day = $ctrl.dataGrid[i];
          if ("everyday" === day.id) return day;
        }

        return null;
      }

      function onMouseDown(e) {
        if (e.target._slot) {
          mouseDown = !0;
          var slot = e.target._slot,
              selected = !slot.selected;
          (dragEvent = {
            startSlot: slot,
            endSlot: slot,
            selected: selected
          }).originalGrid = angular.copy($ctrl.dataGrid);
        }
      }

      function onMouseUp(e) {
        e.target._slot && ($scope.$evalAsync(function () {
          dragEvent.startSlot === dragEvent.endSlot && toggleSlotSelected(), updateModel();
        }), mouseDown = !1);
      }

      function onMouseOver(e) {
        if (mouseDown) {
          var slot = e.target._slot;
          dragEvent.endSlot = slot, $scope.$evalAsync(function () {
            toggleSlotSelected();
          });
        }
      }

      function onMouseLeave(e) {
        mouseDown && (mouseDown = !1, $scope.$evalAsync(function () {
          restoreGridSelectionBeforeDrag();
        }));
      }

      function resetSlots() {
        for (var i = 0; i < $ctrl.dataGrid.length; i++) {
          for (var day = $ctrl.dataGrid[i], k = 0; k < day.slots.length; k++) {
            var slot = day.slots[k];
            slot.selected = !1, slot.partials = null;
          }
        }
      }

      function toggleSlotSelected() {
        if (dragEvent.endSlot) {
          var startDay = dragEvent.startSlot.dayIndex < dragEvent.endSlot.dayIndex ? dragEvent.startSlot : dragEvent.endSlot,
              endDay = dragEvent.startSlot.dayIndex < dragEvent.endSlot.dayIndex ? dragEvent.endSlot : dragEvent.startSlot,
              startTime = dragEvent.startSlot.index < dragEvent.endSlot.index ? dragEvent.startSlot : dragEvent.endSlot,
              endTime = dragEvent.startSlot.index < dragEvent.endSlot.index ? dragEvent.endSlot : dragEvent.startSlot;

          if (startDay.dayIndex === endDay.dayIndex || "everyday" !== startDay.day && "everyday" !== endDay.day) {
            restoreGridSelectionBeforeDrag();
            var k = 0;

            if ("everyday" === startDay.day || "everyday" === endDay.day) {
              var everyday = $ctrl.dataGrid[startDay.dayIndex];

              for (k = startTime.index; k <= endTime.index; k++) {
                everyday.slots[k].selected = dragEvent.selected, selectDailySlots(k, dragEvent.selected);
              }
            } else {
              for (var i = startDay.dayIndex; i <= endDay.dayIndex; i++) {
                var day = $ctrl.dataGrid[i],
                    slots = day.slots;

                for (day.selected && !dragEvent.selected && (day.selected = !1), k = startTime.index; k <= endTime.index; k++) {
                  slots[k].selected = dragEvent.selected, slots[k].partials = null;
                }
              }

              toggleEverydaySlot();
            }
          }
        }
      }

      function toggleEverydaySlot() {
        for (var slotLookup = {}, everyday = null, i = 0; i < $ctrl.dataGrid.length; i++) {
          var day = $ctrl.dataGrid[i];
          if ("everyday" !== day.id) for (var k = 0; k < day.slots.length; k++) {
            var slot = day.slots[k];
            slotLookup[slot.index] || (slotLookup[slot.index] = 0), slot.selected && slotLookup[slot.index]++;
          } else everyday = day;
        }

        var numOfDays = $ctrl.dataGrid.length - 1;
        if (null !== everyday) for (var s in slotLookup) {
          everyday.slots[s].selected = slotLookup[s] === numOfDays;
        }
      }

      function restoreGridSelectionBeforeDrag() {
        for (var i = 0; i < $ctrl.dataGrid.length; i++) {
          for (var day = $ctrl.dataGrid[i], k = 0; k < day.slots.length; k++) {
            var slot = day.slots[k],
                originalSlot = dragEvent.originalGrid[i].slots[k];
            slot.selected = originalSlot.selected;
          }
        }
      }

      function selectDailySlots(index, selected) {
        for (var i = 0; i < $ctrl.dataGrid.length; i++) {
          var day = $ctrl.dataGrid[i];

          if ("everyday" !== day.id) {
            if (!selected && day.selected) continue;
            day.slots[index].selected = selected;
          }
        }
      }

      function updateModel() {
        for (var modelLookup = {}, i = 0; i < $ctrl.dataGrid.length; i++) {
          for (var day = $ctrl.dataGrid[i], k = 0; k < day.slots.length; k++) {
            var startSlot = day.slots[k],
                endSlot = day.slots[k];

            if (startSlot.selected) {
              for (var n = k + 1; n < day.slots.length && day.slots[n].selected;) {
                endSlot = day.slots[n], k = ++n;
              }

              var end = endSlot.endTime,
                  start = startSlot.startTime;
              endSlot.partial && (end = endSlot.startTime + endSlot.partial, endSlot.partialStart && (start = endSlot.startTime + endSlot.partialStart));
              var lookupId = start + "-" + end;
              modelLookup[lookupId] ? modelLookup[lookupId].days.push(startSlot.day) : modelLookup[lookupId] = {
                startTime: toHHmm(start),
                endTime: toHHmm(end),
                days: [startSlot.day]
              };
            }
          }
        }

        for (var l in $ctrl.model.length = 0, modelLookup) {
          $ctrl.model.push(modelLookup[l]);
        }

        fireOnChange();
      }

      function toMinutes(hhmm, isEndtime) {
        var mins = 0,
            t = hhmm.split(":");
        return t.length > 1 && (mins = parseInt(t[1]) + 60 * parseInt(t[0])), isEndtime && 0 == mins ? 1440 : mins;
      }

      function toHHmm(minutes) {
        if (1440 === minutes) return "00:00";
        var h = Math.floor(minutes / 60),
            m = minutes % 60;
        return 1 === (h = h.toString()).length && (h = "0" + h), 1 === (m = m.toString()).length && (m = "0" + m), h + ":" + m;
      }

      $ctrl.readOnly = !1, $ctrl.intervalFilter = {
        options: {
          placement: "",
          isOpen: !1
        },
        selectedInputs: {},
        model: [{
          name: "intervalfilter",
          value: "hour"
        }],
        menuGroups: [{
          name: "intervalfilter",
          showHeader: !1,
          type: "singleselect",
          items: [{
            label: "hour",
            buttonText: "hour",
            value: "hour"
          }, {
            label: "30 mins",
            buttonText: "30 mins",
            value: "min30"
          }, {
            label: "15 mins",
            buttonText: "15 mins",
            value: "min15"
          }, {
            label: "1 min",
            buttonText: "1 min",
            value: "min1"
          }]
        }]
      }, $ctrl.headers = [], $ctrl.dataGrid = [{
        id: "monday",
        label: "Monday",
        label3Letters: "Mon",
        label1Letter: "M",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "tuesday",
        label: "Tuesday",
        label3Letters: "Tue",
        label1Letter: "T",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "wednesday",
        label: "Wednesday",
        label3Letters: "Wed",
        label1Letter: "W",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "thursday",
        label: "Thursday",
        label3Letters: "Thu",
        label1Letter: "T",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "friday",
        label: "Friday",
        label3Letters: "Fri",
        label1Letter: "F",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "saturday",
        label: "Saturday",
        label3Letters: "Sat",
        label1Letter: "S",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "sunday",
        label: "Sunday",
        label3Letters: "Sun",
        label1Letter: "S",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }, {
        id: "everyday",
        label: "Everyday",
        label3Letters: "Eve",
        label1Letter: "E",
        enabled: !0,
        hidden: !1,
        selected: !1,
        slots: []
      }], $ctrl.$onInit = function () {
        $scope.$watch("$ctrl.options", function (value) {
          !function () {
            $ctrl.options.interval ? ($ctrl.intervalFilter.model[0].value = $ctrl.options.interval, generateDataGrid($ctrl.options.interval)) : generateDataGrid();
            $ctrl.options.readOnly && function () {
              $ctrl.readOnly = !0, $element.addClass("dayparting-readonly"), removeEventListeners();

              for (var i = 0; i < $ctrl.dataGrid.length; i++) {
                var day = $ctrl.dataGrid[i];
                day.label = day.label.substr(0, 1);
              }
            }();
          }();
        }, !0), $scope.$watch("$ctrl.model", function (value) {
          !function onModelUpdated() {
            $ctrl.gridLoading ? $timeout(function () {
              onModelUpdated();
            }, 100) : updateDataGrid();
          }();
        }, !0);
        var el = $element[0];
        el.addEventListener("mousedown", onMouseDown, !1), el.addEventListener("mouseup", onMouseUp, !1), el.addEventListener("mouseover", onMouseOver, !1), el.addEventListener("mouseleave", onMouseLeave, !1), $ctrl.api = {
          clear: $ctrl.clear
        }, $ctrl.onApiReady && $ctrl.onApiReady({
          api: $ctrl.api
        });
      }, $ctrl.$onDestroy = function () {
        removeEventListeners();
      }, $ctrl.onIntervalFilterClick = function (value) {
        generateDataGrid(value), updateDataGrid(), $(".dayparting-time-block").scrollLeft(0);
      }, $ctrl.onDayClick = function (day) {
        if ("everyday" !== day.id && !$ctrl.readOnly) {
          day.selected = !day.selected;

          for (var i = 0; i < day.slots.length; i++) {
            var slot = day.slots[i];
            if (day.selected) slot.selected = day.selected;else getEveryday().slots[slot.index].selected || (slot.selected = day.selected);
            slot.partials = null;
          }

          updateModel();
        }
      }, $ctrl.clear = function () {
        $ctrl.model.length = 0, $scope.$evalAsync(function () {
          resetSlots(), fireOnChange();
        });
      };
    }]
  });
}(), window.angular.module("core.ui").directive("asuiDragDrop", function () {
  return {
    restrict: "E",
    transclude: !0,
    templateUrl: "component-dragdrop/dragdrop.template",
    scope: {
      id: "@",
      ngModel: "=",
      options: "=",
      onMove: "&",
      onSelect: "&",
      onDeselect: "&",
      onCopy: "&",
      onRemove: "&",
      onAdd: "&",
      onUncheck: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("options", scope.onOptionsUpdated), element.on("$destroy", function () {
        scope.destroy();
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", function ($scope, $location, $element, $timeout) {
      $scope.effectAllowed = "move", $scope.showAlert = !1, $scope.maxCountReached = !1, $scope.alert = null;
      var alertTimeout = null;

      function outsideClickHandler(e) {
        $element.is(e.target) || $element.has(e.target).length || $scope.ngModel && $scope.ngModel.items && ($scope.ngModel.selected = null, angular.forEach($scope.ngModel.items, function (item) {
          !0 === item.selected && (item.selected = !1);
        }), $scope.$apply());
      }

      function flashAlert(alert) {
        alertTimeout && $timeout.cancel(alertTimeout), $scope.showAlert = !0, $scope.alert = alert, alertTimeout = $timeout(function () {
          alertTimeout = null, $scope.showAlert = !1;
        }, 2e3);
      }

      $scope.multiselect = !1, $scope.dragging = !1, document.body.addEventListener("click", outsideClickHandler, !0), $scope.destroy = function () {
        document.body.removeEventListener("click", outsideClickHandler, !0);
      }, $scope.onOptionsUpdated = function () {
        $scope.updateEffect(), $scope.options && !0 === $scope.options.multiselect && ($scope.multiselect = !0);
      }, $scope.updateEffect = function () {
        var mode = "move";
        $scope.options && "copy" === $scope.options.dragMode && (mode = "copy"), $scope.effectAllowed = mode;
      }, $scope.getItemClass = function (item) {
        var css = null;
        return $scope.ngModel.selected === item && (css = "dnd-selected"), !0 === item.disabled && (css = "dnd-disabled"), css;
      }, $scope.isMaxCountReached = function () {
        return $scope.options && $scope.options.maxCount > 0 && $scope.ngModel.items.length >= $scope.options.maxCount ? ($scope.maxCountReached = !0, flashAlert("Limit reached (" + $scope.options.maxCount + " items max)")) : $scope.maxCountReached = !1, $scope.maxCountReached;
      }, $scope.dropCallback = function (item) {
        return item;
      }, $scope.removeClick = function (index, item) {
        $scope.ngModel.items.splice(index, 1), $scope.onRemove && $scope.onRemove({
          item: item
        });
      }, $scope.addClick = function (index, item) {
        $scope.options && "copy" != $scope.options.dragMode ? $scope.ngModel.items.splice(index, 1) : item.checked = !0, $scope.onAdd && $scope.onAdd({
          item: item
        });
      }, $scope.checkedClick = function (index, item) {
        $scope.options && "copy" == $scope.options.dragMode && (item.checked = !1), $scope.onUncheck && $scope.onUncheck({
          item: item
        });
      }, $scope.dndMoved = function (index, item) {
        $scope.ngModel.items.splice(index, 1), $scope.onMove && $scope.onMove({
          item: item
        });
      }, $scope.dndCopied = function (index, item) {
        "copy" === $scope.options.dragMode && (item.disabled = !0, item.checked = !0), $scope.onCopy && $scope.onCopy({
          item: item
        });
      }, $scope.dndSelected = function (item) {
        !0 !== item.disabled && ($scope.ngModel.selected = item, $scope.onSelect && $scope.onSelect({
          item: item
        }));
      }, $scope.dndMultiselectDrop = function (list, items, index) {
        var shouldAllow = !0;

        if ($scope.options && $scope.options.maxCount > 0 && items.length + list.items.length > $scope.options.maxCount && (shouldAllow = !1, flashAlert("Limit reached (" + $scope.options.maxCount + " items max)")), shouldAllow) {
          for (var i = items.length - 1; i >= 0; i--) {
            var item = items[i];
            item.selected = !1, item.disabled = !1;
          }

          return list.items = list.items.slice(0, index).concat(items).concat(list.items.slice(index)), !0;
        }

        return !1;
      }, $scope.dndMultiselectDraggable = function (list, item) {
        return item.selected = !0, list.items.filter(function (item) {
          return item.selected;
        });
      }, $scope.dndMultiselectDragstart = function (list, event) {
        $scope.dragging = !0;
      }, $scope.dndMultiselectDragEnd = function (list) {
        $scope.dragging = !1;
      }, $scope.dndMultiselectMoved = function (list) {
        list.items = list.items.filter(function (item) {
          return !item.selected;
        }), $scope.onMove && $scope.onMove({
          item: list.items
        });
      }, $scope.dndMultiselectCopied = function (list) {
        "copy" === $scope.options.dragMode && angular.forEach(list.items, function (item) {
          item.selected && (item.disabled = !0, item.checked = !0, item.selected = !1);
        }), $scope.onCopy && $scope.onCopy({
          item: list.items
        });
      }, $scope.getMultiselectItemClass = function (item) {
        var css = null;
        return item.selected && (css = "dnd-selected"), !0 === item.disabled && (css = "dnd-disabled"), css;
      }, $scope.dndMultiselectSelected = function (list, item, event) {
        if (event.metaKey || event.ctrlKey || angular.forEach(list.items, function (itm) {
          itm.selected = !1;
        }), !0 !== item.disabled) {
          var selectState = !item.selected;
          item.selected = selectState, item.selected && $scope.onSelect ? $scope.onSelect({
            item: item
          }) : !item.selected && $scope.onDeselect && $scope.onDeselect({
            item: item
          });
        }
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiDropTarget", function () {
  return {
    restrict: "A",
    scope: {
      onDragOver: "&",
      onDragEnter: "&",
      onDragLeave: "&",
      onDrop: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.destroy();
      }), element[0].addEventListener("dragenter", scope.dragEnter), element[0].addEventListener("dragover", scope.dragOver), element[0].addEventListener("dragleave", scope.dragLeave), element[0].addEventListener("drop", scope.drop);
    },
    controller: function controller($scope, $element) {
      function removeDragClass() {
        $element.removeClass("dt-dragenter");
      }

      function preventDefault(e) {
        e.stopPropagation(), e.preventDefault();
      }

      $scope.destroy = function () {
        $element[0].removeEventListener("dragenter", $scope.dragEnter), $element[0].removeEventListener("dragover", $scope.dragOver), $element[0].removeEventListener("dragleave", $scope.dragLeave), $element[0].removeEventListener("drop", $scope.drop);
      }, $scope.dragEnter = function (e) {
        removeDragClass(), $element.addClass("dt-dragenter"), preventDefault(e), $scope.onDragEnter && $scope.$evalAsync(function () {
          $scope.onDragEnter({
            event: e
          });
        });
      }, $scope.dragOver = function (e) {
        preventDefault(e), $scope.onDragOver && $scope.$evalAsync(function () {
          $scope.onDragOver({
            event: e
          });
        });
      }, $scope.dragLeave = function (e) {
        removeDragClass(), preventDefault(e), $scope.onDragLeave && $scope.$evalAsync(function () {
          $scope.onDragLeave({
            event: e
          });
        });
      }, $scope.drop = function (e) {
        removeDragClass(), preventDefault(e);
        var files = e.dataTransfer.files;
        $scope.onDrop && $scope.$evalAsync(function () {
          $scope.onDrop({
            event: e,
            files: files
          });
        });
      };
    }
  };
}), window.angular.module("core.ui").directive("asuiDropdown", function () {
  return {
    restrict: "EA",
    replace: "false",
    templateUrl: "component-dropdown/dropdown.template",
    scope: {
      items: "=",
      placeholder: "@",
      options: "=?",
      disabled: "@",
      disabledTooltip: "@",
      ngModel: "=",
      onChange: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("items", scope.itemsUpdated, !0), scope.$watch("ngModel", scope.modelUpdated, !0);
    },
    controller: ["$scope", "$location", "$element", "$timeout", function ($scope, $location, $element, $timeout) {
      var selectPickerInit = !1,
          currentSelection = "";

      function modelHasValue() {
        return void 0 !== $scope.ngModel && null !== $scope.ngModel && "" !== $scope.ngModel;
      }

      function onSelectChange(e, i) {
        $timeout(function () {
          if ($scope.placeholder && i--, i >= 0) {
            var val = $scope.items[i].value;
            $scope.ngModel = val, currentSelection = $scope.ngModel, $scope.onChange && $scope.onChange({
              value: val,
              item: $scope.items[i]
            });
          }
        });
      }

      $scope.destroy = function () {
        var el = $($element.find(".as-select"));
        el.selectpicker("destroy"), el.off("changed.bs.select", onSelectChange);
      }, $scope.modelUpdated = function (val) {
        var el = $($element.find(".as-select"));
        selectPickerInit && $scope.items && $scope.items.length && (modelHasValue() ? $scope.ngModel != currentSelection && (el.selectpicker("val", "val-" + $scope.ngModel), currentSelection = $scope.ngModel) : el.selectpicker("val", ""));
      }, $scope.itemsUpdated = function () {
        if ($scope.items && $scope.items.length > 0) {
          var el = $($element.find(".as-select"));
          el.selectpicker("destroy");
          var htmlArray = [],
              optGroups = {};

          for (var key in $scope.items.forEach(function (item) {
            optGroups[item.optgroup] ? optGroups[item.optgroup].push(item) : optGroups[item.optgroup] = [item];
          }), optGroups) {
            var group = optGroups[key];
            "undefined" != key && htmlArray.push('<optgroup label="' + key + '">'), group.forEach(function (item) {
              htmlArray.push('<option value="val-'), htmlArray.push(item.value), htmlArray.push('"'), item.icon && htmlArray.push(' data-content="' + item.icon + " " + item.label + '"'), htmlArray.push(">"), htmlArray.push(item.label), htmlArray.push("</option>");
            }), "undefined" != key && htmlArray.push("</optgroup>");
          }

          var html = htmlArray.join("");
          el.html(html), el.selectpicker($scope.options ? $scope.options : {}), selectPickerInit = !0, modelHasValue() && (el.selectpicker("val", "val-" + $scope.ngModel), currentSelection = $scope.ngModel), el.on("changed.bs.select", onSelectChange);
        }
      };
    }]
  };
}), window.angular.module("core.ui").component("asuiDropdownTypeahead", {
  bindings: {
    options: "<",
    selectedItem: "<",
    disabled: "<",
    onChange: "&"
  },
  templateUrl: "component-dropdown-typeahead/dropdown-typeahead.template",
  controller: function controller($element, $scope, $timeout) {
    var $ctrl = this;
    $ctrl.isLoading = !1, $ctrl.keywords = null, $ctrl.isOpen = !1, $ctrl.items = [], $ctrl.filteredItems = [], $ctrl.groups = [], $ctrl.templateType = "html";
    var currentRequestId = 0;
    $ctrl.placeholder = "Select one";
    var prevSelected = null;

    function outsideClickHandler(e) {
      if ($ctrl.isOpen) {
        if ($element.is(e.target) || $element.has(e.target).length) return;
        selectActiveItem(), $scope.$evalAsync(function () {
          $ctrl.isOpen = !1;
        });
      }
    }

    function scrollIntoView() {
      $element.find(".dropdown-item.active")[0].scrollIntoView({
        block: "nearest",
        behavior: "smooth"
      });
    }

    function getFirstItem(items) {
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        if (!item._isGroup) return item;
      }

      return null;
    }

    function selectActiveItem() {
      if ($ctrl.keywords) {
        if ($ctrl.filteredItems.length) for (var i = 0; i < $ctrl.filteredItems.length; i++) {
          var item = $ctrl.filteredItems[i];
          if (item._active) return void setSelectedItem(item, !0);
        }
        if ($ctrl.options && $ctrl.options.allowCustomValues) setSelectedItem({
          label: $ctrl.keywords,
          value: $ctrl.keywords
        }, !0), $element.find(".textbox").blur();else if (prevSelected) setSelectedItem(prevSelected, !1);else if ($ctrl.options.allowEmptyValue) clearSelection();else {
          var firstItem = getFirstItem($ctrl.filteredItems.length ? $ctrl.filteredItems : $ctrl.items);
          firstItem && setSelectedItem(firstItem);
        }
      }
    }

    function getFilteredItems() {
      if ($ctrl.options.retrieveItemsAsync) {
        $ctrl.isLoading = !0;
        var activeId = ++currentRequestId;
        $ctrl.options.retrieveItemsAsync($ctrl.keywords).then(function (data) {
          $ctrl.items.length || ($ctrl.items = angular.copy(data)), activeId === currentRequestId && ($ctrl.filteredItems = data, $ctrl.isLoading = !1);
        });
      } else if ($ctrl.options.items && $ctrl.options.items.length) {
        if ($ctrl.keywords) {
          var keywords = $ctrl.keywords.toLowerCase();
          $ctrl.filteredItems = [];

          for (var i = 0; i < $ctrl.options.items.length; i++) {
            var item = $ctrl.options.items[i];
            item._active = !1, -1 !== item.label.toLowerCase().indexOf(keywords) && $ctrl.filteredItems.push(item);
          }
        } else $ctrl.filteredItems = $ctrl.options.items;

        $ctrl.items.length || ($ctrl.items = angular.copy($ctrl.options.items));
      }
    }

    function clearSelection() {
      $ctrl.selectedItem = null, prevSelected = null, $ctrl.keywords = null;
    }

    function setSelectedItem(item, fireOnChange, autoClose) {
      $ctrl.selectedItem = item, $ctrl.selectedItemArray = [item], $ctrl.keywords = null, !1 !== autoClose && ($ctrl.isOpen = !1), fireOnChange && $ctrl.onChange({
        value: $ctrl.selectedItem
      });
    }

    $ctrl.$onInit = function () {
      document.body.addEventListener("click", outsideClickHandler, !0);
    }, $ctrl.$onChanges = function (changes) {
      var options;
      changes.options && changes.options.currentValue && (($ctrl.options.items || $ctrl.options.retrieveItemsAsync) && getFilteredItems(), $ctrl.options.placeholder && ($ctrl.placeholder = $ctrl.options.placeholder), (options = $ctrl.options).itemTemplateUrl ? $ctrl.templateType = "templateUrl" : !options.itemTemplateUrl && options.itemTemplate ? $ctrl.templateType = "template" : $ctrl.templateType = "html"), changes.selectedItem && (changes.selectedItem.currentValue ? setSelectedItem($ctrl.selectedItem, !1, !1) : clearSelection());
    }, $ctrl.$onDestroy = function () {
      document.body.removeEventListener("click", outsideClickHandler, !0);
    }, $ctrl.onInputClick = function () {
      if (!$ctrl.disabled) if ($ctrl.isOpen = !$ctrl.isOpen, $ctrl.isOpen) {
        if (getFilteredItems(), $ctrl.filteredItems && $ctrl.filteredItems.length) if ($ctrl.selectedItem) for (var i = 0; i < $ctrl.filteredItems.length; i++) {
          var item = $ctrl.filteredItems[i];
          item._active = item.value === $ctrl.selectedItem.value;
        } else {
          var firstItem = getFirstItem($ctrl.filteredItems);
          firstItem && (firstItem._active = !0);
        }
        $ctrl.selectedItem && (prevSelected = angular.copy($ctrl.selectedItem));
      } else selectActiveItem();
    }, $ctrl.onKeywordsChange = function () {
      $ctrl.isOpen = !0, $ctrl.selectedItem = null, getFilteredItems();
    }, $ctrl.onMouseOver = function (item) {
      item._active = !0;
    }, $ctrl.onMouseLeave = function (item) {
      item._active = !1;
    }, $ctrl.onItemClick = function (item) {
      var sanitizedItem = {};

      for (var key in item) {
        0 != key.indexOf("$") && (sanitizedItem[key] = item[key]);
      }

      setSelectedItem(sanitizedItem, !0);
    }, $ctrl.onKeyUp = function (e) {
      switch (e.which ? e.which : e.keyCode) {
        case 13:
          selectActiveItem();
          break;

        case 38:
          !function prev() {
            if ($ctrl.filteredItems && $ctrl.filteredItems.length) {
              for (var prevIndex = 0, i = 0; i < $ctrl.filteredItems.length; i++) {
                var item = $ctrl.filteredItems[i];

                if (item._active) {
                  item._active = !1, prevIndex = i - 1;
                  break;
                }
              }

              prevIndex < 0 && (prevIndex = $ctrl.filteredItems.length - 1);
              var prevItem = $ctrl.filteredItems[prevIndex];
              prevItem._active = !0, prevItem._isGroup && prev();
            }
          }(), $timeout(scrollIntoView, 10);
          break;

        case 40:
          !function next() {
            if ($ctrl.filteredItems && $ctrl.filteredItems.length) {
              for (var nextIndex = 0, i = 0; i < $ctrl.filteredItems.length; i++) {
                var item = $ctrl.filteredItems[i];

                if (item._active) {
                  item._active = !1, nextIndex = i + 1;
                  break;
                }
              }

              nextIndex >= $ctrl.filteredItems.length && (nextIndex = 0);
              var nextItem = $ctrl.filteredItems[nextIndex];
              nextItem._active = !0, nextItem._isGroup && next();
            }
          }(), $timeout(scrollIntoView, 10);
      }
    }, $ctrl.onClearClick = function () {
      clearSelection(), $ctrl.onChange({
        value: null
      });
    };
  }
}), window.angular.module("core.ui").directive("asuiDuration", function () {
  return {
    restrict: "E",
    templateUrl: "component-duration/duration.template",
    scope: {
      ngModel: "=",
      options: "=?",
      onChange: "&"
    },
    link: function link(scope, element) {
      scope.$watch("ngModel", scope.onModelChange), scope.$watch("ngModel", scope.onOptionsChange), scope.$watch("isOpen", scope.onOpen), element.on("$destroy", function () {
        scope.destroy();
      });
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      $scope.isOpen = !1;
      var clamped = !1,
          usingInitialDuration = !1,
          initialDuration = null,
          secsPerMinute = 60,
          secsPerHour = 60 * secsPerMinute,
          secsPerDay = 24 * secsPerHour;

      function removeEventListeners() {
        document.body.removeEventListener("click", outsideClickHandler, !0);
      }

      function outsideClickHandler(e) {
        if ($scope.isOpen) {
          if ($element.is(e.target) || $element.has(e.target).length) return;
          $scope.isOpen = !1, $scope.$apply();
        }
      }

      function modelToDuration() {
        var duration = {
          day: Math.floor($scope.ngModel / secsPerDay),
          hour: Math.floor($scope.ngModel % secsPerDay / secsPerHour),
          min: Math.floor($scope.ngModel % secsPerHour / secsPerMinute),
          sec: Math.floor($scope.ngModel % secsPerMinute)
        };
        return duration.day = duration.day < 10 ? "0" + duration.day : duration.day + "", duration.hour = duration.hour < 10 ? "0" + duration.hour : duration.hour + "", duration.min = duration.min < 10 ? "0" + duration.min : duration.min + "", duration.sec = duration.sec < 10 ? "0" + duration.sec : duration.sec + "", duration;
      }

      function fireOnChange() {
        !clamped && $scope.onChange && $scope.onChange({
          value: $scope.ngModel
        });
      }

      $scope.hideDay = !1, $scope.hideHour = !1, $scope.hideMinute = !1, $scope.hideSecond = !1, $scope.onOpen = function (val) {
        !0 === val ? (!$scope.ngModel && initialDuration ? ($scope.ngModel = initialDuration, usingInitialDuration = !0) : usingInitialDuration = !1, removeEventListeners(), $scope.isOpen && document.body.addEventListener("click", outsideClickHandler, !0)) : $scope.options && $scope.ngModel === initialDuration && ($scope.ngModel = 0), $scope.ngModel || ($scope.ngModel = 0);
      }, $scope.destroy = function () {
        removeEventListeners();
      }, $scope.onOptionsChange = function () {
        var o = $scope.options;
        o && (o.initialDuration && (initialDuration = o.initialDuration), o.maxDuration && o.maxDuration < secsPerDay && ($scope.hideDay = !0), (o.maxDuration && o.maxDuration < secsPerHour || o.minDuration && o.minDuration >= secsPerDay) && ($scope.hideHour = !0), (o.maxDuration && o.maxDuration < secsPerMinute || o.minDuration && o.minDuration >= secsPerHour) && ($scope.hideMinute = !0), o.minDuration && o.minDuration >= secsPerMinute && ($scope.hideSecond = !0));
      }, $scope.clearInput = function ($event) {
        $scope.ngModel = null, $scope.isOpen = !1, $event.preventDefault(), fireOnChange();
      }, $scope.onModelChange = function () {
        !0 === $scope.isOpen && (!usingInitialDuration || usingInitialDuration && $scope.ngModel !== initialDuration) && ($scope.clampValue(), fireOnChange());
      }, $scope.change = function ($event, type) {
        $scope.updateModelFromUi(type), $scope.clampValue();
      }, $scope.clampValue = function () {
        return clamped = !1, $scope.options && $scope.options.maxDuration > 0 && $scope.ngModel > $scope.options.maxDuration && ($scope.ngModel = $scope.options.maxDuration, clamped = !0), $scope.options && $scope.options.minDuration > 0 && $scope.ngModel < $scope.options.minDuration && ($scope.ngModel = $scope.options.minDuration, clamped = !0), $scope.ngModel < 0 && ($scope.ngModel = 0, clamped = !0), clamped;
      }, $scope.getValue = function (type) {
        var val = 0,
            duration = modelToDuration();

        switch (type) {
          case "d":
            val = duration.day;
            break;

          case "h":
            val = duration.hour;
            break;

          case "m":
            val = duration.min;
            break;

          case "s":
            val = duration.sec;
        }

        return val;
      }, $scope.updateModelFromUi = function () {
        var day, hour, min, sec;
        $scope.ngModel = (day = parseInt($($element.find(".input-day")[0]).val()), hour = parseInt($($element.find(".input-hour")[0]).val()), min = parseInt($($element.find(".input-minute")[0]).val()), sec = parseInt($($element.find(".input-second")[0]).val()), day = isNaN(day) ? 0 : day, hour = isNaN(hour) ? 0 : hour, min = isNaN(min) ? 0 : min, sec = isNaN(sec) ? 0 : sec, day * secsPerDay + hour * secsPerHour + 60 * min + sec), $scope.clampValue();
        var duration = modelToDuration();
        $($element.find(".input-day")[0]).val(duration.day), $($element.find(".input-hour")[0]).val(duration.hour), $($element.find(".input-minute")[0]).val(duration.min), $($element.find(".input-second")[0]).val(duration.sec);
      }, $scope.onBlockClick = function (type) {
        "d" == type && $($element.find(".input-day")[0]).focus(), "h" == type && $($element.find(".input-hour")[0]).focus(), "m" == type && $($element.find(".input-minute")[0]).focus(), "s" == type && $($element.find(".input-second")[0]).focus();
      }, $scope.upDay = function () {
        $scope.ngModel = $scope.ngModel + secsPerDay, $scope.clampValue(), $scope.onBlockClick("d");
      }, $scope.downDay = function () {
        $scope.ngModel >= secsPerDay && ($scope.ngModel = $scope.ngModel - secsPerDay), $scope.clampValue(), $scope.onBlockClick("d");
      }, $scope.upHour = function () {
        $scope.ngModel = $scope.ngModel + secsPerHour, $scope.clampValue(), $scope.onBlockClick("h");
      }, $scope.downHour = function () {
        $scope.ngModel >= secsPerHour && ($scope.ngModel = $scope.ngModel - secsPerHour), $scope.clampValue(), $scope.onBlockClick("h");
      }, $scope.upMin = function () {
        $scope.ngModel = $scope.ngModel + secsPerMinute, $scope.clampValue(), $scope.onBlockClick("m");
      }, $scope.downMin = function () {
        $scope.ngModel >= secsPerMinute && ($scope.ngModel = $scope.ngModel - secsPerMinute), $scope.clampValue(), $scope.onBlockClick("m");
      }, $scope.upSec = function () {
        $scope.ngModel = $scope.ngModel + 1, $scope.clampValue(), $scope.onBlockClick("s");
      }, $scope.downSec = function () {
        $scope.ngModel = $scope.ngModel - 1, $scope.clampValue(), $scope.onBlockClick("s");
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiEditableLabel", function () {
  return {
    restrict: "E",
    templateUrl: "component-editable-label/editable-label.template",
    scope: {
      maxlength: "=?",
      text: "@",
      updateOnBlur: "@",
      placeholder: "@",
      onChange: "&",
      onCancel: "&",
      validator: "&",
      validationState: "=?"
    },
    link: function link(scope, element, attrs) {
      scope.isValidatorExist = "validator" in attrs, scope.$watch("text", scope.onTextUpdate), element.on("$destroy", function () {
        scope.onDestroy();
      }), scope.$watch("maxlength", scope.maxlengthUpdated, !0), scope.init();
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      var validationCount = 0,
          State = {
        INITIAL: "INITIAL",
        EDITING: "EDITING",
        VALIDATING: "VALIDATING",
        VALID: "VALID",
        ERROR: "ERROR"
      },
          blurTimeout = 0;

      function makeEditable() {
        if (cancelBlurTimeout(), $scope.validationState == State.INITIAL) {
          $scope.validationState = State.EDITING, $scope.isValidating = !1, $scope.hideCancelIcon = !1;
          var el = $($element.find(".editable-label-input")[0]);
          $timeout(function () {
            el.focus();
          }, 100);
        }
      }

      function cancelBlurTimeout() {
        blurTimeout && ($timeout.cancel(blurTimeout), blurTimeout = 0);
      }

      $scope.validationState = State.INITIAL, $scope.isValidating = !1, $scope.hideSaveIcon = !0, $scope.hideCancelIcon = !1, $scope.showPlaceholder = !1, $scope.ignoreBlur = !1, $scope.init = function () {
        $scope.onTextUpdate();
      }, $scope.onDestroy = function () {
        cancelBlurTimeout();
      }, $scope.maxlengthUpdated = function () {
        $element.find("input").attr("maxlength", $scope.maxlength);
      }, $scope.onTextUpdate = function () {
        $scope.editedText = $scope.text, $scope.text ? $scope.showPlaceholder = !1 : $scope.showPlaceholder = !0, $scope.placeholder || ($scope.placeholder = "Enter text");
      }, $scope.onClick = function () {
        makeEditable();
      }, $scope.onLabelFocus = function () {
        makeEditable(), $scope.ignoreBlur = !1;
      }, $scope.onBlur = function ($event) {
        cancelBlurTimeout(), $scope.ignoreBlur ? $scope.ignoreBlur = !1 : blurTimeout = $timeout(function () {
          $scope.text == $scope.editedText ? ($scope.validationState = State.INITIAL, $scope.isValidating = !1, $scope.hideSaveIcon = !0, $scope.hideCancelIcon = !0) : $scope.updateOnBlur && "true" == $scope.updateOnBlur.toLowerCase() && $scope.onSave();
        }, 100);
      }, $scope.onKeyup = function (e) {
        13 == e.which ? (e.preventDefault(), $scope.onSave()) : 9 == e.which ? $scope.onBlur() : $scope.$evalAsync(function () {
          $scope.validationState = State.EDITING, $scope.hideSaveIcon = !1, $scope.onChange({
            value: $scope.editedText
          });
        });
      }, $scope.onIgnoreBlur = function () {
        $scope.ignoreBlur = !0, cancelBlurTimeout();
      }, $scope.onCancelClick = function () {
        cancelBlurTimeout(), $scope.validationState = State.INITIAL, $scope.hideSaveIcon = !0, $scope.editedText = $scope.text, $scope.onCancel({
          value: $scope.editedText
        });
      }, $scope.onSave = function () {
        cancelBlurTimeout(), $scope.isValidatorExist ? function (value) {
          validationCount++, $scope.hideSaveIcon = !0, $scope.isValidating = !0, $scope.validationState = State.VALIDATING;
          var currentCount = validationCount;
          $scope.validator({
            value: value
          }).then(function () {
            currentCount == validationCount && ($scope.text = $scope.editedText, $scope.text ? $scope.showPlaceholder = !1 : $scope.showPlaceholder = !0, $scope.validationState = State.INITIAL, $scope.isValidating = !1, $scope.hideSaveIcon = !0, $scope.hideCancelIcon = !0);
          }, function (err) {
            currentCount == validationCount && ($scope.validationState = State.ERROR, $scope.isValidating = !1, $scope.hideSaveIcon = !0, $scope.hideCancelIcon = !1);
          });
        }($scope.editedText) : ($scope.text = $scope.editedText, $scope.text ? $scope.showPlaceholder = !1 : $scope.showPlaceholder = !0, $scope.validationState = State.INITIAL, $scope.hideSaveIcon = !0, $scope.hideCancelIcon = !0);
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiFileDragdrop", function () {
  return {
    restrict: "AE",
    templateUrl: "component-file-dragdrop/file-dragdrop.template",
    scope: {
      options: "=?",
      onChange: "&",
      onDelete: "&",
      onError: "&"
    },
    link: function link(scope, element) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.init();
    },
    controller: function controller($scope, $element, $compile) {
      var acceptedExt = null,
          flow = null;
      $scope.fileUploaded = !1, $scope.showUploadIcon = !0, $scope.preBrowseText = null, $scope.browseText = "browse", $scope.postBrowseText = null;
      var maxFiles = 0,
          fileCount = 0;

      function fileAdded(file, message) {
        return setErrorMsg(""), maxFiles > 0 && fileCount >= maxFiles ? (onError("You can only upload " + maxFiles + " file" + (maxFiles > 1 ? "s" : "") + "."), !1) : function (file) {
          var accepted = !0;

          if (acceptedExt && acceptedExt.length > 0) {
            var ext = "." + file.getExtension().toLowerCase();
            accepted = !1;

            for (var i = 0; i < acceptedExt.length; i++) {
              var e = acceptedExt[i].toLowerCase();

              if (ext == e) {
                accepted = !0;
                break;
              }
            }
          } else if (acceptedFileTypes && acceptedFileTypes.length > 0) for (var k = 0; k < acceptedFileTypes.length; k++) {
            var type = acceptedFileTypes[k].toLowerCase();
            if (accepted = file.file.type.indexOf(type + "/") > -1) break;
          }

          return accepted;
        }(file) ? void function (fileId, filePath, progress, size) {
          var fileContainerEl = $($element.find(".file-list"));
          fileContainerEl.empty();
          var html = '<div class="file-row flow-file-' + fileId + '"><div class="file-col filename-col"><span>' + filePath + "</span></div>" + (size ? '<div class="file-col filesize-col">' + function (bytes, decimals) {
            for (var sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], i = 0; i < sizes.length; i++) {
              if (bytes <= 1024) return bytes + " " + sizes[i];
              bytes = parseFloat(bytes / 1024).toFixed(decimals);
            }

            return bytes;
          }(size, 0) + "</div>" : "") + '<div class="file-col delete-col"><i class="icon icon-clear upload-cancel" ng-click="onFileDelete(\'' + fileId + "')\"></i></div></div>",
              el = $compile(html)($scope);
          fileContainerEl.append(el), fileCount++, $scope.fileUploaded = !0;
        }(file.uniqueIdentifier, file.name, 0, file.size) : (onError("File format not supported. Accepted file formats (" + acceptedExt.join(", ") + ")"), !1);
      }

      function filesSubmitted(file) {
        file.length > 0 && $scope.onChange && $scope.onChange({
          file: file
        });
      }

      function onError(err) {
        setErrorMsg(err), function () {
          for (var i = 0; i < flow.files.length; i++) {
            var f = flow.files[i];
            f.cancel();
          }
        }(), $scope.onError && $scope.onError({
          error: err
        });
      }

      function setErrorMsg(err) {
        $scope.$evalAsync(function () {
          $scope.error = err;
        });
      }

      $scope.init = function () {
        !function () {
          if ($scope.options) {
            var o = $scope.options;
            o.fileExtensions && o.fileExtensions.length > 0 && (acceptedExt = o.fileExtensions), void 0 !== o.showUploadIcon && null !== o.showUploadIcon && ($scope.showUploadIcon = o.showUploadIcon), o.preBrowseText && ($scope.preBrowseText = o.preBrowseText), o.browseText && ($scope.browseText = o.browseText), o.postBrowseText && ($scope.postBrowseText = o.postBrowseText), o.maxFiles && (maxFiles = o.maxFiles);
          }
        }(), (flow = new Flow({
          target: null,
          chunkSize: 1048576,
          testChunks: !1,
          singleFile: !0
        })).support || setErrorMsg("Flow.js is not supported."), $scope.$evalAsync(function () {
          flow.assignBrowse($element.find(".browse")[0]), flow.assignDrop($element.find(".drop")[0]), flow.on("fileAdded", fileAdded), flow.on("filesSubmitted", filesSubmitted);
        });
      }, $scope.destroy = function () {}, $scope.onFileDelete = function (id) {
        var file = null;
        if (flow && flow.files) for (var i = 0; i < flow.files.length; i++) {
          var f = flow.files[i];

          if (f.uniqueIdentifier == id) {
            file = f, f.cancel();
            break;
          }
        }

        if (file && ($scope.fileUploaded = !1, fileCount--, maxFiles > 0 && fileCount < maxFiles && setErrorMsg(""), $scope.onDelete)) {
          var fileRemoved = {
            id: file.uniqueIdentifier,
            originalName: file.file.name,
            file: file.file.name,
            path: null
          };
          $scope.onDelete({
            file: fileRemoved
          });
        }
      };
    }
  };
}), function ($angular) {
  $angular.module("core.ui").directive("asuiFileUpload", function () {
    return {
      restrict: "EA",
      replace: "true",
      templateUrl: "component-fileupload/fileupload.template",
      scope: {
        options: "=?",
        ngModel: "=",
        validation: "=?",
        resolveFilePath: "&",
        onApiReady: "&",
        onFileAdded: "&",
        onComplete: "&",
        onSort: "&",
        onError: "&",
        onDelete: "&",
        onToolbarButtonClick: "&",
        targetFunction: "&",
        targetUrl: "@",
        showGenericError: "@",
        showUploadIcon: "@"
      },
      link: function link(scope, element, attrs) {
        scope.api = {
          addExistingFiles: scope.addExistingFiles,
          cancelUpload: scope.cancelUpload
        }, scope.init(), scope.onApiReady && scope.onApiReady({
          api: scope.api
        });
      },
      controller: ["$scope", "$location", "$element", "$timeout", "$compile", "$window", "ContentUtil", function ($scope, $location, $element, $timeout, $compile, $window, ContentUtil) {
        var contentUtil = new ContentUtil(),
            autoUpload = !0,
            singleFile = !1,
            maxFiles = 0,
            autoReplace = !1,
            fileCount = 0,
            acceptedExt = null,
            acceptedFileTypes = null,
            acceptedFileMsg = null,
            flow = null,
            showThumbnail = !1,
            sortEnabled = !1;
        $scope.error = null;
        var localFiles = [],
            chunkSize = 1048576;

        function constructValidation() {
          if ($scope.validation) {
            var v = $scope.validation;
            v.fileExtensions && v.fileExtensions.length > 0 ? (acceptedExt = v.fileExtensions, acceptedFileMsg = "Please upload supported file format: " + v.fileExtensions.join(", ")) : v.fileTypes && v.fileTypes.length > 0 && (acceptedFileTypes = v.fileTypes, acceptedFileMsg = "Please upload an " + v.fileTypes.join(", ") + " file."), $scope.showGenericError && (acceptedFileMsg = "Failed to upload. The format is not supported. Please try again.");
          }
        }

        function appendFile(fileId, filePath, progress, existing, size) {
          var fileContainerEl = $($element.find(".file-list"));
          singleFile && fileContainerEl.empty();

          var html = '<div class="file-row flow-file-' + fileId + '">' + (sortEnabled ? '<div class="file-col sort-col"><i ng-click="moveUp(\'' + fileId + '\')" class="fa fa-caret-up"></i><i ng-click="moveDown(\'' + fileId + '\')" class="fa fa-caret-down"></i></div>' : "") + (showThumbnail ? '<div class="file-col thumbnail-col"><img class="file-thumbnail" src="images/doc.svg" /></div>' : "") + '<div class="file-col filename-col"><span>' + filePath + '</span></div><div class="file-col toolbar-col">' + function (filename, fileId) {
            var html = "";
            if ($scope.options && $scope.options.toolbarButtons) for (var btns = $scope.options.toolbarButtons, ext = function (filename) {
              var ext = null;

              if (filename) {
                var i = filename.lastIndexOf(".");
                -1 != i && (ext = filename.substr(i).toLowerCase());
              }

              return ext;
            }(filename), i = 0; i < btns.length; i++) {
              var btn = btns[i],
                  show = !0;

              if (btn && btn.extensions && btn.extensions.length > 0) {
                show = !1;

                for (var j = 0; j < btn.extensions.length; j++) {
                  var e = btn.extensions[j].toLowerCase();

                  if (ext == e) {
                    show = !0;
                    break;
                  }
                }
              }

              if (btn && btn.notExtensions && btn.notExtensions.length > 0) {
                show = !0;

                for (var k = 0; k < btn.notExtensions.length; k++) {
                  var ne = btn.notExtensions[k].toLowerCase();

                  if (ext == ne) {
                    show = !1;
                    break;
                  }
                }
              }

              show && (html += '<button type="button" class="btn btn-default ' + btn["class"] + '" ng-click="toolbarButtonClick(\'' + fileId + "', options.toolbarButtons[" + i + '])">' + btn.label + "</button>");
            }
            return html;
          }(filePath, fileId) + "</div>" + (existing ? "" : '<div class="file-col progress-col"><div class="progress"><div class="progress-bar" role="progressbar" aria-valuenow="' + progress + '" aria-valuemin="0" aria-valuemax="100" style="width: ' + progress + '%"><span class="sr-only">' + progress + "% Complete</span></div></div></div>") + (size ? '<div class="file-col filesize-col">' + function (bytes, decimals) {
            for (var sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"], i = 0; i < sizes.length; i++) {
              if (bytes <= 1024) return bytes + " " + sizes[i];
              bytes = parseFloat(bytes / 1024).toFixed(decimals);
            }

            return bytes;
          }(size, 0) + "</div>" : "") + '<div class="file-col delete-col"><i class="fa fa-check upload-success hidden"></i><i class="fa fa-warning upload-failed hidden"></i><i class="fa fa-remove upload-cancel' + (existing ? " hidden" : "") + '" ng-click="onFileDelete(\'' + fileId + '\')"></i><i class="fa fa-trash upload-delete' + (existing ? "" : " hidden") + '" ng-click="onFileDelete(\'' + fileId + "')\"></i></div></div>",
              el = $compile(html)($scope);

          fileContainerEl.append(el), fileCount++;
        }

        function generateGuid() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = 16 * Math.random() | 0;
            return ("x" == c ? r : 3 & r | 8).toString(16);
          });
        }

        function setError(err) {
          $scope.error = err, $timeout(function () {
            $scope.$apply();
          });
        }

        function fileAdded(file, message) {
          setError("");
          var o = $scope.options;
          if (o.maxFiles && 1 == (maxFiles = o.maxFiles) && (singleFile = !0), o.autoReplace && !0 === o.autoReplace && (autoReplace = o.autoReplace), autoReplace && !0 === autoReplace) $($element.find(".file-list")).empty();else if (maxFiles > 0 && fileCount >= maxFiles) return setError("You can only upload " + maxFiles + " file" + (maxFiles > 1 ? "s" : "") + "."), !1;
          if (!function (file) {
            var accepted = !0;

            if (acceptedExt && acceptedExt.length > 0) {
              var ext = "." + file.getExtension().toLowerCase();
              accepted = !1;

              for (var i = 0; i < acceptedExt.length; i++) {
                var e = acceptedExt[i].toLowerCase();

                if (ext == e) {
                  accepted = !0;
                  break;
                }
              }
            } else if (acceptedFileTypes && acceptedFileTypes.length > 0) for (var k = 0; k < acceptedFileTypes.length; k++) {
              var type = acceptedFileTypes[k].toLowerCase();
              if (accepted = file.file.type.indexOf(type + "/") > -1) break;
            }

            return accepted;
          }(file)) return setError(acceptedFileMsg), !1;
          if (o.customFilename && o.customFilename.length > 0) if (0 === contentUtil.getContentType(o.customFilename)) {
            var ext = "." + file.getExtension().toLowerCase();
            file.name = o.customFilename + ext;
          } else file.name = o.customFilename;
          $scope.onFileAdded && $scope.onFileAdded({
            file: file
          }), appendFile(file.uniqueIdentifier, file.name, 0, !1, file.size), function (file) {
            var type = file.file.type,
                iconUrl = contentUtil.getMediaIconByFilename(file.name);
            if (type) {
              if (0 === type.indexOf("image")) {
                if (0 === type.indexOf("image/tiff")) setPreviewThumbnailUrl(iconUrl, file.uniqueIdentifier);else {
                  var fileReader = new FileReader();
                  fileReader.onload = function (event) {
                    var tnUrl = event.target.result;
                    setPreviewThumbnailUrl(tnUrl, file.uniqueIdentifier);
                  }, fileReader.readAsDataURL(file.file);
                }
              } else 0 === type.indexOf("video") && 0 === type.indexOf("video/mp4") ? function (file) {
                var fileReader = new FileReader();
                fileReader.onload = function () {
                  var blob = new Blob([fileReader.result], {
                    type: file.file.type
                  }),
                      url = URL.createObjectURL(blob),
                      video = document.createElement("video"),
                      timeupdate = function timeupdate() {
                    snapImage() && (video.removeEventListener("timeupdate", timeupdate), video.pause());
                  };

                  video.addEventListener("loadeddata", function () {
                    snapImage() && video.removeEventListener("timeupdate", timeupdate);
                  });

                  var snapImage = function snapImage() {
                    var canvas = document.createElement("canvas");
                    canvas.width = video.videoWidth, canvas.height = video.videoHeight, canvas.getContext("2d").drawImage(video, 0, 0, canvas.width, canvas.height);
                    var tnUrl = canvas.toDataURL(),
                        success = tnUrl.length > 1e5;
                    return success && (setPreviewThumbnailUrl(tnUrl, file.uniqueIdentifier), URL.revokeObjectURL(url)), success;
                  };

                  video.addEventListener("timeupdate", timeupdate), video.preload = "metadata", video.src = url, video.muted = !0, video.playsInline = !0, video.play();
                }, fileReader.readAsArrayBuffer(file.file);
              }(file) : setPreviewThumbnailUrl(iconUrl, file.uniqueIdentifier);
            } else setPreviewThumbnailUrl(iconUrl, file.uniqueIdentifier);
          }(file);
        }

        function setPreviewThumbnailUrl(url, fileId) {
          $timeout(function () {
            var el = $element.find(".flow-file-" + fileId + " .file-thumbnail");
            $(el).attr("src", url);
          });
        }

        function filesSubmitted(file) {
          file.length > 0 && flow.upload();
        }

        function fileProgress(file) {
          var progress = Math.floor(100 * file.progress()),
              el = $element.find(".flow-file-" + file.uniqueIdentifier + " .progress-bar");
          $(el).css({
            width: progress + "%"
          });
        }

        function fileSuccess(file, path) {
          var fileId, show, el;

          if (fileId = file.uniqueIdentifier, show = !0, el = $element.find(".flow-file-" + fileId + " .upload-success"), show ? $(el).removeClass("hidden") : $(el).addClass("hidden"), toggleProgressBar(file.uniqueIdentifier, !1), toggleDelete(file.uniqueIdentifier, !0), toggleCancel(file.uniqueIdentifier, !1), null === $scope.ngModel && ($scope.ngModel = []), $scope.resolveFilePath) {
            var rpath = $scope.resolveFilePath({
              path: path
            });
            rpath && (path = rpath);
          }

          var m = {
            id: file.uniqueIdentifier,
            originalName: file.file.name,
            file: file.file.name,
            path: path
          },
              pos = getItemPosition(m.id);
          pos > -1 ? (localFiles.splice(pos, 0, m), $scope.ngModel.splice(pos, 0, m)) : (localFiles.push(m), $scope.ngModel.push(m)), $scope.onComplete && $scope.onComplete({
            file: file,
            value: path
          });
        }

        function fileError(file, message) {
          null !== message && 0 !== message.length || (message = "Error uploading file"), autoUpload && function (fileId, show, error) {
            var el = $element.find(".flow-file-" + fileId + " .upload-failed");

            if (show) {
              $(el).removeClass("hidden"), $(el).attr("title", error);
              var pb = $element.find(".flow-file-" + fileId + " .progress");
              $(pb).hide();
            } else $(el).addClass("hidden");
          }(file.uniqueIdentifier, !0, message), toggleProgressBar(file.uniqueIdentifier, !1), toggleDelete(file.uniqueIdentifier, !0), toggleCancel(file.uniqueIdentifier, !1), $scope.onError && $scope.onError({
            file: file,
            message: message
          });
        }

        function sortModel(id) {
          var pos = getItemPosition(id);
          if (-1 != pos) for (var i = 0; i < $scope.ngModel.length; i++) {
            var m = angular.copy($scope.ngModel[i]);

            if (m.id.toString() === id && i !== pos) {
              $scope.ngModel.splice(i, 1), $scope.ngModel.splice(pos, 0, m);
              break;
            }
          }
        }

        function getItemPosition(id) {
          for (var rows = $($element.find(".file-list")).children(), pos = -1, i = 0; i < rows.length; i++) {
            if (-1 != rows[i].className.indexOf("flow-file-" + id)) {
              pos = i;
              break;
            }
          }

          return pos;
        }

        function toggleProgressBar(fileId, show) {
          var el = $element.find(".flow-file-" + fileId + " .progress-col");
          show ? $(el).show() : $(el).hide();
        }

        function toggleCancel(fileId, show) {
          var el = $element.find(".flow-file-" + fileId + " .upload-cancel");
          show ? $(el).removeClass("hidden") : $(el).addClass("hidden");
        }

        function toggleDelete(fileId, show) {
          var el = $element.find(".flow-file-" + fileId + " .upload-delete");
          show ? $(el).removeClass("hidden") : $(el).addClass("hidden");
        }

        $scope.init = function () {
          !function () {
            if ($scope.options) {
              var o = $scope.options;
              o.maxFiles && 1 == (maxFiles = o.maxFiles) && (singleFile = !0), o.chunkSize && (chunkSize = o.chunkSize), o.autoReplace && !0 === o.autoReplace && (autoReplace = o.autoReplace), o.showThumbnail && !0 === o.showThumbnail && (showThumbnail = o.showThumbnail), o.sortEnabled && 1 == o.sortEnabled && (sortEnabled = o.sortEnabled), !1 === o.autoUpload && (autoUpload = o.autoUpload);
            }

            constructValidation();
          }();
        }, $scope.$watch("validation", function (newVal, oldVal) {
          newVal != oldVal && constructValidation();
        }), $scope.$watch("targetUrl", function (newVal, oldVal) {
          flow ? newVal != oldVal && (flow.target = newVal) : newVal && function () {
            !$scope.targetUrl && $scope.autoUpload && setError("TargetUrl not set.");
            var flowOptions = {
              target: $scope.targetUrl,
              chunkSize: chunkSize,
              testChunks: !1,
              singleFile: singleFile,
              generateUniqueIdentifier: generateGuid
            };
            $scope.options && $scope.options.headers ? flowOptions.headers = $scope.options.headers : flowOptions.headers = {
              token: $window.sessionStorage.token,
              Accept: "application/json"
            };
            $scope.flow = flow = new Flow(flowOptions), flow.support || ($scope.error = "Flow.js is not supported.");
            $timeout(function () {
              flow.assignBrowse($element.find(".browse")[0]), flow.assignDrop($element.find(".drop")[0]), flow.on("fileAdded", fileAdded), flow.on("filesSubmitted", filesSubmitted), flow.on("fileProgress", fileProgress), flow.on("fileSuccess", fileSuccess), flow.on("fileError", fileError), $scope.addExistingFiles();
            }, 0);
          }();
        }), $scope.addExistingFiles = function () {
          if ($scope.ngModel && $scope.ngModel.length > 0) {
            for (var i = 0; i < $scope.ngModel.length; i++) {
              var f = $scope.ngModel[i];

              if (f && f.file) {
                f.id || (f.id = i);
                var filename = "";
                filename = f.originalName ? f.originalName : f.path, appendFile(f.id, filename, 100, !0);
              }
            }

            localFiles = $angular.copy($scope.ngModel);
          }
        }, $scope.showDropText = function (id) {
          return $scope.options && null !== $scope.options.dropText && void 0 !== $scope.options.dropText ? $scope.options.dropText : "Drop files here or";
        }, $scope.cancelUpload = function () {
          if (flow && flow.files) for (var i = 0; i < flow.files.length; i++) {
            flow.files[i].cancel();
          }
        }, $scope.onFileDelete = function (id) {
          var file = null;
          if (flow && flow.files) for (var i = 0; i < flow.files.length; i++) {
            var f = flow.files[i];

            if (f.uniqueIdentifier == id) {
              file = f, f.cancel();
              break;
            }
          }
          var fileEl = $element.find(".flow-file-" + id);
          $(fileEl).remove();

          for (var fileRemoved = null, j = 0; j < localFiles.length; j++) {
            var lf = localFiles[j];

            if (lf && lf.id == id) {
              for (var k = 0; k < $scope.ngModel.length; k++) {
                var m = $scope.ngModel[k];

                if (m && m.id == lf.id) {
                  fileRemoved = $scope.ngModel.splice(k, 1)[0];
                  break;
                }
              }

              id = lf.path, localFiles.splice(j, 1);
              break;
            }
          }

          fileCount--, maxFiles > 0 && fileCount < maxFiles && setError(""), $scope.onDelete && (!fileRemoved && file && (fileRemoved = {
            id: file.uniqueIdentifier,
            originalName: file.file.name,
            file: file.file.name,
            path: null
          }), $scope.onDelete({
            file: fileRemoved
          }));
        }, $scope.moveUp = function (id) {
          var e = $($element.find(".flow-file-" + id));
          e.prev().insertAfter(e), sortModel(id), $scope.onSort && $scope.onSort();
        }, $scope.moveDown = function (id) {
          var e = $($element.find(".flow-file-" + id));
          e.next().insertBefore(e), sortModel(id), $scope.onSort && $scope.onSort();
        }, $scope.toolbarButtonClick = function (fileId, btn) {
          var file = null;
          if ($scope.ngModel) for (var i = 0; i < $scope.ngModel.length; i++) {
            var f = $scope.ngModel[i];

            if (f && f.id == fileId) {
              file = f;
              break;
            }
          }
          if (null === file && flow.files) for (var k = 0; k < flow.files.length; k++) {
            var fl = flow.files[k];

            if (fl && fl.uniqueIdentifier == fileId) {
              file = {
                id: fl.uniqueIdentifier,
                originalName: fl.file.name,
                file: fl.uniqueIdentifier,
                path: null
              };
              break;
            }
          }
          $scope.onToolbarButtonClick && $scope.onToolbarButtonClick({
            file: file,
            btn: btn
          });
        };
      }]
    };
  });
}(window.angular), window.angular.module("core.ui").directive("asuiFlip", function () {
  return {
    restrict: "E",
    transclude: !0,
    templateUrl: "component-flip/flip.template",
    scope: {
      flip: "=?"
    },
    link: function link(scope, element) {
      scope.$watch("flip", scope.onFlipChange), scope.init();
    },
    controller: function controller($scope, $timeout, $element) {
      var flipContainer;
      $scope.postTransition = !1, $scope.shouldFlip = !1;
      var flipInProgress = !1,
          flipPending = !0;
      $scope.init = function () {
        flipContainer = $element.find(".flip-container"), $scope.setupPostTransition();
      }, $scope.onTransitionComlete = function () {
        $scope.$evalAsync(function () {
          flipContainer.removeClass("enable-transition"), $scope.setupPostTransition(), flipInProgress = !1, flipPending && $scope.onFlipChange();
        });
      }, $scope.setupPostTransition = function () {
        $scope.postTransition = !0;
      }, $scope.setupPreTransition = function () {
        $scope.postTransition = !1;
      }, $scope.onFlipChange = function (newVal, previousValue) {
        flipInProgress ? flipPending = !0 : (flipPending = !1, $scope.startFlip());
      }, $scope.startFlip = function () {
        flipInProgress = !0, $scope.setupPreTransition(), $timeout(function () {
          flipContainer.addClass("enable-transition"), $scope.shouldFlip = $scope.flip, $timeout($scope.onTransitionComlete, 600);
        }, 1);
      };
    }
  };
}), window.angular.module("core.ui").constant("FloorplanEditorEnums", {
  POIs: {
    Room: {
      Auditorium: {
        label: "Auditorium",
        icon: "icon-auditorium"
      },
      Classroom: {
        label: "Class Room",
        icon: "icon-class-room"
      },
      ConferenceRoom: {
        label: "Conference Room",
        icon: "icon-conference-room"
      },
      ExecutiveRoom: {
        label: "Executive Room",
        icon: "icon-executive-room"
      },
      MeetingRoom: {
        label: "Meeting Room",
        icon: "icon-meeting-room"
      },
      Office: {
        label: "Office",
        icon: "icon-office"
      },
      Room: {
        label: "Room",
        icon: "icon-room"
      },
      VideoConferenceRoom: {
        label: "Video Conference Room",
        icon: "icon-video-conference-room"
      }
    },
    Space: {
      Desk: {
        label: "Desk",
        icon: "icon-desk"
      },
      Fitness: {
        label: "Fitness",
        icon: "icon-fitness"
      },
      HuddleSpace: {
        label: "Huddle Space",
        icon: "icon-huddle-space"
      },
      OpenSeating: {
        label: "Open Seating",
        icon: "icon-open-seating"
      },
      OpenTables: {
        label: "Open Tables",
        icon: "icon-open-tables"
      },
      Neighborhood: {
        label: "Neighborhood",
        icon: "icon-poi-neighborhood"
      },
      QuietSpace: {
        label: "Quiet Space",
        icon: "icon-quiet"
      },
      ParkingSpace: {
        label: "Parking Space",
        icon: "icon-poi-parking"
      },
      Silent: {
        label: "Silent Area",
        icon: "icon-poi-silent"
      },
      Social: {
        label: "Social Area",
        icon: "icon-poi-social"
      },
      SocialLounge: {
        label: "Social Lounge",
        icon: "icon-social-lounge"
      },
      Training: {
        label: "Training Area",
        icon: "icon-poi-training"
      }
    },
    POI: {
      Atm: {
        label: "Atm",
        icon: "icon-poi-atm"
      },
      Bathroom: {
        label: "Bathroom",
        icon: "icon-poi-bathroom"
      },
      BathroomHandicap: {
        label: "Bathroom Handicap",
        icon: "icon-poi-bathroom-handicap"
      },
      BathroomMen: {
        label: "Bathroom Men",
        icon: "icon-poi-bathroommen"
      },
      BathroomWomen: {
        label: "Bathroom Women",
        icon: "icon-poi-bathroomwomen"
      },
      Bleachers: {
        label: "Bleachers",
        icon: "icon-poi-bleachers"
      },
      Breakroom: {
        label: "Break Room",
        icon: "icon-poi-breakroom"
      },
      Bus: {
        label: "Bus",
        icon: "icon-poi-bus"
      },
      Cafe: {
        label: "Cafe",
        icon: "icon-poi-cafe"
      },
      ChangingTable: {
        label: "Changing Table",
        icon: "icon-poi-changingtable"
      },
      DryCleaner: {
        label: "Dry Cleaner",
        icon: "icon-poi-drycleaner"
      },
      Elevator: {
        label: "Elevator",
        icon: "icon-poi-elevator"
      },
      ElevatorDown: {
        label: "Elevator Down",
        icon: "icon-poi-elevator-down"
      },
      ElevatorUp: {
        label: "Elevator Up",
        icon: "icon-poi-elevator-up"
      },
      Escalator: {
        label: "Escalator",
        icon: "icon-poi-escalator"
      },
      EscalatorDown: {
        label: "Escalator Down",
        icon: "icon-poi-escalator-down"
      },
      EscalatorUp: {
        label: "Escalator Up",
        icon: "icon-poi-escalator-up"
      },
      Exit: {
        label: "Exit",
        icon: "icon-poi-exit"
      },
      ExitLeft: {
        label: "Exit Left",
        icon: "icon-poi-exit-left"
      },
      ExitRight: {
        label: "Exit Right",
        icon: "icon-poi-exit-right"
      },
      FastFood: {
        label: "Fast Food",
        icon: "icon-poi-fastfood"
      },
      Freight: {
        label: "Freight",
        icon: "icon-poi-freight"
      },
      Firehose: {
        label: "Firehose",
        icon: "icon-poi-firehose"
      },
      FrontDesk: {
        label: "Front Desk",
        icon: "icon-poi-frontdesk"
      },
      FrontPorch: {
        label: "Front Porch",
        icon: "icon-front-porch"
      },
      Game: {
        label: "Games",
        icon: "icon-poi-game"
      },
      Gym: {
        label: "Gym",
        icon: "icon-poi-gym"
      },
      Information: {
        label: "Information",
        icon: "icon-poi-information"
      },
      JanitorsCloset: {
        label: "Janitor's Closet",
        icon: "icon-poi-janitorscloset"
      },
      Library: {
        label: "Library",
        icon: "icon-poi-library"
      },
      Lockers: {
        label: "Lockers",
        icon: "icon-poi-lockers"
      },
      Mail: {
        label: "Mail",
        icon: "icon-poi-mail"
      },
      MaintenanceRoom: {
        label: "Maintenance Room",
        icon: "icon-poi-maintenance-room"
      },
      Medical: {
        label: "Medical",
        icon: "icon-poi-medical"
      },
      Nursery: {
        label: "Nursery",
        icon: "icon-poi-nursery"
      },
      Parking: {
        label: "Parking",
        icon: "icon-poi-parking"
      },
      PrayerRoom: {
        label: "Prayer Room",
        icon: "icon-poi-prayerroom"
      },
      Printer: {
        label: "Printer",
        icon: "icon-poi-printer"
      },
      Recycling: {
        label: "Recycling",
        icon: "icon-poi-recycling"
      },
      Restaurant: {
        label: "Restaurant",
        icon: "icon-poi-restaurant"
      },
      SanitizingStation: {
        label: "Sanitizing Station",
        icon: "icon-poi-sanitizing-station"
      },
      ServiceDesk: {
        label: "Service Desk",
        icon: "icon-poi-service-desk"
      },
      Shop: {
        label: "Shop",
        icon: "icon-poi-shop"
      },
      Shower: {
        label: "Shower",
        icon: "icon-poi-shower"
      },
      Solarium: {
        label: "Solarium",
        icon: "icon-poi-solarium"
      },
      Stairs: {
        label: "Stairs",
        icon: "icon-poi-stairs"
      },
      StairsDown: {
        label: "Stairs Down",
        icon: "icon-poi-stairs-down"
      },
      StairsUp: {
        label: "Stairs Up",
        icon: "icon-poi-stairs-up"
      },
      Taxi: {
        label: "Taxi",
        icon: "icon-poi-taxi"
      },
      Terrace: {
        label: "Terrace",
        icon: "icon-poi-terrace"
      },
      Toilet: {
        label: "Toilet",
        icon: "icon-poi-toilet"
      },
      Train: {
        label: "Train",
        icon: "icon-poi-train"
      },
      Trash: {
        label: "Trash",
        icon: "icon-poi-trash"
      },
      VendingMachine: {
        label: "Vending Machine",
        icon: "icon-poi-vendingmachine"
      },
      Video: {
        label: "Video",
        icon: "icon-poi-video"
      },
      Washroom: {
        label: "Washroom",
        icon: "icon-poi-washroom"
      },
      Wellness: {
        label: "Wellness",
        icon: "icon-poi-wellness"
      },
      WaterFountain: {
        label: "Water Fountain",
        icon: "icon-poi-waterfountain"
      },
      WheelchairAccessible: {
        label: "Wheelchair Accessible",
        icon: "icon-poi-wheelchairaccessible"
      }
    }
  }
}), window.angular.module("core.ui").directive("asuiFloorplanEditor", function () {
  return {
    restrict: "E",
    templateUrl: "component-floorplan-editor/floorplan-editor.template",
    scope: {
      floorplan: "@",
      items: "=?",
      itemsSelected: "=?",
      options: "=?",
      onNewItem: "&",
      onNewItemCancel: "&",
      onItemClick: "&",
      onStageClick: "&",
      onZoomUpdate: "&",
      onFloorplanLoad: "&",
      onApiReady: "&"
    },
    link: function link(scope, element, attrs) {
      element.on("$destroy", function () {
        scope.onDestroy();
      }), scope.$watch("floorplan", scope.onFloorplanUpdate), scope.$watch("items", scope.onItemsUpdate, !0), scope.$watchCollection("itemsSelected", scope.onItemsSelectedUpdate), scope.onInit();
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      var floorPlanInfo = {
        imageWidth: 1,
        imageHeight: 1,
        imageRatio: 1,
        elementWidth: 1,
        elementHeight: 1
      },
          resizeInterval = null,
          poiLayerApi = null;

      function reset() {
        poiLayerApi.cancelNewItem();
      }

      function setZoom(scale) {
        poiLayerApi.setZoom(scale);
      }

      function resetZoom() {
        poiLayerApi.resetZoom();
      }

      function getZoom() {
        poiLayerApi.getZoom();
      }

      function createNewItem(type, options) {
        $scope.mode = $scope.EDITOR_MODE.NEWPOI, poiLayerApi.createNewItem(type, options);
      }

      function cancelNewItem() {
        $scope.mode = null, poiLayerApi.cancelNewItem();
      }

      function selectItems(itemIds) {
        $scope.mode = null, poiLayerApi.cancelNewItem(), poiLayerApi.selectItems(itemIds), $scope.itemsSelected = poiLayerApi.getSelectedItems();
      }

      function getSelectedItems() {
        return poiLayerApi.getSelectedItems();
      }

      function getItemBoundary(itemId) {
        return poiLayerApi.getItemBoundary(itemId);
      }

      function moveItem(itemId, newPosition) {
        return poiLayerApi.moveItem(itemId, newPosition);
      }

      function updateItem(item) {
        return poiLayerApi.updateItem(item);
      }

      function stopResizeInterval() {
        resizeInterval && (clearInterval(resizeInterval), resizeInterval = 0);
      }

      function checkResize() {
        if (poiLayerApi) {
          var elmWidth = Math.floor($element.innerWidth()),
              elmHeight = Math.floor($element.innerHeight()),
              resizeRequired = !1;
          floorPlanInfo.elementWidth != elmWidth && (floorPlanInfo.elementWidth = elmWidth, resizeRequired = !0), floorPlanInfo.elementHeight != elmHeight && (floorPlanInfo.elementHeight = elmHeight, resizeRequired = !0), resizeRequired && poiLayerApi.setStageSize(elmWidth, elmHeight);
        }
      }

      $scope.EDITOR_MODE = {
        NEWPOI: "newpoi",
        MOVEPOI: "movepoi"
      }, $scope.mode, $scope.onDestroy = function () {
        stopResizeInterval();
      }, $scope.onInit = function () {}, $scope.onPoiLayerApi = function (api) {
        poiLayerApi = api, $element.find("asui-floorplan-editor-poi-layer"), $scope.api = {
          reset: reset,
          selectItems: selectItems,
          getSelectedItems: getSelectedItems,
          createNewItem: createNewItem,
          cancelNewItem: cancelNewItem,
          poiLayerApi: poiLayerApi,
          setZoom: setZoom,
          updateItem: updateItem,
          resetZoom: resetZoom,
          getZoom: getZoom,
          getItemBoundary: getItemBoundary,
          moveItem: moveItem
        }, $scope.onApiReady && $scope.onApiReady({
          api: $scope.api
        });
      }, $scope.onItemsSelectedUpdate = function () {
        $scope.itemsSelected ? poiLayerApi.selectItems($scope.itemsSelected) : poiLayerApi.selectItems();
      }, $scope.onFloorplanUpdate = function () {
        $scope.floorplan;
      }, $scope.onItemsUpdate = function () {
        poiLayerApi && $scope.$evalAsync(poiLayerApi.buildScene);
      }, $scope.onLayerNewItem = function (item) {
        $scope.mode = "", poiLayerApi.selectItems(), $scope.onNewItem({
          item: item
        });
      }, $scope.onLayerNewItemCancel = function () {
        $scope.mode = "", poiLayerApi.selectItems(), $scope.onNewItemCancel();
      }, $scope.onLayerItemClick = function (item, event) {
        $scope.onItemClick({
          item: item,
          event: event
        });
      }, $scope.onLayerStageClick = function (event) {
        $scope.onStageClick({
          event: event
        });
      }, $scope.onPoiFloorplanLoad = function (size) {
        floorPlanInfo.imageWidth = size.width, floorPlanInfo.imageHeight = size.height, floorPlanInfo.imageRatio = size.width / size.height, floorPlanInfo.elementWidth = 0, floorPlanInfo.elementHeight = 0, stopResizeInterval(), resizeInterval = setInterval(checkResize, 50), checkResize(), $timeout($scope.onFloorplanLoad, 100);
      }, $scope.onLayerZoomUpdate = function (zoom) {
        $scope.onZoomUpdate({
          zoom: zoom
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiGrid", function () {
  return {
    restrict: "E",
    templateUrl: "component-grid/grid.template",
    transclude: {
      noDataContent: "?noDataContent",
      itemDirective: "?itemDirective"
    },
    scope: {
      items: "=?",
      options: "=?",
      onApiReady: "&",
      onItemEvent: "&",
      onSelectionChange: "&",
      onDataRendered: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$on("LastRepeaterElement", scope.dataRenderedEvent), scope.$watchCollection("items", scope.itemsUpdated), scope.$watch("options", function (newVal) {
        newVal && scope.init();
      }), scope.$watch("options.paging.type", function (newVal, oldVal) {
        newVal != oldVal && scope.reloadData();
      }), scope.$watch("options.paging.method", function (newVal, oldVal) {
        newVal != oldVal && (scope.apiMethod = newVal, scope.reloadData());
      }), scope.$watch("options.enableSelectable", function () {
        scope.onSelectableChange();
      }), scope.initApi();
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      $scope.totalItems = 0, $scope.ngStartIndex = null, $scope.isRetrievingItemsAsyc = !1, $scope.hasInit = !1, $scope.totalPages = 0, $scope.apiMethod = "page", $scope.nextPageCursor = null, $scope.items = $scope.items ? $scope.items : [], $scope.selectedCount = 0;
      var lastSelectedItemWithShiftKey = null,
          runninid = new Date().getTime();
      $scope.ngLimit = null;
      var virtualScrollCheck = 0,
          retrieveTimeout = 0;

      function stopVirtualScrollCheck() {
        virtualScrollCheck && (clearInterval(virtualScrollCheck), virtualScrollCheck = 0);
      }

      function startVirtualScrollCheck() {
        stopVirtualScrollCheck(), virtualScrollCheck = setInterval(checkVirtualScroll, 100);
      }

      function checkVirtualScroll() {
        !retrieveTimeout && !$scope.isRetrievingItemsAsyc && $scope.options.paging.currentPage < $scope.totalPages && function (element, overscan) {
          var elementRect = element.getBoundingClientRect(),
              isHorizontalScrolling = !1;
          if ("horizontal" == $scope.options.direction && (isHorizontalScrolling = !0), 0 === $element.height()) return !1;
          if (0 === $element.width()) return !1;
          var viewPortPadding = .5;
          null !== overscan && void 0 !== overscan && (viewPortPadding = overscan);
          var viewPortRect = null;

          if (isHorizontalScrolling) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            return viewPortRect = {
              left: -windowWidth * viewPortPadding,
              right: windowWidth * (1 + viewPortPadding)
            }, !(elementRect.left > viewPortRect.right || elementRect.right < 0 || elementRect.right < viewPortRect.left);
          }

          var windowHeight = window.innerHeight || document.documentElement.clientHeight;
          return viewPortRect = {
            top: -windowHeight * viewPortPadding,
            bottom: windowHeight * (1 + viewPortPadding)
          }, !(elementRect.top > viewPortRect.bottom || elementRect.bottom < 0 || elementRect.bottom < viewPortRect.top);
        }($element.find(".grid-virtualscroll-marker")[0]) && $scope.showMoreItems();
      }

      function updateItemsAsyncSuccess(response) {
        $scope.$evalAsync(function () {
          !$scope.options.paging || "virtual" != $scope.options.paging.type && "ondemand" != $scope.options.paging.type ? $scope.items = response.items : ($scope.items || ($scope.items = []), $scope.items = $scope.items.concat(response.items)), "cursor" == $scope.apiMethod ? !response.nextPage || response.isEndOfPage ? $scope.totalItems = $scope.items.length : ($scope.nextPageCursor = response.nextPage, $scope.totalItems = Number.MAX_SAFE_INTEGER) : $scope.totalItems = void 0 != response.totalItems ? response.totalItems : response.size, $scope.updateLocalItems(), !0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !1), $scope.isRetrievingItemsAsyc = !1;
        });
      }

      function updateItemsAsyncFail(response) {
        $scope.$evalAsync(function () {
          $scope.items = [], !0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !1), $scope.isRetrievingItemsAsyc = !1;
        });
      }

      function updateNgLimits() {
        if ($scope.ngStartIndex = null, $scope.ngLimit = null, $scope.options && !$scope.options.retrieveItemsAsync && $scope.options.paging && $scope.options.paging.currentPage > 0 && $scope.options.paging.itemsPerPage > 0) {
          var startIndex = ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage;
          !$scope.options.paging || "virtual" != $scope.options.paging.type && "ondemand" != $scope.options.paging.type ? ($scope.ngStartIndex = startIndex, $scope.ngLimit = $scope.options.paging.itemsPerPage) : ($scope.ngStartIndex = 0, $scope.ngLimit = $scope.options.paging.currentPage * $scope.options.paging.itemsPerPage);
        }
      }

      function updateSelectedItemCount() {
        $scope.selectedCount = 0, $scope.items.forEach(function (item) {
          $scope.options && $scope.options.enableSelectable && !1 !== item.isSelectable && (item.isSelected ? $scope.selectedCount++ : void 0 == item.isSelected && (item.isSelected = !1));
        }), $scope.selectedCount > 0 ? $($element.find(".asui-grid")).addClass("asui-selectable-item-multiselect") : $($element.find(".asui-grid")).removeClass("asui-selectable-item-multiselect");
      }

      function unselectAll() {
        $scope.items.forEach(function (item) {
          item.isSelected = !1;
        }), updateSelectedItemCount();
      }

      function selectAll() {
        $scope.items.forEach(function (item) {
          item.isSelected = !0;
        }), updateSelectedItemCount();
      }

      function select(ids) {
        Array.isArray(ids) || (ids = [ids]), ids.forEach(function (id) {
          for (var i = 0; i < $scope.items.length; i++) {
            var item = $scope.items[i];

            if (item.id == id) {
              item.isSelected = !0;
              break;
            }
          }
        }), updateSelectedItemCount();
      }

      function unselect(ids) {
        Array.isArray(ids) || (ids = [ids]), ids.forEach(function (id) {
          for (var i = 0; i < $scope.items.length; i++) {
            var item = $scope.items[i];

            if (item.id == id) {
              item.isSelected = !1;
              break;
            }
          }
        }), updateSelectedItemCount();
      }

      function getSelected(includeUnselectable) {
        var selected = [];
        return $scope.items.forEach(function (item) {
          1 == item.isSelected && (item.isSelectable || includeUnselectable) && selected.push(item);
        }), selected;
      }

      $scope.initApi = function () {
        var api = {
          unselectAll: unselectAll,
          selectAll: selectAll,
          select: select,
          getSelected: getSelected,
          unselect: unselect,
          getItems: $scope.getItems,
          reloadData: $scope.reloadData
        };
        $scope.onApiReady && $scope.onApiReady({
          api: api
        });
      }, $scope.clearData = function () {
        $scope.options && ($scope.options.paging && ("virtual" !== $scope.options.paging.type && "ondemand" !== $scope.options.paging.type || ($scope.options.paging.currentPage = 1)), $scope.totalPages = 0, $scope.totalItems = 0, $scope.ngLimit = null, $scope.nextPageCursor = null, lastSelectedItemWithShiftKey = null, $scope.items = [], $scope.ngStartIndex = null), updateSelectedItemCount(), stopVirtualScrollCheck();
      }, $scope.getItems = function () {
        return $scope.items;
      }, $scope.reloadData = function () {
        $scope.options && $scope.options.retrieveItemsAsync ? ($scope.clearData(), $scope.updateItemsAsync()) : (!$scope.options.paging || "virtual" !== $scope.options.paging.type && "ondemand" !== $scope.options.paging.type || ($scope.options.paging.currentPage = 1, $scope.nextPageCursor = null), updateNgLimits()), $scope.options.paging && "virtual" == $scope.options.paging.type ? startVirtualScrollCheck() : stopVirtualScrollCheck();
      }, $scope.dataRenderedEvent = function (event) {
        $scope.onDataRendered && $scope.onDataRendered(), event.stopPropagation();
      }, $scope.init = function () {
        $scope.options && ($scope.options.paging && ($scope.apiMethod = $scope.options.paging.method ? $scope.options.paging.method : "page", void 0 == $scope.options.paging.currentPage && ($scope.options.paging.currentPage = 1)), $scope.options.retrieveItemsAsync && (void 0 === $scope.options.retrieveItemsAsyncOnload || $scope.options.retrieveItemsAsyncOnload) && $scope.updateItemsAsync(), $scope.options.paging && "virtual" == $scope.options.paging.type ? startVirtualScrollCheck() : stopVirtualScrollCheck());
      }, $scope.destroy = function () {
        stopVirtualScrollCheck(), $timeout.cancel(retrieveTimeout);
      }, $scope.requestBatchDelay = 50, $scope.updateItemsAsync = function () {
        $scope.options && $scope.options.retrieveItemsAsync && (!0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !0), $timeout.cancel(retrieveTimeout), $scope.isRetrievingItemsAsyc = !0, retrieveTimeout = $timeout($scope.executeRetrieveItemsAsync, $scope.requestBatchDelay));
      }, $scope.showMoreItems = function () {
        $scope.options.paging.currentPage < $scope.totalPages && ($scope.options.paging.currentPage++, $scope.pageChanged());
      }, $scope.executeRetrieveItemsAsync = function () {
        retrieveTimeout = 0;
        var queryCriteria = {};
        "cursor" == $scope.apiMethod ? (queryCriteria.page = $scope.nextPageCursor, $scope.options.paging && $scope.options.paging.itemsPerPage && (queryCriteria.limit = $scope.options.paging.itemsPerPage)) : (queryCriteria.currentPage = 1, $scope.options.paging && $scope.options.paging.itemsPerPage && (queryCriteria.itemsPerPage = $scope.options.paging.itemsPerPage, queryCriteria.limit = $scope.options.paging.itemsPerPage), $scope.options.paging && $scope.options.paging.currentPage && (queryCriteria.currentPage = $scope.options.paging.currentPage)), $scope.options.retrieveItemsAsync(queryCriteria).then(updateItemsAsyncSuccess, updateItemsAsyncFail);
      }, $scope.showPaging = function () {
        return !(!$scope.options || !$scope.options.paging || $scope.options.paging && ("virtual" == $scope.options.paging.type || "ondemand" == $scope.options.paging.type) || 0 === $scope.totalItems || !($scope.options.paging && $scope.options.paging.currentPage && $scope.options.paging.itemsPerPage) || $scope.totalItems <= $scope.options.paging.itemsPerPage);
      }, $scope.pageChanged = function (newPage) {
        return $scope.options && $scope.options.retrieveItemsAsync ? $scope.updateItemsAsync() : updateNgLimits(), !0;
      }, $scope.itemId = function (item) {
        return item.id = item.id ? item.id : item.Id ? item.Id : runninid++, item.id;
      }, $scope.itemsUpdated = function (val) {
        val && ($scope.hasInit = !0), $scope.updateLocalItems();
      }, $scope.updateLocalItems = function () {
        $scope.items && ($scope.ngStartIndex = null, $scope.ngLimit = null, $scope.options && !$scope.options.retrieveItemsAsync ? ($scope.totalItems = $scope.items.length, updateNgLimits(), $scope.options && $scope.options.paging && $scope.options.paging.itemsPerPage && ($scope.totalPages = Math.ceil($scope.totalItems / $scope.options.paging.itemsPerPage))) : $scope.options && $scope.options.paging && $scope.options.paging.itemsPerPage && ($scope.totalPages = Math.ceil($scope.totalItems / $scope.options.paging.itemsPerPage)), updateSelectedItemCount(), $scope.items.forEach(function (item) {
          item._ActionMenu && item._ActionMenu.length ? item._FilteredActionMenu = item._ActionMenu : item._FilteredActionMenu = $scope.options.actionMenus;
        }));
      }, $scope.raiseItemEvent = function (event) {
        $scope.$evalAsync(function () {
          $scope.onItemEvent && $scope.onItemEvent({
            event: event
          });
        });
      }, $scope.onSelectableChange = function () {
        updateSelectedItemCount();
      }, $scope.onItemSelectionClick = function (itemSelect, event) {
        var newSelectState = !itemSelect.isSelected,
            items = [itemSelect];
        event.shiftKey ? lastSelectedItemWithShiftKey ? (newSelectState = lastSelectedItemWithShiftKey.isSelected, unselectAll(), items = function (itemA, itemB) {
          var itemAIndex = -1,
              itemBIndex = -1,
              itemsInBetween = [];
          if ($scope.items.forEach(function (item, index) {
            item.id == itemA.id ? itemAIndex = index : item.id == itemB.id && (itemBIndex = index);
          }), itemAIndex >= 0 && itemBIndex >= 0) for (var endIndex = itemBIndex >= itemAIndex ? itemBIndex : itemAIndex, i = itemAIndex <= itemBIndex ? itemAIndex : itemBIndex; i < endIndex + 1; i++) {
            var item = $scope.items[i];
            itemsInBetween.push(item);
          } else itemAIndex >= 0 ? itemsInBetween.push(itemA) : itemBIndex >= 0 && itemsInBetween.push(itemB);
          return itemsInBetween;
        }(lastSelectedItemWithShiftKey, itemSelect)) : lastSelectedItemWithShiftKey = itemSelect : lastSelectedItemWithShiftKey = null, items.forEach(function (item) {
          item.isSelected = newSelectState;
        }), updateSelectedItemCount(), $scope.onSelectionChange({
          items: items
        });
      };
    }]
  };
}), function ($angular) {
  $angular.module("core.ui").directive("asuiGrouper", function () {
    return {
      restrict: "E",
      replace: "true",
      transclude: !0,
      templateUrl: "component-grouper/grouper.template",
      scope: {
        id: "@",
        displayProperty: "@?",
        items: "=",
        isOpen: "=?",
        options: "="
      },
      link: function link(scope, element) {
        scope.$watch("items", scope.onItemsUpdated, !0), scope.$watch("options", scope.onOptionsUpdated, !0), scope.$watch("isOpen", scope.onOpened, !0), scope.$on("RepeaterElementRender", scope.elementRender), element.on("$destroy", function () {
          scope.destroy();
        });
      },
      controller: ["$scope", "$location", "$element", function ($scope, $location, $element) {
        function outsideClickHandler(e) {
          if ($scope.isOpen) {
            if ($element.is(e.target) || $element.has(e.target).length) return;
            $scope.isOpen = !1, $scope.$apply();
          }
        }

        $scope.maxItems = 1, $scope.ellipsis = !0, $scope.defaultTooltipTemplate = "component-grouper/grouper-tooltip.template", $scope.destroy = function () {
          document.body.removeEventListener("click", outsideClickHandler, !0);
        }, $scope.onOpened = function (isOpen) {
          document.body.removeEventListener("click", outsideClickHandler, !0), isOpen && document.body.addEventListener("click", outsideClickHandler, !0);
        }, $scope.elementRender = function (event, data) {
          data.index >= $scope.maxItems - 1 && $scope.generateLabel();
        }, $scope.generateLabel = function () {
          var remainderEl = $element.find(".grouper-remainder");

          if ($scope.items.length > 1) {
            var parentWidth = $element[0].offsetWidth,
                remainder = $scope.itemsCopy.length - $scope.maxItems,
                remainderText = remainder > 0 ? "+" + remainder : "";
            $(remainderEl).html(remainderText), $scope.ellipsis = !0;
            var el = $element.find(".grouper-item");
            if (el.length > 1) for (var childrenWidth = 0, spaceRemaining = !0, i = 0; i < el.length; i++) {
              spaceRemaining ? (childrenWidth += el[i].offsetWidth) + remainderEl[0].offsetWidth > parentWidth && (spaceRemaining = !1, 0 === i ? (remainderText = (remainder = $scope.itemsCopy.length - i - 1) > 0 ? "+" + remainder : "", $(remainderEl).html(remainderText), $scope.ellipsis = !0) : (remainderText = (remainder = $scope.itemsCopy.length - i) > 0 ? "+" + remainder : "", $(remainderEl).html(remainderText), $scope.itemsCopy[i].$hide = !0, childrenWidth + remainderEl[0].offsetWidth > parentWidth && i === $scope.itemsCopy.length - 1 && ($scope.ellipsis = !0))) : $scope.itemsCopy[i].$hide = !0;
            }
          } else $(remainderEl).html("");
        }, $scope.onItemsUpdated = function () {
          $scope.itemsCopy = $angular.copy($scope.items);

          for (var i = 0; i < $scope.itemsCopy.length; i++) {
            $scope.itemsCopy[i].$id = i;
          }
        }, $scope.onOptionsUpdated = function () {
          $scope.options && $scope.options.maxItems && $scope.options.maxItems > 1 && ($scope.maxItems = $scope.options.maxItems);
        }, $scope.getRenderType = function (item) {
          var type;
          return $scope.options && ($scope.options.itemTemplateUrl && $scope.options.itemTemplateUrl.length > 0 ? type = "templateUrl" : $scope.options.itemTemplate && $scope.options.itemTemplate.length > 0 && (type = "template")), type || (type = item.sref && item.sref.length > 0 ? "link" : "text"), type;
        };
      }]
    };
  });
}(window.angular), window.angular.module("core.ui").directive("asuiHorizontalNavbar", function () {
  return {
    restrict: "E",
    templateUrl: "component-horizontalnavbar/horizontalnavbar.template",
    scope: {
      id: "@",
      items: "=",
      ngModel: "=",
      options: "=",
      searchOpen: "=?",
      searchText: "=",
      onNavClick: "&",
      onCommandClick: "&",
      onSearchTextChange: "&",
      onSearchClose: "&",
      onSearchOpen: "&",
      onSearch: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("options", scope.optionsUpdated, !0), scope.$watch("searchOpen", scope.onSearchOpen, !0);
    },
    controller: ["$scope", "$location", "$element", "$timeout", "$interval", "$state", function ($scope, $location, $element, $timeout, $interval, $state) {
      var initialOpenHappened = !1,
          currentState = null,
          checkStateInterval = $interval(function () {
        currentState != $state.current.name && updateTabs();
      }, 50);

      function updateTabs() {
        if ($scope.options && $scope.options.searchSref && 0 === $state.current.name.indexOf($scope.options.searchSref) && ($scope.searchOpen = !0), $scope.items && $scope.items.length) {
          currentState = $state.current.name;

          for (var i = 0; i < $scope.items.length; i++) {
            var item = $scope.items[i];
            if (item.sref && 0 === $state.current.name.indexOf(item.sref)) return void ($scope.ngModel = item);
          }
        }
      }

      $scope.$on("$destroy", function () {
        $interval.cancel(checkStateInterval);
      }), $scope.optionsUpdated = function () {
        $scope.options && (initialOpenHappened || !0 !== $scope.options.initialSearchOpen || ($scope.searchOpen = !0, initialOpenHappened = !0)), updateTabs();
      }, $scope.onSearchOpen = function () {
        !0 === $scope.searchOpen ? ($timeout(function () {
          var input = $element.find(".horznav-search-autocomplete-container input");
          $(input).focus();
        }, 100), $scope.options && $scope.options.searchSref && 0 !== $state.current.name.indexOf($scope.options.searchSref) && (void 0 !== $scope.options.searchSrefParams && $scope.options.searchSrefParams ? $state.go($scope.options.searchSref, $scope.options.searchSrefParams) : $state.go($scope.options.searchSref))) : $scope.ngModel && $scope.ngModel.sref && 0 !== $state.current.name.indexOf($scope.ngModel.sref) && $state.go($scope.ngModel.sref);
      }, $scope.onNavItemClick = function ($event, item) {
        if ($scope.onNavClick) {
          var obj = $scope.onNavClick({
            event: $event,
            item: item
          });
          !obj || "object" != _typeof(obj) && "function" != typeof obj || "function" != typeof obj.then ? !1 === obj ? $event.preventDefault() : $scope.ngModel = item : obj.then(function () {
            $scope.ngModel = item;
          }, function () {
            $event.preventDefault();
          });
        } else $scope.ngModel = item;
      }, $scope.onCommandItemClick = function ($event, command) {
        $scope.onCommandClick && !1 === $scope.onCommandClick({
          event: $event,
          command: command
        }) && $event.preventDefault();
      }, $scope.onSearchClick = function ($event) {
        $scope.onSearchOpen && !1 === $scope.onSearchOpen({
          event: $event
        }) ? $event.preventDefault() : $scope.searchOpen = !0;
      }, $scope.onCloseSearch = function ($event) {
        if ($scope.onSearchClose && !1 === $scope.onSearchClose({
          event: $event
        })) $event.preventDefault();else if ($scope.searchOpen = !1, $scope.options.searchSref && $scope.ngModel) for (var i = 0; i < $scope.items.length; i++) {
          var item = $scope.items[i];

          if (item.value === $scope.ngModel.value) {
            item.sref && $state.go(item.sref);
            break;
          }
        }
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiInfoLabel", function () {
  return {
    restrict: "E",
    templateUrl: "component-info-label/info-label.template",
    scope: {
      label: "=",
      tooltip: "=",
      options: "="
    },
    link: function link(scope, element) {
      scope.isOpen = !1, scope.onMouseOver = function () {
        var el = element.find(".info-label")[0];
        el.offsetWidth < el.scrollWidth ? scope.tooltip || scope.options && scope.options.tooltipTemplate || (scope.labelTooltip = scope.label) : scope.labelTooltip = null;
      };
    }
  };
}), window.angular.module("core.ui").directive("asuiInput", function () {
  return {
    restrict: "E",
    scope: {
      id: "@",
      type: "@",
      ngModel: "=?",
      placeholder: "@"
    },
    templateUrl: "component-input/input.template",
    link: function link(scope, element) {
      var before;
      $(element).on("focus", function () {
        before = $(this).html();
      }).on("blur keyup paste", function () {
        before != $(this).html() && $(this).trigger("change");
      }), $(element).on("change", function () {
        scope.ngModel = $(this).text().trim(), scope.$apply();
      });
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      $scope.toggleCheckbox = function () {
        $scope.ngModel = !$scope.ngModel;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiInputValidator", function () {
  return {
    restrict: "EA",
    scope: {
      validator: "&",
      iconPlacement: "@",
      validationState: "=?"
    },
    templateUrl: "component-input-validator/input-validator.template",
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.removeEvents(), scope.removeSpinner(), scope.stopPlacementTracking();
      }), scope.addEvents(), scope.addSpinner(), scope.trackPlacement();
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      var checkT = null,
          delay = .6,
          validationCount = 0,
          State = {
        EMPTY: "EMPTY",
        VALIDATING: "VALIDATING",
        VALID: "VALID",
        ERROR: "ERROR"
      },
          ValidatorCSS = {
        INITIAL: "asui-input-validator-icon",
        VALIDATING: "spinner",
        VALID: "icon icon-check asui-input-validator-icon-valid",
        ERROR: "icon icon-cross asui-input-validator-icon-error"
      },
          placementInterval = null,
          spinner = $("<div class='" + ValidatorCSS.INITIAL + "'></div>");

      function updatePlacement() {
        var pos = $($element).position(),
            width = $($element).outerWidth(!1),
            height = $($element).outerHeight(!1);

        switch ($scope.iconPlacement) {
          case "outer-left":
            spinner.css({
              top: pos.top,
              left: -height,
              height: height,
              width: height
            });
            break;

          case "inner-left":
            spinner.css({
              top: pos.top,
              left: 0,
              height: height,
              width: height
            });
            break;

          case "outer-right":
            spinner.css({
              top: pos.top,
              left: pos.left + width,
              height: height,
              width: height
            });
            break;

          default:
            spinner.css({
              top: pos.top,
              left: pos.left + width - height,
              height: height,
              width: height
            });
        }
      }

      function onFocus() {
        "" == $($element).val() && ($scope.validationState = State.EMPTY);
      }

      function onEnter(e) {
        13 == e.keyCode && ($timeout.cancel(checkT), validateInput($($element).val()));
      }

      function onInput(e) {
        $timeout.cancel(checkT), checkT = null, checkT = $timeout(function () {
          validateInput($element.val());
        }, 1e3 * delay);
      }

      function validateInput(value) {
        if ($scope.validator) {
          if ("" != value) {
            if (validationCount++, $scope.validator) {
              spinner.empty(), spinner.append("<div class='" + ValidatorCSS.VALIDATING + "'> </div>"), $scope.validationState = State.VALIDATING, spinner.css("display", "flex");
              var currentCount = validationCount;
              $scope.validator({
                value: value
              }).then(function (data) {
                currentCount == validationCount && ($scope.validationState = State.VALID, spinner.empty(), spinner.append("<div class='" + ValidatorCSS.VALID + "'> </div>"));
              }, function (err) {
                currentCount == validationCount && ($scope.validationState = State.ERROR, spinner.empty(), spinner.append("<div class='" + ValidatorCSS.ERROR + "'> </div>"));
              });
            } else $scope.validationState = State.VALID;
          } else spinner.empty();
        } else $scope.validationState = State.VALID;
      }

      $scope.validationState = State.EMPTY, $scope.addSpinner = function () {
        $element.addClass("asui-input-validator").after(spinner);
      }, $scope.removeSpinner = function () {
        spinner.remove();
      }, $scope.addEvents = function () {
        $($element).on("focus", onFocus), $($element).on("keyup paste", onInput), $($element).on("keypress", onEnter);
      }, $scope.trackPlacement = function () {
        updatePlacement(), placementInterval = setInterval(updatePlacement, 100);
      }, $scope.stopPlacementTracking = function () {
        clearInterval(placementInterval);
      }, $scope.removeEvents = function () {
        $($element).off("focus", onFocus).off("keyup paste", onInput).off("keypress", onEnter);
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiJsonToExcel", function () {
  return {
    restrict: "AE",
    scope: {
      filename: "@",
      data: "=",
      options: "=",
      onComplete: "&",
      onError: "&"
    },
    link: function link(scope, element) {
      function generateExcelFile(data) {
        var ws = XLSX.utils.json_to_sheet(data);

        for (var key in ws) {
          var cell = ws[key];
          "s" == cell.t && (cell.t = "t");
        }

        var wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, scope.filename), XLSX.writeFile(wb, scope.filename + ".xlsx"), fireOnComplete();
      }

      function fireOnComplete() {
        scope.onComplete && scope.onComplete();
      }

      scope.filename = scope.filename ? "export-excel" : scope.filename, element.bind("click", function () {
        scope.options && scope.options.retrieveItemsAsync ? scope.options.retrieveItemsAsync().then(function (data) {
          generateExcelFile(data), fireOnComplete();
        }, function (err) {
          scope.processing = !1, scope.onError && scope.onError({
            error: err
          });
        }) : scope.data && generateExcelFile(scope.data);
      });
    }
  };
}), window.angular.module("core.ui").directive("asuiLoadingMask", function () {
  return {
    restrict: "EA",
    templateUrl: "component-loadingmask/loadingmask.template",
    scope: {
      show: "=?",
      type: "@",
      message: "@"
    },
    link: function link(scope, element) {
      void 0 === scope.show && (scope.show = !0);
    }
  };
}), window.angular.module("core.ui").component("asuiModalConfirmation", {
  templateUrl: "component-modal/modal-confirmation.template",
  bindings: {
    resolve: "<",
    close: "&",
    dismiss: "&"
  },
  controller: function controller() {
    var $ctrl = this;
    $ctrl.$onInit = function () {
      $ctrl.title = $ctrl.resolve.title, $ctrl.content = $ctrl.resolve.content, $ctrl.contentTemplate = $ctrl.resolve.contentTemplate, $ctrl.contentTemplateUrl = $ctrl.resolve.contentTemplateUrl, $ctrl.confirmLabel = $ctrl.resolve.confirmLabel;
    }, $ctrl.ok = function () {
      $ctrl.close();
    }, $ctrl.cancel = function () {
      $ctrl.dismiss({
        $value: "cancel"
      });
    };
  }
}), window.angular.module("core.ui").component("asuiModalCustom", {
  templateUrl: "component-modal/modal-custom.template",
  bindings: {
    resolve: "<",
    close: "&",
    dismiss: "&"
  },
  controller: function controller() {
    var $ctrl = this;
    $ctrl.text = "Sample custom modal controller", $ctrl.placeholder = "I am a text placeholder", $ctrl.textarea = "I am a text area", $ctrl.$onInit = function () {}, $ctrl.ok = function () {
      $ctrl.close();
    }, $ctrl.cancel = function () {
      $ctrl.dismiss({
        $value: "cancel"
      });
    };
  }
}), window.angular.module("core.ui").component("modalErrorComponent", {
  templateUrl: "component-modal/modal-error.template",
  bindings: {
    resolve: "<",
    close: "&",
    dismiss: "&"
  },
  controller: function controller() {
    var $ctrl = this;
    $ctrl.$onInit = function () {
      $ctrl.title = $ctrl.resolve.title, $ctrl.content = $ctrl.resolve.content, $ctrl.contentTemplate = $ctrl.resolve.contentTemplate, $ctrl.contentTemplateUrl = $ctrl.resolve.contentTemplateUrl;
    }, $ctrl.ok = function () {
      $ctrl.close();
    };
  }
}), window.angular.module("core.ui").component("modalNotificationComponent", {
  templateUrl: "component-modal/modal-notification.template",
  bindings: {
    resolve: "<",
    close: "&",
    dismiss: "&"
  },
  controller: function controller() {
    var $ctrl = this;
    $ctrl.$onInit = function () {
      $ctrl.title = $ctrl.resolve.title, $ctrl.content = $ctrl.resolve.content, $ctrl.contentTemplate = $ctrl.resolve.contentTemplate, $ctrl.contentTemplateUrl = $ctrl.resolve.contentTemplateUrl;
    }, $ctrl.ok = function () {
      $ctrl.close();
    };
  }
}), function ($angular) {
  function modalService($uibModal, $uibModalStack) {
    return {
      openError: function openError(options) {
        return options || (options = {}), !0 === options.closeOnOutsideClick && (options.backdrop = "static"), $uibModal.open({
          component: "modalErrorComponent",
          size: "md",
          backdrop: options.backdrop,
          resolve: {
            title: function title() {
              return options.title || "Error!";
            },
            content: function content() {
              return options.content || "Looks like we encountered an error. Please refresh your browser to continue.";
            },
            contentTemplate: function contentTemplate() {
              return options.contentTemplate;
            },
            contentTemplateUrl: function contentTemplateUrl() {
              return options.contentTemplateUrl;
            }
          }
        }).result;
      },
      openNotification: function openNotification(options) {
        return options || (options = {}), $uibModal.open({
          component: "modalNotificationComponent",
          size: "md",
          backdrop: "static",
          resolve: {
            title: function title() {
              return options.title;
            },
            content: function content() {
              return options.content;
            },
            contentTemplate: function contentTemplate() {
              return options.contentTemplate;
            },
            contentTemplateUrl: function contentTemplateUrl() {
              return options.contentTemplateUrl;
            }
          }
        }).result;
      },
      openConfirmation: function openConfirmation(options) {
        return options || (options = {}), $uibModal.open({
          component: "asuiModalConfirmation",
          size: "md",
          backdrop: "static",
          resolve: {
            title: function title() {
              return options.title || "Confirmation";
            },
            content: function content() {
              return options.content || "Are you sure you want to continue?";
            },
            contentTemplate: function contentTemplate() {
              return options.contentTemplate;
            },
            contentTemplateUrl: function contentTemplateUrl() {
              return options.contentTemplateUrl;
            },
            confirmLabel: function confirmLabel() {
              return options.confirmLabel || "OK";
            }
          }
        }).result;
      },
      openCustom: function openCustom(options) {
        return options || (options = {}), void 0 === options.backdrop && (options.backdrop = "static"), $uibModal.open(options).result;
      },
      dismissAll: function dismissAll(reason) {
        $uibModalStack.dismissAll(reason || "Dismiss all modals was called.");
      }
    };
  }

  window.angular.module("core.ui").factory("modalService", modalService), modalService.$inject = ["$uibModal", "$uibModalStack"];
}(), window.angular.module("core.ui").directive("asuiMultiselect", function () {
  return {
    restrict: "EA",
    templateUrl: "component-multiselect/multiselect.template",
    scope: {
      items: "=",
      placeholder: "@",
      validation: "=?",
      options: "=?",
      ngModel: "=",
      onChange: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watchCollection("items", scope.onItemsChange), scope.$watch("options", scope.onOptionsUpdate, !0), scope.$watch("ngModel", scope.onModelUpdate, !0);
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      var selectElem = null;

      function initPicker() {
        $scope.options && $scope.options.maxSelection && $scope.options.maxSelection > 0 && $scope.ngModel && $scope.ngModel.length > $scope.options.maxSelection && $scope.ngModel.splice($scope.options.maxSelection), (selectElem = $($element.find("select"))).selectpicker("destroy");
        var htmlArray = [],
            optGroups = {};

        for (var key in $scope.items.forEach(function (item) {
          optGroups[item.optgroup] ? optGroups[item.optgroup].push(item) : optGroups[item.optgroup] = [item];
        }), optGroups) {
          var group = optGroups[key];
          "undefined" != key && htmlArray.push('<optgroup label="' + key + '">'), group.forEach(function (item) {
            htmlArray.push('<option value="'), htmlArray.push(item.value), htmlArray.push('"'), item.icon && htmlArray.push(' data-content="' + (item.icon ? item.icon + " " : "") + item.label + '"'), !0 === item.disabled && htmlArray.push(" disabled "), htmlArray.push(">"), htmlArray.push(item.label), htmlArray.push("</option>");
          }), "undefined" != key && htmlArray.push("</optgroup>");
        }

        var html = htmlArray.join("");
        selectElem.html(html), selectElem.selectpicker($scope.options ? $scope.options : {}), void 0 !== $scope.ngModel && null !== $scope.ngModel && "" !== $scope.ngModel && selectElem.selectpicker("val", $scope.ngModel);
      }

      $scope.destroy = function () {
        selectElem && (selectElem.selectpicker("destroy"), selectElem = null);
      }, $scope.onItemsChange = function () {
        initPicker();
      }, $scope.onOptionsUpdate = function () {
        $scope.options && null != $scope.options.disabled && selectElem.prop("disabled", $scope.options.disabled);
      }, $scope.onModelUpdate = function () {
        selectElem && selectElem.selectpicker("refresh");
      }, $scope.onSelectChange = function () {
        $scope.error = null, $scope.validation && $scope.validation.required && ($scope.ngModel && 0 !== $scope.ngModel.length || ($scope.error = "This field is required")), $scope.onChange && $scope.onChange({
          value: $scope.ngModel
        });
      };
    }]
  };
}), window.angular.module("core.ui").component("asuiPhoneNumber", {
  bindings: {
    options: "<",
    ngModel: "<",
    ngDisabled: "<",
    onLoad: "&",
    onChange: "&"
  },
  transclude: !0,
  templateUrl: "component-phone-number/phone-number.template",
  controller: function controller($element, $scope, $timeout) {
    var $ctrl = this,
        errorMap = ["Invalid number", "Invalid country code", "Too short", "Too long", "Invalid number"],
        input = null,
        iti = null;

    function onKeypress(e) {
      var charCode = (e = e || window.event).which ? e.which : e.keyCode;
      return 13 == charCode ? (validateNumber(), !0) : 43 == charCode ? (resetError(), !0) : charCode > 31 && (charCode < 48 || charCode > 57) ? (e.preventDefault(), !1) : (resetError(), !0);
    }

    function resetError() {
      input.classList.remove("error");
    }

    function validateNumber() {
      resetError();
      var error = null;

      if ($ctrl.ngModel || ($ctrl.ngModel = {}), $ctrl.ngModel.country = iti.getSelectedCountryData(), input.value.trim()) {
        if ($ctrl.ngModel.number = iti.getNumber(), !iti.isValidNumber()) {
          input.classList.add("error");
          var errorCode = iti.getValidationError();
          error = {
            errorCode: errorCode,
            errorMessage: errorMap[errorCode]
          };
        }
      } else $ctrl.ngModel.number = null;

      $timeout(function () {
        $ctrl.onChange({
          value: $ctrl.ngModel,
          error: error
        });
      });
    }

    $ctrl.$onInit = function () {
      (input = $element.find("#phone")[0]).addEventListener("keypress", onKeypress), input.addEventListener("blur", validateNumber);
    }, $ctrl.$onDestroy = function () {
      input.removeEventListener("keypress", onKeypress), input.removeEventListener("blur", validateNumber);
    }, $ctrl.$onChanges = function () {
      $scope.$evalAsync(function () {
        var options = {};
        if ($ctrl.options) for (var key in $ctrl.options) {
          options[key] = $ctrl.options[key];
        }
        input = $element.find("#phone")[0], iti = window.intlTelInput(input, options), $ctrl.ngModel && ($ctrl.ngModel.country && $ctrl.ngModel.country.iso2 && iti.setCountry($ctrl.ngModel.country.iso2), $ctrl.ngModel.number && iti.setNumber($ctrl.ngModel.number)), $ctrl.onLoad({
          input: iti
        });
      });
    };
  }
}), window.angular.module("core.ui").directive("asuiQrcodeScanner", function () {
  return {
    restrict: "E",
    scope: {
      displayOverlay: "=?",
      onCodeScanned: "&"
    },
    templateUrl: "component-qrcode-scanner/qrcode-scannner.template",
    link: function link(scope, element) {
      element.on("$destroy", scope.destroy), scope.init();
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      var video = null,
          canvasElement = null,
          canvas = null,
          mediaStream = null,
          lastCode = null,
          lastVideoTime = -1;

      function drawLine(begin, end, color) {
        canvas.beginPath(), canvas.moveTo(begin.x, begin.y), canvas.lineTo(end.x, end.y), canvas.lineWidth = 4, canvas.strokeStyle = color, canvas.stroke();
      }

      function fireCodeScanned() {
        $scope.onCodeScanned({
          code: lastCode
        });
      }

      function getNextFrame() {
        1 == $scope.displayOverlay ? requestAnimationFrame(onAnimationTick) : setTimeout(onAnimationTick, 400);
      }

      function loadingComplete() {
        $scope.loading = !1;
      }

      function onAnimationTick() {
        if (video) {
          var time = video.currentTime;

          if (time != lastVideoTime) {
            if (lastVideoTime = time, video.readyState === video.HAVE_ENOUGH_DATA) {
              $scope.loading && $scope.$evalAsync(loadingComplete), canvasElement.height = video.videoHeight, canvasElement.width = video.videoWidth, canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
              var imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height),
                  code = jsQR(imageData.data, imageData.width, imageData.height, {
                inversionAttempts: "dontInvert"
              });
              code && ($scope.onCodeScanned && lastCode != code.data && (lastCode = code.data, $scope.$evalAsync(fireCodeScanned)), 1 == $scope.displayOverlay) && (drawLine(code.location.topLeftCorner, code.location.topRightCorner, "#1D7BE3"), drawLine(code.location.topRightCorner, code.location.bottomRightCorner, "#1D7BE3"), drawLine(code.location.bottomRightCorner, code.location.bottomLeftCorner, "#1D7BE3"), drawLine(code.location.bottomLeftCorner, code.location.topLeftCorner, "#1D7BE3"));
            }

            getNextFrame();
          } else getNextFrame();
        }
      }

      $scope.destroy = function () {
        mediaStream && (mediaStream.getTracks().forEach(function (track) {
          track.stop();
        }), mediaStream = null), video && (video.pause(), video.removeAttribute("src"), video.load(), video = null);
      }, $scope.init = function () {
        video = $element.find("video")[0], canvasElement = $element.find("canvas")[0], canvas = canvasElement.getContext("2d", {
          alpha: !1
        }), $scope.beginScan();
      }, $scope.toggleCheckbox = function () {
        $scope.ngModel = !$scope.ngModel;
      }, $scope.beginScan = function () {
        if (!navigator || !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return $scope.errorIcon = "icon-alert", void ($scope.error = "Your browser does not support webcam access, please use a supported browser such as Chrome, Edge, Safari or Firefox.");
        $scope.loading = !0, navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "environment"
          }
        }).then(function (stream) {
          mediaStream = stream, video.srcObject = stream, video.setAttribute("playsinline", !0), video.play(), getNextFrame();
        }, function (err) {
          $scope.$evalAsync(function () {
            loadingComplete(), $scope.errorIcon = "icon-lock", $scope.error = "We were unable to open your webcam, please check your browser security settings and allow access.";
          }), console.log(err);
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiRadio", function () {
  return {
    restrict: "EA",
    templateUrl: "component-radio/radio.template",
    scope: {
      id: "@",
      name: "@",
      items: "=",
      options: "=?",
      disabled: "=?",
      ngModel: "=",
      onClick: "&",
      onChange: "&"
    },
    controller: ["$scope", function ($scope) {
      $scope.onRadioChange = function (event) {
        $scope.onClick({
          value: event.item.value
        }), $scope.onChange({
          value: event.item.value
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiRangeSlider", function () {
  return {
    restrict: "E",
    templateUrl: "component-range-slider/range-slider.template",
    scope: {
      min: "@",
      max: "@",
      ngModel: "=",
      onChange: "&"
    },
    link: function link(scope) {
      scope.$watch("min", scope.onMinUpdate, !0), scope.$watch("max", scope.onMaxUpdate, !0), scope.init();
    },
    controller: ["$scope", "$timeout", function ($scope, $timeout) {
      $scope.minRange = 1, $scope.maxRange = 100, $scope.init = function () {}, $scope.onMinUpdate = function () {
        $timeout(function () {
          $scope.minRange = $scope.min;
        });
      }, $scope.onMaxUpdate = function () {
        $timeout(function () {
          $scope.maxRange = $scope.max;
        });
      }, $scope.onSliderChange = function () {
        $scope.onChange && $scope.onChange({
          value: $scope.ngModel
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiRichText", function () {
  return {
    restrict: "EA",
    templateUrl: "component-richtext/richtext.template",
    scope: {
      id: "@",
      label: "@",
      placeholder: "@",
      options: "=?",
      validation: "=?",
      ngModel: "=",
      onChange: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", scope.onDestroy), scope.$watch("options", scope.onOptionsUpdate, !0), scope.$watch("ngModel.html", scope.onHtmlUpdate, !0), scope.$watch("ngModel.css", scope.onCssUpdate, !0), scope.init();
    },
    controller: ["$scope", "$element", "$timeout", "AsComponentUtil", function ($scope, $element, $timeout, AsComponentUtil) {
      var componentUtil = new AsComponentUtil(),
          textboxEl = null,
          toolboxEl = null,
          showToolbox = !1,
          fontColorEl = null,
          bgColorEl = null,
          bgContainerColorEl = null,
          prevFontColor = {
        hex: null,
        alpha: 0
      },
          prevBgColor = {
        hex: null,
        alpha: 0
      },
          prevBgContainerColor = {
        hex: null,
        alpha: 0
      },
          bgContainerColor = null,
          defaultFontCssText = "",
          style = null;

      function destroyEditor() {
        bgColorEl && (bgColorEl.spectrum("destroy"), bgColorEl.remove(), bgColorEl = null), bgContainerColorEl && (bgContainerColorEl.spectrum("destroy"), bgContainerColorEl.remove(), bgContainerColorEl = null), fontColorEl && (fontColorEl.spectrum("destroy"), fontColorEl.remove(), fontColorEl = null), textboxEl.data("froala.editor") && (textboxEl.off("froalaEditor.contentChanged", fireOnChangeEventNative), $element.unbind("click"), textboxEl.froalaEditor("destroy"));
      }

      function initStyleEditor() {
        if (0 != (textboxEl = $($element).find("textarea")).length) {
          destroyEditor();
          var froalaSettings = {
            charCounterCount: !1,
            quickInsertButtons: !1,
            placeholderText: $scope.placeholder,
            lineHeights: {
              Normal: "",
              .85: ".85",
              "0.90": ".90",
              .95: ".95",
              Single: "1",
              1.15: "1.15",
              1.5: "1.5",
              Double: "2",
              2.5: "2.5",
              "3.0": "3"
            },
            paragraphFormat: {
              H1: "Title",
              H2: "Subtitle",
              H3: "Heading 3",
              H4: "Heading 4",
              P: "Paragraph",
              PRE: "Code"
            },
            paragraphFormatDefaultSelection: "Paragraph",
            paragraphFormatSelection: !0
          };

          if ($scope.options.customFroalaSettings) {
            var customSettings = $scope.options.customFroalaSettings;

            for (var key in customSettings) {
              froalaSettings[key] = customSettings[key];
            }
          }

          if ($scope.options.style) {
            var style = $scope.options.style;

            if (style.size && style.size.length > 0 && (froalaSettings.fontSize = style.size), style.fontFamily && style.fontFamily.length > 0) {
              froalaSettings.fontFamily = {};

              for (var i = 0; i < style.fontFamily.length; i++) {
                var f = style.fontFamily[i];
                froalaSettings.fontFamily[f] = f;
              }
            }
          }

          var toolbarButtons = initToolbarButtons();
          toolbarButtons && toolbarButtons.length > 0 && (froalaSettings.toolbarButtons = toolbarButtons, froalaSettings.toolbarButtonsSM = toolbarButtons, froalaSettings.toolbarButtonsMD = toolbarButtons, froalaSettings.toolbarButtonsXS = toolbarButtons), froalaSettings.tableEditButtons = ["tableHeader", "tableRemove", "|", "tableRows", "tableColumns", "-", "tableCells", "tableCellBackground", "tableCellVerticalAlign", "tableCellHorizontalAlign"], $scope.isSticky() || (froalaSettings.toolbarContainer = "#" + $scope.toolboxId), textboxEl.froalaEditor(froalaSettings), $scope.ngModel && getDefaultFontStyle(), $element.click(function () {
            toggleToolbox(!0);
          }), textboxEl.on("froalaEditor.contentChanged", fireOnChangeEventNative), $scope.ngModel && $scope.ngModel.html && textboxEl.froalaEditor("html.set", $scope.ngModel.html), toggleGrayscale(!0);
        }
      }

      function initToolbarButtons() {
        var buttons = null,
            insertDivider = !1;
        return $scope.options && (style = $scope.options.style) && !jQuery.isEmptyObject(style) && (buttons = [], style.print && (buttons.push("print"), insertDivider = !0), style.clearFormatting && (buttons.push("clearFormatting"), insertDivider = !0), insertDivider && buttons.push("|"), style.font && !0 === style.font && (buttons.push("fontFamily"), insertDivider = !0), style.size && (buttons.push("fontSize"), insertDivider = !0), insertDivider && buttons.push("|"), style.decorations && !0 === style.decorations && (buttons.push("bold"), buttons.push("italic"), buttons.push("underline"), buttons.push("|")), insertDivider = !1, style.paragraphFormat && !0 === style.paragraphFormat && (buttons.push("|"), buttons.push("paragraphFormat"), buttons.push("|")), style.paragraphStyle && !0 === style.paragraphStyle && (buttons.push("paragraphStyle"), insertDivider = !0), style.lineHeight && !0 === style.lineHeight && (buttons.push("lineHeight"), insertDivider = !0), style.quote && !0 === style.quote && (buttons.push("quote"), insertDivider = !0), style.alignment && !0 === style.alignment && (buttons.push("align"), insertDivider = !0), style.list && !0 === style.list && (buttons.push("formatOL"), buttons.push("formatUL"), insertDivider = !0), style.outdent && !0 === style.outdent && (buttons.push("outdent"), buttons.push("outdent"), insertDivider = !0), style.indent && !0 === style.indent && (buttons.push("indent"), buttons.push("indent"), insertDivider = !0), insertDivider && buttons.push("|"), style.specialCharacters && (buttons.push("specialCharacters"), insertDivider = !0), insertDivider = !1, style.color && !0 === style.color && (void 0 === $.FroalaEditor.COMMANDS.fontcolor && ($.FroalaEditor.DefineIconTemplate("fontColorIconTemplate", '<i class="gy glyphicon icon icon-text-color"></i>'), $.FroalaEditor.DefineIcon("fontColorIcon", {
          NAME: "font-color",
          template: "fontColorIconTemplate"
        }), $.FroalaEditor.RegisterCommand("fontcolor", {
          title: "Font Color",
          icon: "fontColorIcon",
          undo: !1,
          focus: !0,
          refreshAfterCallback: !1,
          callback: function callback() {}
        })), $scope.$evalAsync(function () {
          !function () {
            null === fontColorEl && (fontColorEl = $($element.find("[data-cmd='fontcolor']")));
            var initialColor = null;
            style && style.color && (initialColor = style.color);
            var colorSettings = componentUtil.getColorPickerSettings(initialColor);
            colorSettings.showAlpha = !1, colorSettings.allowEmpty = !1, fontColorEl.spectrum(colorSettings), fontColorEl.on("move.spectrum", onFontColorMove), fontColorEl.on("change.spectrum", onFontColorChange), fontColorEl.on("hide.spectrum", onFontColorChange), fontColorEl.on("show.spectrum", function () {
              var el = textboxEl.froalaEditor("selection.element"),
                  color = $(el).css("color");
              fontColorEl.spectrum("set", color), textboxEl.froalaEditor("selection.save");
            });
          }();
        }), buttons.push("fontcolor"), insertDivider = !0), style.backgroundColor && !0 === style.backgroundColor && (void 0 === $.FroalaEditor.COMMANDS.bgcolor && ($.FroalaEditor.DefineIconTemplate("bgcolorTemplate", '<i class="icon icon-[NAME]"></i>'), $.FroalaEditor.DefineIcon("bgColorIcon", {
          NAME: "background-color",
          template: "bgcolorTemplate"
        }), $.FroalaEditor.RegisterCommand("bgcolor", {
          title: "Background Color",
          icon: "bgColorIcon",
          undo: !1,
          focus: !0,
          refreshAfterCallback: !1,
          callback: function callback() {}
        })), $scope.$evalAsync(function () {
          !function () {
            null === bgColorEl && (bgColorEl = $($element.find("[data-cmd='bgcolor']")));
            var initialColor = null;
            style && style.backgroundColor && (initialColor = style.backgroundColor);
            var colorSettings = componentUtil.getColorPickerSettings(initialColor);
            colorSettings.showAlpha = !1, colorSettings.allowEmpty = !0, bgColorEl.spectrum(colorSettings), bgColorEl.on("move.spectrum", onBgColorMove), bgColorEl.on("change.spectrum", onBgColorOk), bgColorEl.on("hide.spectrum", onBgColorHide), bgColorEl.on("show.spectrum", function () {
              var el = textboxEl.froalaEditor("selection.element"),
                  color = $(el)[0].style["background-color"];

              if (prevBgColor = color, -1 == color.indexOf("rgba")) {
                var opacity = $(el).css("opacity");
                color = color.replace(")", ", " + opacity + ")").replace("rgb", "rgba");
              }

              bgColorEl.spectrum("set", color);
            });
          }();
        }), buttons.push("bgcolor"), insertDivider = !0), style.containerColor && !0 === style.containerColor && (void 0 === $.FroalaEditor.COMMANDS.bgcontainercolor && ($.FroalaEditor.DefineIcon("bgContainerColorIcon", {
          NAME: "tint"
        }), $.FroalaEditor.RegisterCommand("bgcontainercolor", {
          title: "Background Container Color",
          icon: "bgContainerColorIcon",
          undo: !1,
          focus: !0,
          refreshAfterCallback: !1,
          callback: function callback() {}
        })), $scope.$evalAsync(function () {
          !function () {
            null === bgContainerColorEl && (bgContainerColorEl = $($element.find("[data-cmd='bgcontainercolor']")));
            var initialColor = null;
            $scope.ngModel && $scope.ngModel.css && $scope.ngModel.css["background-color"] && (bgContainerColor = initialColor = $scope.ngModel.css["background-color"]), bgContainerColorEl.spectrum(componentUtil.getColorPickerSettings(initialColor)), bgContainerColorEl.on("move.spectrum", onBgContainerColorMove), bgContainerColorEl.on("change.spectrum", onBgContainerColorChange), bgContainerColorEl.on("hide.spectrum", onBgContainerColorChange);
          }();
        }), buttons.push("bgcontainercolor"), insertDivider = !0), insertDivider && buttons.push("|"), insertDivider = !1, style.insertLink && !0 === style.insertLink && (buttons.push("insertLink"), insertDivider = !0), style.insertTable && !0 === style.insertTable && (buttons.push("insertTable"), insertDivider = !0), style.insertLink && buttons.push("insertLink"), buttons.push("html"), style.fullscreen && buttons.push("fullscreen")), buttons;
      }

      function onFontColorMove(e, color) {
        prevFontColor = componentUtil.resetColorPickerAlpha(fontColorEl, color, prevFontColor), onFontColorChange(0, color);
      }

      function onFontColorChange(e, tinycolor) {
        var color = "";
        tinycolor && (color = tinycolor.toHexString(), tinycolor.getAlpha());

        try {
          textboxEl.froalaEditor("selection.save"), textboxEl.froalaEditor("colors.text", color);
        } catch (ex) {}

        fireOnChangeEventNative();
      }

      function onBgColorOk(e, color) {
        $(e.currentTarget).data("changed", !0), onBgColorChange(0, color);
      }

      function onBgColorHide(e, color) {
        $(e.currentTarget).data("changed") || (prevBgColor = prevBgColor && prevBgColor.length > 0 ? tinycolor(prevBgColor).toHexString() : "", textboxEl.froalaEditor("colors.background", prevBgColor), fireOnChangeEventNative());
      }

      function onBgColorMove(e, color) {
        onBgColorChange(0, color);
      }

      function onBgColorChange(e, tinycolor) {
        var color = "",
            alpha = 1;
        tinycolor && (color = tinycolor.toHexString(), alpha = tinycolor.getAlpha()), 0 !== alpha && "#000000" !== color || (color = "");

        try {
          textboxEl.froalaEditor("selection.restore"), textboxEl.froalaEditor("colors.background", color);
        } catch (ex) {}

        fireOnChangeEventNative();
      }

      function onBgContainerColorMove(e, color) {
        prevBgContainerColor = componentUtil.resetColorPickerAlpha(bgContainerColorEl, color, prevBgContainerColor), onBgContainerColorChange(0, color);
      }

      function onBgContainerColorChange(e, tinycolor) {
        var color = "";
        tinycolor && (color = tinycolor.toRgbString()), bgContainerColor = color, fireOnChangeEventNative();
      }

      function onDocumentMouseUp(e) {
        var colorPicker = $(".sp-container"),
            focused = document.activeElement;
        !showToolbox || $element.is(e.target) || 0 !== $element.has(e.target).length || 0 !== $element.has(focused).length || colorPicker.is(e.target) || 0 !== colorPicker.has(e.target).length || toggleToolbox(!1);
      }

      function toggleToolbox(show) {
        if ($scope.options.style && $scope.options.style.locked && (show = !1), null === show) showToolbox = !showToolbox;else {
          if (show == showToolbox) return;
          showToolbox = show;
        }
        toolboxEl || (toolboxEl = $($element.find(".style-toolbar"))), toolboxEl.velocity("stop"), showToolbox ? (toolboxEl.velocity("fadeIn", {
          duration: 200,
          display: ""
        }), toggleGrayscale(!1)) : (toolboxEl.velocity("fadeOut", {
          duration: 200,
          display: "none"
        }), toggleGrayscale(!0));
      }

      function toggleGrayscale(showGrayscale) {
        if ($scope.options && (!0 === $scope.options.desaturateOnBlur || void 0 === $scope.options.desaturateOnBlur)) {
          var textbox = $($element.find(".fr-element"));
          showGrayscale ? textbox.addClass("grayscale") : textbox.removeClass("grayscale");
        }
      }

      function getDefaultFontStyle() {
        for (var currentNode = textboxEl.froalaEditor("selection.element"); currentNode && currentNode.childNodes.length > 0;) {
          currentNode = currentNode.childNodes[0];
        }

        var cssText = function (node) {
          var cssText = "";
          if (node) for (var foundRoot = !1; !foundRoot;) {
            switch (node.style && (cssText += node.style.cssText + " "), node.tagName) {
              case "STRONG":
                cssText += "font-weight: bold;";
                break;

              case "EM":
                cssText += "font-style: italic;";
                break;

              case "U":
                cssText += "text-decoration: underline;";
            }

            if (node && node.classList) for (var i = 0; i < node.classList.length; i++) {
              if ("fr-element" == node.classList[i]) {
                foundRoot = !0;
                break;
              }
            }
            node = node.parentNode;
          }
          return cssText;
        }(currentNode);

        return cssText && cssText.includes(";") && (defaultFontCssText = cssText), cssText;
      }

      function fireOnChangeEventNative() {
        $timeout(fireOnChangeEvent);
      }

      function fireOnChangeEvent() {
        $scope.isDirty = !0;
        var customstyle = {},
            html = textboxEl.froalaEditor("html.get", !1),
            text = (text = (text = (text = html.split("</p>").join("\n").split("<p>").join("")).split("</h1>").join("\n").split("<h1>").join("")).split("</h2>").join("\n").split("<h2>").join("")).split("</h3>").join("\n").split("<h3>").join("");
        (text = $("<span>" + text + "</span>").text()).lastIndexOf("\n") == text.length - 1 && (text = text.slice(0, text.length - 1)), $scope.requiredValid = function (text) {
          var valid = !0;
          return $scope.id && $scope.validation && $scope.validation.required && (text && 0 !== text.length || (valid = !1)), valid;
        }(text);
        var updateDefaultStyle = !0;
        if ($scope.options && $scope.options.style && $scope.options.style.locked && (updateDefaultStyle = !1), updateDefaultStyle) getDefaultFontStyle();else if (defaultFontCssText && defaultFontCssText.length > 0) {
          var defaultCssClass = function (cssText) {
            var cssClass = {};
            if (cssText && cssText.length) for (var styles = cssText.split(";"), i = 0; i < styles.length; i++) {
              var s = styles[i].split(":");

              if (2 == s.length) {
                var key = s[0],
                    val = s[1].trim();
                cssClass[key] = val;
              }
            }
            return cssClass;
          }(defaultFontCssText),
              pFormatting = "";

          for (var key in defaultCssClass) {
            var value = defaultCssClass[key];
            pFormatting += key + ":" + (value = value.split('"').join("'")) + ";";
          }

          if (html.indexOf('<div class="customstyle" style="') >= 0) {
            var startIndex = html.indexOf('">') + 2,
                endIndex = html.length - "</div>".length;
            html = html.substring(startIndex, endIndex);
          }

          -1 == html.indexOf("style=") && (html = '<div class="customstyle" style="' + pFormatting + '">' + html + "</div>");
        }
        if (style.customcss) for (var k in style.customcss) {
          customstyle[k] = style.customcss[k];
        }

        if (customstyle["background-color"] = bgContainerColor, $scope.lengthValid = function (text) {
          var minlengthValid = !0,
              maxlengthValid = !0;
          return $scope.id && $scope.validation && ($scope.validation.minlength > 0 && (!text || text.length < $scope.validation.minlength) && (minlengthValid = !1), $scope.validation.maxlength > 0 && text && text.length > $scope.validation.maxlength && (maxlengthValid = !1)), minlengthValid && maxlengthValid;
        }(text), $scope.requiredValid && $scope.lengthValid && $scope.onChange) {
          var val = {
            html: html,
            text: text,
            css: customstyle
          };
          $scope.ngModel = val, $scope.onChange && $scope.onChange({
            value: val
          });
        }
      }

      $scope.toolboxId = null, $scope.isDirty = !1, angular.element(document).bind("mouseup", onDocumentMouseUp), $scope.init = function () {
        $scope.toolboxId = "toolbox_" + componentUtil.generateGuid(), $scope.validation && $scope.validation.maxlength && $scope.validation.maxlength > 0 && $scope.ngModel && $scope.ngModel.length > $scope.validation.maxlength && ($scope.ngModel = $scope.ngModel.substring(0, $scope.validation.maxlength)), initStyleEditor();
      }, $scope.onDestroy = function () {
        destroyEditor(), angular.element(document).unbind("mouseup", onDocumentMouseUp);
      }, $scope.isSticky = function () {
        return !(!$scope.options || !0 !== $scope.options.sticky);
      }, $scope.onHtmlUpdate = function (newVal) {
        textboxEl && textboxEl.froalaEditor("html.get") != newVal && textboxEl.froalaEditor("html.set", newVal);
      }, $scope.onCssUpdate = function (newVal) {
        newVal && (bgContainerColor = newVal["background-color"] ? newVal["background-color"] : newVal.backgroundcolor);
      }, $scope.onOptionsUpdate = function (newVal) {
        newVal && newVal.style && initStyleEditor();
      };
    }]
  };
}), function ($angular) {
  var angular = window.angular;
  angular.module("core.ui").component("asuiScheduleTable", {
    bindings: {
      options: "<",
      onApiReady: "&",
      onItemClick: "&",
      onItemInfoCloseClick: "&",
      onMapToggleClick: "&",
      onItemActionClick: "&",
      onScheduleClick: "&",
      onFreeSlotClick: "&",
      onEndClick: "&",
      onExtendClick: "&",
      onCheckInClick: "&",
      onFilterClick: "&",
      onStatusChanged: "&",
      onItemsRetrieved: "&",
      onItemInfoShowChanged: "&"
    },
    templateUrl: "component-schedule-table/schedule-table.template",
    controller: ["$scope", "$element", "$timeout", "$interval", "$q", "ScheduleBoardThemeUtil", "ScheduleBoardScheduleUtil", function ($scope, $element, $timeout, $interval, $q, ScheduleBoardThemeUtil, ScheduleBoardScheduleUtil) {
      var $ctrl = this,
          retrieveTimeout = null,
          retrieveItemsAsync = null,
          listBlock = null,
          timelineList = null,
          timelineHeader = null,
          resizeTimer = 0,
          updateScheduleStatusTime = 0,
          timelineMoveInProgress = !1,
          lastPassiveScroll = new Date().getTime(),
          tableSize = {
        width: -1,
        height: -1
      };

      function getWaitTimeForScheduleStatusEvent() {
        var wait = 60 - new Date().getSeconds();
        return wait < 1 && (wait = 1), 1e3 * wait;
      }

      function updateScheduleStatus() {
        $scope.$broadcast("sb-update-status"), updateScheduleStatusTime = $timeout(updateScheduleStatus, getWaitTimeForScheduleStatusEvent());
      }

      function onThemeUpdated() {
        $ctrl.options.theme && !jQuery.isEmptyObject($ctrl.options.theme) || ($ctrl.options.theme = {
          timeline: {
            color: "#182449",
            backgroundColor: "white"
          },
          table: {
            borderColor: "#EEF4FA"
          },
          items: {
            backgroundColor: "white"
          }
        }), ScheduleBoardThemeUtil.applyTheme($ctrl.options, $ctrl.elementSizes, $ctrl.readonly);
      }

      function setFilter(filter) {
        switch ($ctrl.filter = filter, $ctrl.filter) {
          case "occupied":
            $ctrl.filterLabel = "Occupied";
            break;

          case "available":
            $ctrl.filterLabel = "Available";
            break;

          case "checkin":
            $ctrl.filterLabel = "Check-in";
            break;

          default:
            $ctrl.filterLabel = "Filter by";
        }

        updateContainerHeight(), updateFilterCount();
      }

      function updateFilterCount() {
        $ctrl.filterCount = 0;

        for (var i = 0; i < $ctrl.items.length; i++) {
          var localItem = $ctrl.items[i];
          $ctrl.filter && $ctrl.filter != localItem.status || $ctrl.filterCount++;
        }
      }

      function onMovement() {
        lastPassiveScroll = new Date().getTime();
      }

      function updateItem(item) {
        $scope.$evalAsync(function () {
          var info = ScheduleBoardScheduleUtil.getScheduleInfo(item, $ctrl.options ? $ctrl.options.timeformat : null);
          item.status = info.status;

          for (var i = 0; i < $ctrl.items.length; i++) {
            if ($ctrl.items[i].id == item.id) {
              $ctrl.items[i] = angular.copy(item), $ctrl.selectedItem && $ctrl.selectedItem.id == item.id && ($ctrl.selectedItem = $ctrl.items[i]);
              break;
            }
          }

          $ctrl.api.mapApi && $ctrl.api.mapApi.onItemUpdate && $ctrl.api.mapApi.onItemUpdate(item), $timeout(function () {
            updateContainerHeight(), updateFilterCount(), onShowMapToggleChange($ctrl.options.showMapToggle);
          }, 100);
        });
      }

      function moveTimeline(adjustmentMS) {
        if (!timelineMoveInProgress) {
          timelineMoveInProgress = !0;
          var currentTime = getCurrentTimeFromScroll();
          scrollToDate(new Date(currentTime.getTime() + adjustmentMS), 500).then(function () {
            $ctrl.options.timeline.start = new Date($ctrl.options.timeline.start.getTime() + adjustmentMS), determineElementSizes(), generateScheduleSlots();
            var scrollAdjust = $ctrl.elementSizes.pixelsPerMs * adjustmentMS;
            timelineList.scrollLeft -= scrollAdjust, $(timelineHeader)[0].scrollLeft -= scrollAdjust, timelineMoveInProgress = !1, $timeout(function () {
              updateContainerHeight(), updateFilterCount();
            }, 100);
          });
        }
      }

      function checkTableState() {
        var width = $element.width(),
            height = $element.height();
        tableSize.width == width && tableSize.height == height || (determineElementSizes(), $ctrl.elementSizes.rowHeight > 0 && $ctrl.elementSizes.slotWidth > 0 && (tableSize.width = width, tableSize.height = height, $ctrl.items = angular.copy($ctrl.items), updateContainerHeight())), function () {
          $ctrl.elementSizes.rowHeight > 0 && $ctrl.elementSizes.slotWidth > 0 && (currentTime = getCurrentTimeFromScroll(), day = moment(currentTime).format("ddd"), $ctrl.currentDate = day);
          var currentTime, day;
          $ctrl.timelineScrollOffset = timelineHeader.scrollLeft;
        }(), function () {
          if ($ctrl.options && !timelineMoveInProgress && !1 !== $ctrl.options.timeline.sync) {
            var ctime = new Date().getTime();
            $ctrl.options.timeline.start.getTime() + 1e3 * $ctrl.options.timeline.interval - ctime <= 0 && moveTimeline(1e3 * $ctrl.options.timeline.interval);
          }
        }(), function () {
          var ctime = new Date().getTime();

          if ($ctrl.options && $ctrl.options.pagingInterval && ctime > lastPassiveScroll + $ctrl.options.pagingInterval) {
            lastPassiveScroll = ctime;

            var cPage = (yScroll = listBlock.scrollTop, itemsPerPage = Math.floor(listBlock.offsetHeight / $ctrl.elementSizes.rowHeight), Math.ceil(yScroll / $ctrl.elementSizes.rowHeight / itemsPerPage)),
                totalPages = function () {
              var itemsPerPage = Math.floor(listBlock.offsetHeight / $ctrl.elementSizes.rowHeight);
              return Math.floor($ctrl.items.length / itemsPerPage);
            }();

            ++cPage > totalPages && (cPage = 0), function (page, duration) {
              var defer = $q.defer();
              void 0 === duration && (duration = 1e3);

              var desiredScroll = function (page) {
                var itemsPerPage = Math.floor(listBlock.offsetHeight / $ctrl.elementSizes.rowHeight);
                return page * itemsPerPage * $ctrl.elementSizes.rowHeight;
              }(page);

              $(listBlock).animate({
                scrollTop: desiredScroll + "px"
              }, duration, function () {
                defer.resolve();
              }), defer.promise;
            }(cPage);
          }

          var yScroll, itemsPerPage;
        }();
      }

      function refresh(resetScroll) {
        determineElementSizes(), $ctrl.updateItemsAsync(), resetScroll && (listBlock.scrollTop = 0, timelineList.scrollLeft = 0);
      }

      function bookEvent(item, slot) {
        item && slot && $ctrl.onFreeSlotClick && $ctrl.onFreeSlotClick({
          item: item,
          slot: slot
        });
      }

      function endEvent(item, schedule) {
        item && schedule && $ctrl.onEndClick && $ctrl.onEndClick({
          item: item,
          schedule: schedule
        });
      }

      function extendEvent(item, schedule) {
        item && schedule && $ctrl.onExtendClick && $ctrl.onExtendClick({
          item: item,
          schedule: schedule
        });
      }

      function checkInEvent(item, schedule) {
        item && schedule && $ctrl.onCheckInClick && $ctrl.onCheckInClick({
          item: item,
          schedule: schedule
        });
      }

      function switchView() {
        $ctrl.onMapToggleClick(), $ctrl.selectedItem = void 0;
      }

      function setShowFooter(show) {
        $ctrl.showFooter = show;
      }

      function determineElementSizes() {
        listBlock = $element.find(".schedule-list-block")[0], timelineList = $element.find(".schedule-timeline-block")[0], timelineHeader = $element.find(".schedule-timeline-header")[0];
        var rowHeightElm = $("<div style='position:absolute' class='schedule-row-height' />");
        $element.append(rowHeightElm);
        var rowRect = rowHeightElm[0].getBoundingClientRect();
        $ctrl.elementSizes.rowHeight = rowRect.height, rowHeightElm.remove();
        var slotWidthElm = $("<div style='position:absolute' class='schedule-slot-width' />");
        $element.append(slotWidthElm);
        var slotRect = slotWidthElm[0].getBoundingClientRect();
        $ctrl.elementSizes.slotWidth = slotRect.width, slotWidthElm.remove(), $ctrl.elementSizes.pixelsPerMs = $ctrl.elementSizes.slotWidth / $ctrl.options.timeline.interval / 1e3, $ctrl.elementSizes.timelineWidth = ($ctrl.options.timeline.end.getTime() - $ctrl.options.timeline.start.getTime()) * $ctrl.elementSizes.pixelsPerMs, $ctrl.elementSizes.numberOfSlots = ($ctrl.options.timeline.end - $ctrl.options.timeline.start) / (1e3 * $ctrl.options.timeline.interval), onThemeUpdated();
      }

      function initMapApi() {
        $ctrl.api.mapApi && $ctrl.api.mapApi.init && $ctrl.api.mapApi.init();
      }

      function onDefaultShowMapChange(val, prev) {
        !val || null != $ctrl.mapShow && val == prev || showMap(val), val && initMapApi();
      }

      function onShowMapToggleChange(val) {
        val && initMapApi();
      }

      function generateScheduleSlots() {
        if ($ctrl.scheduleSlots = [], $ctrl.options.timeline && $ctrl.options.timeline.start && !($ctrl.options.timeline.end <= $ctrl.options.timeline.start) && $ctrl.options.timeline.interval) {
          for (var ctime = $ctrl.options.timeline.start; ctime.getTime() < $ctrl.options.timeline.end.getTime();) {
            var endTime = new Date(ctime.getTime() + 1e3 * $ctrl.options.timeline.interval);
            endTime > $ctrl.options.timeline.end && (endTime = $ctrl.options.timeline.end);
            var slot = {
              start: ctime,
              end: endTime
            };
            ctime = endTime, $ctrl.scheduleSlots.push(slot);
          }

          updateContainerHeight();
        } else console.log("Invalid timeline configuration");
      }

      function updateItemsAsyncSuccess(response) {
        $ctrl.totalItems = response.totalItems, $ctrl.items = response.items, $ctrl.isRetrievingItemsAsyc = !1, $ctrl.rendering.lastRow = 0, determineElementSizes(), $timeout(function () {
          updateContainerHeight(), updateFilterCount();
        }, 100), generateScheduleSlots(), $ctrl.onItemsRetrieved && $ctrl.items && $ctrl.items.length > 0 && ($ctrl.onItemsRetrieved(), onDefaultShowMapChange($ctrl.options.defaultShowMap));
      }

      function updateItemsAsyncFail(response) {
        $ctrl.items = [], $ctrl.isRetrievingItemsAsyc = !1;
      }

      function scrollToDate(date, duration) {
        var defer = $q.defer();
        void 0 === duration && (duration = 1e3);
        var timespan = $ctrl.options.timeline.end.getTime() - $ctrl.options.timeline.start.getTime(),
            timelineNextDay = (date.getTime() - $ctrl.options.timeline.start.getTime()) / timespan,
            desiredScroll = $ctrl.elementSizes.timelineWidth * timelineNextDay;
        return $(timelineList).animate({
          scrollLeft: desiredScroll - 1 + "px"
        }, duration, function () {
          defer.resolve();
        }), $(timelineHeader).animate({
          scrollLeft: desiredScroll - 1 + "px"
        }, duration), defer.promise;
      }

      function getCurrentTimeFromScroll() {
        var slotOffset = Math.floor(timelineHeader.scrollLeft / $ctrl.elementSizes.timelineWidth * $ctrl.elementSizes.numberOfSlots);
        return new Date($ctrl.options.timeline.start.getTime() + slotOffset * $ctrl.options.timeline.interval * 1e3);
      }

      function updateContainerHeight() {
        var numberOfVisibleItems = $ctrl.items.length;

        if ($ctrl.filter) {
          numberOfVisibleItems = 0;

          for (var i = 0; i < $ctrl.items.length; i++) {
            var item = $ctrl.items[i];
            $ctrl.filter == item.status && numberOfVisibleItems++;
          }
        }

        0 == numberOfVisibleItems && (numberOfVisibleItems = 1), $element.find(".schedule-timeline-container-fixed-height").css("min-height", $ctrl.elementSizes.rowHeight * numberOfVisibleItems + "px"), $element.find(".schedule-timeline-container-fixed-height").css("max-height", $ctrl.elementSizes.rowHeight * numberOfVisibleItems + "px");
      }

      function showMap(show) {
        void 0 == show && (show = !$ctrl.mapShow), $ctrl.mapShow = show;
        var mapBlock = $(".schedule-map-block");
        show ? (mapBlock.addClass("schedule-map-block-show"), (!$ctrl.itemInfoShow || $ctrl.itemInfoShow && $ctrl.options.showMapToggle) && mapBlock.addClass("no-background-landscape")) : (closeItemInfo(show), mapBlock.removeClass("schedule-map-block-show"), mapBlock.removeClass("no-background-landscape"));
      }

      function showItemInfo(show) {
        void 0 == show && (show = !$ctrl.itemInfoShow), $ctrl.itemInfoShow = show, $ctrl.onItemInfoShowChanged({
          show: $ctrl.itemInfoShow
        });
      }

      function openItemInfo(itemId, showMapLocation) {
        return itemId && ($ctrl.selectedItem = function (itemId) {
          for (var i = 0; i < $ctrl.items.length; i++) {
            var localItem = $ctrl.items[i];
            if (localItem.id == itemId) return localItem;
          }

          return null;
        }(itemId)), !!$ctrl.selectedItem && (showItemInfo(!0), showMapLocation && showMap(!0), !0);
      }

      function closeItemInfo(closeMap) {
        showItemInfo(!1), closeMap && showMap(!1);
      }

      function selectItem(item) {
        $ctrl.selectedItem = item;
      }

      $ctrl.elementSizes = {
        rowHeight: 0,
        slotWidth: 0
      }, $ctrl.isRetrievingItemsAsyc = !1, $ctrl.items = [], $ctrl.filter = "", $ctrl.filterCount = 0, $ctrl.scheduleSlots = [], $ctrl.filterLabel = "Filter by", $ctrl.mapShow = null, $ctrl.itemInfoShow = !1, $ctrl.selectedItem = null, $ctrl.rendering = {
        lastRow: 6,
        lastSlot: 10
      }, $ctrl.currentDate = "", $ctrl.$onDestroy = function () {
        $interval.cancel(resizeTimer), $timeout.cancel(updateScheduleStatusTime), $element[0].removeEventListener("mousewheel", onMovement, !1), $element[0].removeEventListener("wheel", onMovement, !1), $element[0].removeEventListener("touchmove", onMovement, !1), $element[0].removeEventListener("mousedown", onMovement, !1);
      }, $ctrl.$onInit = function () {
        determineElementSizes(), updateScheduleStatusTime = $timeout(updateScheduleStatus, getWaitTimeForScheduleStatusEvent()), $scope.$watch("$ctrl.options", function (val, prev) {
          $ctrl.options && (retrieveItemsAsync = $ctrl.options.retrieveItemsAsync, $ctrl.options.retrieveItemsAsyncOnload && $ctrl.updateItemsAsync());
        }), $scope.$watch("$ctrl.options.defaultShowMap", function (val, prev) {
          onDefaultShowMapChange(val, prev);
        }), $scope.$watch("$ctrl.options.showMapToggle", function (val, prev) {
          onShowMapToggleChange(val);
        }), $scope.$watch("$ctrl.options.readonly", function (value) {
          onThemeUpdated();
        }, !0), $scope.$watch("$ctrl.options.theme", function (value) {
          onThemeUpdated();
        }, !0), $scope.$watch("$ctrl.options.view", function (value) {
          closeItemInfo(!0), ScheduleBoardThemeUtil.applyTheme($ctrl.options, $ctrl.elementSizes, $ctrl.readonly);
        }, !0), $element[0].addEventListener("mousewheel", onMovement, !1), $element[0].addEventListener("wheel", onMovement, !1), $element[0].addEventListener("touchmove", onMovement, !1), $element[0].addEventListener("mousedown", onMovement, !1), $ctrl.api = {
          updateItem: updateItem,
          selectItem: selectItem,
          openItemInfo: openItemInfo,
          closeItemInfo: closeItemInfo,
          showMap: showMap,
          moveTimeline: moveTimeline,
          setFilter: setFilter,
          refresh: refresh,
          resetDay: $ctrl.resetDay,
          setShowFooter: setShowFooter,
          bookEvent: bookEvent,
          endEvent: endEvent,
          extendEvent: extendEvent,
          checkInEvent: checkInEvent,
          switchView: switchView
        }, $ctrl.onApiReady && $ctrl.onApiReady({
          api: $ctrl.api
        }), checkTableState(), resizeTimer = $interval(checkTableState, 250), $scope.$on("LastRepeaterElement", function (e) {}), $ctrl.filterClick = function () {
          $ctrl.onFilterClick && $ctrl.onFilterClick();
        }, $scope.$on("timeline.schedule.click", function (event, data) {
          $ctrl.onScheduleClick && ($ctrl.onScheduleClick(data), updateItem(data.item));
        }), $scope.$on("timeline.slot.click", function (event, data) {
          $ctrl.onFreeSlotClick && ($ctrl.onFreeSlotClick(data), updateItem(data.item));
        }), $scope.$on("timeline.schedule.statuschanged", function (event, data) {
          $ctrl.onStatusChanged && $ctrl.onStatusChanged(data);
        });
      }, $ctrl.onMapApiReady = function (api) {
        $ctrl.api.mapApi = api;
      }, $ctrl.resetFilter = function () {
        setFilter("");
      }, $ctrl.updateItemsAsync = function () {
        $timeout.cancel(retrieveTimeout), retrieveTimeout = $timeout($ctrl.executeRetrieveItemsAsync, 10);
      }, $ctrl.executeRetrieveItemsAsync = function () {
        retrieveTimeout = 0, $ctrl.isRetrievingItemsAsyc = !0;
        retrieveItemsAsync({}).then(updateItemsAsyncSuccess, updateItemsAsyncFail);
      }, $ctrl.nextDay = function () {
        var currentTime = getCurrentTimeFromScroll(),
            nextDay = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate() + 1, 8);
        nextDay > $ctrl.options.timeline.end || scrollToDate(nextDay);
      }, $ctrl.previousDay = function () {
        var currentTime = getCurrentTimeFromScroll(),
            previousDay = new Date(currentTime.getFullYear(), currentTime.getMonth(), currentTime.getDate() - 1, 8);
        previousDay < $ctrl.options.timeline.start && (previousDay = $ctrl.options.timeline.start), scrollToDate(previousDay);
      }, $ctrl.resetDay = function () {
        scrollToDate($ctrl.options.timeline.start);
      }, $ctrl.onItemSelectClick = function ($event, item) {
        $ctrl.selectedItem = item, $ctrl.onItemClick({
          item: item
        });
      }, $ctrl.itemActionClick = function (action) {
        "info-close" == action.type && (showItemInfo(!1), $ctrl.selectedItem = null), $ctrl.api.mapApi && $ctrl.api.mapApi.onItemAction && $ctrl.api.mapApi.onItemAction(action), $ctrl.onItemActionClick({
          action: action
        });
      }, $ctrl.onMapActionClick = function () {
        console.log(action);
      }, $ctrl.onMapToggleClickEvent = function () {
        showMap(), $ctrl.onMapToggleClick({
          mapShow: $ctrl.mapShow
        });
      };
    }]
  });
}(), window.angular.module("core.ui").factory("ScheduleBoardScheduleUtil", ["SCHEDULE_STATUSES", function (SCHEDULE_STATUSES) {
  return {
    getScheduleInfo: function getScheduleInfo(item, timeformat) {
      if (!item) return {};
      var scheduleInfo = {
        status: "available",
        upcomingMeetings: []
      },
          cdate = new Date(),
          ctime = cdate.getTime();

      if (item.schedules) {
        item.schedules.sort(sortSchedulesFunc);

        for (var timeformat = timeformat || "HH:mm A", y = 0; y < item.schedules.length; y++) {
          var schedule = item.schedules[y];

          if (!(schedule.end < ctime)) {
            (schedule = angular.copy(schedule)).startDateString = moment(schedule.start).format(timeformat), schedule.endDateString = moment(schedule.end).format(timeformat), schedule.timeString = schedule.startDateString + " - " + schedule.endDateString, schedule.dateTimeString = schedule.timeString, new Date(schedule.start).getDate() != cdate.getDate() && (schedule.dateTimeString = moment(schedule.start).format("dddd") + " " + schedule.timeString);
            var timeToStart = getTimeToMeetingStart(schedule);
            isScheduleInCheckinState(schedule, scheduleInfo.activeSchedule, timeToStart, 6e5) ? (scheduleInfo.status = "checkin", scheduleInfo.upcomingMeetings.push(schedule)) : 0 == timeToStart ? (scheduleInfo.activeSchedule = schedule, 1 == schedule.confirmed ? scheduleInfo.status = "occupied" : scheduleInfo.status = "checkin") : scheduleInfo.upcomingMeetings.push(schedule);
          }
        }
      }

      return scheduleInfo;
    },
    sortSchedules: function sortSchedules(schedules) {
      schedules.sort(sortSchedulesFunc);
    },
    getTimeToMeetingStart: getTimeToMeetingStart,
    isScheduleInCheckinState: isScheduleInCheckinState
  };

  function sortSchedulesFunc(a, b) {
    var al = a.start,
        bl = b.start;
    return al < bl ? -1 : al > bl ? 1 : 0;
  }

  function getTimeToMeetingStart(schedule) {
    var ctime = new Date().getTime();
    return ctime >= schedule.start && ctime <= schedule.end ? 0 : schedule.start - ctime;
  }

  function isScheduleInCheckinState(schedule, activeSchedule, timeToStart, checkingTime) {
    return Boolean(schedule.ignoreCheckInConfiguration && schedule.status === SCHEDULE_STATUSES.CHECK_IN || !schedule.ignoreCheckInConfiguration && !activeSchedule && 1 != schedule.confirmed && timeToStart > 0 && timeToStart < checkingTime);
  }
}]), window.angular.module("core.ui").factory("ScheduleBoardThemeUtil", ["CssUtil", function (CssUtil) {
  return {
    applyTheme: function applyTheme(options, elementSizes) {
      var timelineColor = "",
          borderColor = "",
          timelineBgColor = "",
          checkingBgColor = "",
          statusOccupied = "",
          statusCheckin = "",
          statusAvailable = "",
          theme = options.theme;

      if (theme) {
        if (theme.timeline && theme.timeline.color && (timelineColor = theme.timeline.color + " !important"), theme.table && theme.table.borderColor && (borderColor = theme.table.borderColor + " !important"), theme.timeline && theme.timeline.backgroundColor) {
          timelineBgColor = theme.timeline.backgroundColor;
          var baseColor = tinycolor(timelineBgColor);
          baseColor.setAlpha(1);
          var brightness = baseColor.getBrightness();
          brightness > 50 ? (baseColor.darken(10), checkingBgColor = baseColor.toRgbString() + " !important") : (baseColor.lighten(10), checkingBgColor = baseColor.toRgbString() + " !important");
        }

        theme.status && theme.status.occupied && (statusOccupied = theme.status.occupied + " !important"), theme.status && theme.status.checkin && (statusCheckin = theme.status.checkin + " !important"), theme.status && theme.status.available && (statusAvailable = theme.status.available + " !important");
      }

      var bgPattern = creatBgPattern(theme, elementSizes.slotWidth, elementSizes.rowHeight, options.readonly, options.view),
          bookNowPattern = creatBookNowPattern(theme, elementSizes.slotWidth, elementSizes.rowHeight),
          bookedPattern = creatBookedPattern(timelineBgColor);
      CssUtil.createClass(".asui-schedule-table-filter-footer", "color: " + timelineColor), CssUtil.createClass(".schedule-list-block", "background-color: " + timelineBgColor), CssUtil.createClass(".schedule-map-block", "background-color: " + timelineBgColor), CssUtil.createClass(".schedule-item-info-block", "background-color: " + timelineBgColor + "; color: " + timelineColor), CssUtil.createClass(".schedule-map-block", "background-color: " + timelineBgColor), CssUtil.createClass(".item-info-meetings-schedule", "border-color: " + borderColor), CssUtil.createClass(".item-info-button", "border-color: " + timelineColor), CssUtil.createClass(".filter-view-all", "border-color: " + timelineColor), CssUtil.createClass(".filter-partial-container", "color: " + timelineColor), CssUtil.createClass(".schedule-item-status-available", "background-color: " + statusAvailable), CssUtil.createClass(".schedule-item-status-occupied", "background-color: " + statusOccupied), CssUtil.createClass(".schedule-item-status-checkin", "background-color: " + statusCheckin), CssUtil.createClass(".timeline-schedule-booknow", "background-image: " + bookNowPattern), CssUtil.createClass(".schedule-checkin", "border-color: " + timelineColor), CssUtil.createClass(".asui-schedule-table-item", "color: " + timelineColor + "; border-color: " + borderColor), CssUtil.createClass(".asui-schedule-table-item-timeline", "border-color: " + borderColor + "; background-image: " + bgPattern), CssUtil.createClass(".asui-schedule-table-item-timeline-readonly", "background-color: " + borderColor + ";"), CssUtil.createClass(".asui-schedule-table-timeline-header-edge", "border-color: " + borderColor), CssUtil.createClass(".timeline-schedule-checkin", "background-color: " + checkingBgColor + ";border-color: " + borderColor), CssUtil.createClass(".schedule-container", "background: " + bookedPattern), CssUtil.createClass(".schedule-booknow", "color: " + timelineColor + "; border-color: " + timelineColor), CssUtil.createClass(".facility-logo g, .facility-logo path", "fill: " + timelineColor + "; stroke: " + timelineColor);
    },
    creatBookNowPattern: creatBookNowPattern,
    creatBookedPattern: creatBookedPattern,
    creatBgPattern: creatBgPattern
  };

  function getAdjustedSize(pixels) {
    var windowSize_width = $(window).width(),
        windowSize_height = $(window).height(),
        ratio = windowSize_width / 1920;
    windowSize_width < windowSize_height && (ratio = windowSize_height / 1920);
    var adjustedPixels = pixels * ratio;
    return adjustedPixels = adjustedPixels > 1 ? adjustedPixels : 1, parseInt(adjustedPixels, 10);
  }

  function creatBookedPattern(timelineBgColor) {
    if (timelineBgColor) {
      var baseColor = tinycolor(timelineBgColor);
      baseColor.setAlpha(.7);
      var color1 = null,
          color2 = null;
      return baseColor.getBrightness() > 50 ? (baseColor.darken(10), color1 = tinycolor(baseColor).toRgb(), baseColor.darken(10), color2 = tinycolor(baseColor).toRgb()) : (baseColor.lighten(10), color1 = tinycolor(baseColor).toRgb(), baseColor.lighten(10), color2 = tinycolor(baseColor).toRgb()), color1 = tinycolor(color1).toRgbString(), color2 = tinycolor(color2).toRgbString(), "repeating-linear-gradient(45deg, " + color1 + ", " + color1 + " " + getAdjustedSize(5) + "px, " + color2 + " " + getAdjustedSize(6) + "px, " + color2 + " " + getAdjustedSize(8) + "px) !important;";
    }

    return "";
  }

  function creatBgPattern(theme, slotWidth, slotHeight, readonly, view) {
    if (readonly || "current" == view) return "none";
    var canvas = document.createElement("canvas");
    canvas.width = slotWidth, canvas.height = slotHeight;
    var baseColor = "#dbe0ea";
    theme && theme.table && theme.table.borderColor && (baseColor = theme.table.borderColor);
    var lineWidth = getAdjustedSize(1),
        lineLength = getAdjustedSize(10),
        ctx = canvas.getContext("2d");
    ctx.fillStyle = baseColor;
    var verticalLineX = slotWidth / 2 - lineWidth / 2,
        verticalLineY = slotHeight / 2 - lineLength / 2;
    ctx.fillRect(verticalLineX, verticalLineY, lineWidth, lineLength);
    var horizontalLineX = slotWidth / 2 - lineLength / 2,
        horizontalLineY = slotHeight / 2 - lineWidth / 2;
    return ctx.fillRect(horizontalLineX, horizontalLineY, lineLength, lineWidth), ctx.fillRect(slotWidth - 1, 0, 1, slotHeight), "url('" + canvas.toDataURL() + "')";
  }

  function creatBookNowPattern(theme, slotWidth, slotHeight) {
    getAdjustedSize(10);
    var canvas = document.createElement("canvas"),
        renderWidth = 2 * slotWidth,
        renderHeight = 2 * slotHeight;
    canvas.width = renderWidth, canvas.height = renderHeight;
    var lineWidth = getAdjustedSize(6),
        lineLength = getAdjustedSize(40),
        ctx = canvas.getContext("2d"),
        baseColor = "#182449";
    theme && theme.timeline && theme.timeline.color && (baseColor = theme.timeline.color), ctx.fillStyle = baseColor, ctx.strokeStyle = baseColor, ctx.beginPath(), ctx.lineWidth = getAdjustedSize(5), ctx.arc(renderWidth / 2, renderHeight / 2, renderWidth / 4.7, 0, 2 * Math.PI), ctx.stroke();
    var verticalLineX = renderWidth / 2 - lineWidth / 2,
        verticalLineY = renderHeight / 2 - lineLength / 2;
    ctx.fillRect(verticalLineX, verticalLineY, lineWidth, lineLength);
    var horizontalLineX = renderWidth / 2 - lineLength / 2,
        horizontalLineY = renderHeight / 2 - lineWidth / 2;
    return ctx.fillRect(horizontalLineX, horizontalLineY, lineLength, lineWidth), "url('" + canvas.toDataURL() + "')";
  }
}]), window.angular.module("core.ui").directive("asuiSearch", function () {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: "component-search/search.template",
    scope: {
      placeholder: "@",
      maxLength: "@",
      options: "=",
      ngModel: "=",
      onTextChange: "&",
      onSearch: "&",
      onFocus: "&",
      onClear: "&"
    },
    controller: ["$scope", function ($scope) {
      $scope.onChange = function () {
        $scope.onTextChange({
          value: $scope.ngModel
        });
      }, $scope.onKeyUp = function (e) {
        13 == (e.which ? e.which : e.keyCode) && $scope.onSearchClick();
      }, $scope.onInputFocus = function (e) {
        $scope.onFocus();
      }, $scope.onSearchClick = function () {
        $scope.onSearch({
          value: $scope.ngModel
        });
      }, $scope.onClearClick = function () {
        $scope.ngModel = null, $scope.onClear();
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiSearchAutocomplete", function () {
  return {
    restrict: "E",
    templateUrl: "component-search-autocomplete/search-autocomplete.template",
    scope: {
      options: "=",
      model: "=",
      onKeywordChange: "&",
      onSearch: "&",
      onClear: "&",
      onItemClick: "&"
    },
    link: function link(scope, element) {
      $(element).on("keyup", scope.onKeyUp), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("options", scope.optionsUpdated, !0);
    },
    controller: ["$scope", "$element", "$timeout", function ($scope, $element, $timeout) {
      function closeDropdown() {
        $scope.isOpen = !1, document.body.removeEventListener("click", outsideClickHandler, !0);
      }

      function outsideClickHandler(e) {
        $(e.target).closest(".search-item-row").length > 0 ? $timeout(closeDropdown, 100) : $element.is(e.target) || $element.has(e.target).length || $timeout(closeDropdown, 100);
      }

      function performSearch(keywords) {
        if (closeDropdown(), $scope.isOpen = !0, document.body.addEventListener("click", outsideClickHandler, !0), $scope.searchResults = [], $scope.options && $scope.options.retrieveItemsAsync) {
          $scope.isSearching = !0;
          var queryCriteria = {
            keywords: keywords
          };
          $scope.options.retrieveItemsAsync(queryCriteria).then(function (res) {
            $scope.isSearching = !1, $scope.searchResults = res, $scope.searchResultItems = [];

            for (var total = 0, i = 0; i < res.length; i++) {
              var group = res[i];
              total += group.items.length, group.items.forEach(function (item) {
                $scope.searchResultItems.push(item);
              });
            }

            0 == total && $scope.options && $scope.options.hideOnEmpty && ($scope.isOpen = !1);
          }, function (err) {
            console.log("Failed to autocomplete search", err), $scope.isSearching = !1;
          });
        }
      }

      function scrollIntoView() {
        var activeEl = $element.find(".search-item-row.active")[0];
        activeEl && activeEl.scrollIntoView({
          block: "nearest",
          behavior: "smooth"
        });
      }

      $scope.isSearching = !0, $scope.searchResults = [], $scope.isOpen = !1, $scope.onTextChange = function (val) {
        $scope.model = val, $scope.onKeywordChange({
          value: val
        }), val && val.length > 0 ? $scope.keywordsUpdated(val) : closeDropdown();
      }, $scope.destroy = function () {
        closeDropdown(), $($element).off("keyup", $scope.onKeyUp);
      }, $scope.onFocus = function () {
        $scope.options && $scope.options.searchOnFocus && performSearch($scope.model);
      }, $scope.keywordsUpdated = function (keywords) {
        keywords && keywords.length > 0 && performSearch(keywords);
      }, $scope.onSearchEvent = function (value) {
        $scope.onSearch({
          value: value
        }), closeDropdown();
      }, $scope.onClearEvent = function () {
        $scope.model = "", $scope.onClear(), closeDropdown();
      }, $scope.itemClick = function (item) {
        $scope.onItemClick({
          item: item
        });
      }, $scope.onMouseOver = function (item) {
        item._active = !0;
      }, $scope.onMouseLeave = function (item) {
        item._active = !1;
      }, $scope.onKeyUp = function (e) {
        switch (e.which ? e.which : e.keyCode) {
          case 13:
            if ($scope.searchResultItems && $scope.searchResultItems.length) for (var i = 0; i < $scope.searchResultItems.length; i++) {
              var item = $scope.searchResultItems[i];

              if (item._active) {
                $scope.itemClick(item);
                break;
              }
            }
            break;

          case 38:
            $scope.$evalAsync(function () {
              !function () {
                if ($scope.searchResultItems && $scope.searchResultItems.length) {
                  for (var prevIndex = 0, i = 0; i < $scope.searchResultItems.length; i++) {
                    var item = $scope.searchResultItems[i];

                    if (item._active) {
                      item._active = !1, prevIndex = i - 1;
                      break;
                    }
                  }

                  prevIndex < 0 && (prevIndex = $scope.searchResultItems.length - 1);
                  var prevItem = $scope.searchResultItems[prevIndex];
                  prevItem._active = !0;
                }
              }(), $timeout(scrollIntoView, 10);
            });
            break;

          case 40:
            $scope.$evalAsync(function () {
              !function () {
                if ($scope.searchResultItems && $scope.searchResultItems.length) {
                  for (var nextIndex = 0, i = 0; i < $scope.searchResultItems.length; i++) {
                    var item = $scope.searchResultItems[i];

                    if (item._active) {
                      item._active = !1, nextIndex = i + 1;
                      break;
                    }
                  }

                  nextIndex >= $scope.searchResultItems.length && (nextIndex = 0);
                  var nextItem = $scope.searchResultItems[nextIndex];
                  nextItem._active = !0;
                }
              }(), $timeout(scrollIntoView, 10);
            });
        }
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiSpinner", function () {
  return {
    restrict: "EA",
    templateUrl: "component-spinner/spinner.template",
    scope: {
      type: "@"
    }
  };
}), window.angular.module("core.ui").directive("asuiSplitButton", function () {
  return {
    restrict: "E",
    templateUrl: "component-split-button/split-button.template",
    scope: {
      id: "@",
      options: "=?",
      ngDisabled: "=?",
      onMainActionClick: "&",
      onActionClick: "&"
    },
    link: function link(scope) {
      scope.$watch("option", scope.optionsUpdated);
    },
    controller: ["$scope", function ($scope) {
      $scope.optionsUpdated = function () {};
    }]
  };
}), window.angular.module("core.ui").directive("asuiStyleEditor", function () {
  return {
    restrict: "EA",
    templateUrl: "component-styleeditor/styleeditor.template",
    scope: {
      options: "=",
      ngModel: "=",
      onApiReady: "&",
      onStyleChange: "&"
    },
    link: function link(scope, element) {
      scope.$watch("ngModel", scope.onStyleUpdate, !0), scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("options", scope.onOptionsUpdate, !0), scope.api = {}, scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", "AsComponentUtil", function ($scope, $location, $element, $timeout, AsComponentUtil) {
      var componentUtil = new AsComponentUtil();
      $scope.showSize = !1, $scope.showFontFamily = !1, $scope.showDecorations = !1, $scope.showAlignment = !1, $scope.showColor = !1, $scope.showBgColor = !1, $scope.showGridColor = !1, $scope.bold = !1, $scope.italic = !1, $scope.underline = !1;
      var style = null,
          fontColorEl = null,
          bgColorEl = null,
          gridColorEl = null,
          prevFontColor = {
        hex: null,
        alpha: 0
      },
          prevBgColor = {
        hex: null,
        alpha: 0
      },
          prevGridColor = {
        hex: null,
        alpha: 0
      };

      function destroyColorPicker() {
        bgColorEl && (bgColorEl.spectrum("destroy"), bgColorEl.remove(), bgColorEl = null), gridColorEl && (gridColorEl.spectrum("destroy"), gridColorEl.remove(), gridColorEl = null), fontColorEl && (fontColorEl.spectrum("destroy"), fontColorEl.remove(), fontColorEl = null);
      }

      function setActiveFontSize(size) {
        style.size = size, $scope.ngModel = style, $timeout(function () {
          var list = $($element.find(".font-size").find("li"));
          list.removeClass("active"), list.each(function (index) {
            if ($(this).text().indexOf(size) > -1) return $(this).addClass("active"), !1;
          });
        }, 0);
      }

      function setActiveFontFamily(font) {
        style.fontFamily = font, $scope.ngModel = style, $timeout(function () {
          var list = $($element.find(".font-family").find("li"));
          list.removeClass("active"), list.each(function (index) {
            if ($(this).text().indexOf(font) > -1) return $(this).addClass("active"), !1;
          });
        }, 0);
      }

      function toggleBold(active) {
        toggleDecoration("bold", active);
      }

      function toggleItalic(active) {
        toggleDecoration("italic", active);
      }

      function toggleUnderline(active) {
        toggleDecoration("underline", active);
      }

      function toggleDecoration(id, active) {
        $timeout(function () {
          var el = $($element.find("#ts-" + id));
          active ? el.addClass("active") : el.removeClass("active");
        }, 0);
      }

      function addDecoration(item) {
        null !== style.decorations && void 0 !== style.decorations || (style.decorations = []), style.decorations.push(item), $scope.ngModel = style;
      }

      function removeDecoration(item) {
        null !== style.decorations && void 0 !== style.decorations || (style.decorations = []);
        var index = style.decorations.indexOf(item);
        index > -1 && style.decorations.splice(index, 1), $scope.ngModel = style;
      }

      function toggleAlignment(alignment) {
        $($element.find("#ts-align" + alignment)).addClass("active").siblings().removeClass("active");
      }

      function onFontColorMove(e, color) {
        prevFontColor = componentUtil.resetColorPickerAlpha(fontColorEl, color, prevFontColor), onFontColorChange(0, color);
      }

      function onFontColorChange(e, color) {
        var val = null;
        color && (val = color.toRgbString()), style.color = val, fireOnStyleChange();
      }

      function onBgColorMove(e, color) {
        prevBgColor = componentUtil.resetColorPickerAlpha(bgColorEl, color, prevBgColor), onBgColorChange(0, color);
      }

      function onBgColorChange(e, color) {
        var val = null;
        color && (val = color.toRgbString()), style.backgroundColor = val, fireOnStyleChange();
      }

      function onGridColorMove(e, color) {
        prevGridColor = componentUtil.resetColorPickerAlpha(gridColorEl, color, prevGridColor), onGridColorChange(0, color);
      }

      function onGridColorChange(e, color) {
        var val = null;
        color && (val = color.toRgbString()), style.gridColor = val, fireOnStyleChange();
      }

      function fireOnStyleChange() {
        $scope.onStyleChange && $scope.onStyleChange({
          style: $scope.ngModel
        });
      }

      $scope.onOptionsUpdate = function () {
        var options;
        options = $scope.options, destroyColorPicker(), options && !jQuery.isEmptyObject(options) && (options.size && options.size.length > 0 && ($scope.showSize = !0), !1 !== options.font && options.fontFamily && options.fontFamily.length > 0 && ($scope.showFontFamily = !0), options.decorations && !0 === options.decorations && ($scope.showDecorations = !0), options.alignment && !0 === options.alignment && ($scope.showAlignment = !0), options.color && !0 === options.color && ($scope.showColor = !0, $timeout(function () {
          null !== fontColorEl && void 0 !== fontColorEl || (fontColorEl = $($element.find("#color")));
          var initialColor = null;
          style && style.color && (initialColor = style.color), fontColorEl.spectrum(componentUtil.getColorPickerSettings(initialColor)), fontColorEl.on("move.spectrum", onFontColorMove), fontColorEl.on("change.spectrum", onFontColorChange), fontColorEl.on("hide.spectrum", onFontColorChange);
        }, 0)), options.backgroundColor && !0 === options.backgroundColor && ($scope.showBgColor = !0, $timeout(function () {
          null !== bgColorEl && void 0 !== bgColorEl || (bgColorEl = $($element.find("#bgColor")));
          var initialColor = null;
          style && style.backgroundColor && (initialColor = style.backgroundColor), bgColorEl.spectrum(componentUtil.getColorPickerSettings(initialColor)), bgColorEl.on("move.spectrum", onBgColorMove), bgColorEl.on("change.spectrum", onBgColorChange), bgColorEl.on("hide.spectrum", onBgColorChange);
        }, 0)), options.gridColor && !0 === options.gridColor && ($scope.showGridColor = !0, $timeout(function () {
          null !== gridColorEl && void 0 !== gridColorEl || (gridColorEl = $($element.find("#gridColor")));
          var initialColor = null;
          style && style.gridColor && (initialColor = style.gridColor), gridColorEl.spectrum(componentUtil.getColorPickerSettings(initialColor)), gridColorEl.on("move.spectrum", onGridColorMove), gridColorEl.on("change.spectrum", onGridColorChange), gridColorEl.on("hide.spectrum", onGridColorChange);
        }, 0)));
      }, $scope.destroy = function () {
        destroyColorPicker();
      }, $scope.onStyleUpdate = function (newVal) {
        newVal || !jQuery.isEmptyObject(newVal) ? function (style) {
          if (style && !jQuery.isEmptyObject(style)) {
            if (style.size && "" !== style.size && setActiveFontSize(style.size), style.fontFamily && "" !== style.fontFamily && setActiveFontFamily(style.fontFamily), style.decorations && style.decorations.length > 0) for (var i = 0; i < style.decorations.length; i++) {
              var d = style.decorations[i];
              "bold" == d ? ($scope.bold = !0, toggleBold($scope.bold)) : "italic" == d ? ($scope.italic = !0, toggleItalic($scope.italic)) : "underline" == d && ($scope.underline = !0, toggleUnderline($scope.underline));
            }

            if ((style.alignment && "left" == style.alignment || "center" == style.alignment || "right" == style.alignment) && toggleAlignment(style.alignment), style.color) {
              null !== fontColorEl && void 0 !== fontColorEl || (fontColorEl = $($element.find("#color"))), fontColorEl.spectrum("set", style.color);
              var color = tinycolor(style.color);
              prevFontColor = {
                hex: color.toHexString(),
                alpha: color.getAlpha()
              };
            }

            if (style.backgroundColor) {
              null !== bgColorEl && void 0 !== bgColorEl || (bgColorEl = $($element.find("#bgColor"))), bgColorEl.spectrum("set", style.backgroundColor);
              var color2 = tinycolor(style.backgroundColor);
              prevBgColor = {
                hex: color2.toHexString(),
                alpha: color2.getAlpha()
              };
            }

            if (style.gridColor) {
              null !== gridColorEl && void 0 !== gridColorEl || (gridColorEl = $($element.find("#gridColor"))), gridColorEl.spectrum("set", style.gridColor);
              var color3 = tinycolor(style.gridColor);
              prevGridColor = {
                hex: color3.toHexString(),
                alpha: color3.getAlpha()
              };
            }
          }
        }(style = newVal) : $scope.ngModel = {};
      }, $scope.onFontSizeChange = function ($event, size) {
        setActiveFontSize(size), fireOnStyleChange();
      }, $scope.onFontFamilyChange = function ($event, font) {
        setActiveFontFamily(font), fireOnStyleChange();
      }, $scope.onBoldClick = function () {
        $scope.bold = !$scope.bold, toggleBold($scope.bold), $scope.bold ? addDecoration("bold") : removeDecoration("bold"), fireOnStyleChange();
      }, $scope.onItalicClick = function () {
        $scope.italic = !$scope.italic, toggleItalic($scope.italic), $scope.italic ? addDecoration("italic") : removeDecoration("italic"), fireOnStyleChange();
      }, $scope.onUnderlineClick = function () {
        $scope.underline = !$scope.underline, toggleUnderline($scope.underline), $scope.underline ? addDecoration("underline") : removeDecoration("underline"), fireOnStyleChange();
      }, $scope.onAlignmentClick = function ($event, alignment) {
        "left" != alignment && "center" != alignment && "right" != alignment || toggleAlignment(alignment), style.alignment = alignment, $scope.ngModel = style, fireOnStyleChange();
      };
    }]
  };
}), window.angular.module("core.ui").factory("syncrhonizeScrollService", function ($window) {
  var groups = {},
      animationFrameId = null;

  function scheduleScrollUpdate() {
    animationFrameId || (animationFrameId = window.requestAnimationFrame(onAnimationFrame));
  }

  function onElementFocus(event) {
    for (var element = event.target; element && !element._scrollGroups;) {
      element = element.parentNode;
    }

    if (element) {
      for (var groupName in element._scrollGroups) {
        var group = element._scrollGroups[groupName];
        group.activeElement = element, group.updateUntil = new Date().getTime() + 500;
      }

      scheduleScrollUpdate();
    }
  }

  function onAnimationFrame() {
    animationFrameId = 0;
    var scheduleUpdate = !1,
        ctime = new Date().getTime();

    for (var groupName in groups) {
      var group = groups[groupName];
      group.updateUntil < ctime || group.activeElement && (scheduleUpdate = !0, group.scrollOffsetX != group.activeElement.scrollLeft && (group.scrollOffsetX = group.activeElement.scrollLeft, group.updateUntil = new Date().getTime() + 500), group.scrollOffsetY != group.activeElement.scrollTop && (group.scrollOffsetY = group.activeElement.scrollTop, group.updateUntil = new Date().getTime() + 500), updateGroupScroll(group, group.scrollOffsetX, group.scrollOffsetY));
    }

    scheduleUpdate && scheduleScrollUpdate();
  }

  function updateGroupScroll(group, scrollLeft, scrollTop) {
    for (var activeElement = group.activeElement, i = 0; i < group.elements.length; i++) {
      var element = group.elements[i];
      element !== activeElement && (group.trackHorizontalScroll && (element.scrollLeft = scrollLeft), group.trackVerticalScroll && (element.scrollTop = scrollTop));
    }
  }

  return {
    registerSynchronizeElement: function registerSynchronizeElement(element, group, direction, onScroll) {
      var elementGroup = groups[group];
      void 0 === elementGroup && (elementGroup = {
        scrollOffsetX: 0,
        scrollOffsetY: 0,
        direction: direction,
        onScroll: onScroll,
        trackVerticalScroll: !direction || "vertical" == direction,
        trackHorizontalScroll: !direction || "horizontal" == direction,
        elements: []
      }, groups[group] = elementGroup);

      for (var i = 0; i < elementGroup.elements.length; i++) {
        if (elementGroup.elements[i] === element) return;
      }

      elementGroup.elements.push(element), void 0 == element._scrollGroups && (element.addEventListener("wheel", onElementFocus, !1), element.addEventListener("mouseup", onElementFocus, !1), element.addEventListener("mousewheel", onElementFocus, !1), element.addEventListener("touchmove", onElementFocus, !1), element._scrollGroups = {}), element._scrollGroups[group] = elementGroup;
    },
    unregisterSynchronizeElement: function unregisterSynchronizeElement(element, group) {
      var elementGroup = groups[group];

      if (void 0 !== elementGroup) {
        for (var i = 0; i < elementGroup.elements.length; i++) {
          if (elementGroup.elements[i] === element) {
            elementGroup.elements.splice(i, 1), delete element._scrollGroups[group];
            break;
          }
        }

        0 == elementGroup.elements.length && delete groups[group], 0 === Object.keys(element._scrollGroups).length && (element._scrollGroups = void 0, element.removeEventListener("wheel", onElementFocus, !1), element.removeEventListener("mouseup", onElementFocus, !1), element.removeEventListener("mousewheel", onElementFocus, !1), element.removeEventListener("touchmove", onElementFocus, !1));
      } else console.log("Can not unregister scroll element, not group found.");
    }
  };
}), window.angular.module("core.ui").directive("asuiSynchronizeScroll", function (syncrhonizeScrollService) {
  return {
    restrict: "A",
    scope: {
      scrollGroup: "@",
      onScroll: "&"
    },
    link: function link(scope, element, attrs) {
      if (scope.scrollGroup) {
        var onScroll = null;
        angular.isDefined(attrs.onScroll) && (element[0]._onScrollCallback = function (group, scrollOffsetLeft, scrollOffsetTop) {
          scope.onScroll(group, scrollOffsetLeft, scrollOffsetTop);
        }), function () {
          for (var scrollGroups = [], scrollGroupsCollection = scope.scrollGroup.split(","), i = 0; i < scrollGroupsCollection.length; i++) {
            var segs = scrollGroupsCollection[i].split(":"),
                groupName = segs[0].trim(),
                groupDirection = segs[1].trim().toLowerCase();
            scrollGroups.push({
              name: groupName,
              direction: groupDirection
            });
          }

          element.on("$destroy", function () {
            for (var k = 0; k < scrollGroups.length; k++) {
              var group = scrollGroups[k];
              syncrhonizeScrollService.unregisterSynchronizeElement(element[0], group.name);
            }
          });

          for (var k = 0; k < scrollGroups.length; k++) {
            var group = scrollGroups[k];
            syncrhonizeScrollService.registerSynchronizeElement(element[0], group.name, group.direction, onScroll);
          }
        }();
      } else console.log("No scroll group specified");
    }
  };
}), function ($angular) {
  var app = window.angular.module("core.ui");
  app.directive("asuiTable", function () {
    return {
      restrict: "EA",
      templateUrl: "component-table/table.template",
      transclude: {
        noDataContent: "?noDataContent"
      },
      scope: {
        id: "@",
        items: "=?",
        options: "=?",
        validation: "=?",
        onApiReady: "&",
        onChange: "&",
        onActionMenuItemClick: "&",
        onGroupActionMenuItemClick: "&",
        onCheckBoxItemClick: "&",
        onCheckAllClick: "&",
        onMove: "&",
        onSortOrderChanged: "&",
        searchFilter: "=",
        onSortableClicked: "&",
        onDataRendered: "&"
      },
      link: function link(scope, element, attrs) {
        scope.$on("$destroy", function () {
          scope.destroy();
        }), element.on("$destroy", function () {
          scope.destroy();
        }), scope.$on("LastRepeaterElement", scope.dataRenderedEvent), scope.$watchCollection("items", scope.itemsUpdated), scope.$watch("options.sortable", function (newVal, oldVal) {
          newVal != oldVal && scope.options.sortable && (scope.options.dragSort = !1, scope.options.orderInput = !1);
        }), scope.$watch("options.dragSort", function (newVal, oldVal) {
          newVal != oldVal && scope.options.dragSort && (scope.options.sortable = !1);
        }), scope.$watch("options.orderInput", function (newVal, oldVal) {
          newVal != oldVal && scope.options.orderInput && (scope.options.sortable = !1, scope.assignSortOrder(scope.localItems));
        }), scope.$watch("options", function (newVal) {
          newVal && scope.init();
        }), scope.$watch("options.groupActionMenus", function (newVal) {
          newVal && scope.initGroupActionsMenu();
        }), scope.api = {
          reloadData: scope.reloadData,
          refresh: scope.updateLocalItems,
          getItems: scope.getItems,
          toggleCheckAll: scope.toggleCheckAll,
          toggleCheckbox: scope.toggleCheckbox,
          getCheckedItems: scope.getCheckedItems
        }, scope.onApiReady && scope.onApiReady({
          api: scope.api
        });
      },
      controller: ["$scope", "$location", "$element", "$timeout", "$http", "$filter", function ($scope, $location, $element, $timeout, $http, $filter) {
        $scope.checkAll = {
          value: !1
        }, $scope.isCheckBoxVisible = [], $scope.checkCount = 0, $scope.localItems = [], $scope.isRetrievingItemsAsyc = !1, $scope.totalItems = 0, $scope.ngStartIndex = null, $scope.ngLimit = null, $scope.colCount = 0, $scope.colMode = "template";
        var insertIndex = null,
            retrieveTimeout = 0;

        function updateItemsAsyncSuccess(response) {
          $timeout(function () {
            $scope.totalItems = void 0 != response.totalItems ? response.totalItems : response.size, $scope.items = response.items, !0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !1), $scope.isRetrievingItemsAsyc = !1;
          });
        }

        function updateItemsAsyncFail(response) {
          $timeout(function () {
            $scope.items = [], !0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !1), $scope.isRetrievingItemsAsyc = !1;
          });
        }

        function updateNgLimits() {
          if ($scope.ngStartIndex = null, $scope.ngLimit = null, $scope.options && !$scope.options.retrieveItemsAsync && $scope.options.paging && $scope.options.paging.currentPage > 0 && $scope.options.paging.itemsPerPage > 0) {
            var startIndex = ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage;
            $scope.ngStartIndex = startIndex, $scope.ngLimit = $scope.options.paging.itemsPerPage + 1;
          }
        }

        function updateCheckCount() {
          $scope.checkCount = 0, $scope.localItems.forEach(function (item) {
            void 0 != item.isSelected && (item.isSelected = item.$tbState._Checked), void 0 != item._selected && (item._selected = item.$tbState._Checked), !1 !== item._selectable && item.$tbState._Checked && $scope.checkCount++;
          }), $scope.checkCount == $scope.localItems.length ? $scope.checkAll.value = !0 : $scope.checkAll.value = !1;
        }

        $scope.reloadData = function () {
          $scope.options && $scope.options.retrieveItemsAsync && $scope.updateItemsAsync();
        }, $scope.dataRenderedEvent = function (event) {
          $scope.onDataRendered && $scope.onDataRendered(), event.stopPropagation();
        }, $scope.contextMenuOptions = {
          placement: "bottom-right"
        }, $scope.initGroupActionsMenu = function () {
          $scope.options._FilteredGroupActionMenu = $filter("filterByMenu")($scope.options.actionMenus, $scope.options.groupActionMenus);
        }, $scope.init = function () {
          $scope.options && (void 0 === $scope.options.showHeader && ($scope.options.showHeader = !0), void 0 === $scope.options.showHeaderWhenNoData && ($scope.options.showHeaderWhenNoData = !0), $scope.initGroupActionsMenu(), $scope.options.sortable && ($scope.options.dragSort || $scope.options.orderInput) && ($scope.options.sortable = !1, $scope.options.dragSort = !1, $scope.options.orderInput = !1, console.log("Configuration conflict: Table: Sortable & DragSort Can't Be Enabled At Same Time")), function () {
            $scope.colCount = 0, void 0 !== $scope.options.rowTemplate && void 0 === $scope.options.altRowTemplate ? ($scope.colMode = "tpl-row", $scope.colCount += 1) : void 0 !== $scope.options.rowTemplate && void 0 !== $scope.options.altRowTemplate ? ($scope.colMode = "tpl-row-alt", $scope.colCount += 1) : ($scope.colMode = "td", $scope.options.columns && ($scope.colCount += $scope.options.columns.length), $scope.options.actionMenus && ($scope.colCount += $scope.options.actionMenus.length));
            $scope.colCount += $scope.options.dragSort ? 1 : 0, $scope.colCount += $scope.options.orderInput ? 1 : 0, $scope.options.checkBox && "none" != $scope.options.checkBox.toLowerCase() && $scope.colCount++;
          }(), $scope.options.retrieveItemsAsync && (void 0 === $scope.options.retrieveItemsAsyncOnload || $scope.options.retrieveItemsAsyncOnload) && $scope.updateItemsAsync());
        }, $scope.destroy = function () {
          $timeout.cancel(retrieveTimeout);
        }, $scope.toggleCheckbox = function (index, check) {
          for (var i = 0; i < $scope.localItems.length; i++) {
            if (i === index) {
              var newCheck;
              newCheck = void 0 !== check ? check : !$scope.localItems[i].$tbState._Checked, $scope.localItems[i].$tbState._Checked != newCheck && ($scope.localItems[i].$tbState._Checked = newCheck, $scope.toggleCheck(i));
              break;
            }
          }
        }, $scope.requestBatchDelay = 50, $scope.updateItemsAsync = function () {
          $scope.options && $scope.options.retrieveItemsAsync && (!0 !== $scope.options.autoShowMask && void 0 !== $scope.options.autoShowMask || ($scope.options.showMask = !0), $timeout.cancel(retrieveTimeout), retrieveTimeout = $timeout($scope.executeRetrieveItemsAsync, $scope.requestBatchDelay));
        }, $scope.executeRetrieveItemsAsync = function () {
          $scope.isRetrievingItemsAsyc = !0;
          var queryCriteria = {
            sortBy: $scope.options.sortOrder,
            sortReverse: $scope.options.sortReverse,
            currentPage: 1
          };
          $scope.options.paging && $scope.options.paging.itemsPerPage && (queryCriteria.itemsPerPage = $scope.options.paging.itemsPerPage, queryCriteria.limit = $scope.options.paging.itemsPerPage), $scope.options.paging && $scope.options.paging.currentPage && (queryCriteria.currentPage = $scope.options.paging.currentPage), $scope.options.retrieveItemsAsync(queryCriteria).then(updateItemsAsyncSuccess, updateItemsAsyncFail);
        }, $scope.showPaging = function () {
          return !(!$scope.options || !$scope.options.paging) && !!$scope.totalItems && !!($scope.options.paging && $scope.options.paging.currentPage && $scope.options.paging.itemsPerPage) && !($scope.totalItems <= $scope.options.paging.itemsPerPage);
        }, $scope.pageChanged = function (newPage) {
          return $scope.options && $scope.options.retrieveItemsAsync ? $scope.updateItemsAsync() : updateNgLimits(), !0;
        }, $scope.itemsUpdated = function () {
          $scope.updateLocalItems();
        }, $scope.updateLocalItems = function () {
          $scope.items ? $scope.localItems = $scope.items : $scope.localItems = [], $scope.checkCount = 0, $scope.checkAll.value = !1, $scope.ngStartIndex = null, $scope.ngLimit = null, $scope.options && !$scope.options.retrieveItemsAsync && ($scope.totalItems = $scope.localItems.length, updateNgLimits()), $scope.options && ($scope.options.dragSort || $scope.options.orderInput) && $scope.assignSortOrder($scope.localItems);
          var id = 0;
          $scope.localItems.forEach(function (item) {
            item.$tbState || (item.$tbState = {}), item.$tbState._FilteredActionMenu = $filter("filterByMenu")($scope.options.actionMenus, item._ActionMenu), item.$tbState._Id = id++, void 0 != item.isSelectable && (item._selectable = item.isSelectable), void 0 != item.isSelected && (item._selected = item.isSelected), !0 === item._selected ? item.$tbState._Checked = !0 : item.$tbState._Checked = !1, item.id ? item.$tbState.$id = item.id : item.Id ? item.$tbState.$id = item.Id : item.$tbState.$id = item.$tbState._Id;
          }), updateCheckCount();
        }, $scope.getItems = function () {
          return $scope.items ? $scope.items : [];
        }, $scope.sortByColumn = function (column) {
          if ($scope.options.sortable && (void 0 === column.sortable || column.sortable)) {
            var columnName = "";
            if (columnName = void 0 !== column.sortBy ? column.sortBy : column.name, $scope.options.sortOrder == columnName ? $scope.options.sortReverse = !$scope.options.sortReverse : ($scope.options.sortOrder = columnName, $scope.options.sortReverse = !0), $scope.options && $scope.options.retrieveItemsAsync) $scope.updateItemsAsync();else {
              for (var customSortFunction, i = 0; i < $scope.options.columns.length; i++) {
                $scope.options.columns[i].name === $scope.options.sortOrder && void 0 !== $scope.options.columns[i].customSort && (customSortFunction = $scope.options.columns[i].customSort);
              }

              $scope.localItems = void 0 !== customSortFunction ? $filter("orderBy")($scope.localItems, $scope.options.sortOrder, !1, customSortFunction) : $filter("orderBy")($scope.localItems, $scope.options.sortOrder, $scope.options.sortReverse);
            }
            $scope.onSortableClicked && $scope.onSortableClicked({
              sortColumn: $scope.options.sortOrder,
              reverse: $scope.options.sortReverse
            });
          }
        }, $scope.toggleCheckAll = function (check) {
          $scope.checkAll.value = void 0 === check ? !$scope.checkAll.value : check, $scope.toggleCheckAllUpdated();
        }, $scope.toggleCheckAllUpdated = function ($event) {
          var i = null;

          if ($scope.checkAll.value) {
            if (void 0 !== $scope.options.maxSelection && $scope.checkCount == $scope.options.maxSelection) return;

            for ($scope.checkCount = 0, i = 0; i < $scope.localItems.length && (!1 === $scope.localItems[i]._selectable || ($scope.localItems[i].$tbState._Checked || ($scope.localItems[i].$tbState._Checked = !0), $scope.checkCount++, void 0 === $scope.options.maxSelection || $scope.checkCount != $scope.options.maxSelection)); i++) {
              ;
            }
          } else for ($scope.checkCount = 0, i = 0; i < $scope.localItems.length; i++) {
            !1 !== $scope.localItems[i]._selectable && ($scope.localItems[i].$tbState._Checked = !1);
          }

          $event && $scope.onCheckAllClick && $scope.onCheckAllClick({
            checked: $scope.checkAll.value
          });
        };
        var pendingUpdateToCheckCount = !1;
        $scope.toggleCheck = function (index, $event) {
          void 0 !== index && $scope.localItems[index].$tbState._Checked && void 0 !== $scope.options.maxSelection && $scope.checkCount >= $scope.options.maxSelection ? $scope.localItems[index].$tbState._Checked = !1 : (pendingUpdateToCheckCount = !0, $scope.$evalAsync(function () {
            pendingUpdateToCheckCount && (updateCheckCount(), pendingUpdateToCheckCount = !1), $event && $scope.onCheckBoxItemClick && $scope.onCheckBoxItemClick({
              target: $scope.localItems[index],
              value: $scope.localItems[index].$tbState._Checked
            });
          }));
        }, $scope.showCheckAll = function () {
          $scope.isCheckAllVisible = !0;
        }, $scope.hideCheckAll = function () {
          $scope.isCheckAllVisible = !1;
        }, $scope.showCheckBox = function (index) {
          $scope.isCheckBoxVisible[index] = !0;
        }, $scope.hideCheckBox = function (index) {
          $scope.isCheckBoxVisible[index] = !1;
        }, $scope.actionMenuItemClick = function (target, value) {
          $timeout(function () {
            if ($scope.onActionMenuItemClick) {
              var p = $scope.onActionMenuItemClick({
                target: target,
                value: value
              });
              p && p.then && p.then($scope.updateLocalItems);
            }
          });
        }, $scope.groupActionMenuItemClick = function (target, value) {
          $timeout(function () {
            if ($scope.onGroupActionMenuItemClick) {
              var checkedItems = $scope.getCheckedItems(),
                  p = $scope.onGroupActionMenuItemClick({
                target: checkedItems,
                value: value
              });
              p && p.then && p.then($scope.updateLocalItems);
            }
          });
        }, $scope.getCheckedItems = function (includeUnselectable) {
          for (var checkedItems = [], i = 0; i < $scope.localItems.length; i++) {
            (!1 !== $scope.localItems[i]._selectable || includeUnselectable) && !0 === $scope.localItems[i].$tbState._Checked && checkedItems.push($scope.localItems[i]);
          }

          return checkedItems;
        }, $scope.checkBoxItemClick = function (target, value) {
          $timeout(function () {
            $scope.onCheckBoxItemClick && $scope.onCheckBoxItemClick({
              target: target,
              value: value
            });
          });
        }, $scope.updateSortOrder = function (item, newValue) {
          var oldValue = -1;
          newValue = parseInt(newValue);

          for (var i = 0; i < $scope.localItems.length; i++) {
            if (item === $scope.localItems[i]) {
              oldValue = $scope.options && $scope.options.retrieveItemsAsync ? i + ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage : i;
              break;
            }
          }

          if (-1 !== oldValue) {
            var extractedItem;

            if (oldValue == newValue - 1 && console.log("Sort order did not change"), $scope.options && $scope.options.retrieveItemsAsync) {
              newValue > $scope.totalItems ? newValue = $scope.totalItems : newValue <= 0 && (newValue = 1);
              var localOldValueIndex = oldValue - ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage,
                  localNewValueIndex = newValue - ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage;
              extractedItem = $scope.localItems.splice(localOldValueIndex, 1), localNewValueIndex >= 0 && extractedItem.length > 0 && localNewValueIndex <= $scope.localItems.length + 1 && $scope.localItems.splice(localNewValueIndex - 1, 0, extractedItem[0]);
            } else newValue > $scope.localItems.length ? newValue = $scope.localItems.length : newValue <= 0 && (newValue = 1), (extractedItem = $scope.localItems.splice(oldValue, 1)).length > 0 && newValue <= $scope.localItems.length + 1 && $scope.localItems.splice(newValue - 1, 0, extractedItem[0]);

            $timeout(function () {
              $scope.assignSortOrder($scope.localItems), $scope.onSortOrderChanged && $scope.onSortOrderChanged({
                item: item,
                newValue: newValue,
                oldValue: oldValue + 1
              });
            });
          } else console.warn("Unable to find previous value");
        }, $scope.refreshSortOrder = function () {
          $scope.assignSortOrder($scope.localItems);
        }, $scope.onSortOrderPress = function (event) {
          var key = event.which || event.charCode || event.keyCode;
          (key < 48 || key > 57) && event.preventDefault();
        }, $scope.onSortOrderPaste = function (event) {
          (function (value) {
            var x;
            if (isNaN(value)) return !1;
            return (0 | (x = parseFloat(value))) === x;
          })(event.originalEvent.clipboardData.getData("text/plain")) || event.preventDefault();
        }, $scope.dndMoved = function (index, item) {
          var oldValue = index,
              newValue = insertIndex;
          insertIndex > index ? oldValue += 1 : newValue += 1;
          var movedItem = $scope.localItems[insertIndex];
          $scope.localItems.splice(index, 1), $scope.onMove && newValue !== oldValue && $scope.onMove({
            item: movedItem,
            newValue: newValue,
            oldValue: oldValue
          });
        }, $scope.dndInserted = function (index, external, type) {
          insertIndex = index, $timeout(function () {
            $scope.assignSortOrder($scope.localItems);
          }, 10);
        }, $scope.assignSortOrder = function (items) {
          var sortOrder = 1;
          $scope.options && $scope.options.retrieveItemsAsync && (sortOrder += ($scope.options.paging.currentPage - 1) * $scope.options.paging.itemsPerPage), items.forEach(function (item) {
            item.$tbState || (item.$tbState = {}), item.$tbState._SortOrder = sortOrder++;
          });
        };
      }]
    };
  }), app.filter("filterByMenu", function () {
    return function (menuGroups, itemMenus) {
      var menuHeaders = [];

      if (itemMenus && itemMenus.constructor === Array) {
        if (!(itemMenus.length > 0)) return itemMenus;
        if ("string" != typeof itemMenus[0]) return itemMenus;
        menuHeaders = itemMenus;
      } else itemMenus && itemMenus.length > 0 && (menuHeaders = itemMenus.split(",").map(function (item) {
        return item.trim();
      }));

      var menus = [];
      if (menuGroups && menuGroups.length > 0 && menuHeaders.length > 0) for (var i = 0; i < menuHeaders.length; i++) {
        for (var k = 0; k < menuGroups.length; k++) {
          if (menuHeaders[i] === menuGroups[k].header) {
            menus.push(menuGroups[k]);
            break;
          }
        }
      }
      return menus;
    };
  });
}();

var TextEditorImageInput = function (_Handsontable$editors) {
  function TextEditorImageInput() {
    return _Handsontable$editors.apply(this, arguments) || this;
  }

  _inheritsLoose(TextEditorImageInput, _Handsontable$editors);

  var _proto = TextEditorImageInput.prototype;
  return _proto.createElements = function () {
    _Handsontable$editors.prototype.createElements.call(this), this.TEXTAREA = $('<input type="text"/>')[0], this.TEXTAREA.className = "handsontableInput", this.textareaStyle = this.TEXTAREA.style, this.textareaStyle.display = "none", Handsontable.dom.empty(this.TEXTAREA_PARENT), this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
  }, _proto.open = function () {
    _Handsontable$editors.prototype.open.call(this);

    var editor = this,
        fileInput = $("<input/>"),
        img = null;

    function updateCellValue(value) {
      editor.instance.setDataAtCell(editor.row, editor.col, value), editor.close();
    }

    function svgImgToDataUrl(event) {
      var response = event.target.responseText;
      updateCellValue("data:image/svg+xml;base64," + window.btoa(response));
    }

    function canvasImgToDataUrl() {
      var contentRatio = img.width / img.height,
          max_width = 350,
          max_height = 350;
      editor.instance._editorOptions && (editor.instance._editorOptions.maxImageWidth && (max_width = editor.instance._editorOptions.maxImageWidth), editor.instance._editorOptions.maxImageHeight && (max_height = editor.instance._editorOptions.maxImageHeight));
      var canvasWidth = img.width,
          canvasHeight = img.height;
      canvasWidth > max_width && (canvasWidth = max_width), canvasHeight > max_height && (canvasHeight = max_height), contentRatio > canvasWidth / canvasHeight ? (canvasWidth = canvasWidth, canvasHeight /= contentRatio) : (canvasWidth = canvasHeight * contentRatio, canvasHeight = canvasHeight);
      var canvas = $("<canvas></canvas>")[0];
      canvas.width = canvasWidth, canvas.height = canvasHeight;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);

      for (var data = ctx.getImageData(0, 0, canvasWidth, canvasHeight).data, hasTransparency = !1, i = 0; i < data.length; i += 4) {
        if (data[i + 3] < 255) {
          hasTransparency = !0;
          break;
        }
      }

      updateCellValue(hasTransparency ? canvas.toDataURL("image/png") : canvas.toDataURL("image/jpeg", .85));
    }

    fileInput[0].type = "file", fileInput[0].onchange = function handleFiles(e) {
      fileInput[0].removeEventListener("change", handleFiles, !1), fileInput.remove();
      var url = (window.webkitURL || window.URL).createObjectURL(e.target.files[0]);

      if ("image/svg+xml" == e.target.files[0].type) {
        var request = new XMLHttpRequest();
        request.open("GET", url), request.addEventListener("load", svgImgToDataUrl), request.send();
      } else (img = new Image()).onload = canvasImgToDataUrl, img.src = url;
    }, fileInput.css("display", "none"), $("body")[0].appendChild(fileInput[0]), setTimeout(function () {
      fileInput.click();
    }, 250);
  }, TextEditorImageInput;
}(Handsontable.editors.TextEditor);

!function ($angular) {
  $angular.module("core.ui").directive("asuiTableEditor", function () {
    return {
      restrict: "EA",
      templateUrl: "component-tableeditor/tableeditor.template",
      scope: {
        options: "=?",
        validation: "=?",
        onApiReady: "&",
        onValidityCheck: "&"
      },
      link: function link(scope, element) {
        element.on("$destroy", scope.destroy), scope.api = {
          initTable: scope.initTable,
          getModel: scope.getModel,
          render: scope.render,
          clearData: scope.clearData
        }, scope.onApiReady && scope.onApiReady({
          api: scope.api
        });
      },
      controller: function controller($scope, $element, $timeout) {
        var hot = null,
            model = null,
            maxRows = 1 / 0,
            isInit = !1,
            initTimer = 0;

        function imageRenderer(instance, td, row, col, prop, value, cellProperties) {
          if (null == value || "string" != typeof value) return null;

          if (0 === value.indexOf("http") && (value = Handsontable.helper.stringify(value)), 0 === value.indexOf("data:image/") || 0 === value.indexOf("http")) {
            var img = $("<div/>");
            img.addClass("cell-image"), img.css("background-image", "url(" + value + ")"), Handsontable.dom.addEvent(img[0], "mousedown", function (e) {
              e.preventDefault();
            }), $(td).css("cursor", "pointer"), Handsontable.dom.empty(td), td.appendChild(img[0]);
          } else {
            var label = $("<span></span");
            label.text("+"), label.addClass("cell-image-add"), label.attr("align", "center"), label.css("cursor", "pointer"), Handsontable.dom.empty(td), td.appendChild(label[0]);
          }

          return td;
        }

        function updateCellType(instance, row, col, type) {
          instance.setDataAtCell(row, col, "");
          var cellMeta = instance.getCellMeta(row, col);

          switch (cellMeta.type = type, type) {
            case "image":
              cellMeta.renderer = imageRenderer, cellMeta.editor = TextEditorImageInput;
              break;

            default:
              cellMeta.renderer = type, cellMeta.editor = type;
          }

          instance.setCellMeta(row, col, cellMeta), instance.setDataAtCell(row, col, "");
        }

        function updateCellsType(instance, typeString, selectedRanges) {
          if (1 == selectedRanges.length) {
            typeString = typeString.replace("type:", "");

            for (var selectedRange = selectedRanges[0], selectedRowCount = selectedRange.start.row - selectedRange.end.row + 1, i = selectedRange.start.row; i <= selectedRange.end.row; i++) {
              instance.getCellMeta(i, selectedRange.start.col).type != typeString && updateCellType(instance, i, selectedRange.start.col, typeString);
            }

            1 == selectedRowCount && (instance.selectCell(selectedRange.start.row, selectedRange.start.col), instance.getActiveEditor().beginEditing());
          }
        }

        function canUpdateSelectedCellType(instance, type) {
          var selectedRanges = instance.getSelectedRange();
          if (1 != selectedRanges.length) return !1;
          var selectedRange = selectedRanges[0],
              selectedRowCount = selectedRange.to.row - selectedRange.from.row + 1;
          if (1 != selectedRange.to.col - selectedRange.from.col + 1 || 1 != selectedRowCount) return !1;

          if ($scope.options && $scope.options.columns) {
            var colSettings = $scope.options.columns[selectedRange.to.col];
            if (colSettings && colSettings.type != type) return !1;
          }

          return !0;
        }

        function afterHotTableChange(changes, source) {
          "loadData" !== source && hot.validateCells(function (valid) {
            $scope.onValidityCheck && $scope.onValidityCheck({
              valid: valid,
              changes: changes
            });
          });
        }

        $scope.destroy = function () {
          initTimer && $timeout.cancel(initTimer), null != hot && (hot.destroy(), hot = null);
        }, $scope.initTable = function (m) {
          var excludePlaceholder = !1;
          isInit = !0, m && m.length > 0 && (excludePlaceholder = !0), m && 0 == m.length && (m = null), model = $angular.copy(m), function () {
            if ($scope.validation) {
              var v = $scope.validation;
              v.maxRows && (maxRows = v.maxRows);
            }
          }(), function () {
            if (model && model.length > maxRows) {
              var deleteCount = model.length - maxRows;
              model.splice(maxRows, deleteCount);
            }
          }(), function () {
            if (!model || 0 == model.length) return;
            var colFormatLookup = {};
            if ($scope.options && $scope.options.columns) for (var i = 0; i < $scope.options.columns.length; i++) {
              var c = $scope.options.columns[i];
              c.format && (colFormatLookup[c.name] = c.format);
            }
            model.forEach(function (row) {
              for (var colName in row) {
                var col = row[colName];
                col instanceof Date && (row[colName] = moment(col).format(colFormatLookup[colName] ? colFormatLookup[colName] : "MM/DD/YYYY"));
              }
            });
          }(), null != hot && (hot.destroy(), hot = null), function (excludePlaceholder) {
            var container = $element.find(".table-container")[0],
                colHeaders = [],
                columns = [],
                dataSchema = {},
                contextMenu = !0;

            if (Handsontable.cellTypes.registerCellType("image", {
              editor: TextEditorImageInput,
              renderer: imageRenderer
            }), $scope.options) {
              var hotCustomOptions = {};

              for (var key in $scope.options) {
                var value = $scope.options[key];

                switch (key) {
                  case "columns":
                    for (var i = 0; i < $scope.options.columns.length; i++) {
                      var c = $scope.options.columns[i];
                      colHeaders.push(c.label), dataSchema[c.name] = null;
                      var col = {
                        data: c.name,
                        type: c.type
                      };

                      switch (c.type) {
                        case "date":
                          col.dateFormat = c.format, col.correctFormat = !0;
                          break;

                        case "dropdown":
                          col.source = c.options, col.allowInvalid = !1;
                          break;

                        case "autocomplete":
                          col.source = c.options, col.strict = c.strict;
                          break;

                        default:
                          col.format = c.format;
                      }

                      if (c.placeholder && (col.placeholder = c.placeholder), c.horizontalAlign && c.horizontalAlign.length > 0) {
                        var className = "htLeft";

                        switch (c.horizontalAlign) {
                          case "left":
                            className = "htLeft";
                            break;

                          case "center":
                            className = "htCenter";
                            break;

                          case "right":
                            className = "htRight";
                            break;

                          case "justify":
                            className = "htJustify";
                        }

                        col.className = className;
                      }

                      columns.push(col);
                    }

                    break;

                  case "contextMenu":
                    contextMenu = value;
                    break;

                  default:
                    hotCustomOptions[key] = value;
                }
              }
            }

            !0 === contextMenu && (contextMenu = function () {
              var contextMenu = {
                items: {}
              };
              contextMenu.items.upload = {
                name: "Upload Image",
                key: "image",
                callback: function callback(typeString, selectedRanges) {
                  updateCellsType(this, typeString, selectedRanges);
                },
                disabled: function disabled() {
                  return !canUpdateSelectedCellType(this, "image");
                }
              }, $scope.options && $scope.options.columns || (contextMenu.items.text = {
                name: "Set Text",
                key: "text",
                callback: function callback(typeString, selectedRanges) {
                  updateCellsType(this, typeString, selectedRanges);
                },
                disabled: function disabled() {
                  return !canUpdateSelectedCellType(this, "text");
                }
              });
              return contextMenu.items.hsep1 = "---------", contextMenu.items.row_above = {}, contextMenu.items.row_below = {}, contextMenu.items.hsep2 = "---------", contextMenu.items.col_left = {}, contextMenu.items.col_right = {}, contextMenu.items.hsep3 = "---------", contextMenu.items.remove_row = {}, contextMenu.items.remove_col = {}, contextMenu.items.hsep4 = "---------", contextMenu.items.undo = {}, contextMenu.items.redo = {}, contextMenu.items.hsep5 = "---------", contextMenu.items.alignment = {}, contextMenu.items.hsep6 = "---------", contextMenu.items.copy = {}, contextMenu.items.cut = {}, contextMenu;
            }());
            var hotOptions = {
              data: model,
              colHeaders: colHeaders,
              maxRows: maxRows,
              rowHeaders: !0,
              stretchH: "all",
              contextMenu: contextMenu,
              rowHeaderWidth: 30,
              afterChange: afterHotTableChange
            };

            for (var cOpt in hotCustomOptions) {
              hotOptions[cOpt] = hotCustomOptions[cOpt];
            }

            maxRows = hotOptions.maxRows, hotOptions.cells = function (row, col, val) {
              var cellPrp = {},
                  cell = this.instance.getDataAtCell(row, col);
              if (cell && "image" != cellPrp.type && "string" == typeof cell) 0 == cell.indexOf("data:image/") && (cellPrp.type = "image");else if (!excludePlaceholder && $scope.options.placeholders && $scope.options.placeholders[row]) {
                var p = $scope.options.placeholders[row][col];
                p && (cellPrp.placeholder = p);
              }
              return cellPrp;
            }, columns.length > 0 && (hotOptions.columns = columns, hotOptions.dataSchema = dataSchema);
            (hot = new Handsontable(container, hotOptions))._editorOptions = $scope.options;
          }(excludePlaceholder), imageRenderer(), hot.deselectCell();
        }, $scope.clearData = function () {
          if (hot) {
            var rowCount = hot.countRows(),
                colCount = hot.countCols();
            rowCount > 1 && colCount > 1 && hot.clear();
          }
        }, $scope.render = function () {
          if (hot) return hot.render();
        }, $scope.getModel = function () {
          var data = hot.getSourceData(),
              schema = hot.getSchema();

          if (!jQuery.isEmptyObject(schema) && data && schema.constructor != Array && data.length > 0 && data[0].constructor === Array) {
            var data2 = hot.getData();

            if (data2 && data2.length > 0) {
              data = [];

              for (var i = 0; i < data2.length; i++) {
                var source = data2[i],
                    d = {},
                    k = 0;

                for (var prop in schema) {
                  d[prop] = source[k++];
                }

                data.push(d);
              }
            }
          }

          return data = function (data) {
            if ($scope.options && $scope.options.columns && $scope.options.columns.length > 0) return data;
            var colLength = hot.countCols();
            if (0 == colLength) hot.alter("insert_col", 0, 1);else for (var emptyCols = hot.countEmptyCols(!0), i = 0; i < data.length; i++) {
              var row = data[i];
              row.length > 0 && row.splice(colLength - emptyCols, emptyCols);
            }
            return data;
          }(data = function (data) {
            var emptyRows = hot.countEmptyRows(!0);

            if (data.length > 0 && emptyRows > 0) {
              var startDelete = data.length - emptyRows;
              data.splice(startDelete, emptyRows);
            }

            return data;
          }(data));
        }, $scope.validation || ($scope.validation = {}), $scope.validation.fileextensions = [".xlsx"], !1 !== $scope.options.autoInitialize && (initTimer = $timeout(function () {
          initTimer = 0, isInit || $scope.initTable();
        }, 0));
      }
    };
  });
}(window.angular), window.angular.module("core.ui").directive("asuiTagsInput", function () {
  return {
    restrict: "EA",
    templateUrl: "component-tagsinput/tagsinput.template",
    scope: {
      model: "=",
      displayProperty: "@?",
      options: "=?",
      validationInProgress: "=?",
      placeholder: "@",
      autocompleteSettings: "=?",
      onTagAdding: "&",
      onTagRemoving: "&",
      onTagAdded: "&",
      onTagRemoved: "&",
      onInvalidTag: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$watch("autocompleteSettings", scope.initAutoComplete, !0), scope.$watch("options", scope.onOptionsUpdate, !0), scope.$watch("model", scope.onModelUpdate, !0), scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.init(), scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$location", "$element", "$q", "$interval", "$timeout", function ($scope, $location, $element, $q, $interval, $timeout) {
      $scope.init = !1, $scope.tagTemplate = "component-tagsinput/default-tag.template", $scope.autocompleteTemplate = "component-tagsinput/default-autocomplete.template", $scope.addFromAutocompleteOnly = !1, $scope.autocompleteMinLength = 0, $scope.autocompleteMaxResultsToShow = 50, $scope.currentProgress = 0, $scope.validationInProgress = !1, $scope.progressComplete = !0;
      var autocompleteData = null,
          tagsAdding = [],
          progressInterval = null,
          progressStartTimeout = null,
          asynRequestCount = 0,
          validationsCheckCount = 0,
          currentAutoCompleteRequestId = 0;

      function setTagsId(tags) {
        if (tags && tags.length) for (var j = 0; j < tags.length; j++) {
          var tag = tags[j];
          "string" == typeof tag ? ($scope.displayProperty = "text", tags[j] = {
            text: tag,
            id: tag
          }) : tag.Id ? tag.id = tag.Id : !tag.id && $scope.displayProperty && tag[$scope.displayProperty] && (tag.id = tag[$scope.displayProperty]);
        }
      }

      function stopProgress() {
        null !== progressStartTimeout && ($timeout.cancel(progressStartTimeout), progressStartTimeout = null), null !== progressInterval && ($interval.cancel(progressInterval), progressInterval = null), $scope.progressComplete = !0;
      }

      function startProgress() {
        stopProgress(), $scope.options.showProgress && (progressStartTimeout = $timeout(function () {
          $scope.progressComplete = !1, $scope.currentProgress = 1, progressInterval = $interval(function () {
            var increment = 1;
            $scope.currentProgress > 85 ? increment = .1 : $scope.currentProgress > 65 && (increment = .5), $scope.currentProgress += increment, $scope.currentProgress >= 100 && tryStopProgress();
          }, 16);
        }, 200));
      }

      function tryStopProgress() {
        0 == asynRequestCount && stopProgress();
      }

      function invalidateTag(tag, message) {
        tag.invalid = !0, tag.tooltip = message || ($scope.options.invalidTagMessage ? $scope.options.invalidTagMessage : "Invalid tag"), $scope.onInvalidTag && $scope.onInvalidTag({
          tag: tag
        });
      }

      function updateValidationInProgress() {
        validationsCheckCount <= 0 ? (validationsCheckCount = 0, $scope.validationInProgress = !1) : $scope.validationInProgress = !0;
      }

      function fireOnTagAdded(tag) {
        $scope.onTagAdded && $scope.onTagAdded({
          tag: tag
        });
      }

      function toggleTextboxVisibilty() {
        if ($scope.options.maxTags) {
          var elements = $element.find("input");

          if (elements && elements.length) {
            var txtboxEl = $(elements[0]);
            $scope.model.length >= $scope.options.maxTags ? txtboxEl.addClass("input-hidden") : txtboxEl.removeClass("input-hidden");
          }
        }
      }

      function isSameTag(t1, t2) {
        return t1.id || t2.id ? t1.id === t2.id : ($scope.displayProperty && (t1 = t1[$scope.displayProperty], t2 = t2[$scope.displayProperty]), t1 === t2);
      }

      function filterAutocompleteList(data, query) {
        return $.grep(data, function (val, key) {
          return $scope.displayProperty && (val = val[$scope.displayProperty]), val.match(new RegExp(query, "i"));
        });
      }

      function groupItems(items) {
        for (var groups = {}, noGroup = [], i = 0; i < items.length; i++) {
          var item = angular.copy(items[i]);

          if (item.group) {
            var group = groups[item.group];
            group ? group.push(item) : (item.header = item.group, groups[item.group] = [item]);
          } else noGroup.push(item);
        }

        var res = noGroup;

        for (var key in groups) {
          res = res.concat(groups[key]);
        }

        return res;
      }

      function isInt(value) {
        if (isNaN(value)) return !1;
        var x = parseFloat(value);
        return (0 | x) === x;
      }

      $scope.init = function () {
        $scope.options || ($scope.options = {}), $scope.init = !0;
      }, $scope.destroy = function () {
        stopProgress();
      }, $scope.onModelUpdate = function () {
        if ($scope.model && $scope.model.length > 0) {
          setTagsId($scope.model);

          for (var copy = angular.copy($scope.model), i = 0; i < copy.length; i++) {
            for (var t1 = copy[i], count = 0, k = $scope.model.length - 1; k >= 0; k--) {
              var t2 = $scope.model[k];
              (t2.id ? t2.id === t1.id : t2 === t1) && ++count > 1 && (console.log("Duplicate in tags input removed: ", t2), $scope.model.splice(k, 1));
            }
          }

          toggleTextboxVisibilty();
        }
      }, $scope.onOptionsUpdate = function () {
        $scope.options && ($scope.options.autocompleteTemplate && ($scope.autocompleteTemplate = $scope.options.autocompleteTemplate), $scope.options.tagTemplate && ($scope.tagTemplate = $scope.options.tagTemplate));
      }, $scope.focusOnTagInput = function () {
        var input = $($element).find("input");
        input.length > 0 && input[0].focus();
      }, $scope.tagAdded = function (tag) {
        if (tagsAdding = [], $scope.addFromAutocompleteOnly) fireOnTagAdded(tag);else if ($scope.options.checkInvalidTag) {
          if (tag.id) fireOnTagAdded(tag);else {
            if ($scope.options && $scope.options.validateTag) return startProgress(), asynRequestCount++, validationsCheckCount++, tag.validating = !0, updateValidationInProgress(), void $scope.options.validateTag(tag).then(function (res) {
              asynRequestCount--, validationsCheckCount--, delete tag.validating, updateValidationInProgress(), 1 == res.valid ? fireOnTagAdded(tag) : invalidateTag(tag, res.error), tryStopProgress();
            }, function (error) {
              validationsCheckCount--, asynRequestCount--, delete tag.validating, updateValidationInProgress(), invalidateTag(tag, error), tryStopProgress();
            });
            invalidateTag(tag);
          }
        } else tag.id || (tag.newTag = !0), fireOnTagAdded(tag);
        toggleTextboxVisibilty();
      }, $scope.tagRemoved = function (tag) {
        tag.validating && (validationsCheckCount--, asynRequestCount--, updateValidationInProgress(), tryStopProgress()), $scope.onTagRemoved && $scope.onTagRemoved({
          tag: tag
        }), toggleTextboxVisibilty();
      }, $scope.tagAdding = function (tag) {
        var i = null;

        if ($scope.addFromAutocompleteOnly && $scope.autocompleteSettings && $scope.autocompleteSettings.data) {
          var found = !1;

          for (i = 0; i < $scope.autocompleteSettings.data.length; i++) {
            if ($scope.autocompleteSettings.data[i].name.toLowerCase() == tag.name.toLowerCase()) {
              found = !0;
              break;
            }
          }

          if (!found) return !1;
        }

        if (tagsAdding.length) for (var k = 0; k < tagsAdding.length; k++) {
          if (isSameTag(tagsAdding[k], tag)) return !1;
        }

        if ($scope.model) {
          for (i = 0; i < $scope.model.length; i++) {
            if (isSameTag($scope.model[i], tag)) return !1;
          }

          if ($scope.model.length + tagsAdding.length >= $scope.options.maxTags) return !1;
        }

        tagsAdding.push(tag), $scope.onTagAdding && $scope.onTagAdding({
          tag: tag
        });
      }, $scope.tagRemoving = function (tag) {
        if (!0 === tag.readOnly) return !1;
      }, $scope.initAutoComplete = function () {
        var settings = $scope.autocompleteSettings;

        if (settings) {
          var acOnly = settings.addFromAutocompleteOnly;
          acOnly && !0 === acOnly && ($scope.addFromAutocompleteOnly = acOnly), setTagsId(autocompleteData = settings.data), isInt(settings.minLength) && ($scope.autocompleteMinLength = settings.minLength), isInt(settings.maxResultsToShow) && ($scope.autocompleteMaxResultsToShow = settings.maxResultsToShow);
        }
      }, $scope.loadAutocompleteList = function (query) {
        var defer = $q.defer();

        if ($scope.autocompleteSettings && $scope.autocompleteSettings.source) {
          startProgress(), asynRequestCount++;
          var activeId = ++currentAutoCompleteRequestId;
          $scope.autocompleteSettings.source(query).then(function (data) {
            if (asynRequestCount--, activeId !== currentAutoCompleteRequestId) return defer.reject(), void tryStopProgress();
            var res = filterAutocompleteList(data, query);
            res = groupItems(res), defer.resolve(res), tryStopProgress();
          }, function () {
            asynRequestCount--, defer.reject(), tryStopProgress();
          });
        } else if (autocompleteData && autocompleteData.length > 0) {
          var res = filterAutocompleteList(autocompleteData, query);
          res = groupItems(res), defer.resolve(res);
        }

        return defer.promise;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiThumbnailUpload", function () {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: function templateUrl($element, $attrs) {
      return {
        content: "component-thumbnailupload/thumbnailupload.template",
        channels: "component-thumbnailupload/thumbnailuploadchannels.template"
      }[$attrs.template];
    },
    scope: {
      customThumbnailUrl: "@",
      defaultThumbnailUrl: "@",
      customFilename: "@",
      basePath: "@",
      options: "=?",
      validation: "=?",
      targetUrl: "@",
      onApiReady: "&",
      onComplete: "&",
      onError: "&",
      onDelete: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("customThumbnailUrl", scope.onThumbnailUrlUpdate), scope.$watch("defaultThumbnailUrl", scope.onThumbnailUrlUpdate), scope.api = {}, scope.init(), scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", "$compile", function ($scope, $location, $element, $timeout, $compile) {
      $scope.uploadOptions = {}, $scope.uploadValidation = {
        fileTypes: ["image"]
      }, $scope.fileList = [], $scope.firstInitialize = !1, $scope.thumbnailUrl = null, $scope.showDefaultText = !0;
      var fileUploadApi = null;
      $scope.init = function () {
        !function () {
          $scope.options || ($scope.options = {}), $scope.options.defaultText || ($scope.options.defaultText = "A default thumbnail screenshot will be generated when you save your content."), $scope.validation || ($scope.validation = {});
          var v = $scope.validation;
          v.fileExtensions || (v.fileTypes = ["image"]), $scope.uploadOptions.maxFiles = 1, $scope.uploadOptions.autoReplace = !0, $scope.uploadOptions.extraText = $scope.options.uploadExtraText ? $scope.options.uploadExtraText : "custom thumbnail", $scope.uploadOptions.dropText = "", $scope.uploadOptions.browseText = $scope.options.uploadBrowseText ? $scope.options.uploadBrowseText : "Upload", $scope.uploadOptions.customFilename = $scope.customFilename || "_customthumbnail";
        }();
      }, $scope.destroy = function () {}, $scope.onFileUploadApiReady = function (api) {
        fileUploadApi = api, $scope.onThumbnailUrlUpdate();
      }, $scope.onThumbnailUrlUpdate = function () {
        if ($scope.customThumbnailUrl) {
          $scope.thumbnailUrl = $scope.customThumbnailUrl;
          var filename = $scope.uploadOptions.customFilename;
          $scope.fileList.push({
            originalName: filename,
            file: $scope.customThumbnailUrl,
            path: $scope.customThumbnailUrl
          }), fileUploadApi.addExistingFiles(), $scope.showDefaultText = !1;
        } else $scope.thumbnailUrl = $scope.defaultThumbnailUrl, $scope.thumbnailUrl && 0 !== $scope.thumbnailUrl.length || $timeout(function () {
          $scope.firstInitialize = !0, $scope.showDefaultText = !0;
        });
      }, $scope.getThumbnailClass = function () {
        if (!$scope.customThumbnailUrl && $scope.thumbnailUrl && -1 != $scope.thumbnailUrl.indexOf("images/content-type")) return "as-thumbnail-default";
      }, $scope.onUploadComplete = function (file, value) {
        var url = "";
        $scope.basePath && $scope.basePath.length > 0 && (url = $scope.basePath, $scope.basePath.endsWith("/") || (url += "/")), url += value, $scope.showDefaultText = !1, $timeout(function () {
          $scope.customThumbnailUrl = $scope.thumbnailUrl = url + "?t=" + new Date().getTime(), $scope.onComplete && $scope.onComplete({
            file: url
          });
        });
      }, $scope.onUploadError = function (file, message) {
        $scope.onError && $scope.onError({
          file: file
        });
      }, $scope.onUploadDelete = function (file) {
        $timeout(function () {
          $scope.firstInitialize ? ($scope.thumbnailUrl = null, $scope.showDefaultText = !0) : ($scope.thumbnailUrl = $scope.defaultThumbnailUrl, $scope.thumbnailUrl && 0 !== $scope.thumbnailUrl.length || ($scope.showDefaultText = !0));
        }, 300), $scope.onDelete && $scope.onDelete({
          file: file
        });
      };
    }]
  };
}), function ($angular) {
  var angular = window.angular;
  angular.module("core.ui").factory("timeZoneHelper", function () {
    var _tzFull = [];
    !function () {
      for (var names = moment.tz.names(), i = 0; i < names.length; i++) {
        var name = names[i],
            zone = moment.tz.zone(name),
            abbr = zone.abbrs[0],
            gmtOffset = moment.tz(name).format("Z"),
            offset = moment.duration(gmtOffset).asHours(),
            displayName = name.split("_").join(" ");
        displayName = "(GMT" + gmtOffset + ") " + displayName, _tzFull.push({
          label: displayName,
          value: name,
          timezone: name,
          offset: offset,
          abbr: abbr
        });
      }

      _tzFull.sort(function (a, b) {
        return a.offset < b.offset ? -1 : a.offset > b.offset ? 1 : 0;
      });
    }();
    var _tzStandard = [{
      value: "Dateline Standard Time",
      abbr: "DST",
      offset: -12,
      isdst: !1,
      label: "(GMT-12:00) International Date Line West",
      timezone: "Pacific/Wallis"
    }, {
      value: "UTC-11",
      abbr: "U",
      offset: -11,
      isdst: !1,
      label: "(GMT-11:00) Coordinated Universal Time",
      timezone: "Pacific/Pago_Pago"
    }, {
      value: "Hawaiian Standard Time",
      abbr: "HST",
      offset: -10,
      isdst: !1,
      label: "(GMT-10:00) Hawaii",
      timezone: "US/Hawaii"
    }, {
      value: "Alaskan Standard Time",
      abbr: "AKDT",
      offset: -9,
      isdst: !0,
      label: "(GMT-09:00) Alaska",
      timezone: "US/Alaska"
    }, {
      value: "Pacific Standard Time (Mexico)",
      abbr: "PDT",
      offset: -8,
      isdst: !0,
      label: "(GMT-08:00) Baja California",
      timezone: "America/Pacific"
    }, {
      value: "Pacific Standard Time",
      abbr: "PDT",
      offset: -8,
      isdst: !0,
      label: "(GMT-08:00) Pacific Time (US & Canada)",
      timezone: "America/Pacific"
    }, {
      value: "US Mountain Standard Time",
      abbr: "UMST",
      offset: -7,
      isdst: !1,
      label: "(GMT-07:00) Arizona",
      timezone: "America/Mountain"
    }, {
      value: "Mountain Standard Time (Mexico)",
      abbr: "MDT",
      offset: -7,
      isdst: !0,
      label: "(GMT-07:00) Chihuahua, La Paz, Mazatlan",
      timezone: "America/Chihuahua"
    }, {
      value: "Mountain Standard Time",
      abbr: "MDT",
      offset: -7,
      isdst: !0,
      label: "(GMT-07:00) Mountain Time (US & Canada)",
      timezone: "US/Mountain"
    }, {
      value: "Central America Standard Time",
      abbr: "CAST",
      offset: -6,
      isdst: !1,
      label: "(GMT-06:00) Central America",
      timezone: "America/Managua"
    }, {
      value: "Central Standard Time",
      abbr: "CDT",
      offset: -6,
      isdst: !0,
      label: "(GMT-06:00) Central Time (US & Canada)",
      timezone: "US/Central"
    }, {
      value: "Central Standard Time (Mexico)",
      abbr: "CDT",
      offset: -6,
      isdst: !0,
      label: "(GMT-06:00) Guadalajara, Mexico City, Monterrey",
      timezone: "America/Mexico_City"
    }, {
      value: "Canada Central Standard Time",
      abbr: "CCST",
      offset: -6,
      isdst: !1,
      label: "(GMT-06:00) Saskatchewan",
      timezone: "Canada/Saskatchewan"
    }, {
      value: "SA Pacific Standard Time",
      abbr: "SPST",
      offset: -5,
      isdst: !1,
      label: "(GMT-05:00) Bogota, Lima, Quito",
      timezone: "America/Lima"
    }, {
      value: "Eastern Standard Time",
      abbr: "EDT",
      offset: -5,
      isdst: !0,
      label: "(GMT-05:00) Eastern Time (US & Canada)",
      timezone: "US/Eastern"
    }, {
      value: "US Eastern Standard Time",
      abbr: "UEDT",
      offset: -5,
      isdst: !0,
      label: "(GMT-05:00) Indiana (East)",
      timezone: "US/East-Indiana"
    }, {
      value: "Venezuela Standard Time",
      abbr: "VST",
      offset: -4,
      isdst: !1,
      label: "(GMT-04:00) Caracas",
      timezone: "America/Caracas"
    }, {
      value: "Paraguay Standard Time",
      abbr: "PST",
      offset: -4,
      isdst: !1,
      label: "(GMT-04:00) Asuncion",
      timezone: "America/Santiago"
    }, {
      value: "Atlantic Standard Time",
      abbr: "ADT",
      offset: -4,
      isdst: !0,
      label: "(GMT-04:00) Atlantic Time (Canada)",
      timezone: "Canada/Atlantic"
    }, {
      value: "Central Brazilian Standard Time",
      abbr: "CBST",
      offset: -4,
      isdst: !1,
      label: "(GMT-04:00) Cuiaba",
      timezone: "America/Sao_Paulo"
    }, {
      value: "SA Western Standard Time",
      abbr: "SWST",
      offset: -4,
      isdst: !1,
      label: "(GMT-04:00) Georgetown, La Paz, Manaus, San Juan",
      timezone: "America/La_Paz"
    }, {
      value: "Pacific SA Standard Time",
      abbr: "PSST",
      offset: -4,
      isdst: !1,
      label: "(GMT-04:00) Santiago",
      timezone: "America/Santiago"
    }, {
      value: "Newfoundland Standard Time",
      abbr: "NDT",
      offset: -3.5,
      isdst: !0,
      label: "(GMT-03:30) Newfoundland",
      timezone: "Canada/Newfoundland"
    }, {
      value: "E. South America Standard Time",
      abbr: "ESAST",
      offset: -3,
      isdst: !1,
      label: "(GMT-03:00) Brasilia",
      timezone: "America/Sao_Paulo"
    }, {
      value: "Argentina Standard Time",
      abbr: "AST",
      offset: -3,
      isdst: !1,
      label: "(GMT-03:00) Buenos Aires",
      timezone: "America/Argentina/Buenos_Aires"
    }, {
      value: "SA Eastern Standard Time",
      abbr: "SEST",
      offset: -3,
      isdst: !1,
      label: "(GMT-03:00) Cayenne, Fortaleza",
      timezone: "America/Cayenne"
    }, {
      value: "Greenland Standard Time",
      abbr: "GDT",
      offset: -3,
      isdst: !0,
      label: "(GMT-03:00) Greenland",
      timezone: "America/Godthab"
    }, {
      value: "Montevideo Standard Time",
      abbr: "MST",
      offset: -3,
      isdst: !1,
      label: "(GMT-03:00) Montevideo",
      timezone: "America/Montevideo"
    }, {
      value: "Bahia Standard Time",
      abbr: "BST",
      offset: -3,
      isdst: !1,
      label: "(GMT-03:00) Salvador",
      timezone: "America/Montevideo"
    }, {
      value: "UTC-02",
      abbr: "U",
      offset: -2,
      isdst: !1,
      label: "(GMT-02:00) Coordinated Universal Time",
      timezone: "America/Godthab"
    }, {
      value: "Mid-Atlantic Standard Time",
      abbr: "MDT",
      offset: -2,
      isdst: !0,
      label: "(GMT-02:00) Mid-Atlantic",
      timezone: "America/Noronha"
    }, {
      value: "Azores Standard Time",
      abbr: "ADT",
      offset: -1,
      isdst: !0,
      label: "(GMT-01:00) Azores",
      timezone: "Atlantic/Azores"
    }, {
      value: "Cape Verde Standard Time",
      abbr: "CVST",
      offset: -1,
      isdst: !1,
      label: "(GMT-01:00) Cape Verde Is.",
      timezone: "Atlantic/Cape_Verde"
    }, {
      value: "Morocco Standard Time",
      abbr: "MDT",
      offset: 0,
      isdst: !0,
      label: "(GMT) Casablanca",
      timezone: "Africa/Casablanca"
    }, {
      value: "GMT",
      abbr: "CUT",
      offset: 0,
      isdst: !1,
      label: "(GMT) Coordinated Universal Time",
      timezone: "Etc/Greenwich"
    }, {
      value: "GMT Standard Time",
      abbr: "GDT",
      offset: 0,
      isdst: !0,
      label: "(GMT) Dublin, Edinburgh, Lisbon, London",
      timezone: "Europe/London"
    }, {
      value: "Greenwich Standard Time",
      abbr: "GST",
      offset: 0,
      isdst: !1,
      label: "(GMT) Monrovia, Reykjavik",
      timezone: "Africa/Monrovia"
    }, {
      value: "W. Europe Standard Time",
      abbr: "WEDT",
      offset: 1,
      isdst: !0,
      label: "(GMT+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
      timezone: "Europe/Amsterdam"
    }, {
      value: "Central Europe Standard Time",
      abbr: "CEDT",
      offset: 1,
      isdst: !0,
      label: "(GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague",
      timezone: "Europe/Budapest"
    }, {
      value: "Romance Standard Time",
      abbr: "RDT",
      offset: 1,
      isdst: !0,
      label: "(GMT+01:00) Brussels, Copenhagen, Madrid, Paris",
      timezone: "Europe/Paris"
    }, {
      value: "Central European Standard Time",
      abbr: "CEDT",
      offset: 1,
      isdst: !0,
      label: "(GMT+01:00) Sarajevo, Skopje, Warsaw, Zagreb",
      timezone: "Europe/Warsaw"
    }, {
      value: "W. Central Africa Standard Time",
      abbr: "WCAST",
      offset: 1,
      isdst: !1,
      label: "(GMT+01:00) West Central Africa",
      timezone: "Africa/Lagos"
    }, {
      value: "Africa/Windhoek",
      abbr: "NST",
      offset: 2,
      isdst: !1,
      label: "(GMT+02:00) Windhoek",
      timezone: "Africa/Windhoek"
    }, {
      value: "GTB Standard Time",
      abbr: "GDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) Athens, Bucharest",
      timezone: "Europe/Athens"
    }, {
      value: "Middle East Standard Time",
      abbr: "MEDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) Beirut",
      timezone: "Asia/Beirut"
    }, {
      value: "Egypt Standard Time",
      abbr: "EST",
      offset: 2,
      isdst: !1,
      label: "(GMT+02:00) Cairo",
      timezone: "Africa/Cairo"
    }, {
      value: "Syria Standard Time",
      abbr: "SDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) Damascus",
      timezone: "Asia/Damascus"
    }, {
      value: "E. Europe Standard Time",
      abbr: "EEDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) E. Europe",
      timezone: "Europe/London"
    }, {
      value: "South Africa Standard Time",
      abbr: "SAST",
      offset: 2,
      isdst: !1,
      label: "(GMT+02:00) Harare, Pretoria",
      timezone: "Africa/Harare"
    }, {
      value: "FLE Standard Time",
      abbr: "FDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius",
      timezone: "Europe/Helsinki"
    }, {
      value: "Israel Standard Time",
      abbr: "JDT",
      offset: 2,
      isdst: !0,
      label: "(GMT+02:00) Jerusalem",
      timezone: "Asia/Jerusalem"
    }, {
      value: "Libya Standard Time",
      abbr: "LST",
      offset: 2,
      isdst: !1,
      label: "(GMT+02:00) Tripoli",
      timezone: "Africa/Tripoli"
    }, {
      value: "Jordan Standard Time",
      abbr: "JST",
      offset: 2,
      isdst: !1,
      label: "(GMT+02:00) Amman",
      timezone: "Asia/Amman"
    }, {
      value: "Turkey Standard Time",
      abbr: "TDT",
      offset: 3,
      isdst: !0,
      label: "(GMT+03:00) Istanbul",
      timezone: "Europe/Istanbul"
    }, {
      value: "Arabic Standard Time",
      abbr: "AST",
      offset: 3,
      isdst: !1,
      label: "(GMT+03:00) Baghdad",
      timezone: "Asia/Baghdad"
    }, {
      value: "Europe/Minsk",
      abbr: "KST",
      offset: 3,
      isdst: !1,
      label: "(GMT+03:00) Kaliningrad, Minsk",
      timezone: "Europe/Minsk"
    }, {
      value: "Arab Standard Time",
      abbr: "AST",
      offset: 3,
      isdst: !1,
      label: "(GMT+03:00) Kuwait, Riyadh",
      timezone: "Asia/Kuwait"
    }, {
      value: "E. Africa Standard Time",
      abbr: "EAST",
      offset: 3,
      isdst: !1,
      label: "(GMT+03:00) Nairobi",
      timezone: "Africa/Nairobi"
    }, {
      value: "Russian Standard Time",
      abbr: "RST",
      offset: 3,
      isdst: !1,
      label: "(GMT+03:00) Moscow, St. Petersburg, Volgograd",
      timezone: "Europe/Moscow"
    }, {
      value: "Iran Standard Time",
      abbr: "IDT",
      offset: 3.5,
      isdst: !0,
      label: "(GMT+03:30) Tehran",
      timezone: "Asia/Tehran"
    }, {
      value: "Arabian Standard Time",
      abbr: "AST",
      offset: 4,
      isdst: !1,
      label: "(GMT+04:00) Abu Dhabi, Muscat",
      timezone: "Asia/Muscat"
    }, {
      value: "Azerbaijan Standard Time",
      abbr: "ADT",
      offset: 4,
      isdst: !0,
      label: "(GMT+04:00) Baku",
      timezone: "Asia/Baku"
    }, {
      value: "Mauritius Standard Time",
      abbr: "MST",
      offset: 4,
      isdst: !1,
      label: "(GMT+04:00) Port Louis",
      timezone: "Indian/Mauritius"
    }, {
      value: "Georgian Standard Time",
      abbr: "GST",
      offset: 4,
      isdst: !1,
      label: "(GMT+04:00) Tbilisi",
      timezone: "Asia/Tbilisi"
    }, {
      value: "Caucasus Standard Time",
      abbr: "CST",
      offset: 4,
      isdst: !1,
      label: "(GMT+04:00) Yerevan",
      timezone: "Asia/Yerevan"
    }, {
      value: "Afghanistan Standard Time",
      abbr: "AST",
      offset: 4.5,
      isdst: !1,
      label: "(GMT+04:30) Kabul",
      timezone: "Asia/Kabul"
    }, {
      value: "West Asia Standard Time",
      abbr: "WAST",
      offset: 5,
      isdst: !1,
      label: "(GMT+05:00) Ashgabat, Tashkent",
      timezone: "Asia/Tashkent"
    }, {
      value: "Pakistan Standard Time",
      abbr: "PST",
      offset: 5,
      isdst: !1,
      label: "(GMT+05:00) Islamabad, Karachi",
      timezone: "Asia/Karachi"
    }, {
      value: "Ekaterinburg Standard Time",
      abbr: "EST",
      offset: 5,
      isdst: !1,
      label: "(GMT+05:00) Ekaterinburg",
      timezone: "Asia/Yekaterinburg"
    }, {
      value: "India Standard Time",
      abbr: "IST",
      offset: 5.5,
      isdst: !1,
      label: "(GMT+05:30) Chennai, Kolkata, Mumbai, New Delhi",
      timezone: "Asia/Kolkata"
    }, {
      value: "Sri Lanka Standard Time",
      abbr: "SLST",
      offset: 5.5,
      isdst: !1,
      label: "(GMT+05:30) Sri Jayawardenepura",
      timezone: "Asia/Calcutta"
    }, {
      value: "Nepal Standard Time",
      abbr: "NST",
      offset: 5.75,
      isdst: !1,
      label: "(GMT+05:45) Kathmandu",
      timezone: "Asia/Katmandu"
    }, {
      value: "Central Asia Standard Time",
      abbr: "CAST",
      offset: 6,
      isdst: !1,
      label: "(GMT+06:00) Astana",
      timezone: "Asia/Dhaka"
    }, {
      value: "Bangladesh Standard Time",
      abbr: "BST",
      offset: 6,
      isdst: !1,
      label: "(GMT+06:00) Dhaka",
      timezone: "Asia/Dhaka"
    }, {
      value: "Myanmar Standard Time",
      abbr: "MST",
      offset: 6.5,
      isdst: !1,
      label: "(GMT+06:30) Yangon (Rangoon)",
      timezone: "Asia/Rangoon"
    }, {
      value: "SE Asia Standard Time",
      abbr: "SAST",
      offset: 7,
      isdst: !1,
      label: "(GMT+07:00) Bangkok, Hanoi, Jakarta",
      timezone: "Asia/Bangkok"
    }, {
      value: "N. Central Asia Standard Time",
      abbr: "NCAST",
      offset: 7,
      isdst: !1,
      label: "(GMT+07:00) Novosibirsk",
      timezone: "Asia/Novosibirsk"
    }, {
      value: "North Asia Standard Time",
      abbr: "NAST",
      offset: 7,
      isdst: !1,
      label: "(GMT+07:00) Krasnoyarsk",
      timezone: "Asia/Krasnoyarsk"
    }, {
      value: "China Standard Time",
      abbr: "CST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Beijing, Chongqing, Hong Kong, Urumqi",
      timezone: "Asia/Hong_Kong"
    }, {
      value: "Singapore Standard Time",
      abbr: "MPST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Kuala Lumpur, Singapore",
      timezone: "Asia/Kuala_Lumpur"
    }, {
      value: "W. Australia Standard Time",
      abbr: "WAST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Perth",
      timezone: "Australia/Perth"
    }, {
      value: "Taipei Standard Time",
      abbr: "TST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Taipei",
      timezone: "Asia/Taipei"
    }, {
      value: "Ulaanbaatar Standard Time",
      abbr: "UST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Ulaanbaatar",
      timezone: "Asia/Ulaanbaatar"
    }, {
      value: "North Asia East Standard Time",
      abbr: "NAEST",
      offset: 8,
      isdst: !1,
      label: "(GMT+08:00) Irkutsk",
      timezone: "Asia/Irkutsk"
    }, {
      value: "Tokyo Standard Time",
      abbr: "TST",
      offset: 9,
      isdst: !1,
      label: "(GMT+09:00) Osaka, Sapporo, Tokyo",
      timezone: "Asia/Tokyo"
    }, {
      value: "Korea Standard Time",
      abbr: "KST",
      offset: 9,
      isdst: !1,
      label: "(GMT+09:00) Seoul",
      timezone: "Asia/Seoul"
    }, {
      value: "Yakutsk Standard Time",
      abbr: "YST",
      offset: 9,
      isdst: !1,
      label: "(GMT+09:00) Yakutsk",
      timezone: "Asia/Yakutsk"
    }, {
      value: "Cen. Australia Standard Time",
      abbr: "CAST",
      offset: 9.5,
      isdst: !1,
      label: "(GMT+09:30) Adelaide",
      timezone: "Australia/Adelaide"
    }, {
      value: "AUS Central Standard Time",
      abbr: "ACST",
      offset: 9.5,
      isdst: !1,
      label: "(GMT+09:30) Darwin",
      timezone: "Australia/Darwin"
    }, {
      value: "E. Australia Standard Time",
      abbr: "EAST",
      offset: 10,
      isdst: !1,
      label: "(GMT+10:00) Brisbane",
      timezone: "Australia/Brisbane"
    }, {
      value: "AUS Eastern Standard Time",
      abbr: "AEST",
      offset: 10,
      isdst: !1,
      label: "(GMT+10:00) Canberra, Melbourne, Sydney",
      timezone: "Australia/Melbourne"
    }, {
      value: "West Pacific Standard Time",
      abbr: "WPST",
      offset: 10,
      isdst: !1,
      label: "(GMT+10:00) Guam, Port Moresby",
      timezone: "Pacific/Port_Moresby"
    }, {
      value: "Tasmania Standard Time",
      abbr: "TST",
      offset: 10,
      isdst: !1,
      label: "(GMT+10:00) Hobart",
      timezone: "Australia/Hobart"
    }, {
      value: "Vladivostok Standard Time",
      abbr: "VST",
      offset: 10,
      isdst: !1,
      label: "(GMT+10:00) Vladivostok",
      timezone: "Asia/Vladivostok"
    }, {
      value: "Central Pacific Standard Time",
      abbr: "CPST",
      offset: 11,
      isdst: !1,
      label: "(GMT+11:00) Solomon Is., New Caledonia",
      timezone: "Pacific/Guadalcanal"
    }, {
      value: "Magadan Standard Time",
      abbr: "MST",
      offset: 11,
      isdst: !1,
      label: "(GMT+11:00) Magadan",
      timezone: "Asia/Magadan"
    }, {
      value: "New Zealand Standard Time",
      abbr: "NZST",
      offset: 12,
      isdst: !1,
      label: "(GMT+12:00) Auckland, Wellington",
      timezone: "Pacific/Auckland"
    }, {
      value: "UTC+12",
      abbr: "U",
      offset: 12,
      isdst: !1,
      label: "(GMT+12:00) Coordinated Universal Time",
      timezone: "Pacific/Kwajalein"
    }, {
      value: "Fiji Standard Time",
      abbr: "FST",
      offset: 12,
      isdst: !1,
      label: "(GMT+12:00) Fiji",
      timezone: "Pacific/Fiji"
    }, {
      value: "Kamchatka Standard Time",
      abbr: "KDT",
      offset: 12,
      isdst: !0,
      label: "(GMT+12:00) Petropavlovsk-Kamchatsky",
      timezone: "Asia/Kamchatka"
    }, {
      value: "Tonga Standard Time",
      abbr: "TST",
      offset: 13,
      isdst: !1,
      label: "(GMT+13:00) Nuku'alofa",
      timezone: "Pacific/Tongatapu"
    }, {
      value: "Samoa Standard Time",
      abbr: "SST",
      offset: 13,
      isdst: !1,
      label: "(GMT+13:00) Samoa",
      timezone: "Pacific/Samoa"
    }];

    function getTimeZone(timezone) {
      for (var i = 0; i < _tzStandard.length; i++) {
        var tz = _tzStandard[i];
        if (timezone == tz.timezone) return tz;
        if (timezone == tz.name) return tz;
      }

      return getTimeZone("Europe/London");
    }

    return {
      getTimeZone: getTimeZone,
      getCurrentTimeZone: function getCurrentTimeZone() {
        return getTimeZone(moment.tz.guess());
      },
      getStandardTimeZones: function getStandardTimeZones() {
        return angular.copy(_tzStandard);
      },
      getAllTimeZones: function getAllTimeZones() {
        return angular.copy(_tzFull);
      }
    };
  });
}(), window.angular.module("core.ui").directive("asuiTimezone", function () {
  return {
    restrict: "EA",
    templateUrl: "component-timezone/timezone.template",
    scope: {
      options: "=",
      ngModel: "=",
      onChange: "&"
    },
    link: function link(scope) {
      scope.init();
    },
    controller: ["$scope", "timeZoneHelper", function ($scope, timeZoneHelper) {
      $scope.timeZones = timeZoneHelper.getStandardTimeZones(), $scope.dropdownOptions = {
        container: "body"
      }, $scope.init = function () {
        $scope.options && $scope.options.allowEmpty ? $scope.options.placeholder || ($scope.options.placeholder = "Select timezone") : $scope.ngModel || ($scope.ngModel = timeZoneHelper.getCurrentTimeZone(moment.tz.guess()).value);
      }, $scope.onTimezoneChange = function (value, item) {
        $scope.onChange && $scope.onChange({
          value: value,
          item: item
        });
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiVerticalNavbar", function () {
  return {
    restrict: "E",
    templateUrl: "component-verticalnavbar/verticalnavbar.template",
    scope: {
      id: "@",
      items: "=",
      ngModel: "=",
      onNavClick: "&"
    },
    controller: ["$scope", "$state", "$interval", function ($scope, $state, $interval) {
      var currentState = null,
          checkStateInterval = $interval(function () {
        currentState != $state.current.name && function () {
          if ($scope.items && $scope.items.length) {
            currentState = $state.current.name;

            for (var i = 0; i < $scope.items.length; i++) {
              var item = $scope.items[i];
              if (item.sref && 0 === $state.current.name.indexOf(item.sref)) return void ($scope.ngModel = item);
            }
          }
        }();
      }, 50);
      $scope.$on("$destroy", function () {
        $interval.cancel(checkStateInterval);
      }), $scope.onNavItemClick = function ($event, item) {
        $scope.onNavClick && !1 === $scope.onNavClick({
          event: $event,
          item: item
        }) ? $event.preventDefault() : $scope.ngModel = item;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiWell", function () {
  return {
    restrict: "A",
    replace: "true",
    transclude: !0,
    templateUrl: "component-well/well.template"
  };
}), window.angular.module("core.ui").directive("asuiWorkbook", function () {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: "component-workbook/workbook.template",
    scope: {
      onApiReady: "&",
      onHandsontableLoad: "&",
      onChange: "&"
    },
    link: function link(scope, element) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.api = {
        loadSheets: scope.loadSheets,
        getSheets: scope.getSheets
      }, scope.init(), scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "modalService", function ($scope, modalService) {
      $scope.sheets = [];
      var nameIndex = 1,
          sheetMenu = [{
        name: "actions",
        showHeader: !1,
        items: [{
          label: "Delete",
          value: "delete"
        }, {
          label: "Duplicate",
          value: "duplicate"
        }, {
          label: "Rename",
          value: "rename"
        }]
      }, {
        name: "move",
        showHeader: !1,
        items: [{
          label: "Move right",
          value: "moveright"
        }, {
          label: "Move left",
          value: "moveleft"
        }]
      }];

      function redrawSelected() {
        (function () {
          for (var i = 0; i < $scope.sheets.length; i++) {
            var s = $scope.sheets[i];
            if (s.selected) return s;
          }

          return null;
        })().api.render();
      }

      function initSheets(src) {
        var sheets = [];
        src && src.length || (src = [{}]);

        for (var i = 0; i < src.length; i++) {
          var sheet = createSheet(src[i]);
          0 === i && (sheet.selected = !0), sheets.push(sheet);
        }

        $scope.sheets = sheets, resetSheetMenu(), setTimeout(redrawSelected, 100);
      }

      function createSheet(src) {
        var name = null,
            inc = 1,
            initialName = null;
        if (src && src.name) for (initialName = name = src.name; isNameExist(name);) {
          name = initialName + " " + inc++;
        } else for (name = "Sheet" + nameIndex++; isNameExist(name);) {
          name = "Sheet" + nameIndex++;
        }

        for (inc = 1, initialName = name; isNameExist(name);) {
          name = initialName + " " + inc++;
        }

        var data = src ? src.data : null,
            options = src ? src.options : null;
        return {
          name: name,
          data: data,
          menu: angular.copy(sheetMenu),
          options: function (customOptions) {
            var options = {
              minSpareRows: 50,
              minSpareCols: 10,
              manualColumnResize: !0,
              manualColumnMove: !0,
              manualRowMove: !0
            };
            if (customOptions) for (var key in customOptions) {
              options[key] = customOptions[key];
            }
            return options;
          }(options)
        };
      }

      function unSelectSheets() {
        for (var i = 0; i < $scope.sheets.length; i++) {
          var s = $scope.sheets[i];
          s.selected ? (s.data = s.api.getModel(), s.selected = !1) : s.api = null;
        }
      }

      function moveSheet(sheet, increment) {
        for (var i = 0; i < $scope.sheets.length; i++) {
          if ($scope.sheets[i].name.toLowerCase() === sheet.name.toLowerCase()) {
            $scope.sheets.splice(i, 1), $scope.sheets.splice(i + increment, 0, sheet), resetSheetMenu();
            break;
          }
        }
      }

      function isNameExist(sheetName) {
        for (var lcName = sheetName.toLowerCase(), i = 0; i < $scope.sheets.length; i++) {
          if ($scope.sheets[i].name.toLowerCase() === lcName) return !0;
        }

        return !1;
      }

      function resetSheetMenu() {
        for (var i = 0; i < $scope.sheets.length; i++) {
          var s = $scope.sheets[i];
          s.menu[1].items[1].disabled = 0 === i, s.menu[1].items[0].disabled = i === $scope.sheets.length - 1, s.menu[0].items[0].disabled = 1 === $scope.sheets.length;
        }
      }

      function fireOnChange() {
        $scope.$evalAsync(function () {
          $scope.onChange && $scope.onChange();
        });
      }

      $scope.init = function () {
        initSheets();
      }, $scope.loadSheets = function (sheets) {
        nameIndex = 1, $scope.sheets = [], initSheets(sheets);
      }, $scope.getSheets = function () {
        for (var sheets = [], i = 0; i < $scope.sheets.length; i++) {
          var sheet = {
            name: $scope.sheets[i].name,
            options: $scope.sheets[i].options,
            data: $scope.sheets[i].api && $scope.sheets[i].selected ? $scope.sheets[i].api.getModel() : $scope.sheets[i].data
          };
          sheets.push(sheet);
        }

        return sheets;
      }, $scope.newSheetClick = function () {
        var sheet = createSheet();
        unSelectSheets(), sheet.selected = !0, $scope.sheets.push(sheet), resetSheetMenu(), fireOnChange();
      }, $scope.sheetClick = function (sheet) {
        unSelectSheets(), sheet.selected = !0, setTimeout(redrawSelected, 100);
      }, $scope.onSheetReady = function (sheet, api) {
        sheet.api = api, sheet.data && sheet.api.initTable(sheet.data);
      }, $scope.onSheetUpdated = function (sheet, valid, changes) {
        fireOnChange();
      }, $scope.onSheetMenuClick = function (sheet, value) {
        switch (value) {
          case "moveleft":
            moveSheet(sheet, -1), fireOnChange();
            break;

          case "moveright":
            moveSheet(sheet, 1), fireOnChange();
            break;

          case "delete":
            modalService.openConfirmation({
              title: "Heads up!",
              content: "Are you sure you want to delete this sheet?"
            }).then(function () {
              !function (sheet) {
                for (var i = 0; i < $scope.sheets.length; i++) {
                  var s = $scope.sheets[i];

                  if (s.name.toLowerCase() === sheet.name.toLowerCase()) {
                    $scope.sheets.splice(i, 1), resetSheetMenu();
                    break;
                  }
                }

                $scope.sheets[0].selected = !0;
              }(sheet), fireOnChange();
            }, function () {});
            break;

          case "duplicate":
            !function (sheet) {
              for (var i = 0; i < $scope.sheets.length; i++) {
                var s = $scope.sheets[i];

                if (s.name.toLowerCase() === sheet.name.toLowerCase()) {
                  var newSheet = angular.copy(sheet);
                  newSheet.name = "Copy of " + sheet.name;

                  for (var inc = 1, initialName = newSheet.name; isNameExist(newSheet.name);) {
                    newSheet.name = initialName + " " + inc++;
                  }

                  $scope.sheets.splice(i + 1, 0, newSheet), unSelectSheets(), newSheet.selected = !0, resetSheetMenu();
                  break;
                }
              }
            }(sheet), fireOnChange();
            break;

          case "rename":
            !function (sheet) {
              var el = document.getElementById(sheet.$$hashKey);
              el.contentEditable = "true", el.className = "editing", window.setTimeout(function () {
                var sel, range;
                window.getSelection && document.createRange ? ((range = document.createRange()).selectNodeContents(el), (sel = window.getSelection()).removeAllRanges(), sel.addRange(range)) : document.body.createTextRange && ((range = document.body.createTextRange()).moveToElementText(el), range.select());
              }, 1);
            }(sheet), fireOnChange();
        }
      }, $scope.onSheetNameBlur = function (sheet) {
        var el = document.getElementById(sheet.$$hashKey),
            name = el.innerText,
            valid = !0,
            err = "";
        "true" === el.contentEditable && name.toLowerCase() !== sheet.name.toLowerCase() && (sheet.name.length ? isNameExist(name) && (valid = !1, err = 'A sheet with the name "' + name + '" already exists. Please enter another name.') : (valid = !1, err = "The sheet name cannot be empty.")), valid ? (el.contentEditable = "false", el.className = "", sheet.name = name) : (el.className += " error", modalService.openNotification({
          title: "There was a problem",
          content: err
        }).then(function () {}));
      }, $scope.onSheetNameKeydown = function (event, sheet) {
        13 !== event.charCode && 13 !== event.keyCode || (event.preventDefault(), $scope.onSheetNameBlur(sheet));
      }, $scope.handsontableLoad = function (hotInstance) {
        hotInstance && ($scope.onHandsontableLoad && $scope.onHandsontableLoad({
          hotInstance: hotInstance
        }), Handsontable.hooks.add("afterCreateCol", fireOnChange, hotInstance), Handsontable.hooks.add("afterCreateRow", fireOnChange, hotInstance), Handsontable.hooks.add("afterRemoveCol", fireOnChange, hotInstance), Handsontable.hooks.add("afterRemoveRow", fireOnChange, hotInstance));
      }, $scope.destroy = function () {};
    }]
  };
}), window.angular.module("core.ui").directive("asuiWorkflowNavbar", function () {
  return {
    restrict: "E",
    replace: "true",
    templateUrl: "component-workflownavbar/workflownavbar.template",
    scope: {
      items: "=",
      ngModel: "=",
      options: "=",
      onNavClick: "&"
    },
    controller: ["$scope", function ($scope) {
      $scope.getClass = function (index) {
        var activeIndex = -1;
        if ($scope.ngModel) for (var i = 0; i < $scope.items.length; i++) {
          if ($scope.items[i].value === $scope.ngModel.value) {
            activeIndex = i;
            break;
          }
        }
        return index == activeIndex ? "active" : index < activeIndex ? "previous" : "next";
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiBackground", function ($templateCache) {
  return {
    restrict: "EA",
    replace: "true",
    templateUrl: "custom-background/background.template",
    scope: {
      ngModel: "=",
      options: "=?",
      validation: "=?",
      targetUrl: "@",
      resolveFilePath: "&",
      onApiReady: "&",
      onColorChange: "&",
      onColorPickerMove: "&",
      onFileComplete: "&",
      onFileError: "&",
      onFileDelete: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.api = {}, scope.init(), scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", "$compile", "AsComponentUtil", function ($scope, $location, $element, $timeout, $compile, AsComponentUtil) {
      var componentUtil = new AsComponentUtil(),
          prevBgColor = {
        hex: null,
        alpha: 0
      };
      $scope.bgOptions = {}, $scope.bgFiles = [], $scope.bgValidation = {}, $scope.init = function () {
        !function () {
          if ($scope.bgOptions.maxFiles = 1, $scope.bgOptions.autoReplace = !0, $scope.options && ($scope.bgOptions.dropText = $scope.options.dropText, $scope.bgOptions.browseText = $scope.options.browseText, $scope.bgOptions.extraText = $scope.options.extraText), $scope.validation) {
            var v = $scope.validation;
            v.fileExtensions && v.fileExtensions.length > 0 ? $scope.bgValidation.fileExtensions = v.fileExtensions : $scope.bgValidation.fileTypes = ["image"];
          }

          if ($scope.ngModel && $scope.ngModel.bgImage) if ($scope.ngModel.bgFile) $scope.bgFiles = [$scope.ngModel.bgFile];else if ($scope.ngModel.bgImage.length > 0) {
            for (var filenames = $scope.ngModel.bgImage.split("/"), filename = "untitled", i = filenames.length - 1; i >= 0 && !((filename = filenames[i]) && filename.length > 0 && " " != filename); i--) {
              ;
            }

            $scope.bgFiles = [{
              file: filename,
              path: $scope.ngModel.bgImage
            }];
          }
        }(), $timeout(function () {
          !function () {
            if ((!$scope.options || !1 !== $scope.options.showColor) && (null === $scope.ngModel && ($scope.ngModel = {
              bgColor: null,
              bgImage: null
            }), (null === $scope.ngModel.bgColor || "" === $scope.ngModel.bgColor) && $scope.options.defaultColor)) {
              $scope.ngModel.bgColor = $scope.options.defaultColor;
              var color = tinycolor($scope.options.defaultColor);
              prevBgColor = {
                hex: color.toHexString(),
                alpha: color.getAlpha()
              };
            }
          }(), $timeout(function () {
            $scope.options && !1 === $scope.options.showColor || (cpEl = $element.find(".color")[0], $(cpEl).spectrum({
              preferredFormat: "hex8",
              chooseText: "OK",
              cancelText: "Cancel",
              showPalette: !0,
              showInitial: !0,
              showInput: !0,
              palette: $scope.options.palette,
              allowEmpty: !0,
              showAlpha: !0,
              move: colorPickerMoveHandler,
              hide: triggerOnChangeEvent,
              change: triggerOnChangeEvent
            }), $(".sp-input").attr("maxlength", 9)), function () {
              if ($scope.options) {
                var showBg = $scope.options.showImage;

                if (null !== showBg && void 0 !== showBg && !1 === showBg) {
                  var bgEl = $($element.find(".file"));
                  $(bgEl).hide();
                }
              }
            }();
          }, 0);
        }, 0);
      }, $scope.destroy = function () {
        $(cpEl).spectrum("destroy");
      };
      var cpEl = null;

      function colorPickerMoveHandler(color) {
        if (onChangeSent = !1, $scope.onColorPickerMove) {
          var val = "transparent";
          color && (val = color.toRgbString()), $scope.onColorPickerMove({
            value: val
          });
        }
      }

      var onChangeSent = !1;

      function triggerOnChangeEvent(color) {
        var curColor = {
          alpha: 0,
          hex: null
        };

        if (color && (curColor = {
          hex: color.toHexString(),
          alpha: color.getAlpha()
        }), !onChangeSent && $scope.onColorChange && (prevBgColor.alpha !== curColor.alpha || prevBgColor.hex !== curColor.hex)) {
          prevBgColor = componentUtil.resetColorPickerAlpha(cpEl, color, prevBgColor);
          var val = "transparent";
          color && (val = color.toRgbString()), $scope.onColorChange({
            value: val
          }), onChangeSent = !0;
        }
      }

      $scope.onUploadComplete = function (file, value) {
        $scope.ngModel.bgImage = value, $scope.ngModel.bgFile = {
          id: file.uniqueIdentifier,
          originalName: file.file.name,
          file: file.uniqueIdentifier,
          path: value
        }, $scope.onFileComplete && $scope.onFileComplete({
          file: file,
          path: value
        });
      }, $scope.onUploadDelete = function (file) {
        $scope.ngModel.bgImage = null, $scope.ngModel.bgFile = null, $scope.onFileDelete && $scope.onFileDelete({
          file: file
        });
      }, $scope.resolveFilePathUpload = function (path) {
        return $scope.resolveFilePath && (path = $scope.resolveFilePath({
          path: path
        })), path;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiDocumentReader", function () {
  return {
    restrict: "EA",
    templateUrl: "custom-documentreader/documentreader.template",
    scope: {
      returnType: "@",
      options: "=?",
      validation: "=?",
      onApiReady: "&",
      onFileSelected: "&",
      onComplete: "&",
      onError: "&"
    },
    link: function link(scope, element, attrs) {
      scope.$on("$destroy", function () {
        scope.destroy();
      }), element.on("$destroy", function () {
        scope.destroy();
      }), scope.api = {
        clearError: scope.clearError
      }, scope.init(), scope.onApiReady && scope.onApiReady({
        api: scope.api
      });
    },
    controller: ["$scope", "$location", "$element", "$timeout", "fileConverter", function ($scope, $location, $element, $timeout, fileConverter) {
      var acceptedExt = null,
          flow = null;

      function onComplete(data) {
        cancelFiles(), $scope.$evalAsync(function () {
          $scope.onComplete({
            value: data
          });
        });
      }

      function cancelFiles() {
        for (var i = 0; i < flow.files.length; i++) {
          flow.files[i].cancel();
        }
      }

      function fileAdded(file, message) {
        var err,
            ext = "." + file.getExtension().toLowerCase(),
            accepted = !0;

        if (acceptedExt) {
          accepted = !1;

          for (var i = 0; i < acceptedExt.length; i++) {
            if (ext == acceptedExt[i].toLowerCase()) {
              accepted = !0;
              break;
            }
          }
        }

        if (!accepted) return err = "Please upload supported file format: " + acceptedExt.join(", "), $scope.error = err, cancelFiles(), $scope.$evalAsync(function () {
          $scope.onError({
            error: err
          });
        }), !1;
      }

      function filesSubmitted(file) {
        file.length > 0 && ($scope.onFileSelected && $scope.onFileSelected({
          file: file
        }), function (file) {
          FileReader.prototype.readAsBinaryString || (FileReader.prototype.readAsBinaryString = function (fileData) {
            var binary = "",
                pt = this,
                localreader = new FileReader();
            localreader.onload = function (e) {
              for (var bytes = new Uint8Array(localreader.result), length = bytes.byteLength, i = 0; i < length; i++) {
                binary += String.fromCharCode(bytes[i]);
              }

              pt.content = binary, $(pt).trigger("onload");
            }, localreader.readAsArrayBuffer(fileData);
          });
          var returnType = $scope.returnType.toLowerCase(),
              reader = new FileReader(),
              fileExt = "." + file.getExtension().toLowerCase();

          switch (reader.onload = function (e, result) {
            var data;
            data = e ? e.target.result : this.content, "json" === returnType ? function (data, fileExt) {
              ".xlsx" === fileExt && function (data) {
                var workbook = XLSX.read(data, {
                  type: "binary",
                  cellDates: !0
                });
                fileConverter.fixWorkbookDates(workbook), onComplete(function (workbook) {
                  var result = {
                    header: null,
                    data: null
                  };

                  if (workbook.SheetNames && workbook.SheetNames.length > 0) {
                    var sheetName = workbook.SheetNames[0],
                        sheet = workbook.Sheets[sheetName];
                    sheet ? jQuery.isEmptyObject(sheet) ? ($scope.error = "Your file appears to be empty. Please confirm that it has data.", $scope.onError({
                      error: $scope.error
                    })) : result = $scope.options && $scope.options.columns && $scope.options.columns.length > 0 ? function (sheet) {
                      var result = {
                        header: null,
                        data: null
                      };

                      result.header = function (sheet) {
                        var C,
                            headers = [],
                            range = XLSX.utils.decode_range(sheet["!ref"]),
                            R = range.s.r;

                        for (C = range.s.c; C <= range.e.c; ++C) {
                          var cell = sheet[XLSX.utils.encode_cell({
                            c: C,
                            r: R
                          })];

                          if (cell && cell.t) {
                            var hdr = XLSX.utils.format_cell(cell);
                            headers.push(hdr);
                          }
                        }

                        return headers;
                      }(sheet);

                      var roa = XLSX.utils.sheet_to_row_object_array(sheet),
                          data = [];
                      return roa.length > 0 && roa.forEach(function (row) {
                        var rowVal = {};
                        result.header.forEach(function (hd) {
                          void 0 === row[hd] && (row[hd] = ""), rowVal[hd] = row[hd];
                        }), data.push(rowVal);
                      }), result.data = data, result;
                    }(sheet) : function (sheet) {
                      var result = {
                        header: [],
                        data: null
                      },
                          numberPattern = /\d+/g,
                          roa = [],
                          possibleColumns = {};

                      for (var key in sheet) {
                        var numMatch = key.match(numberPattern);

                        if (null !== numMatch) {
                          var r = numMatch.toString(),
                              column = key.replace(r, ""),
                              rowOffset = parseInt(r) - 1;
                          possibleColumns[column] = column, roa[rowOffset] || (roa[rowOffset] = {}), roa[rowOffset][column] = sheet[key].w;
                        }
                      }

                      var headers = [],
                          i = 0;

                      for (var x in possibleColumns) {
                        headers[i++] = x;
                      }

                      headers.sort(lengthAlphaSort);

                      for (var data = [], j = 0; j < roa.length; j++) {
                        for (var row = [], k = 0; k < headers.length; k++) {
                          var h = headers[k];
                          roa[j] || (roa[j] = []);
                          var v = roa[j][h];
                          v || (v = ""), row.push(v);
                        }

                        data.push(row);
                      }

                      return result.data = data, result;
                    }(sheet) : ($scope.error = "Oops, looks like I can't read this file. Try opening the file in Excel and resaving.", $scope.onError({
                      error: $scope.error
                    }));
                  }

                  return result;
                }(workbook));
              }(data);
            }(data, fileExt) : onComplete(data);
          }, returnType) {
            case "array-buffer":
              reader.readAsArrayBuffer(file.file);
              break;

            case "text":
              reader.readAsText(file.file);
              break;

            case "data-url":
              reader.readAsDataURL(file.file);
              break;

            default:
              reader.readAsBinaryString(file.file);
          }
        }(file[0]));
      }

      function lengthAlphaSort(a, b) {
        return a.length != b.length ? a.length - b.length : a < b ? -1 : a > b ? 1 : 0;
      }

      $scope.init = function () {
        !function () {
          if ($scope.validation) {
            var v = $scope.validation;
            v.fileExtensions && v.fileExtensions.length > 0 && (acceptedExt = v.fileExtensions);
          }
        }(), (flow = new Flow({
          target: null,
          chunkSize: 1048576,
          testChunks: !1,
          singleFile: !0
        })).support || ($scope.error = "Flow.js is not supported."), $timeout(function () {
          acceptedExt ? flow.assignBrowse($element.find(".browse")[0], null, null, {
            accept: acceptedExt
          }) : flow.assignBrowse($element.find(".browse")[0]), $scope.options.noDrop || flow.assignDrop($element.find(".drop-target")[0]), flow.on("fileAdded", fileAdded), flow.on("filesSubmitted", filesSubmitted);
        }, 100);
      }, $scope.destroy = function () {}, $scope.clearError = function () {
        $scope.error = null;
      };
    }]
  };
}), window.angular.module("core.ui").directive("asuiTextbox", function () {
  return {
    restrict: "EA",
    templateUrl: "custom-textbox/textbox.template",
    scope: {
      placeholder: "@",
      rows: "@",
      options: "=?",
      validation: "=?",
      ngModel: "=",
      textStyle: "=?",
      onChange: "&",
      onStyleChange: "&"
    },
    link: function link(scope) {
      scope.$watch("model", scope.onModelUpdate, !0), scope.$watch("options", scope.onOptionsUpdate, !0), scope.init();
    },
    controller: ["$scope", "$element", function ($scope, $element) {
      function isEmpty(value) {
        return null == value || "" === value;
      }

      function isValid() {
        $scope.error = null;
        var textToValidate = $scope.ngModel ? $scope.ngModel : "",
            length = textToValidate ? textToValidate.length : 0,
            isNumber = !isNaN(textToValidate),
            validation = $scope.validation;

        if (validation) {
          if (validation.required && !length) return $scope.error = "This field is required.", !1;
          if (!isEmpty(validation.minlength) && length < validation.minlength) return $scope.error = "Minimum " + validation.minlength + " characters.", !1;
          if (!isEmpty(validation.maxlength) && length > validation.maxlength) return $scope.error = "Maximum " + validation.maxlength + " characters limit", textToValidate = textToValidate.substring(0, $scope.validation.maxlength), !1;
          if (!isEmpty(validation.minvalue) && (parseFloat($scope.ngModel) < validation.minvalue || !isNumber)) return $scope.error = "Minimum value is " + validation.minvalue, !1;
          if (!isEmpty(validation.maxvalue) && (parseFloat($scope.ngModel) > validation.maxvalue || !isNumber)) return $scope.error = "Maximum value is " + validation.maxvalue, !1;
          if (validation.reservedCharacters) for (var specialChars = validation.reservedCharacters, i = 0; i < specialChars.length; i++) {
            if (textToValidate.indexOf(specialChars[i]) > -1) return $scope.error = "This field cannot contain any of the following characters: " + validation.reservedCharacters, !1;
          }
        }

        return !0;
      }

      $scope.init = function () {
        isValid();
      }, $scope.onOptionsUpdate = function () {
        !function () {
          $scope.toolbarEnabled = !1;
          var o = $scope.options;
          if (o && o.style && !jQuery.isEmptyObject(o.style)) if (o.style.locked && !0 === o.style.locked) $scope.toolbarEnabled = !0;else for (var key in o.style) {
            var val = o.style[key];

            switch (key.toLocaleLowerCase()) {
              case "fontFamily":
              case "fontfamily":
                val && val.length > 0 && ($scope.toolbarEnabled = !0);
                break;

              default:
                $scope.toolbarEnabled = !0;
            }
          }
        }();
      }, $scope.onModelUpdate = function () {
        if ($scope.ngModel && $scope.options) switch ($scope.options.type) {
          case "text":
            $scope.ngModel += "";
            break;

          case "number":
            $scope.ngModel = parseFloat($scope.ngModel);
        }
      }, $scope.onStyleUpdate = function (newVal) {
        newVal && ($scope.textStyle = newVal);
      }, $scope.onKeyUp = function (e) {
        $scope.isDirty = !0;
        var charCode = e.which ? e.which : e.keyCode;
        13 != charCode && 32 != charCode || $scope.onTextChange();
      }, $scope.onTextChange = function () {
        var textValue = $($element.find(".input-field")).val();
        $scope.options && $scope.options.style && $scope.options.style.customcss && "uppercase" == $scope.options.style.customcss["text-transform"] && (textValue = textValue.toUpperCase()), $scope.ngModel != textValue && ($scope.ngModel = textValue), isValid() && $scope.onChange && $scope.onChange({
          value: $scope.ngModel
        });
      };
      var showToolbox = !1,
          toolbarEl = null;

      function toggleToolbox(show) {
        if ($scope.options.style && $scope.options.style.locked && (show = !1), null === show) showToolbox = !showToolbox;else {
          if (show == showToolbox) return;
          showToolbox = show;
        }
        null === toolbarEl && (toolbarEl = $($element.find(".style-toolbar")[0])), toolbarEl.velocity("stop"), showToolbox ? toolbarEl.velocity("fadeIn", {
          duration: 200,
          display: ""
        }) : toolbarEl.velocity("fadeOut", {
          duration: 200,
          display: "none"
        });
      }

      $scope.toolbarEnabled = !1, $scope.onTextboxClick = function () {
        $scope.toolbarEnabled && toggleToolbox(!0);
      }, angular.element(document).mouseup(function (e) {
        if ($scope.toolbarEnabled) {
          var colorPicker = $(".sp-container"),
              focused = document.activeElement;
          !showToolbox || $element.is(e.target) || 0 !== $element.has(e.target).length || 0 !== $element.has(focused).length || colorPicker.is(e.target) || 0 !== colorPicker.has(e.target).length || toggleToolbox(!1);
        }
      }), $scope.styleChange = function (style) {
        $scope.onStyleChange && $scope.onStyleChange({
          style: style
        });
      };
    }]
  };
}), window.angular.module("core.ui").filter("asuiOrderBy", function () {
  return function (array, sortPredicate, reverseOrder, customSortFunction) {
    if (!Array.isArray(array)) return array;
    if (!sortPredicate) return array;
    var arrayCopy = [];
    angular.forEach(array, function (item) {
      arrayCopy.push(item);
    });

    var sortFunction = function sortFunction(a, b) {
      var valueA = a[sortPredicate],
          valueB = b[sortPredicate];
      return "string" == typeof valueA ? reverseOrder ? valueB.localeCompare(valueA) : valueA.localeCompare(valueB) : function (value) {
        return "number" == typeof value;
      }(valueA) || function (value) {
        return "boolean" == typeof value;
      }(valueA) ? reverseOrder ? valueB - valueA : valueA - valueB : 0;
    };

    return void 0 !== customSortFunction && (sortFunction = customSortFunction), arrayCopy.sort(sortFunction), void 0 !== customSortFunction && reverseOrder && arrayCopy.reverse(), arrayCopy;
  };
}), window.angular.module("core.ui").filter("contentDuration", function () {
  return function (duration, defaultDuration) {
    var usingDefault = !1;
    0 !== duration && void 0 !== duration && null !== duration || (usingDefault = !0, duration = defaultDuration || 0);
    var hours = 0 | Math.floor(duration / 3600),
        minutes = 0 | Math.floor(duration / 60),
        seconds = duration % 60 | 0,
        val = "";
    hours > 0 && (minutes = 0 | Math.floor(duration % 3600 / 60));
    var minSeg = minutes < 10 ? "0" + minutes : minutes,
        secSeg = seconds < 10 ? "0" + seconds : seconds;
    return hours && (val += hours + ":"), minSeg && (val += minSeg + ":"), secSeg && (val += secSeg), usingDefault ? val = val.length ? "(" + val + ")" : "Default" : duration < 0 && (val = ""), val;
  };
}), window.angular.module("core.ui").filter("daterange", function () {
  return function (startDate, endDate, format) {
    var start = moment(startDate),
        end = moment(endDate),
        now = moment();
    format || (format = "dt");
    var formattedDate,
        dayDiff = end.diff(start, "days") + 1,
        includeDate = !1,
        includeTime = !1;
    if (("d" == format || "dt" == format || format.indexOf("D") >= 0 || format.indexOf("M") >= 0 || format.indexOf("Y") >= 0) && (includeDate = !0), ("dt" == format || "t" == format || format.indexOf("h") >= 0 || format.indexOf("m") >= 0 || format.indexOf("s") >= 0) && (includeTime = !0), !includeDate && includeTime) formattedDate = start.format("h:mma") + " to " + end.format("h:mma");else {
      if (end.isSame(start, "day")) {
        if (end.isSame(now, "day")) formattedDate = "Today";else {
          var tomorrow = now.clone().add(1, "days").startOf("day"),
              yesterday = now.clone().subtract(1, "days").startOf("day");
          formattedDate = start.isSame(tomorrow, "day") ? "Tomorrow" : start.isSame(yesterday, "day") ? "Yesterday" : start.format("MMMM D, YYYY");
        }
        formattedDate && includeTime && (0 === start.hour() && 0 === start.minute() && 23 === end.hour() && 59 === end.minute() || start.hour() === end.hour() && start.minute() === end.minute() || (formattedDate += " at " + start.format("h:mma") + " to " + end.format("h:mma")));
      } else end.isSame(now, "day") && (includeDate && !includeTime || 0 === start.hour() && 0 === start.minute() && 0 === end.hour() && 0 === end.minute()) && (7 === dayDiff || 30 === dayDiff || 60 === dayDiff || 90 === dayDiff ? formattedDate = "Last " + dayDiff + " days" : 365 !== dayDiff && 366 !== dayDiff || (formattedDate = "Last 12 months"));

      formattedDate || (format && "dt" !== format ? "d" === format && (format = "MMMM D, YYYY") : (format = "MMMM D, YYYY", 0 === start.hour() && 0 === start.minute() && 23 === end.hour() && 59 === end.minute() || 0 === start.hour() && 0 === end.hour() && 0 === start.minute() && 0 === end.minute() || includeTime && (format += " h:mma")), formattedDate = start.format(format) + " to " + end.format(format));
    }
    return formattedDate;
  };
}), window.angular.module("core.ui").filter("datetime", function () {
  return function (date, format, returnAsFormatString) {
    var momentDate = moment(date),
        now = moment(),
        formatString = "";
    if ("t" === format) formatString = "h:mma";else if (format && format.length && "d" != format && "dt" != format) formatString = format;else {
      if (momentDate.isSame(now, "day")) formatString = "[Today]";else {
        var tomorrow = now.clone().add(1, "days").startOf("day"),
            yesterday = now.clone().subtract(1, "days").startOf("day");
        momentDate.isSame(tomorrow, "day") ? formatString = "[Tomorrow]" : momentDate.isSame(yesterday, "day") ? formatString = "[Yesterday]" : (formatString = "MMMM D, YYYY", momentDate.year() === now.year() && (formatString = "MMMM D"));
      }
      "d" != format && (0 === momentDate.hour() && 0 === momentDate.minute() || (formatString += " [at] h:mma"));
    }
    var val = momentDate.format(formatString);
    return "[Today]" !== formatString && "[Tomorrow]" !== formatString && "[Yesterday]" !== formatString || (formatString = "MMMM D, YYYY"), returnAsFormatString ? formatString : val;
  };
}), window.angular.module("core.ui").filter("duration", function () {
  return function (duration, defaultDuration, full) {
    var usingDefault = !1;
    0 !== duration && void 0 !== duration && null !== duration || (usingDefault = !0, duration = defaultDuration || 0);
    var years = Math.floor(duration / 31536e3),
        months = Math.floor(duration / 2592e3),
        days = Math.floor(duration / 86400),
        hours = Math.floor(duration / 3600),
        minutes = Math.floor(duration / 60),
        seconds = duration % 60,
        val = "";

    if (full) {
      var fullArray = [];
      years > 0 && fullArray.push(years + "yr"), months > 0 && (months = Math.floor(duration % 31536e3 / 2592e3)) > 0 && fullArray.push(months + "mo"), days > 0 && (days = Math.floor(duration % 2592e3 / 86400)) > 0 && fullArray.push(days + "d"), hours > 0 && (hours = Math.floor(duration % 86400 / 3600)) > 0 && fullArray.push(hours + "hr"), minutes > 0 && (minutes = Math.floor(duration % 3600 / 60)) > 0 && fullArray.push(minutes + "m"), seconds > 0 && fullArray.push(seconds + "s"), fullArray.length && (val = fullArray.join(" "));
    } else years > 0 ? (val = years + "yr", (months = Math.floor(duration % 31536e3 / 2592e3)) > 0 && (val += " " + months + "mo")) : months > 0 ? (val = months + "mo", (days = Math.floor(duration % 2592e3 / 86400)) > 0 && (val += " " + days + "d")) : days > 0 ? (val = days + "d", (hours = Math.floor(duration % 86400 / 3600)) > 0 && (val += " " + hours + "hr")) : hours > 0 ? (val = hours + "hr", (minutes = Math.floor(duration % 3600 / 60)) > 0 && (val += " " + minutes + "m"), seconds > 0 && (val += " " + seconds + "s")) : minutes > 0 ? (val = minutes + "m", seconds > 0 && (val += " " + seconds + "s")) : seconds > 0 && (val = seconds + "s");

    return seconds < 0 && (val = ""), usingDefault && (val = val.length ? "(" + val + ")" : "Default"), val;
  };
}), window.angular.module("core.ui").filter("filesize", function () {
  return function (size, defaultSize) {
    return size = size ? size < 1024 ? "<1 KB" : size < 1048576 ? Math.round(size / 1024) + " KB" : size < 104857600 ? Math.round(10 * size / 1024 / 1024) / 10 + " MB" : size < 1073741824 ? Math.round(size / 1024 / 1024) + " MB" : size < 107374182400 ? Math.round(10 * size / 1024 / 1024 / 1024) / 10 + " GB" : size < 1099511627776 ? Math.round(size / 1024 / 1024 / 1024) + " GB" : size < 0x640000000000 ? Math.round(10 * size / 1024 / 1024 / 1024 / 1024) / 10 + " TB" : Math.round(size / 1024 / 1024 / 1024 / 1024) + " TB" : defaultSize || "-";
  };
}), window.angular.module("core.ui").filter("asuiQuantity", function () {
  return function (number) {
    return void 0 === number || null === number ? "-" : number < 0 ? "" : number < 1 ? "-" : number < 1e3 ? number : number < 1e6 ? Math.round(10 * number / 1e3) / 10 + "k" : Math.round(10 * number / 1e6) / 10 + "m";
  };
}), window.angular.module("core.ui").filter("asuiPassportProvider", function () {
  return function (type) {
    if (type) switch (type = type.toString().toLowerCase()) {
      case "facebookinstagram":
      case "1":
        return {
          name: "Facebook Instagram",
          logo: "images/passport-logos/facebook-instagram.svg"
        };

      case "facebookworkplace":
      case "2":
        return {
          name: "Facebook Workplace",
          logo: "images/passport-logos/facebook-workplace.svg"
        };

      case "googlecalendar":
      case "3":
        return {
          name: "Google Calendar",
          logo: "images/passport-logos/google-calendar.svg"
        };

      case "instagram":
      case "4":
        return {
          name: "Instagram",
          logo: "images/passport-logos/instagram.svg"
        };

      case "microsoftteams":
      case "5":
        return {
          name: "Microsoft Teams",
          logo: "images/passport-logos/microsoft-teams.svg"
        };

      case "office365calendar":
      case "6":
        return {
          name: "Office 365 Calendar",
          logo: "images/passport-logos/office365-calendar.svg"
        };

      case "skype":
      case "7":
        return {
          name: "Skype",
          logo: "images/passport-logos/skype.svg"
        };

      case "slack":
      case "8":
        return {
          name: "Slack",
          logo: "images/passport-logos/slack.svg"
        };

      case "webexteams":
      case "9":
        return {
          name: "Webex Teams",
          logo: "images/passport-logos/webex-teams.svg"
        };

      case "microsoftonedrive":
      case "10":
        return {
          name: "Microsoft OneDrive",
          logo: "images/passport-logos/microsoft-onedrive.svg"
        };

      case "googledrive":
      case "11":
        return {
          name: "Google Drive",
          logo: "images/passport-logos/google-drive.svg"
        };

      case "webexmeetings":
      case "12":
        return {
          name: "Webex Meetings",
          logo: "images/passport-logos/webex-meetings.svg"
        };

      case "facebook":
      case "13":
        return {
          name: "Facebook",
          logo: "images/passport-logos/facebook.svg"
        };

      case "twitter":
      case "14":
        return {
          name: "Twitter",
          logo: "images/passport-logos/twitter.svg"
        };

      case "workplacechat":
      case "15":
        return {
          name: "Workplace Chat",
          logo: "images/passport-logos/workplace-chat.svg"
        };

      case "zoommeetings":
      case "16":
        return {
          name: "Zoom Meetings",
          logo: "images/passport-logos/zoom.svg"
        };

      case "zoom":
      case "17":
        return {
          name: "Zoom",
          logo: "images/passport-logos/zoom.svg"
        };

      default:
        return {
          name: type,
          logo: "images/doc.svg"
        };
    }
    return null;
  };
}), window.angular.module("core.ui").filter("timeago", function () {
  return function (date, prefixOn, excludeTime, defaultValue, startDate) {
    if (!date) return defaultValue || "-";
    var updateDate = moment(date),
        now = moment(startDate),
        timeDiff = now.diff(updateDate),
        futureDiff = null;
    updateDate.isSameOrAfter(now) && (futureDiff = updateDate.diff(now));
    var formattedDate = null;
    if (futureDiff) updateDate.date() - now.date() == 1 ? (formattedDate = "Tomorrow", excludeTime || (formattedDate += " at " + updateDate.format("h:mma"))) : updateDate.isSame(now, "year") ? (formattedDate = (prefixOn ? "on " : "") + updateDate.format("MMMM D"), excludeTime || (formattedDate += " at " + updateDate.format("h:mma"))) : formattedDate = (prefixOn ? "on " : "") + updateDate.format("MMMM D, YYYY");else if (updateDate.isSame(now, "day")) {
      if (moment.duration(timeDiff).asMinutes() < 1) {
        var seconds = moment.duration(timeDiff).seconds();
        formattedDate = seconds > 1 ? seconds + " secs ago" : "Just now";
      } else if (moment.duration(timeDiff).asHours() < 1) {
        var minutes = moment.duration(timeDiff).minutes();
        formattedDate = minutes > 1 ? minutes + " mins ago" : minutes + " min ago";
      } else {
        var hours = moment.duration(timeDiff).hours();
        formattedDate = hours > 1 ? hours + " hrs ago" : hours + " hr ago";
      }
    } else moment.duration(timeDiff).asDays() <= 2 ? (formattedDate = "Yesterday", excludeTime || (formattedDate += " at " + updateDate.format("h:mma"))) : moment.duration(timeDiff).asDays() <= 7 ? (formattedDate = (prefixOn ? "on " : "") + updateDate.format("dddd"), excludeTime || (formattedDate += " at " + updateDate.format("h:mma"))) : updateDate.isSame(now, "year") ? (formattedDate = (prefixOn ? "on " : "") + updateDate.format("MMMM D"), excludeTime || (formattedDate += " at " + updateDate.format("h:mma"))) : formattedDate = (prefixOn ? "on " : "") + updateDate.format("MMMM D, YYYY");
    return formattedDate;
  };
}), window.angular.module("core.ui").component("asuiAccordionHeader", {
  bindings: {
    options: "<",
    isOpen: "<"
  },
  transclude: !0,
  templateUrl: "component-accordion/accordion-header/accordion-header.template"
}), window.angular.module("core.ui").directive("asuiDaypartingDaySlots", function () {
  return {
    restrict: "A",
    scope: {
      item: "=",
      minSlotWidth: "=",
      onClick: "&",
      onMousedown: "&",
      onMouseup: "&"
    },
    link: function link(scope, element) {
      element.addClass("dayparting-row"), element.on("$destroy", function () {
        scope.destroy();
      }), scope.$watch("item", function (newVal) {
        newVal && scope.refreshSlots();
      }, !0);
    },
    controller: function controller($scope, $element) {
      var itemCount = 0,
          slotElements = [];

      function addSelectedDivElements(el) {
        for (var slot = el._slot; el.hasChildNodes();) {
          el.removeChild(el.firstChild);
        }

        if (slot.selected) {
          var slotDuration = slot.endTime - slot.startTime;
          if (slot.partials && slot.partials.length) for (var i = 0; i < slot.partials.length; i++) {
            var partial = slot.partials[i],
                width = partial.duration / slotDuration * 100,
                marginLeft = "0";

            if (partial.start) {
              var leftM = partial.start,
                  prevPartial = slot.partials[i - 1];
              prevPartial && (leftM -= prevPartial.start + prevPartial.duration), marginLeft = leftM / slotDuration * 100;
            }

            var partialEl = createSelectedDiv(slot, width, marginLeft);
            el.appendChild(partialEl);
          } else {
            var selectedEl = createSelectedDiv(slot, "100", "0");
            el.appendChild(selectedEl);
          }
        }
      }

      function createSelectedDiv(slot, width, marginLeft) {
        var selectedEl = document.createElement("div");
        return selectedEl.style.width = width + "%", selectedEl.style.marginLeft = marginLeft + "%", selectedEl._slot = slot, selectedEl;
      }

      $scope.destroy = function () {
        $element.empty();
      }, $scope.refreshSlots = function () {
        $scope.item && $scope.minSlotWidth && (itemCount != $scope.item.slots.length ? (itemCount = $scope.item.slots.length, "everyday" === $scope.item.id && $element.addClass("dayparting-day-everyday"), $element.empty(), function () {
          if (slotElements = [], $scope.item.slots) for (var i = 0; i < $scope.item.slots.length; i++) {
            var slot = $scope.item.slots[i],
                el = document.createElement("div");
            el._slot = slot, el.style.minWidth = $scope.minSlotWidth, addSelectedDivElements(el), slotElements.push(el);
          }
          $element.append(slotElements);
        }()) : $scope.updateSlots());
      }, $scope.updateSlots = function () {
        for (var i = 0; i < slotElements.length; i++) {
          addSelectedDivElements(slotElements[i]);
        }
      };
    }
  };
}), window.angular.module("core.ui").factory("magicDetectUtil", ["FpePoiLayerUtil", function (FpePoiLayerUtil) {
  var Direction = {
    Left: 0,
    UpLeft: 1,
    Up: 2,
    UpRight: 3,
    Right: 4,
    DownRight: 5,
    Down: 6,
    DownLeft: 7
  };
  return {
    detectShapeFromPoint: function detectShapeFromPoint(canvas, point, options) {
      var ctime = new Date().getTime();
      point.x = Math.round(point.x), point.y = Math.round(point.y);

      for (var context = canvas.getContext("2d"), targetColor = context.getImageData(point.x, point.y, 1, 1).data, imageData = context.getImageData(0, 0, canvas.width, canvas.height).data, states = [], startDirection = 0; startDirection < 4; startDirection++) {
        var pointDirection,
            state = {
          point: {
            x: point.x,
            y: point.y
          },
          direction: Direction.Left,
          targetColor: targetColor,
          imageData: imageData,
          imgWidth: canvas.width,
          imgHeight: canvas.height,
          context: context,
          coveredPixelCount: 0,
          coveredPixels: {},
          options: options,
          pixelsScanned: 0,
          pointHistory: [],
          redundantCornerCount: 0,
          corners: [],
          processedCorners: []
        };

        switch (state.options || (state.options = {}), startDirection) {
          case 0:
            pointDirection = {
              x: -1,
              y: 0
            };
            break;

          case 1:
            pointDirection = {
              x: 0,
              y: -1
            };
            break;

          case 2:
            pointDirection = {
              x: 1,
              y: 0
            };
            break;

          case 3:
            pointDirection = {
              x: 0,
              y: 1
            };
        }

        for (; state.point.x > 0;) {
          if (!checkIsTargetColor(state.point, state)) {
            state.point.x -= pointDirection.x, state.point.y -= pointDirection.y, state.pointHistory.push(state.point);
            break;
          }

          state.point.x += pointDirection.x, state.point.y += pointDirection.y;
        }

        var totalPixels = canvas.width * canvas.height,
            maxPixelsToScan = Math.floor(.5 * totalPixels);
        coverPixel(state.point, state);

        for (var previousPoint = state.point; progressPixel(state, previousPoint);) {
          if (state.pointHistory.push(state.point), previousPoint = state.point, state.pixelsScanned > maxPixelsToScan) {
            state.corners = [];
            break;
          }
        }

        if (0 != state.corners.length) {
          state.processedCorners = FpePoiLayerUtil.removeRedundantPoints(state.processedCorners);
          var circleCheck = FpePoiLayerUtil.detectIsCircleFromPoints(state.corners);
          if (state = {
            isCircle: circleCheck.confidence > 60,
            corners: state.corners,
            success: !!FpePoiLayerUtil.isInside(point, state.processedCorners),
            area: areaOfPolygon(state.processedCorners),
            pixelsScanned: state.pixelsScanned,
            processedCorners: state.processedCorners,
            redundantCornerCount: 0
          }, states.push(state), state.success) break;
        } else states.push({
          corners: state.corners,
          success: !1,
          pixelsScanned: state.pixelsScanned,
          redundantCornerCount: state.redundantCornerCount
        });
      }

      for (var elapse = new Date().getTime() - ctime, finalState = states[0], i = 0; i < states.length; i++) {
        var cstate = states[i];
        finalState.success || !cstate.success ? finalState.area < cstate.area && (finalState = cstate) : finalState = cstate;
      }

      return finalState.success ? (finalState.isCircle ? (finalState.corners = FpePoiLayerUtil.generateCirclePoints(circleCheck.radius, 9, circleCheck.point), console.info("Auto trace: Scanned " + finalState.pixelsScanned + " pixels and detected a circle in " + elapse + "ms")) : (finalState.redundantCornerCount = finalState.corners.length - finalState.processedCorners.length, finalState.corners = finalState.processedCorners, console.info("Auto trace: Scanned " + finalState.pixelsScanned + " pixels and " + finalState.corners.length + " corners in " + states.length + " pass(es), " + elapse + "ms")), finalState.redundantCornerCount > 0 && console.info("Auto trace: Removed " + finalState.redundantCornerCount + " redundant corners"), finalState) : (console.warn("Auto trace: Aborting trace after " + elapse + "ms"), finalState);
    }
  };

  function coverPixel(point, state) {
    state.coveredPixels[point.y] || (state.coveredPixels[point.y] = {}), 1 != state.coveredPixels[point.y][point.x] && (state.coveredPixels[point.y][point.x] = !0, state.coveredPixelCount++);
  }

  function areaOfPolygon(coords) {
    for (var area = 0, j = coords.length - 1, i = 0; i < coords.length; i++) {
      area += (coords[j].x + coords[i].x) * (coords[j].y - coords[i].y), j = i;
    }

    return Math.abs(area / 2);
  }

  function progressPixel(state, previousPoint) {
    var leftPoint = {
      x: state.point.x - 1,
      y: state.point.y
    },
        upPoint = {
      x: state.point.x,
      y: state.point.y - 1
    },
        rightPoint = {
      x: state.point.x + 1,
      y: state.point.y
    },
        downPoint = {
      x: state.point.x,
      y: state.point.y + 1
    },
        sample = function (point, state) {
      state.pixelsScanned++;
      var availablePixels = [];
      return availablePixels.push(checkIsTargetColor({
        x: point.x - 1,
        y: point.y
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x - 1,
        y: point.y - 1
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x,
        y: point.y - 1
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x + 1,
        y: point.y - 1
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x + 1,
        y: point.y
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x + 1,
        y: point.y + 1
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x,
        y: point.y + 1
      }, state)), availablePixels.push(checkIsTargetColor({
        x: point.x - 1,
        y: point.y + 1
      }, state)), availablePixels;
    }(state.point, state),
        startIndex = 0;

    switch (state.direction) {
      case Direction.Left:
        startIndex = 5;
        break;

      case Direction.Up:
        startIndex = 7;
        break;

      case Direction.Right:
        startIndex = 1;
        break;

      case Direction.Down:
        startIndex = 3;
    }

    for (var lastEdgeIndex = -1, i = 0; i < 8; i++) {
      var sampleIndex = startIndex + i;
      sampleIndex >= 8 && (sampleIndex -= 8), sample[sampleIndex] || (lastEdgeIndex = sampleIndex);
    }

    var nextPoint = {};

    switch (lastEdgeIndex) {
      case Direction.Left:
        nextPoint.point = upPoint, nextPoint.direction = Direction.Left, nextPoint.newDirection = !0;
        break;

      case Direction.UpLeft:
        nextPoint.point = upPoint, nextPoint.direction = Direction.Up;
        break;

      case Direction.Up:
        nextPoint.point = rightPoint, nextPoint.direction = Direction.Up, nextPoint.newDirection = !0;
        break;

      case Direction.Right:
        nextPoint.point = downPoint, nextPoint.direction = Direction.Right, nextPoint.newDirection = !0;
        break;

      case Direction.UpRight:
        nextPoint.point = rightPoint, nextPoint.direction = Direction.Right;
        break;

      case Direction.Down:
        nextPoint.point = leftPoint, nextPoint.direction = Direction.Down, nextPoint.newDirection = !0;
        break;

      case Direction.DownRight:
        nextPoint.point = downPoint, nextPoint.direction = Direction.Down;
        break;

      case Direction.DownLeft:
        nextPoint.point = leftPoint, nextPoint.direction = Direction.Left;
    }

    return !(!nextPoint.point || function (point, state) {
      return point.x < 0 || point.y < 0 || point.x >= state.imgWidth || point.y >= state.imgHeight || !!state.coveredPixels[point.y] && void 0 != state.coveredPixels[point.y][point.x];
    }(nextPoint.point, state) || (state.point = nextPoint.point, (state.direction != nextPoint.direction || nextPoint.newDirection) && (state.direction = nextPoint.direction, state.corners.push(previousPoint), state.processedCorners.push(previousPoint)), 0));
  }

  function checkIsTargetColor(point, state) {
    if (point.x < 0 || point.y < 0 || point.x > state.imgWidth || point.y > state.imgHeight) return !1;
    state.pixelsScanned++;
    var offset = 4 * (point.x + state.imgWidth * point.y),
        rDifference = Math.abs(state.imageData[offset] - state.targetColor[0]),
        gDifference = Math.abs(state.imageData[offset + 1] - state.targetColor[1]),
        bDifference = Math.abs(state.imageData[offset + 2] - state.targetColor[2]),
        difference = (Math.abs(state.imageData[offset + 3] - state.targetColor[3]), rDifference);
    return gDifference > difference && (difference = gDifference), bDifference > difference && (difference = bDifference), difference < 10;
  }
}]), window.angular.module("core.ui").directive("asuiFloorplanEditorPoiLayer", function () {
  var MAX_CANVAS_WIDTH = 6e3,
      MAX_CANVAS_HEIGHT = 6e3;
  return {
    restrict: "EA",
    templateUrl: "component-floorplan-editor/poi-layer/poi-layer.template",
    scope: {
      items: "=",
      options: "=",
      floorplan: "@",
      onItemClick: "&",
      onNewItem: "&",
      onNewItemCancel: "&",
      onStageClick: "&",
      onFloorplanLoad: "&",
      onZoomUpdate: "&",
      onApiReady: "&"
    },
    link: function link(scope, element) {
      element.on("$destroy", scope.onDestroy), scope.$watch("options", scope.onOptionsPoiStyleUpdate, !0), scope.$watch("floorplan", scope.onFloorplanChange), scope.onInit();
    },
    controller: function controller($scope, $element, FpePoiLayerUtil, magicDetectUtil) {
      Konva.hitOnDragEnabled = !0;
      var stage = null,
          stageContainer = null,
          poiLayer = new Konva.Group(),
          newPoiLayer = new Konva.Layer(),
          bgLayer = new Konva.Layer(),
          bgImage = null;
      $scope.newItem = null;
      var lastDist,
          tween,
          selectedItems = [],
          floorplanCanvas = null,
          defaultZoom = 1,
          onAnimationFrameHandler = 0,
          nextBuildTime = 0,
          DEFAULT_ZOOM_LEVEL = 1,
          DEFAULT_MAX_ZOOM_LEVEL = 10,
          DPI = window.devicePixelRatio ? window.devicePixelRatio : 1,
          maxZoom = DEFAULT_MAX_ZOOM_LEVEL,
          defaultStyle = {
        fill: "rgb(151,195,248)",
        opacity: .9,
        defocusOpacity: .4,
        strokeWidth: 1
      },
          floorPlanInfo = {
        imageWidth: 1,
        imageHeight: 1,
        imageRatio: 1
      },
          viewPortInfo = {
        mapX: 1,
        mapY: 1,
        mapWidth: 1,
        mapHeight: 1,
        zoom: {
          amount: 1,
          position: {
            x: 0,
            y: 0
          }
        }
      };

      function disposeFloorplanCanvas() {
        if (floorplanCanvas) {
          var context = floorplanCanvas.getContext("2d");
          context.clearRect(0, 0, context.canvas.width, context.canvas.height), context.canvas.height = 0, context.canvas.width = 0, context = void 0, floorplanCanvas = void 0;
        }
      }

      function onFloorplanImageLoad() {
        bgImage && bgImage.destroy(), poiLayer.remove(), disposeFloorplanCanvas();
        var options = $scope.options || {},
            scale = options.floorplanScale,
            naturalWidth = options.floorplanWidth ? options.floorplanWidth : this.naturalWidth,
            naturalHeight = options.floorplanHeight ? options.floorplanHeight : this.naturalHeight,
            canvasWidth = naturalWidth,
            canvasHeight = naturalHeight,
            editEnabled = !(!$scope.options || !$scope.options.enableEdit),
            maxAllowedCanvasWidth = MAX_CANVAS_WIDTH,
            maxAllowedCanvasHeight = MAX_CANVAS_HEIGHT;

        if (naturalWidth < 3500 && naturalHeight < 3500 && !floorPlanInfo.isSVG ? scale = 1 : scale || (naturalWidth >= naturalHeight ? canvasHeight = (canvasWidth = maxAllowedCanvasWidth) * (naturalHeight / naturalWidth) : canvasWidth = (canvasHeight = maxAllowedCanvasHeight) * (naturalWidth / naturalHeight), scale = canvasWidth / naturalWidth), floorPlanInfo.renderScale = scale, floorPlanInfo.imageWidth = naturalWidth, floorPlanInfo.imageHeight = naturalHeight, floorPlanInfo.imageRatio = floorPlanInfo.imageWidth / floorPlanInfo.imageHeight, editEnabled) {
          (floorplanCanvas = document.createElement("canvas")).width = canvasWidth, floorplanCanvas.height = canvasHeight, this.style.shapeRendering = "crispEdges";
          var context = floorplanCanvas.getContext("2d");
          context.imageSmoothingEnabled = !1, context.fillStyle = "red", context.fillRect(0, 0, floorplanCanvas.width, floorplanCanvas.height), context.drawImage(this, 0, 0, floorplanCanvas.width, floorplanCanvas.height);
        }

        (bgImage = new Konva.Image({
          x: 0,
          y: 0,
          image: this
        })).hitStrokeWidth(0), bgImage.shadowForStrokeEnabled(!1), bgLayer.add(bgImage), bgLayer.add(poiLayer), updateStageScale(), resetZoom(), scheduleBuildScene(), $scope.onFloorplanLoad({
          size: {
            width: floorPlanInfo.imageWidth,
            height: floorPlanInfo.imageWidth
          }
        }), $scope.$apply();
      }

      function restrictStageDragPos(pos) {
        return pos;
      }

      function getZoom() {
        return viewPortInfo.zoom;
      }

      function resetZoom() {
        viewPortInfo.zoom = {
          amount: defaultZoom,
          position: {
            x: (stage.width() - stage.width() * defaultZoom) / 2,
            y: (stage.height() - stage.height() * defaultZoom) / 2
          }
        }, stage.scale({
          x: viewPortInfo.zoom.amount,
          y: viewPortInfo.zoom.amount
        }), stage.position(viewPortInfo.zoom.position), stage.draw(), $scope.onZoomUpdate({
          zoom: viewPortInfo.zoom
        });
      }

      function setZoom(scale) {
        viewPortInfo.zoom = scale, stage.scale({
          x: viewPortInfo.zoom.amount,
          y: viewPortInfo.zoom.amount
        }), stage.position(viewPortInfo.zoom.position), stage.draw(), $scope.onZoomUpdate({
          zoom: viewPortInfo.zoom
        });
      }

      function onAnimationFrame() {
        var ctime = new Date().getTime();
        !function () {
          if (0 != stageZoomDeltaY) {
            var mousePointTo = getStagePointerPositions(viewPortInfo.zoom.amount),
                newScale = viewPortInfo.zoom.amount + stageZoomDeltaY / 300;
            newScale > maxZoom ? (newScale = maxZoom, stageZoomDeltaY = 0) : newScale < defaultZoom && (newScale = defaultZoom, stageZoomDeltaY = 0), viewPortInfo.zoom.amount = newScale, viewPortInfo.zoom.position = getZoomPositions(mousePointTo, newScale), viewPortInfo.zoom.position = restrictStageDragPos(viewPortInfo.zoom.position), stage.scale({
              x: viewPortInfo.zoom.amount,
              y: viewPortInfo.zoom.amount
            }), stage.position(viewPortInfo.zoom.position), stage.batchDraw(), stageZoomDeltaY *= .8, Math.abs(stageZoomDeltaY) < .5 && (stageZoomDeltaY = 0), updateShapeCache(), $scope.onZoomUpdate({
              zoom: viewPortInfo.zoom
            }), $scope.$apply();
          }
        }(), nextBuildTime && nextBuildTime < ctime && buildScene(), onAnimationFrameHandler = window.requestAnimationFrame(onAnimationFrame);
      }

      function getStagePointerPosition(stagePointerPosition, stagePosition, scale) {
        return stagePointerPosition / scale - stagePosition / scale;
      }

      function getStagePointerPositions(scale) {
        return {
          x: getStagePointerPosition(stage.getPointerPosition().x, stage.x(), scale),
          y: getStagePointerPosition(stage.getPointerPosition().y, stage.y(), scale)
        };
      }

      function getZoomPosition(oldStagePointerPosition, newStagePointerPosition, scale) {
        return -(oldStagePointerPosition - newStagePointerPosition / scale) * scale;
      }

      function getZoomPositions(point, scale) {
        return {
          x: getZoomPosition(point.x, stage.getPointerPosition().x, scale),
          y: getZoomPosition(point.y, stage.getPointerPosition().y, scale)
        };
      }

      $scope.onDestroy = function () {
        stageContainer[0].removeEventListener("keydown", onKeyDown), stageContainer[0].removeEventListener("blur", onStageBlur), disposeFloorplanCanvas(), bgLayer.off("click", bgLayerClick), stage.off("wheel", onStageWheel), stage.off("touchmove", onStageTouchMove), stage.off("touchend", onStageTouchMoveEnd), stage.destroyChildren(), window.cancelAnimationFrame(onAnimationFrameHandler);
      }, $scope.onInit = function () {
        stageContainer = $element.find(".fpe-poi-layer-stage"), (stage = new Konva.Stage({
          container: stageContainer[0],
          width: Math.floor($element.innerWidth()),
          height: Math.floor($element.innerHeight()),
          draggable: !0,
          dragBoundFunc: restrictStageDragPos
        })).add(bgLayer), $scope.options && $scope.options.enableEdit ? stage.add(newPoiLayer) : newPoiLayer && (newPoiLayer.destroy(), newPoiLayer = null), bgLayer.on("click", bgLayerClick), stage.on("wheel", onStageWheel), stage.on("touchmove", onStageTouchMove), stage.on("touchend", onStageTouchMoveEnd), onAnimationFrameHandler = window.requestAnimationFrame(onAnimationFrame), $scope.api = {
          createNewItem: createNewItem,
          cancelNewItem: cancelNewItem,
          selectItems: selectItems,
          getSelectedItems: getSelectedItems,
          setStageSize: setStageSize,
          moveItem: moveItem,
          updateItem: updateItem,
          resetZoom: resetZoom,
          getZoom: getZoom,
          setZoom: setZoom,
          getItemBoundary: getItemBoundary,
          buildScene: buildScene
        }, $scope.onApiReady && $scope.onApiReady({
          api: $scope.api
        }), stageContainer[0].tabIndex = 1, stageContainer[0].addEventListener("keydown", onKeyDown), stageContainer[0].addEventListener("blur", onStageBlur);
      }, $scope.onOptionsPoiStyleUpdate = function () {
        $scope.options && ($scope.options.defaultPoi && (defaultStyle = $scope.options.defaultPoi), $scope.options.zoom && (defaultZoom = $scope.options.zoom.scale || DEFAULT_ZOOM_LEVEL, maxZoom = $scope.options.zoom.max || DEFAULT_MAX_ZOOM_LEVEL), scheduleBuildScene());
      }, $scope.onFloorplanChange = function () {
        if ($scope.floorplan) {
          var client = new XMLHttpRequest();
          client.open("GET", $scope.floorplan, !0), client.responseType = "blob", client.send(), client.onload = function () {
            floorPlanInfo.isSVG = 0 == this.response.type.indexOf("image/svg"), floorPlanInfo.renderScale = 1;
            var img = new Image();
            img.crossOrigin = "Anonymous", img.onload = onFloorplanImageLoad, img.src = URL.createObjectURL(this.response);
          };
        }
      };
      var stageZoomDeltaY = 0,
          lastZoomShapeCache = 0;

      function updateShapeCache() {
        lastZoomShapeCache != viewPortInfo.zoom.amount && (lastZoomShapeCache = viewPortInfo.zoom.amount, scheduleBuildScene(100));
      }

      function onStageTouchMove(e) {
        e.evt.preventDefault();
        var p1,
            p2,
            touch1 = e.evt.touches[0],
            touch2 = e.evt.touches[1];

        if (touch1 && touch2) {
          var dist = (p1 = {
            x: touch1.clientX,
            y: touch1.clientY
          }, p2 = {
            x: touch2.clientX,
            y: touch2.clientY
          }, Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)));
          lastDist || (lastDist = dist);
          var touchPointTo = getStagePointerPositions(viewPortInfo.zoom.amount),
              newScale = stage.scaleX() * dist / lastDist;
          newScale > maxZoom ? newScale = maxZoom : newScale < defaultZoom && (newScale = defaultZoom), viewPortInfo.zoom.amount != newScale && updateShapeCache(), viewPortInfo.zoom.amount = newScale, viewPortInfo.zoom.position = getZoomPositions(touchPointTo, newScale), viewPortInfo.zoom.position = restrictStageDragPos(viewPortInfo.zoom.position), stage.draggable(!1), stage.scale({
            x: viewPortInfo.zoom.amount,
            y: viewPortInfo.zoom.amount
          }), stage.position(viewPortInfo.zoom.position), stage.batchDraw(), lastDist = dist, $scope.onZoomUpdate({
            zoom: viewPortInfo.zoom
          }), $scope.$apply();
        }
      }

      function onStageTouchMoveEnd(e) {
        stage.draggable(!0), stage.batchDraw(), lastDist = 0;
      }

      function onStageWheel(e) {
        e.evt.preventDefault();
        var delta = e.evt.deltaY;
        e.evt.ctrlKey && (delta *= -1.2), delta > 0 && viewPortInfo.zoom.amount > maxZoom ? (stageZoomDeltaY = 0, scheduleBuildScene(100)) : delta <= 0 && viewPortInfo.zoom.amount < defaultZoom ? (stageZoomDeltaY = 0, scheduleBuildScene(100)) : stageZoomDeltaY = delta;
      }

      function updateStageScale() {
        var stageWidth, stageHeight, stageRatio, bgWidth, bgHeight;
        stageWidth = stage.width(), stageHeight = stage.height(), stageRatio = stageWidth / stageHeight, bgWidth = 0, bgHeight = 0, floorPlanInfo.imageRatio > stageRatio ? (bgWidth = stageWidth, bgHeight = stageWidth / floorPlanInfo.imageRatio) : (bgWidth = stageHeight * floorPlanInfo.imageRatio, bgHeight = stageHeight), viewPortInfo = {
          mapX: (stageWidth - (bgWidth |= 0)) / 2,
          mapY: (stageHeight - (bgHeight |= 0)) / 2,
          mapWidth: bgWidth,
          mapHeight: bgHeight,
          scale: bgWidth / floorPlanInfo.imageWidth,
          zoom: viewPortInfo.zoom
        }, bgImage && (bgImage.x(viewPortInfo.mapX), bgImage.y(viewPortInfo.mapY), bgImage.size({
          width: viewPortInfo.mapWidth,
          height: viewPortInfo.mapHeight
        }), bgLayer.batchDraw()), newPoiLayer && (newPoiLayer.x(viewPortInfo.mapX), newPoiLayer.y(viewPortInfo.mapY), newPoiLayer.batchDraw()), buildScene(), buildNewItem();
      }

      function setStageSize(width, height) {
        stage.width() != width && stage.width(width), stage.height() != height && stage.height(height), updateStageScale();
      }

      function scheduleBuildScene(timeout) {
        nextBuildTime = new Date().getTime() + (void 0 != timeout ? timeout : 50);
      }

      function buildScene() {
        nextBuildTime = 0;
        new Date().getTime();

        if (poiLayer.destroyChildren(), $scope.items && bgImage) {
          poiLayer && (poiLayer.x(viewPortInfo.mapX), poiLayer.y(viewPortInfo.mapY));

          for (var focusShape = null, textObjects = [], shapesToCache = [], i = 0; i < $scope.items.length; i++) {
            var item = $scope.items[i],
                itemStyle = item.style ? angular.copy(item.style) : {};

            for (var key in defaultStyle) {
              void 0 === itemStyle[key] && (itemStyle[key] = defaultStyle[key]);
            }

            var shape = null;
            if (item && item.geoJSON && item.geoJSON.geometry && item.geoJSON.geometry.type) switch (item.geoJSON.geometry.type.toLowerCase()) {
              case "polygon":
                shape = FpePoiLayerUtil.buildItemPolygon(item, viewPortInfo, defaultStyle);
                break;

              case "point":
                shape = FpePoiLayerUtil.buildItemPoint(item, viewPortInfo, defaultStyle);
            }

            if (shape) {
              var shapeOpacity = 1;

              if ($scope.newItem ? shapeOpacity = defaultStyle.defocusOpacity : selectedItems.length && (isSelected(item.id) ? focusShape = shape : shapeOpacity = defaultStyle.defocusOpacity), shape.opacity(shapeOpacity), "auto" == itemStyle.showLabel || void 0 == itemStyle.showLabel) {
                var text = shape.getChildren(function (node) {
                  return "Text" === node.getClassName();
                });

                if (text.length) {
                  (text = text[0]).remove(), text.opacity(shapeOpacity), text.listening(!1);
                  var boundary = FpePoiLayerUtil.getItemBoundary(item),
                      textBoundary = {
                    l: text.x() + shape.x(),
                    t: text.y() + shape.y(),
                    w: text.textWidth,
                    h: text.textHeight
                  };
                  textBoundary.r = textBoundary.l + textBoundary.w, textBoundary.b = textBoundary.t + textBoundary.h, text.x(textBoundary.l), text.y(textBoundary.t);
                  var area = boundary.w * boundary.h;
                  textObjects.push({
                    shape: shape,
                    text: text,
                    focusShape: focusShape === shape,
                    boundary: boundary,
                    textBoundary: textBoundary,
                    area: area
                  });
                }
              }

              shape.on("click tap", onShapeItemClick);
              var pixelRatio = viewPortInfo.zoom.amount < 1 ? 1 : viewPortInfo.zoom.amount;
              poiLayer.add(shape), item.isCurrentLocation ? setCurrentLocationAnimation() : shapesToCache.push(shape);
            }
          }

          textObjects.sort(function (a, b) {
            return a.focusShape ? -1 : b.area - a.area;
          }), textObjects.forEach(function (text, index) {
            if (!text.hide) {
              shapesToCache.push(text.text), poiLayer.add(text.text);

              for (var i = index + 1; i < textObjects.length; i++) {
                var nextText = textObjects[i];
                FpePoiLayerUtil.doBoundariesOverlap(text.textBoundary, nextText.textBoundary, 5) && (nextText.hide = !0);
              }
            }
          }), shapesToCache.forEach(function (shape) {
            shape.cache({
              imageSmoothingEnabled: !1,
              offset: 4,
              pixelRatio: pixelRatio * DPI
            });
          }), focusShape && focusShape.zIndex($scope.items.length - 1), bgLayer.batchDraw(), $scope.newItem && (buildNewItem(), newPoiLayer && newPoiLayer.batchDraw()), new Date().getTime();
        }
      }

      function setCurrentLocationAnimation() {
        var puddle = poiLayer.find(".puddle")[0];
        puddle && (tween && tween.destroy(), new Konva.Animation(function (frame) {
          var scale = frame.time / 1e3 % 1,
              opacity = 1 - scale;
          puddle.scale({
            x: scale,
            y: scale
          }), puddle.opacity(opacity);
        }, poiLayer).start());
      }

      function getItemBoundary(itemId) {
        var item = getItem(itemId);
        return item ? FpePoiLayerUtil.getItemBoundary(item) : null;
      }

      function moveItem(itemId, newPosition) {
        var item = getItem(itemId);
        if (!item || !newPosition) return null;
        var boundary = FpePoiLayerUtil.getItemBoundary(item),
            xDiff = 0,
            yDiff = 0;
        newPosition.x && (xDiff = newPosition.x - boundary.l), newPosition.y && (yDiff = newPosition.y - boundary.t);
        var points = FpePoiLayerUtil.convertGeoJsonToPoints(item.geoJSON);
        points = FpePoiLayerUtil.transformPoints(points, 1, {
          x: xDiff,
          y: yDiff
        }), item.geoJSON = FpePoiLayerUtil.convertPointsToGeoJson(points), buildScene();
      }

      function updateItem(item) {
        if (!(item = getItem(item.id))) return null;
        buildScene();
      }

      function isSelected(itemId) {
        for (var i = 0; i < selectedItems.length; i++) {
          if (selectedItems[i] == itemId) return !0;
        }

        return !1;
      }

      function selectItems(itemIds) {
        selectedItems = itemIds || [], cancelNewItem();
      }

      function getSelectedItems() {
        return angular.copy(selectedItems);
      }

      function cancelNewItem() {
        $scope.newItem && ($scope.newItem = null, $scope.onNewItemCancel()), newPoiLayer && (newPoiLayer.destroyChildren(), newPoiLayer.batchDraw()), $scope.newItem = null, scheduleBuildScene();
      }

      function createNewItem(type, options) {
        newPoiLayer && (type || (type = "polygon"), selectItems = [], $scope.newItem = null, cancelNewItem(), $scope.newItem = {
          coords: [],
          type: type,
          options: options,
          mode: "create"
        }, $scope.newItem.group = new Konva.Group({
          x: 0,
          y: 0,
          draggable: !1
        }), newPoiLayer.add($scope.newItem.group), stageContainer.focus());
      }

      function getMousePoint() {
        return FpePoiLayerUtil.getRelativePointerPosition(bgImage, viewPortInfo.scale);
      }

      function stageMouseMove(konvaEvt) {
        var point = getMousePoint();
        $scope.newItem && "create" == $scope.newItem.mode && "polygon" == $scope.newItem.type && function (point, snap) {
          snap && (point = FpePoiLayerUtil.autoSnapPoint(point, $scope.newItem.coords, 5 / viewPortInfo.scale)), $scope.newItem.mousePoint = point, buildNewItem();
        }(point, !konvaEvt.evt.shiftKey);
      }

      function stageClick(konvaEvt) {
        var point = getMousePoint();
        if ($scope.newItem && "create" == $scope.newItem.mode && floorplanCanvas) if ("trace" == $scope.newItem.type) {
          for (var i = 0; i < $scope.items.length; i++) {
            var item = $scope.items[i];
            if (FpePoiLayerUtil.isInside(point, FpePoiLayerUtil.convertGeoJsonToPoints(item.geoJSON))) return void console.warn("Clicking within existing shape not allowed");
          }

          var renderPoint = angular.copy(point);
          renderPoint.x *= floorPlanInfo.renderScale, renderPoint.y *= floorPlanInfo.renderScale;
          var result = magicDetectUtil.detectShapeFromPoint(floorplanCanvas, renderPoint, null);
          $scope.$evalAsync(function () {
            if (result.success && $scope.newItem && result.corners.length > 3) {
              if (result.corners = FpePoiLayerUtil.transformPoints(result.corners, 1 / floorPlanInfo.renderScale), $scope.newItem.coords = result.corners, $scope.newItem.options && 0 == $scope.newItem.options.requireConfirmation) return onNewItemComplete(), void buildNewItem();
              $scope.newItem.mode = "modify", buildNewItem();
            } else cancelNewItem();
          });
        } else "polygon" == $scope.newItem.type ? addPointToNewItem(point, !konvaEvt.evt.shiftKey) : "point" == $scope.newItem.type && addPointToNewItem(point, !konvaEvt.evt.shiftKey);
      }

      function bgLayerClick(konvaEvt) {
        $scope.onStageClick(konvaEvt.evt);
      }

      function onShapeItemClick(konvaEvt) {
        var item = getItem(konvaEvt.currentTarget.attrs.id);
        item && $scope.$evalAsync(function () {
          $scope.onItemClick({
            item: item,
            event: konvaEvt.evt
          });
        });
      }

      function getItem(id) {
        if (!$scope.items) return null;

        for (var i = 0; i < $scope.items.length; i++) {
          var item = $scope.items[i];
          if (item.id == id) return item;
        }

        return null;
      }

      function addPointToNewItem(point, snap) {
        var snapPoint = FpePoiLayerUtil.autoSnapPoint(point, $scope.newItem.coords, 5 / viewPortInfo.scale);
        snap && (point = snapPoint), $scope.$evalAsync(function () {
          $scope.newItem.coords.push(point), "point" == $scope.newItem.type && 1 == $scope.newItem.coords.length ? onNewItemComplete() : buildNewItem();
        });
      }

      function buildNewItem() {
        if ($scope.newItem && $scope.newItem.group && newPoiLayer) {
          $scope.newItem.group.destroyChildren();
          var touchLayer = new Konva.Rect({
            x: 0,
            y: 0,
            width: viewPortInfo.mapWidth,
            height: viewPortInfo.mapHeight,
            strokeWidth: 0
          });
          touchLayer.on("click", stageClick), touchLayer.on("mousemove", stageMouseMove), $scope.newItem.group.add(touchLayer);
          var anchorCoords = angular.copy($scope.newItem.coords),
              outlineCoords = angular.copy($scope.newItem.coords);
          "create" == $scope.newItem.mode && outlineCoords.length > 0 && $scope.newItem.mousePoint && outlineCoords.push($scope.newItem.mousePoint), outlineCoords = FpePoiLayerUtil.transformPoints(outlineCoords, viewPortInfo.scale), anchorCoords = FpePoiLayerUtil.transformPoints(anchorCoords, viewPortInfo.scale);
          var fillColor = tinycolor(defaultStyle.fill),
              strokeColor = null;
          fillColor.getBrightness() > 50 ? (fillColor.darken(20), strokeColor = tinycolor(fillColor).toRgbString()) : (fillColor.lighten(20), strokeColor = tinycolor(fillColor).toRgbString());
          var outline = new Konva.Line({
            points: FpePoiLayerUtil.convertPointsToCoordArray(outlineCoords),
            fill: defaultStyle.fill,
            stroke: strokeColor,
            strokeWidth: defaultStyle.strokeWidth,
            opacity: defaultStyle.opacity,
            closed: !0
          });
          outline.on("click", stageClick), outline.on("mousemove", stageMouseMove), $scope.newItem.group.add(outline);

          for (var k = 0; k < anchorCoords.length; k++) {
            var anchor = FpePoiLayerUtil.buildAnchor(anchorCoords[k], defaultStyle);
            0 == k ? anchor.on("click", onNewItemFirstAnchorClick) : anchor.on("click", onNewItemAnchorClick), $scope.newItem.group.add(anchor);
          }

          newPoiLayer.batchDraw();
        }
      }

      function onNewItemFirstAnchorClick(evt) {
        $scope.$evalAsync(function () {
          onNewItemComplete();
        }), evt.cancelBubble = !0;
      }

      function onNewItemAnchorClick(evt) {
        evt.cancelBubble = !0;
      }

      function onNewItemComplete() {
        if ($scope.newItem && $scope.newItem.coords.length >= 1) {
          var geoJSON = FpePoiLayerUtil.convertPointsToGeoJson($scope.newItem.coords);
          $scope.newItem = null, cancelNewItem(), $scope.onNewItem({
            item: {
              geoJSON: geoJSON
            }
          });
        } else cancelNewItem();
      }

      function onStageBlur() {
        $scope.options && $scope.options.cancelOnBlur && $scope.$evalAsync(cancelNewItem);
      }

      function onKeyDown(evt) {
        switch (evt.keyCode) {
          case 8:
            !function (evt) {
              $scope.$evalAsync(function () {
                $scope.newItem && ("trace" == $scope.newItem.type ? cancelNewItem() : "point" == $scope.newItem.type ? cancelNewItem() : "polygon" == $scope.newItem.type && ($scope.newItem.coords.length >= 3 ? ($scope.newItem.mode = "create", $scope.newItem.coords.splice($scope.newItem.coords.length - 1, 1), buildNewItem()) : cancelNewItem()));
              }), evt.preventDefault();
            }(evt);
            break;

          case 13:
            !function (evt) {
              $scope.$evalAsync(function () {
                $scope.newItem && 0 == $scope.newItem.coords.length ? cancelNewItem() : $scope.newItem && "polygon" == $scope.newItem.type && $scope.newItem.coords.length < 3 ? cancelNewItem() : onNewItemComplete();
              }), evt.preventDefault();
            }(evt);
            break;

          case 27:
            !function (evt) {
              $scope.$evalAsync(function () {
                $scope.newItem && "trace" == $scope.newItem.type ? cancelNewItem() : $scope.newItem && "point" == $scope.newItem.type ? cancelNewItem() : $scope.newItem && "polygon" == $scope.newItem.type && ($scope.newItem.coords.length >= 3 ? ($scope.newItem.mode = "modify", buildNewItem()) : cancelNewItem());
              }), evt.preventDefault();
            }(evt);
            break;

          case 37:
            !function (evt) {
              $scope.newItem && $scope.newItem.coords.length >= 2 && ($scope.newItem.coords[$scope.newItem.coords.length - 1].x -= 2, buildNewItem()), evt.preventDefault();
            }(evt);
            break;

          case 39:
            !function (evt) {
              $scope.newItem && $scope.newItem.coords.length >= 2 && ($scope.newItem.coords[$scope.newItem.coords.length - 1].x += 2, buildNewItem()), evt.preventDefault();
            }(evt);
            break;

          case 38:
            !function (evt) {
              $scope.newItem && $scope.newItem.coords.length >= 2 && ($scope.newItem.coords[$scope.newItem.coords.length - 1].y -= 2, buildNewItem()), evt.preventDefault();
            }(evt);
            break;

          case 40:
            !function (evt) {
              $scope.newItem && $scope.newItem.coords.length >= 2 && ($scope.newItem.coords[$scope.newItem.coords.length - 1].y += 2, buildNewItem()), evt.preventDefault();
            }(evt);
        }
      }
    }
  };
}), window.angular.module("core.ui").factory("FpePoiLayerUtil", ["FloorplanEditorEnums", function (FloorplanEditorEnums) {
  var iconLookup = {},
      currentLocationGroup = new Konva.Group({}),
      CURRENT_LOCATION_POI = {
    FLAG: "isCurrentLocation",
    ICON: "icon-pin"
  };
  return {
    convertGeoJsonToPoints: convertGeoJsonToPoints,
    convertCoordsToGeoJson: convertCoordsToGeoJson,
    convertPointsToGeoJson: convertPointsToGeoJson,
    convertPointsToCoordArray: convertPointsToCoordArray,
    transformCoords: function transformCoords(coords, scale, translate) {
      var tformed = [];
      translate || (translate = {}), scale || (scale = 1);

      for (var k = 0; k < coords.length; k += 2) {
        var x = coords[k] * scale,
            y = coords[k + 1] * scale;
        translate && translate.x && (x += translate.x), translate && translate.y && (y += translate.y), scale && (x *= scale, y *= scale), tformed.push(x, y);
      }

      return tformed;
    },
    transformPoints: transformPoints,
    area: area,
    centerOfMass: centerOfMass,
    getRelativePointerPosition: function getRelativePointerPosition(node, stageScale) {
      stageScale || (stageScale = 1);
      var transform = node.getAbsoluteTransform().copy();
      transform.invert();
      var pos = node.getStage().getPointerPosition(),
          point = transform.point(pos);
      return point.x /= stageScale, point.y /= stageScale, point;
    },
    getItemBoundary: getItemBoundary,
    getBoundaryFromPoints: getBoundaryFromPoints,
    detectIsCircleFromPoints: function detectIsCircleFromPoints(points) {
      if ((points = angular.copy(points)).length < 10) return {
        confidence: 0
      };
      var boundary = getBoundaryFromPoints(points),
          midX = (boundary.r - boundary.l) / 2,
          midY = (boundary.b - boundary.t) / 2,
          radius = midX;
      points = transformPoints(points, 1, {
        x: -(boundary.l + midX),
        y: -(boundary.t + midY)
      });

      for (var circlePointLookup = {}, circlePoints = generateCirclePoints(radius, 4), i = 0; i < circlePoints.length; i++) {
        var point = circlePoints[i];
        point.x = 3 * Math.floor(point.x / 3), point.y = 3 * Math.floor(point.y / 3);
        var lookupId = point.x + "." + point.y;
        circlePointLookup[lookupId] = !0;
      }

      for (var pointsThatPass = 0, i = 0; i < points.length; i++) {
        var point = points[i],
            x = 3 * Math.floor(point.x / 3),
            y = 3 * Math.floor(point.y / 3),
            lookupId = x + "." + y;
        circlePointLookup[lookupId] && pointsThatPass++;
      }

      var percentThatPass = pointsThatPass / points.length * 100;
      return {
        point: {
          x: boundary.l + midX,
          y: boundary.t + midY
        },
        radius: radius + 1,
        confidence: percentThatPass
      };
    },
    generateCirclePoints: generateCirclePoints,
    distanceBetweenPoints: distanceBetweenPoints,
    angleBetweenPoints: angleBetweenPoints,
    areaFromCoords: areaFromCoords,
    areaFromPoints: function areaFromPoints(points) {
      return areaFromCoords(convertPointsToCoordArray(points));
    },
    isInside: function isInside(point, coords) {
      for (var inside = !1, i = 0, j = coords.length - 1; i < coords.length; j = i++) {
        var xi = coords[i].x,
            yi = coords[i].y,
            xj = coords[j].x,
            yj = coords[j].y,
            intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
        intersect && (inside = !inside);
      }

      return inside;
    },
    doBoundariesOverlap: function doBoundariesOverlap(a, b, margin) {
      return margin || (margin = 0), !(a.l >= b.r + margin || a.t >= b.b + margin || a.r <= b.l - margin || a.b <= b.t - margin);
    },
    autoSnapPoint: autoSnapPoint,
    pointInCollection: pointInCollection,
    removeRedundantPoints: function removeRedundantPoints(points) {
      for (var points = angular.copy(points), scIncrement = 0; scIncrement < 2; scIncrement++) {
        for (var i = 0; i < points.length - 8; i++) {
          for (var samples = [], k = 0; k < 5; k++) {
            samples[k] = points[i + k];
          }

          for (var angles = [], k = 0; k < 4; k++) {
            angles[k] = Math.atan2(samples[k + 1].y - samples[k].y, samples[k + 1].x - samples[k].x);
          }

          for (var repeatingPattern = !0, k = 0; k < angles.length - 2; k++) {
            if (angles[k] != angles[k + 2]) {
              repeatingPattern = !1;
              break;
            }
          }

          repeatingPattern && points.splice(i + 1, 3);
        }
      }

      for (var startIndex = 0, newPoints = [], midPoints = [], i = 0; i < points.length; i++) {
        var startPoint = points[startIndex],
            newPoint = points[i],
            distance = distanceBetweenPoints(startPoint, newPoint);

        if (midPoints.push(newPoint), distance >= 10) {
          var v = doPointsFallOnLine(startPoint, newPoint, midPoints, 4);
          v || (newPoints.push(points[i - 1]), newPoints.push(points[i]), midPoints = [], startIndex = i);
        }
      }

      newPoints.push(points[points.length - 1]);

      for (var snappedPoints = [], i = 0; i < newPoints.length; i++) {
        var point = newPoints[i];
        point = autoSnapPoint(point, snappedPoints, 1.5), snappedPoints.push(point);
      }

      for (var uniquePoints = [], i = 0; i < snappedPoints.length; i++) {
        var snappedPoint = snappedPoints[i];
        pointInCollection(snappedPoint, uniquePoints) || uniquePoints.push(snappedPoint);
      }

      return uniquePoints;
    },
    alignShapesVerticalGeoJson: function alignShapesVerticalGeoJson(shapes) {
      if (!shapes || 1 == shapes.length) return shapes;
      var shapeCollection = [];
      shapes.forEach(function (shape) {
        var shape = {
          geoJSON: shape,
          points: convertGeoJsonToPoints(shape)
        };
        shape.centerOfMass = centerOfMass(shape.points), shapeCollection.push(shape);
      });
      var targetY = shapeCollection[0].centerOfMass.y;
      return shapeCollection.forEach(function (shape, index) {
        var yDiff = shape.centerOfMass.y - targetY;
        shape.points = transformPoints(shape.points, 1, {
          y: -yDiff,
          x: 0
        }), shapes[index] = convertPointsToGeoJson(shape.points);
      }), shapes;
    },
    alignShapesHorizontalGeoJson: function alignShapesHorizontalGeoJson(shapes) {
      if (!shapes || 1 == shapes.length) return shapes;
      var shapeCollection = [];
      shapes.forEach(function (shape) {
        var shape = {
          geoJSON: shape,
          points: convertGeoJsonToPoints(shape)
        };
        shape.centerOfMass = centerOfMass(shape.points), shapeCollection.push(shape);
      });
      var targetX = shapeCollection[0].centerOfMass.x;
      return shapeCollection.forEach(function (shape, index) {
        var xDiff = shape.centerOfMass.x - targetX;
        shape.points = transformPoints(shape.points, 1, {
          x: -xDiff,
          y: 0
        }), shapes[index] = convertPointsToGeoJson(shape.points);
      }), shapes;
    },
    buildItemPolygon: function buildItemPolygon(item, viewport, defaultStyle) {
      defaultStyle = defaultStyle ? angular.copy(defaultStyle) : {};
      var stageScale = viewport.scale,
          zoom = viewport.zoom.amount > 1 ? 1 + .3 * (viewport.zoom.amount - 1) : viewport.zoom.amount,
          itemStyle = item.style ? angular.copy(item.style) : {};

      for (var key in void 0 === itemStyle.showLabel && "Desk" == item.subType && (itemStyle.showLabel = !1), defaultStyle) {
        void 0 === itemStyle[key] && (itemStyle[key] = defaultStyle[key]);
      }

      var boundary = getItemBoundary(item),
          points = convertGeoJsonToPoints(item.geoJSON),
          fontSize = (itemStyle.fontSize ? itemStyle.fontSize : 16) / zoom,
          iconSize = (itemStyle.iconSize ? itemStyle.iconSize : fontSize) / zoom;
      points = transformPoints(points, stageScale, {
        x: -boundary.l,
        y: -boundary.t
      }), boundary.l *= stageScale, boundary.t *= stageScale, boundary.r *= stageScale, boundary.b *= stageScale, boundary.w *= stageScale, boundary.h *= stageScale;
      var group = new Konva.Group({
        id: item.id,
        x: boundary.l,
        y: boundary.t,
        draggable: "move" == item.editMode
      }),
          fillColor = tinycolor(itemStyle.fill),
          strokeColor = null;
      fillColor.getBrightness() > 50 ? (fillColor.darken(40), strokeColor = tinycolor(fillColor).toRgbString()) : (fillColor.lighten(40), strokeColor = tinycolor(fillColor).toRgbString());
      var coords = convertPointsToCoordArray(points),
          area = areaFromCoords(coords),
          strokeWidth = void 0 != itemStyle.strokeWidth ? itemStyle.strokeWidth : 1;
      strokeWidth /= zoom;
      var outline = new Konva.Line({
        id: item.id + "_outline",
        points: coords,
        fill: itemStyle.fill,
        stroke: itemStyle.stroke ? itemStyle.stroke : strokeColor,
        strokeWidth: strokeWidth,
        strokeScaleEnabled: !1,
        opacity: 1,
        closed: !0
      });
      if ("modify" == item.editMode) for (var k = 0; k < points.length; k++) {
        var anchor = buildAnchor(points[k], itemStyle);
        group.add(anchor);
      }
      outline.transformsEnabled("position"), outline.hitStrokeWidth(0), outline.perfectDrawEnabled(!0), outline.shadowForStrokeEnabled(!1);
      var centerPoint = centerOfMass(points);

      if ("POI" == item.type) {
        var minArea = fontSize * fontSize * 2,
            iconBubble = null;
        area > minArea && "POI" == item.type ? (iconBubble = function (item, centerPoint, defaultStyle, strokeColor, fontSize, viewport) {
          var zoom = viewport.zoom.amount > 1 ? 1 + .3 * (viewport.zoom.amount - 1) : viewport.zoom.amount,
              itemStyle = item.style ? angular.copy(item.style) : {};

          for (var key in defaultStyle) {
            void 0 === itemStyle[key] && (itemStyle[key] = defaultStyle[key]);
          }

          var strokeWidth = void 0 != itemStyle.strokeWidth ? itemStyle.strokeWidth : 1;

          if (strokeWidth /= zoom, FloorplanEditorEnums.POIs[item.type]) {
            var subType = FloorplanEditorEnums.POIs[item.type][item.subType];

            if (subType) {
              var midX = centerPoint.x,
                  midY = centerPoint.y,
                  iconInfo = getIconInfo(subType.icon),
                  labelColor = itemStyle.labelColor ? itemStyle.labelColor : "black",
                  labelColorBrightness = tinycolor(labelColor).getBrightness(),
                  labelColorStroke = labelColorBrightness > 50 ? "black" : "white",
                  simpleText = new Konva.Text({
                text: iconInfo.content,
                fontSize: fontSize,
                fontFamily: iconInfo.fontFamily,
                fill: labelColor,
                stroke: labelColorStroke,
                strokeScaleEnabled: !1,
                strokeWidth: strokeWidth
              });
              simpleText.fillAfterStrokeEnabled(!0), simpleText.transformsEnabled("position"), simpleText.hitStrokeWidth(0), simpleText.perfectDrawEnabled(!0), simpleText.shadowForStrokeEnabled(!1);
              var x = midX - simpleText.textWidth / 2,
                  y = midY - simpleText.textHeight / 2;
              return simpleText.x(x), simpleText.y(y), simpleText;
            }
          }

          return null;
        }(item, centerPoint, defaultStyle, 0, iconSize + 1, viewport), group.add(outline)) : iconBubble = createSubtypeIconBubble(viewport, item, centerPoint, defaultStyle, strokeColor, iconSize + 1, zoom), iconBubble && group.add(iconBubble);
      } else if (group.add(outline), !1 !== itemStyle.showLabel) {
        var labelColor = itemStyle.labelColor ? itemStyle.labelColor : "black",
            labelColorBrightness = tinycolor(labelColor).getBrightness(),
            labelColorStroke = labelColorBrightness > 50 ? "black" : "white",
            simpleText = new Konva.Text({
          text: item.name,
          fontSize: fontSize,
          fontFamily: itemStyle.labelFont ? itemStyle.labelFont : "Roboto",
          fill: labelColor,
          stroke: labelColorStroke,
          strokeWidth: strokeWidth
        });
        simpleText.fillAfterStrokeEnabled(!0), simpleText.transformsEnabled("position"), simpleText.hitStrokeWidth(0), simpleText.perfectDrawEnabled(!0), simpleText.shadowForStrokeEnabled(!1);
        var widthScale = simpleText.textWidth / boundary.w,
            heightScale = simpleText.textHeight / boundary.h,
            scale = widthScale > heightScale ? widthScale : heightScale;

        if (scale <= .95) {
          var x = centerPoint.x - simpleText.textWidth / 2,
              y = centerPoint.y - simpleText.textHeight / 2.5;
          simpleText.x(x), simpleText.y(y), group.add(simpleText);
        } else if (scale < 1.5 || !0 === itemStyle.showLabel) {
          simpleText.fontSize(1 * fontSize / scale - .5);
          var x = centerPoint.x - simpleText.textWidth / 2,
              y = centerPoint.y - simpleText.textHeight / 2.5;
          simpleText.x(x), simpleText.y(y), group.add(simpleText);
        } else simpleText.destroy();
      }

      return group;
    },
    buildAnchor: buildAnchor,
    buildItemPoint: function buildItemPoint(item, viewport, defaultStyle) {
      defaultStyle = defaultStyle ? angular.copy(defaultStyle) : {};
      var zoom = viewport.zoom.amount > 1 ? 1 + .3 * (viewport.zoom.amount - 1) : viewport.zoom.amount,
          stageScale = viewport.scale,
          itemStyle = item.style ? angular.copy(item.style) : {};

      for (var key in defaultStyle) {
        void 0 === itemStyle[key] && (itemStyle[key] = defaultStyle[key]);
      }

      var boundary = getItemBoundary(item),
          points = convertGeoJsonToPoints(item.geoJSON),
          fontSize = (itemStyle.fontSize ? itemStyle.fontSize : 16) / zoom,
          iconSize = (itemStyle.iconSize ? itemStyle.iconSize : fontSize) / zoom,
          markerSize = (itemStyle.markerSize ? itemStyle.markerSize : 10) / (!1 === itemStyle.autoResize ? 1 : zoom);
      !1 === itemStyle.autoResize && (markerSize *= stageScale), points = transformPoints(points, stageScale, {
        x: -boundary.l,
        y: -boundary.t
      }), boundary.l *= stageScale, boundary.t *= stageScale, boundary.r *= stageScale, boundary.b *= stageScale;
      var group = new Konva.Group({
        id: item.id,
        x: boundary.l,
        y: boundary.t,
        draggable: "move" == item.editMode
      }),
          fillColor = tinycolor(itemStyle.fill),
          strokeColor = null;
      fillColor.getBrightness() > 50 ? (fillColor.darken(40), strokeColor = tinycolor(fillColor).toRgbString()) : (fillColor.lighten(40), strokeColor = tinycolor(fillColor).toRgbString());
      var strokeWidth = void 0 != itemStyle.strokeWidth ? itemStyle.strokeWidth : 1;
      strokeWidth /= zoom;
      var iconBubble = createSubtypeIconBubble(viewport, item, points[0], defaultStyle, strokeColor, iconSize + 1, zoom);
      if (iconBubble) group.add(iconBubble);else {
        var outline = new Konva.Circle({
          id: item.id + "_outline",
          radius: markerSize,
          x: 0,
          y: 0,
          fill: itemStyle.fill,
          stroke: itemStyle.stroke ? itemStyle.stroke : strokeColor,
          strokeWidth: strokeWidth,
          strokeScaleEnabled: !1,
          opacity: itemStyle.opacity,
          closed: !0
        });
        outline.transformsEnabled("position"), outline.hitStrokeWidth(0), outline.perfectDrawEnabled(!0), outline.shadowForStrokeEnabled(!1), group.add(outline);
      }
      return group;
    }
  };

  function area(points) {
    var i,
        j,
        point1,
        point2,
        area = 0;

    for (i = 0, j = points.length - 1; i < points.length; j = i, i++) {
      point1 = points[i], point2 = points[j], area += point1.x * point2.y, area -= point1.y * point2.x;
    }

    return area /= 2;
  }

  function centerOfMass(points) {
    if (1 == points.length) return points[0];
    var i,
        j,
        f,
        point1,
        point2,
        x = 0,
        y = 0;

    for (i = 0, j = points.length - 1; i < points.length; j = i, i++) {
      point1 = points[i], point2 = points[j], f = point1.x * point2.y - point2.x * point1.y, x += (point1.x + point2.x) * f, y += (point1.y + point2.y) * f;
    }

    return {
      x: x / (f = 6 * area(points)),
      y: y / f
    };
  }

  function getIconInfo(icon) {
    if (iconLookup[icon]) return iconLookup[icon];
    var iconElm = $('<i class="' + icon + '"></i>');
    iconElm.css("display", "none"), $("body").append(iconElm);
    var compStyle = window.getComputedStyle(iconElm[0], ":before"),
        iconInfo = {
      content: compStyle.content.substring(1, compStyle.content.length - 1),
      fontFamily: compStyle.fontFamily
    };
    return iconElm.remove(), iconLookup[icon] = iconInfo, iconInfo;
  }

  function areaFromCoords(coordArray) {
    var x = coordArray,
        a = 0;
    if (x.length % 2) return 0;

    for (var i = 0, iLen = x.length - 2; i < iLen; i += 2) {
      a += x[i] * x[i + 3] - x[i + 2] * x[i + 1];
    }

    return Math.abs(a / 2);
  }

  function transformPoints(points, scale, translate) {
    var tformed = [];
    translate || (translate = {}), scale || (scale = 1);

    for (var k = 0; k < points.length; k++) {
      var x = points[k].x,
          y = points[k].y;
      translate.x && (x += translate.x), translate.y && (y += translate.y), scale && (x *= scale, y *= scale), tformed.push({
        x: x,
        y: y
      });
    }

    return tformed;
  }

  function generateCirclePoints(radius, degIncrement, position) {
    degIncrement || (degIncrement = 4), position || (position = {
      x: 0,
      y: 0
    });

    for (var points = [], angle = 0; angle < 360; angle += degIncrement) {
      var x = radius * Math.cos(angle * Math.PI / 180),
          y = radius * Math.sin(angle * Math.PI / 180);
      points.push({
        x: x + position.x,
        y: y + position.y
      });
    }

    return points;
  }

  function convertPointsToCoordArray(points) {
    for (var coords = [], k = 0; k < points.length; k++) {
      coords.push(points[k].x, points[k].y);
    }

    return coords;
  }

  function pointInCollection(point, points) {
    for (var k = 0; k < points.length; k++) {
      var existing = points[k];
      if (existing.x == point.x && existing.y == point.y) return !0;
    }

    return !1;
  }

  function autoSnapPoint(point, points, maxDistance) {
    maxDistance || (maxDistance = 10);

    for (var closestX = Number.MAX_VALUE, closestY = Number.MAX_VALUE, newX = null, newY = null, k = 0; k < points.length; k++) {
      var existing = points[k],
          xDiff = Math.abs(point.x - existing.x),
          yDiff = Math.abs(point.y - existing.y);
      xDiff < closestX && xDiff < maxDistance && (closestX = xDiff, newX = existing.x), yDiff < closestY && yDiff < maxDistance && (closestY = yDiff, newY = existing.y);
    }

    return {
      x: newX || point.x,
      y: newY || point.y
    };
  }

  function distanceBetweenPoints(p1, p2) {
    var a = p1.x - p2.x,
        b = p1.y - p2.y;
    return Math.sqrt(a * a + b * b);
  }

  function angleBetweenPoints(p1, p2) {
    var deltaY = p2.y - p1.y,
        deltaX = p2.x - p1.x;
    return Math.atan2(deltaY, deltaX) * (180 / Math.PI);
  }

  function findPointFromAngleDistance(point, angle, distance) {
    var newPoint = {};
    return newPoint.x = Math.cos(angle * Math.PI / 180) * distance + point.x, newPoint.y = Math.sin(angle * Math.PI / 180) * distance + point.y, newPoint;
  }

  function doPointsFallOnLine(p1, p2, points, allowedDistance) {
    for (var angle = angleBetweenPoints(p1, p2), i = 0; i < points.length; i++) {
      var point = points[i];
      if (distanceBetweenPoints(findPointFromAngleDistance(p1, angle, distanceBetweenPoints(p1, point)), point) > allowedDistance) return !1;
    }

    return !0;
  }

  function convertGeoJsonToPoints(geoJSON) {
    var points = [];
    if ("Polygon" == geoJSON.geometry.type) for (var i = 0; i < geoJSON.geometry.coordinates[0].length; i++) {
      var point = {
        x: geoJSON.geometry.coordinates[0][i][0],
        y: geoJSON.geometry.coordinates[0][i][1]
      };
      points.push(point);
    } else "Point" == geoJSON.geometry.type && (point = {
      x: geoJSON.geometry.coordinates[0],
      y: geoJSON.geometry.coordinates[1]
    }, points.push(point));
    return points;
  }

  function getBoundaryFromPoints(points) {
    for (var boundary = {
      l: Number.MAX_VALUE,
      t: Number.MAX_VALUE,
      r: Number.MIN_VALUE,
      b: Number.MIN_VALUE
    }, i = 0; i < points.length; i++) {
      var point = points[i];
      point.x < boundary.l ? boundary.l = point.x : point.x > boundary.r && (boundary.r = point.x), point.y < boundary.t ? boundary.t = point.y : point.y > boundary.b && (boundary.b = point.y);
    }

    return boundary.w = boundary.r - boundary.l, boundary.h = boundary.b - boundary.t, boundary;
  }

  function getItemBoundary(item) {
    return getBoundaryFromPoints(convertGeoJsonToPoints(item.geoJSON));
  }

  function createCurrentLocationIcon(centerPoint, itemStyle, fontSize) {
    return function (centerPoint, itemStyle, fontSize) {
      var iconInfo = getIconInfo(CURRENT_LOCATION_POI.ICON),
          simpleText = new Konva.Text({
        text: iconInfo.content,
        fontSize: fontSize,
        fontFamily: iconInfo.fontFamily,
        fill: itemStyle.fill,
        strokeWidth: itemStyle.strokeWidth,
        strokeScaleEnabled: !1,
        padding: 5
      }),
          x = centerPoint.x - simpleText.textWidth / 2 - 5,
          y = centerPoint.y - simpleText.textHeight - 5;
      simpleText.x(x), simpleText.y(y), currentLocationGroup.add(simpleText);
    }(centerPoint, itemStyle, fontSize), function (centerPoint, itemStyle, fontSize) {
      var puddle = new Konva.Ellipse({
        name: "puddle",
        x: centerPoint.x,
        y: centerPoint.y,
        width: 1.5 * fontSize,
        height: 1.5 * fontSize / 2,
        stroke: itemStyle.fill,
        strokeScaleEnabled: !1,
        strokeWidth: 1,
        opacity: .5
      });
      currentLocationGroup.add(puddle);
    }(centerPoint, itemStyle, fontSize), currentLocationGroup;
  }

  function createSubtypeIconBubble(viewport, item, centerPoint, defaultStyle, strokeColor, fontSize, zoom) {
    var itemStyle = item.style ? angular.copy(item.style) : {},
        stageScale = viewport.scale;

    for (var key in defaultStyle) {
      void 0 === itemStyle[key] && (itemStyle[key] = defaultStyle[key]);
    }

    var markerSize = itemStyle.bubbleSize ? itemStyle.bubbleSize / (!1 === itemStyle.autoResize ? 1 : zoom) : fontSize;
    if (!1 === itemStyle.autoResize && (markerSize *= stageScale), item[CURRENT_LOCATION_POI.FLAG]) return createCurrentLocationIcon(centerPoint, itemStyle, 2 * fontSize);
    var strokeWidth = void 0 != itemStyle.strokeWidth ? itemStyle.strokeWidth : 1;

    if (strokeWidth /= zoom, FloorplanEditorEnums.POIs[item.type] && "Desk" != item.subType) {
      var subType = FloorplanEditorEnums.POIs[item.type][item.subType];

      if (subType) {
        var midX = centerPoint.x,
            midY = centerPoint.y,
            iconInfo = getIconInfo(subType.icon),
            group = new Konva.Group({
          x: midX,
          y: midY
        }),
            labelColor = itemStyle.labelColor ? itemStyle.labelColor : "black",
            labelColorStroke = tinycolor(labelColor).getBrightness() > 50 ? "black" : "white",
            outline = new Konva.Circle({
          radius: markerSize,
          x: 0,
          y: 0,
          fill: itemStyle.fill,
          stroke: strokeColor,
          strokeScaleEnabled: !1,
          strokeWidth: strokeWidth,
          opacity: itemStyle.opacity
        }),
            simpleText = new Konva.Text({
          text: iconInfo.content,
          fontSize: markerSize,
          fontFamily: iconInfo.fontFamily,
          fill: labelColor,
          shadowColor: labelColorStroke,
          shadowBlur: 1,
          shadowOffset: {
            x: 0,
            y: 0
          },
          shadowOpacity: .8
        });
        return simpleText.x(-simpleText.textWidth / 2), simpleText.y(-simpleText.textHeight / 2), simpleText.transformsEnabled("position"), simpleText.hitStrokeWidth(0), simpleText.perfectDrawEnabled(!0), simpleText.shadowForStrokeEnabled(!1), outline.transformsEnabled("position"), outline.hitStrokeWidth(0), outline.perfectDrawEnabled(!0), outline.shadowForStrokeEnabled(!1), group.add(outline), group.add(simpleText), group;
      }
    }

    return null;
  }

  function buildAnchor(point, defaultStyle) {
    var strokeWidth = 1;
    return strokeWidth > 0 && strokeWidth < 1 && (strokeWidth = 1), new Konva.Circle({
      x: point.x,
      y: point.y,
      radius: 3,
      fill: "white",
      stroke: defaultStyle.stroke,
      strokeWidth: strokeWidth,
      strokeScaleEnabled: !1,
      shadowColor: "black",
      shadowBlur: 2,
      shadowOffset: {
        x: 0,
        y: 0
      },
      shadowOpacity: .5,
      draggable: !1
    });
  }

  function convertPointsToGeoJson(points) {
    return convertCoordsToGeoJson(convertPointsToCoordArray(points));
  }

  function convertCoordsToGeoJson(coords) {
    var geoJSON = {
      type: "Feature",
      geometry: {
        type: null,
        coordinates: null,
        properties: null
      }
    };
    if (2 == coords.length) return geoJSON.geometry.type = "Point", geoJSON.geometry.coordinates = coords, geoJSON;

    if (4 == coords.length) {
      geoJSON.geometry.type = "LineString", geoJSON.geometry.coordinates = [];

      for (var i = 0; i < coords.length; i += 2) {
        geoJSON.geometry.coordinates.push([coords[i], coords[i + 1]]);
      }

      return geoJSON;
    }

    if (coords.length >= 6) {
      for (geoJSON.geometry.type = "Polygon", geoJSON.geometry.coordinates = [[]], i = 0; i < coords.length; i += 2) {
        geoJSON.geometry.coordinates[0].push([coords[i], coords[i + 1]]);
      }

      return geoJSON.geometry.coordinates[0][0][0] == geoJSON.geometry.coordinates[0][geoJSON.geometry.coordinates[0].length - 1][0] && geoJSON.geometry.coordinates[0][0][1] == geoJSON.geometry.coordinates[0][geoJSON.geometry.coordinates[0].length - 1][1] || geoJSON.geometry.coordinates[0].push(geoJSON.geometry.coordinates[0][0]), geoJSON;
    }

    return null;
  }
}]), window.angular.module("core.ui").directive("asuiScheduleTableFilterFooter", function () {
  return {
    restrict: "E",
    templateUrl: "component-schedule-table/filter-footer/filter-footer.template",
    scope: {
      filter: "=",
      filterCount: "=",
      totalCount: "="
    },
    link: function link(scope, element) {
      scope.$watch("filter", function () {});
    }
  };
}), window.angular.module("core.ui").directive("asuiScheduleTableItem", function () {
  return {
    restrict: "EA",
    templateUrl: "component-schedule-table/item/item.template",
    scope: {
      item: "="
    },
    link: function link(scope, element) {
      element.addClass("asui-schedule-table-item"), element.on("$destroy", function () {
        element.empty();
      });
    },
    controller: function controller($scope) {
      var currentDirection;
      $scope.$watch("item.direction", function (newValue) {
        currentDirection != newValue && function (direction) {
          switch (currentDirection = direction) {
            case "left":
              $scope.directionIcon = "icon-arrow-back";
              break;

            case "right":
              $scope.directionIcon = "icon-arrow-forward";
              break;

            case "forward-left":
              $scope.directionIcon = "icon-arrow-up-left";
              break;

            case "forward-right":
              $scope.directionIcon = "icon-arrow-up-right";
              break;

            case "backward-left":
              $scope.directionIcon = "icon-arrow-down-left";
              break;

            case "backward-right":
              $scope.directionIcon = "icon-arrow-down-right";
              break;

            case "forward":
              $scope.directionIcon = "icon-arrow-up";
              break;

            case "backward":
              $scope.directionIcon = "icon-arrow-down";
              break;

            case "escalator-up":
              $scope.directionIcon = "icon-escalator-up";
              break;

            case "escalator-down":
              $scope.directionIcon = "icon-escalator-down";
              break;

            case "stairs-up":
              $scope.directionIcon = "icon-stairs-up";
              break;

            case "stairs-down":
              $scope.directionIcon = "icon-stairs-down";
              break;

            default:
              $scope.directionIcon = "";
          }
        }(newValue);
      });
    }
  };
}), window.angular.module("core.ui").constant("FACILITY_CONFIG", {
  capacity: {
    logo: '<svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60"><defs><style>.cls-1{fill:#fff;}</style></defs><g id="Page-1" style="stroke-width: 0;"><g id="Facilities"><g id="profile"><path id="Shape" class="cls-1" d="M29.33,32.78a9.27,9.27,0,0,0,9-9.52,9.24,9.24,0,0,0-9-9.48,9.26,9.26,0,0,0-9,9.48A9.29,9.29,0,0,0,29.33,32.78Zm0-16a6.28,6.28,0,0,1,6,6.5,6.29,6.29,0,0,1-6,6.5,6.29,6.29,0,0,1-6-6.5A6.28,6.28,0,0,1,29.33,16.78Z"/><path id="Shape-2" data-name="Shape" class="cls-1" d="M13.53,46.78h31.6a1.21,1.21,0,0,0,1.2-1.24A11.61,11.61,0,0,0,34.92,33.78H23.75A11.61,11.61,0,0,0,12.33,45.54,1.21,1.21,0,0,0,13.53,46.78Zm10.8-10h10a8.07,8.07,0,0,1,8,7h-26A8.09,8.09,0,0,1,24.33,36.78Z"/></g></g></g></svg>',
    supportsCount: !0,
    styling: {
      width: "auto",
      "padding-right": "0.5em",
      "margin-left": "-0.5em"
    }
  },
  screenShare: {
    logo: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" viewBox="0 0 60 60" style="enable-background:new 0 0 60 60;" xml:space="preserve"><g style="stroke-width: 0;"><path class="st0" d="M9.9,22.6c0-0.2,0-0.4,0-0.6c0-1.6,0-3.2,0-4.8c0-1.4,0.6-2.5,1.8-3.2c0.5-0.3,1.1-0.5,1.7-0.5   c1,0,1.9,0,2.9,0c10,0,20,0,29.9,0c0.9,0,1.7,0.2,2.4,0.7c1.1,0.8,1.5,1.8,1.5,3.2c0,5.5,0,10.9,0,16.4c0,3,0,6,0,9   c0,1.3-0.5,2.3-1.6,3.1c-0.6,0.4-1.2,0.6-1.9,0.6c-4.2,0-8.5,0-12.7,0c-0.1,0-0.1,0-0.2,0c0-1.2,0-2.4,0-3.6c0.1,0,0.2,0,0.3,0   c4,0,8.1,0,12.1,0c0.4,0,0.4,0,0.4-0.4c0-8.3,0-16.5,0-24.8c0-0.1,0-0.2,0-0.3c0-0.2-0.1-0.3-0.2-0.3c-0.1,0-0.1,0-0.2,0   c-10.7,0-21.4,0-32.1,0c-0.4,0-0.4,0-0.4,0.4c0,1.5,0,3.1,0,4.6c0,0.2-0.1,0.3-0.3,0.3c-1,0-2,0-3,0C10.1,22.6,10,22.6,9.9,22.6z"/><path class="st0" d="M9.9,30c0-1.2,0-2.4,0-3.6c4.8,0.1,9.1,1.6,12.8,4.7c4.7,4,7.1,9.2,7.3,15.4c-1.2,0-2.4,0-3.6,0   c-0.1-4.5-1.7-8.4-4.8-11.6C18.3,31.6,14.4,30.1,9.9,30z"/><path class="st0" d="M22.7,46.5c-1.3,0-2.4,0-3.6,0c-0.1-2.5-1-4.7-2.7-6.5c-1.8-1.8-3.9-2.6-6.4-2.7c0-0.1,0-0.2,0-0.3 c0-1,0-2,0-3c0-0.3,0.1-0.3,0.3-0.3c1.4,0,2.7,0.3,4,0.7c2.3,0.8,4.3,2.2,5.8,4.2c1.4,1.8,2.3,3.8,2.6,6.1 C22.6,45.2,22.7,45.8,22.7,46.5z"/><path class="st0" d="M15.3,46.4c-1.8,0-3.6,0-5.4,0c0-1.8,0-3.6,0-5.4c1.3,0,2.5,0.4,3.5,1.3C14.6,43.3,15.3,44.7,15.3,46.4z"/></g></svg>'
  },
  ethernet: {
    logo: '<svg width="60px" height="60px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Artboard-2" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="ethernet-(5)" style="stroke-width: 0;" transform="translate(30.500000, 30.500000) scale(-1, -1) translate(-30.500000, -30.500000) translate(14.000000, 14.000000)" fill="#FFFFFF" fill-rule="nonzero"><polygon id="Shape" points="28.875 20.625 22.6875 20.625 22.6875 28.875 10.3125 28.875 10.3125 20.625 4.125 20.625 4.125 0 0 0 0 24.75 6.1875 24.75 6.1875 33 26.8125 33 26.8125 24.75 33 24.75 33 0 28.875 0"></polygon><rect id="Rectangle-path" x="10" y="0" width="4" height="12"></rect><rect id="Rectangle-path" x="19" y="0" width="4" height="12"></rect></g></g></svg>'
  },
  phone: {
    logo: '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="60px" height="60px" viewBox="0 0 60 60" version="1.1"><g id="Artboard-2" stroke="none" stroke-width="1.5" fill="none" fill-rule="evenodd"><g id="phone-call" transform="translate(29.787101, 29.787101) rotate(-13.000000) translate(-29.787101, -29.787101) translate(10.787101, 10.787101)" fill="#FFFFFF" fill-rule="nonzero" stroke="#FFFFFF"><path d="M31.9889042,22.6518817 C31.1594927,21.7921147 30.1590685,21.3324373 29.0987899,21.3324373 C28.0470619,21.3324373 27.0380871,21.7836022 26.174473,22.6433692 L23.4724727,25.3248208 C23.2501562,25.2056452 23.0278397,25.0949821 22.8140738,24.984319 C22.506251,24.8310932 22.2155295,24.6863799 21.9675611,24.5331541 C19.4365734,22.9327957 17.1364528,20.8472222 14.9303892,18.1487455 C13.8615599,16.8037634 13.1433067,15.671595 12.621718,14.5224014 C13.32287,13.8839606 13.9727182,13.2199821 14.6054651,12.5815412 C14.8448829,12.34319 15.0843006,12.0963262 15.3237184,11.8579749 C17.1193515,10.0703405 17.1193515,7.75492832 15.3237184,5.96729391 L12.9893953,3.64336918 C12.7243256,3.37948029 12.4507053,3.10707885 12.1941863,2.83467742 C11.6811482,2.30689964 11.1424583,1.76209677 10.5866671,1.25134409 C9.75725557,0.434139785 8.76538201,0 7.72220465,0 C6.67902729,0 5.67005247,0.434139785 4.81498906,1.25134409 C4.80643842,1.25985663 4.80643842,1.25985663 4.79788779,1.26836918 L1.89067219,4.18817204 C0.796191029,5.27777778 0.17199474,6.60573477 0.0351845945,8.14650538 C-0.170030624,10.6321685 0.565323909,12.9475806 1.12966576,14.4628136 C2.51486848,18.1827957 4.58412194,21.6303763 7.67090085,25.3248208 C11.4160786,29.7768817 15.9222628,33.2925627 21.0697445,35.7697133 C23.0363903,36.6975806 25.661435,37.7956989 28.5943025,37.9829749 C28.7738658,37.9914875 28.9619798,38 29.1329924,38 C31.1081889,38 32.7670119,37.2934588 34.0667083,35.8888889 C34.0752589,35.8718638 34.0923602,35.8633513 34.1009109,35.8463262 C34.5455438,35.3100358 35.0585819,34.8248208 35.5972718,34.3055556 C35.9649491,33.9565412 36.341177,33.5905018 36.7088543,33.2074373 C37.555367,32.3306452 38,31.3091398 38,30.2620968 C38,29.2065412 37.5468164,28.1935484 36.6832023,27.3422939 L31.9889042,22.6518817 Z M35.0500312,31.6155914 C35.0414806,31.6155914 35.0414806,31.6241039 35.0500312,31.6155914 C34.7165565,31.9731183 34.3745311,32.296595 34.0068539,32.6541219 C33.4510627,33.1818996 32.8867208,33.7352151 32.3565815,34.3566308 C31.4929674,35.2759857 30.475442,35.7101254 29.1415431,35.7101254 C29.0132836,35.7101254 28.8764734,35.7101254 28.7482139,35.7016129 C26.2086756,35.5398746 23.8487006,34.5524194 22.0787193,33.7096774 C17.2390604,31.3772401 12.9893953,28.0658602 9.45798337,23.8691756 C6.54221714,20.3705197 4.59267257,17.1357527 3.30152682,13.6626344 C2.50631785,11.5430108 2.21559629,9.89157706 2.3438558,8.33378136 C2.42936214,7.33781362 2.81414068,6.51209677 3.52384331,5.80555556 L6.43960954,2.90277778 C6.85859061,2.51120072 7.30322358,2.2983871 7.73930592,2.2983871 C8.27799587,2.2983871 8.71407821,2.6218638 8.9876985,2.89426523 C8.99624913,2.90277778 9.00479977,2.91129032 9.0133504,2.91980287 C9.53493908,3.40501792 10.0308759,3.90725806 10.5524645,4.44354839 C10.8175342,4.71594982 11.0911545,4.98835125 11.3647748,5.26926523 L13.6990979,7.59318996 C14.6054651,8.49551971 14.6054651,9.3297491 13.6990979,10.2320789 C13.4511295,10.4789427 13.2117117,10.7258065 12.9637434,10.9641577 C12.2454901,11.6962366 11.5614394,12.3772401 10.8175342,13.0412186 C10.8004329,13.0582437 10.7833317,13.0667563 10.774781,13.0837814 C10.0394265,13.8158602 10.1762366,14.530914 10.3301481,15.016129 C10.3386987,15.0416667 10.3472493,15.0672043 10.3558,15.0927419 C10.962895,16.5568996 11.8179584,17.9359319 13.1176548,19.578853 L13.1262054,19.5873656 C15.4861804,22.4816308 17.9744149,24.7374552 20.7191685,26.4655018 C21.0697445,26.686828 21.4288711,26.8655914 21.7708965,27.0358423 C22.0787193,27.1890681 22.3694409,27.3337814 22.6174093,27.4870072 C22.6516118,27.5040323 22.6858143,27.5295699 22.7200169,27.546595 C23.0107384,27.6913082 23.2843587,27.7594086 23.5665296,27.7594086 C24.2762323,27.7594086 24.7208652,27.3167563 24.866226,27.172043 L27.7905429,24.2607527 C28.0812644,23.9713262 28.5429987,23.6223118 29.0816886,23.6223118 C29.6118279,23.6223118 30.0479103,23.9543011 30.3129799,24.2437276 C30.3215306,24.2522401 30.3215306,24.2522401 30.3300812,24.2607527 L35.0414806,28.9511649 C35.9221959,29.8194444 35.9221959,30.7132616 35.0500312,31.6155914 Z" id="Shape"/></g></g></svg>'
  },
  projector: {
    logo: '<svg width="60px" height="60px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Artboard-2" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="projector" style="stroke-width: 0;" transform="translate(7.000000, 14.000000)" fill="#FFFFFF" fill-rule="nonzero"><path d="M44.2155055,0.172370463 L1.69741697,0.172370463 C0.759933579,0.172370463 0,0.945619524 0,1.89952941 L0,30.6551715 C0,31.6090814 0.759933579,32.3823304 1.69741697,32.3823304 L44.2155055,32.3823304 C45.1529889,32.3823304 45.9129225,31.6090814 45.9129225,30.6551715 L45.9129225,1.89952941 C45.9129225,0.945619524 45.1529889,0.172370463 44.2155055,0.172370463 Z M42.5180886,28.9280125 L3.39483395,28.9280125 L3.39483395,3.62668836 L42.5180886,3.62668836 L42.5180886,28.9280125 Z" id="Shape"></path><path d="M30.7500094,21.7222222 C34.6673022,21.7222222 37.8333333,18.5561869 37.8333333,14.6388889 C37.8333333,10.7215909 34.6673022,7.55555556 30.7500094,7.55555556 C26.8327167,7.55555556 23.6666855,10.7215909 23.6666855,14.6388889 C23.6577419,18.5472433 26.8327167,21.7222222 30.7500094,21.7222222 Z M30.7500094,11.0882786 C32.7086558,11.0882786 34.2916714,12.6712963 34.2916714,14.6299453 C34.2916714,16.5885943 32.7086558,18.171612 30.7500094,18.171612 C28.791363,18.171612 27.2083475,16.5885943 27.2083475,14.6299453 C27.2083475,12.6712963 28.791363,11.0882786 30.7500094,11.0882786 Z" id="Shape"></path></g></g></svg>'
  },
  videoConference: {
    logo: '<svg width="60px" height="60px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Artboard-2" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Facilities" style="stroke-width: 0;" transform="translate(6.000000, 14.000000)" fill="#FFFFFF" fill-rule="nonzero"><g id="video-camera"><path d="M36.8123924,0 L1.76419966,0 C0.817555938,0 0,0.770888594 0,1.75591291 L0,30.5357538 C0,31.4779509 0.774526678,32.2916667 1.76419966,32.2916667 L36.8123924,32.2916667 C37.7590361,32.2916667 38.5765921,31.5207781 38.5765921,30.5357538 L38.5765921,22.2272878 L44.9879518,28.6085323 C45.3321859,28.9511494 45.7624785,29.122458 46.2358003,29.122458 C46.4509466,29.122458 46.7091222,29.0796309 46.9242685,28.9939766 C47.5697074,28.7370137 48,28.0946065 48,27.3665451 L48,4.88229443 C48,4.19706012 47.5697074,3.55465296 46.9242685,3.25486295 C46.2788296,2.99790009 45.5043029,3.12638152 45.0309811,3.64030725 L38.6196213,10.0215517 L38.6196213,1.75591291 C38.5765921,0.770888594 37.8020654,1.52152581e-15 36.8123924,0 Z M35.0481928,14.261439 L35.0481928,18.0302277 L35.0481928,28.822668 L3.48537005,28.822668 L3.48537005,3.46899867 L35.0481928,3.46899867 L35.0481928,14.261439 Z M44.4716007,9.1221817 L44.4716007,23.2123121 L38.5765921,17.3449934 L38.5765921,15.0323276 L44.4716007,9.1221817 Z" id="Shape"></path></g></g></g></svg>'
  },
  whiteBoard: {
    logo: '<svg width="60px" height="60px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Artboard-2" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="whiteboard" style="stroke-width: 0;" transform="translate(7.000000, 14.000000)" fill="#FFFFFF" fill-rule="nonzero"><path d="M44.2155055,0.172370463 L1.69741697,0.172370463 C0.759933579,0.172370463 0,0.945619524 0,1.89952941 L0,30.6551715 C0,31.6090814 0.759933579,32.3823304 1.69741697,32.3823304 L44.2155055,32.3823304 C45.1529889,32.3823304 45.9129225,31.6090814 45.9129225,30.6551715 L45.9129225,1.89952941 C45.9129225,0.945619524 45.1529889,0.172370463 44.2155055,0.172370463 Z M42.5180886,28.9280125 L3.39483395,28.9280125 L3.39483395,3.62668836 L42.5180886,3.62668836 L42.5180886,28.9280125 Z" id="Shape"></path><path d="M12.4457828,14.1123991 C12.5950425,14.5228632 12.7355221,15.2340416 12.8299069,15.7037706 C13.1086713,17.1305174 13.3962157,18.6055541 14.4849332,19.3101475 C15.0051471,19.6459817 15.6219407,19.7491465 16.2650742,19.5976918 C18.1791099,19.1564978 18.7607836,16.834193 19.3270924,14.5843231 C19.5553719,13.6602301 19.935106,12.1478785 20.2885002,11.7176595 C20.7143293,11.9832539 21.4320926,13.8709497 21.6757371,14.5206682 C22.3803305,16.390804 23.1112639,18.3267897 24.6214205,18.8140786 C25.5103935,19.2025927 26.2127919,19.0269931 26.636426,18.8140786 C27.8326983,18.2126499 28.1773125,16.7222483 28.5109518,15.2845265 C28.5592417,15.078197 28.6207015,14.8191875 28.6843564,14.5601781 C28.7106963,14.6830978 28.7304513,14.7994326 28.7480112,14.9047924 C29.0553106,16.5510387 29.5140645,19.0379681 31.9373391,19.7491465 C32.872407,20.0344959 33.7196751,19.9159661 34.3342737,19.8325563 C34.6284031,19.7908514 34.9291174,19.7491465 34.9510673,19.7491465 C35.2166617,19.8281663 35.4405512,19.984011 35.7149256,20.1815605 C36.2109945,20.5261747 36.8651031,20.9871237 37.8528508,20.9871237 C37.9713806,20.9871237 38.0943003,20.9805387 38.226,20.9673688 L37.9230907,18.2960597 C37.776026,18.3136197 37.7013962,18.2938648 37.2558122,17.9799805 C36.878273,17.7143861 36.4107391,17.3851368 35.6139559,17.1480773 C35.0169172,17.0273526 34.4549985,17.1041774 33.9633196,17.1722223 C33.4957856,17.2402671 33.0941015,17.295142 32.7121724,17.1788073 C31.9153891,16.9461378 31.6695497,15.93644 31.3907853,14.4218934 C31.1383609,13.0522165 30.7564317,10.9845311 28.7677662,10.9450212 C26.8010506,10.8967313 26.2676668,13.0873364 25.8945176,14.6787079 C25.7891579,15.1374618 25.6245332,15.8398603 25.4664936,16.2349594 C25.0494445,15.8596152 24.4963058,14.3933585 24.1846165,13.5724303 C23.4010032,11.487185 22.5032502,9.11878532 20.3433751,9.00464558 C17.9947304,8.87294587 17.3120869,11.5662048 16.7194382,13.9346045 C16.5109137,14.7577277 16.1575195,16.1778895 15.8392452,16.7573682 C15.6899855,16.3293442 15.5560908,15.6445057 15.466096,15.1879467 C15.1456267,13.5482854 14.7044327,11.3006104 12.6674773,11.3006104 C10.2090828,11.3006104 8.85696584,14.604078 7.66288851,17.5212265 C7.42143906,18.1116802 7.19974455,18.649454 7,19.073088 L9.42327457,20.2232654 C9.64057908,19.7645115 9.88202854,19.1784478 10.1476229,18.5375092 C10.584427,17.4575716 11.6907045,14.7533377 12.4457828,14.1123991 Z" id="Shape"></path></g></g></svg>'
  },
  wifi: {
    logo: '<svg width="60px" height="60px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g id="Artboard-2" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="wifi-connection-signal-symbol" style="stroke-width: 0;" transform="translate(7.000000, 13.000000)" fill="#FFFFFF" fill-rule="nonzero"><path d="M22.999991,25.8750193 C20.6811602,25.8750193 18.7992618,27.806986 18.7992618,30.1875096 C18.7992618,32.5680333 20.6812354,34.5 22.999991,34.5 C25.3187466,34.5 27.2007202,32.5680333 27.2007202,30.1875096 C27.2007202,27.806986 25.3187466,25.8750193 22.999991,25.8750193 Z M45.5074571,10.7970832 C39.8897231,3.93446165 31.6856471,0 22.999991,0 C14.3143348,0 6.11161185,3.93446165 0.492449706,10.7970832 C-0.253935699,11.7084727 -0.139084048,13.068342 0.750114275,13.8345079 C1.14352628,14.1737229 1.62104758,14.3405525 2.09849371,14.3405525 C2.69778181,14.3405525 3.29293585,14.0788878 3.70874694,13.5714543 C8.52560115,7.6878183 15.557634,4.31256752 22.9999158,4.31256752 C30.4421976,4.31256752 37.4742305,7.6878183 42.2910095,13.5700653 C42.7068958,14.0774988 43.3019747,14.3391635 43.9013379,14.3391635 C44.3788592,14.3391635 44.8577335,14.1738001 45.2511455,13.833119 C46.1389157,13.0682648 46.2538425,11.7070065 45.5074571,10.7970832 Z M22.999991,8.62498071 C16.7955214,8.62498071 10.9368845,11.4352333 6.92384153,16.3357169 C6.17753129,17.2471063 6.29230778,18.6069757 7.1815061,19.3731416 C7.5749181,19.7123566 8.05379236,19.8791862 8.53131366,19.8791862 C9.13060176,19.8791862 9.7257558,19.6175215 10.1402139,19.110088 C13.350949,15.187201 18.0389709,12.9374711 23.0000661,12.9374711 C27.9611614,12.9374711 32.6491082,15.187201 35.8612713,19.110088 C36.2771576,19.6189876 36.8722365,19.8791862 37.4700964,19.8791862 C37.9476177,19.8791862 38.426492,19.7138227 38.8199792,19.3731416 C39.7091023,18.6069757 39.8238788,17.2457174 39.0776437,16.3357169 C35.0630975,11.4353105 29.2044606,8.62498071 22.999991,8.62498071 Z M22.999991,17.2499614 C19.2753549,17.2499614 15.7593009,18.9361593 13.3537301,21.8758167 C12.6073447,22.7872061 12.7221963,24.1470755 13.6113946,24.9132414 C14.0048066,25.2524564 14.4836809,25.4192088 14.9612022,25.4192088 C15.5604903,25.4192088 16.1556443,25.1576213 16.5701025,24.6501878 C18.1762216,22.6879726 20.5201574,21.5623746 22.999991,21.5623746 C25.4798245,21.5623746 27.8238355,22.6879726 29.4298795,24.6501878 C29.8457658,25.1590874 30.4408446,25.4192088 31.0387798,25.4192088 C31.5163011,25.4192088 31.9951753,25.2539225 32.3885873,24.9132414 C33.2777857,24.1469983 33.3925621,22.787129 32.6462519,21.8758167 C30.2406059,18.9361593 26.7245519,17.2499614 22.999991,17.2499614 Z" id="Shape"></path></g></g></svg>'
  },
  smartBoard: {
    logo: '<svg xmlns="http://www.w3.org/2000/svg" id="Layer_3" data-name="Layer 3" viewBox="0 0 60 60"><defs><style>.cls-1{fill:#fff;}</style></defs><g id="Page-1" style="stroke-width: 0;"><g id="Artboard"><path id="Combined-Shape" class="cls-1" d="M51.41,14.71a2,2,0,0,1,2,2v26.5a2,2,0,0,1-2,2H8.59a2,2,0,0,1-2-2V16.75a2,2,0,0,1,2-2Zm-1,24.46H9.61v3.06H50.39Zm0-21.4H9.61V36.12H50.39ZM19.81,24.9a2,2,0,0,1,2,2V31a2,2,0,0,1-2,2H15.73a2,2,0,0,1-2-2V26.94a2,2,0,0,1,2-2ZM32,24.9a2,2,0,0,1,2,2V31a2,2,0,0,1-2,2H28a2,2,0,0,1-2-2V26.94a2,2,0,0,1,2-2Zm12.23,0a2,2,0,0,1,2,2V31a2,2,0,0,1-2,2H40.19a2,2,0,0,1-2-2V26.94a2,2,0,0,1,2-2Zm-24.46,2H15.73V31h4.08Zm12.23,0H28V31H32Zm12.23,0H40.19V31h4.08Z"/></g></g></svg>'
  }
}), window.angular.module("core.ui").constant("SCHEDULE_STATUSES", {
  CHECK_IN: "Checkin",
  PENDING: "Pending"
}), window.angular.module("core.ui").component("asuiScheduleItemInfo", {
  bindings: {
    item: "<",
    timeformat: "<",
    readonly: "=",
    onActionClick: "&"
  },
  templateUrl: "component-schedule-table/item-info/item-info.template",
  controller: function controller($sce, $element, FACILITY_CONFIG, ScheduleBoardScheduleUtil) {
    var $ctrl = this,
        ACTIONS_INFO_CLOSE = "info-close",
        ACTIONS_BOOK = "book",
        ACTIONS_EXTEND = "extend",
        ACTIONS_END = "end",
        ACTIONS_CHECK_IN = "checkin";

    function displayFacility(key, facility) {
      var facilityDisplay = [],
          facilityConfig = FACILITY_CONFIG[key];
      return facilityConfig && facility ? (facilityDisplay.push({
        logo: $sce.trustAsHtml(facilityConfig.logo)
      }), facilityConfig.supportsCount && facilityDisplay.push({
        text: facility > 100 ? ">100" : facility,
        styling: facilityConfig.styling
      }), facilityDisplay) : facilityDisplay;
    }

    function onActionClick(action) {
      $ctrl.onActionClick({
        action: {
          item: $ctrl.item,
          type: action,
          upcomingMeetings: $ctrl.itemScheduleInfo.upcomingMeetings,
          currentMeeting: $ctrl.itemScheduleInfo.activeSchedule
        }
      });
    }

    function updateItemScheduleInfo() {
      $ctrl.itemScheduleInfo = ScheduleBoardScheduleUtil.getScheduleInfo($ctrl.item, $ctrl.timeformat), $ctrl.isMeetingExtendable = !$ctrl.itemScheduleInfo.upcomingMeetings || !$ctrl.itemScheduleInfo.upcomingMeetings.length || $ctrl.itemScheduleInfo.activeSchedule && $ctrl.itemScheduleInfo.upcomingMeetings[0].start != $ctrl.itemScheduleInfo.activeSchedule.end;
    }

    $ctrl.nextMeetingText = "", $ctrl.itemScheduleInfo, $ctrl.$onChanges = function (changes) {
      changes.timeformat && changes.timeformat.currentValue && updateItemScheduleInfo(), changes.item && changes.item.currentValue && function () {
        switch ($element.find(".item-info-meetings-schedule-list").scrollTop(0), $ctrl.nextMeetingText = "", updateItemScheduleInfo(), function (facilities) {
          var facilitiesDisplay = [];

          for (var key in facilities) {
            facilitiesDisplay = facilitiesDisplay.concat(displayFacility(key, facilities[key]));
          }

          $ctrl.facilities = facilitiesDisplay;
        }($ctrl.item.facilities), $ctrl.itemScheduleInfo.status) {
          case "occupied":
            $ctrl.nextMeetingText = function () {
              if (0 == $ctrl.itemScheduleInfo.upcomingMeetings.length) return "Available after " + $ctrl.itemScheduleInfo.activeSchedule.endDateString;

              for (var lastMeeting = $ctrl.itemScheduleInfo.activeSchedule, i = 0; i < $ctrl.itemScheduleInfo.upcomingMeetings.length; i++) {
                var difference = $ctrl.itemScheduleInfo.upcomingMeetings[i].start - lastMeeting.end;
                if (difference > 9e5) return "Available after " + lastMeeting.endDateString;
                lastMeeting = $ctrl.itemScheduleInfo.upcomingMeetings[i];
              }

              return "Not available today";
            }();

            break;

          case "available":
            $ctrl.nextMeetingText = 0 == $ctrl.itemScheduleInfo.upcomingMeetings.length ? "Available all day" : "Available until " + $ctrl.itemScheduleInfo.upcomingMeetings[0].startDateString;
        }
      }();
    }, $ctrl.$onInit = function () {}, $ctrl.onCloseClick = function () {
      onActionClick(ACTIONS_INFO_CLOSE);
    }, $ctrl.onBookClick = function () {
      onActionClick(ACTIONS_BOOK);
    }, $ctrl.onExtendClick = function () {
      onActionClick(ACTIONS_EXTEND);
    }, $ctrl.onEndClick = function () {
      onActionClick(ACTIONS_END);
    }, $ctrl.onCheckinClick = function () {
      onActionClick(ACTIONS_CHECK_IN);
    };
  }
}), window.angular.module("core.ui").directive("asuiScheduleTableItemTimeline", function () {
  return {
    restrict: "A",
    scope: {
      item: "=",
      size: "=",
      readonly: "=",
      view: "=",
      timeline: "=",
      timeformat: "="
    },
    link: function link(scope, element) {
      element.addClass("asui-schedule-table-item-timeline"), element.on("$destroy", function () {
        scope.destroy();
      }), element.on("mousedown", scope.onTimelineClick), scope.$watch("item", function (newVal) {
        newVal && scope.scheduleRebuild();
      }), scope.$watch("item.readOnly", function (newVal) {
        newVal && scope.scheduleRebuild();
      }), scope.$watch("readonly", function (newVal) {
        void 0 != newVal && scope.scheduleRebuild();
      }), scope.$watch("timeformat", function (newVal) {
        void 0 != newVal && scope.scheduleRebuild();
      }), scope.$watch("timeline", function (newVal) {
        void 0 != newVal && scope.scheduleRebuild();
      }, !0), scope.$watch("view", function (newVal) {
        void 0 != newVal && scope.scheduleRebuild();
      }, !0), scope.$on("sb-update-status", scope.updateStatus);
    },
    controller: function controller($scope, $element, ScheduleBoardScheduleUtil) {
      var animationFrameId = 0,
          scheduleElems = [],
          activeSchedule = null,
          isReadOnly = !1;

      function onAnimationFrame() {
        animationFrameId = 0, $scope.buildView();
      }

      function buildingMeetingInfoBlock(schedule) {
        var scheduleElm = document.createElement("div");
        scheduleElm.classList.add("timeline-schedule", "schedule-row-height"), scheduleElm._schedule = schedule, scheduleElm.style.marginLeft = schedule.position.leftMargin + "px", scheduleElm.style.minWidth = schedule.position.width + "px", scheduleElm.style.maxWidth = schedule.position.width + "px";
        var scheduleContainerElm = document.createElement("div");
        scheduleContainerElm.classList.add("schedule-container"), scheduleElm.appendChild(scheduleContainerElm);
        var scheduleNameElm = document.createElement("span");

        if (scheduleNameElm.classList.add("schedule-name"), scheduleNameElm.textContent = schedule.name, scheduleContainerElm.appendChild(scheduleNameElm), schedule.organizer) {
          var scheduleOrganizerElm = document.createElement("span");
          scheduleOrganizerElm.classList.add("schedule-organizer"), scheduleOrganizerElm.textContent = schedule.organizer, scheduleContainerElm.appendChild(scheduleOrganizerElm);
        }

        var scheduleTimeElm = document.createElement("span");
        return scheduleTimeElm.classList.add("schedule-time"), scheduleTimeElm.textContent = schedule.startDateLabel + " - " + schedule.endDateLabel, scheduleContainerElm.appendChild(scheduleTimeElm), scheduleElm;
      }

      function buildingMeetingCheckinBlock(schedule) {
        var maxWidth = 2 * $scope.size.slotWidth,
            scheduleElm = document.createElement("div");
        scheduleElm.classList.add("timeline-schedule", "timeline-schedule-checkin", "schedule-row-height"), scheduleElm._schedule = schedule, scheduleElm.style.minWidth = schedule.position.width + "px", scheduleElm.style.maxWidth = schedule.position.width + "px", scheduleElm.style.marginLeft = schedule.position.leftMargin + "px";
        var scheduleContainerElm = document.createElement("div");
        scheduleContainerElm.classList.add("schedule-checkin-continer"), scheduleContainerElm.style.width = schedule.position.width > maxWidth ? maxWidth + "px" : schedule.position.width + "px", scheduleElm.appendChild(scheduleContainerElm);
        var checkinElm = document.createElement("div");
        checkinElm.classList.add("schedule-checkin"), checkinElm.textContent = "Check in", scheduleContainerElm.appendChild(checkinElm);
        var scheduleNameElm = document.createElement("span");
        scheduleNameElm.classList.add("schedule-name"), scheduleNameElm.textContent = schedule.name, scheduleContainerElm.appendChild(scheduleNameElm);
        var scheduleTimeElm = document.createElement("span");
        return scheduleTimeElm.classList.add("schedule-time"), scheduleTimeElm.textContent = schedule.startDateLabel + " - " + schedule.endDateLabel, scheduleContainerElm.appendChild(scheduleTimeElm), scheduleElm;
      }

      function buildingCurrentMeetingInfoBlock(schedule, readonly) {
        var scheduleElm = document.createElement("div");
        scheduleElm.classList.add("timeline-schedule", "schedule-row-height"), scheduleElm._schedule = schedule;
        var scheduleContainerElm = document.createElement("div");
        scheduleContainerElm.classList.add("schedule-container-current"), scheduleElm.appendChild(scheduleContainerElm);
        var scheduleNameElm = null;
        readonly || "checkin" != $scope.item.status || ((scheduleNameElm = document.createElement("span")).classList.add("schedule-checkin"), scheduleNameElm.textContent = "Check in", scheduleContainerElm.appendChild(scheduleNameElm));
        var scheduleFactsElm = document.createElement("div");

        if (scheduleFactsElm.classList.add("schedule-facts"), scheduleContainerElm.appendChild(scheduleFactsElm), (scheduleNameElm = document.createElement("span")).classList.add("schedule-name"), scheduleNameElm.textContent = schedule.name, scheduleFactsElm.appendChild(scheduleNameElm), schedule.organizer) {
          var scheduleOrganizerElm = document.createElement("span");
          scheduleOrganizerElm.classList.add("schedule-organizer"), scheduleOrganizerElm.textContent = schedule.organizer, scheduleFactsElm.appendChild(scheduleOrganizerElm);
        }

        var scheduleTimeElm = document.createElement("span");
        return scheduleTimeElm.classList.add("schedule-time"), scheduleTimeElm.textContent = schedule.startDateLabel + " - " + schedule.endDateLabel, scheduleFactsElm.appendChild(scheduleTimeElm), scheduleElm;
      }

      function shouldHideBookNow(schedule) {
        var allowedMargin = 1e3 * $scope.timeline.interval * .2,
            blockStart = $scope.timeline.start.getTime() + allowedMargin,
            blockEnd = $scope.timeline.start.getTime() + 1e3 * $scope.timeline.interval - allowedMargin;
        return schedule.start > blockStart && schedule.start < blockEnd || schedule.end > blockStart && schedule.end < blockEnd || schedule.start < blockStart && schedule.end > blockEnd;
      }

      function buildTimelineView() {
        var bookNowElm,
            elms = [],
            hideBookNow = !1;

        if ($element[0].style.maxWidth = $scope.size.timelineWidth + "px", $element[0].style.minWidth = $scope.size.timelineWidth + "px", $scope.item.schedules) {
          ScheduleBoardScheduleUtil.sortSchedules($scope.item.schedules);
          var lastTimeOffset = $scope.timeline.start;
          $scope.item.status = "";

          for (var timeformat = $scope.timeformat ? $scope.timeformat : "HH:mm A", y = 0; y < $scope.item.schedules.length; y++) {
            var schedule = $scope.item.schedules[y];

            if (!(schedule.start >= $scope.timeline.end)) {
              var leftMargin = (schedule.start - lastTimeOffset) * $scope.size.pixelsPerMs,
                  adjustedEnd = schedule.end <= $scope.timeline.end ? schedule.end : $scope.timeline.end,
                  width = (adjustedEnd - schedule.start) * $scope.size.pixelsPerMs;

              if (lastTimeOffset = adjustedEnd, leftMargin < 0) {
                if (leftMargin + width <= 0) {
                  lastTimeOffset = $scope.timeline.start;
                  continue;
                }

                width += leftMargin, leftMargin = 0;
              }

              schedule.position = {
                leftMargin: leftMargin,
                width: width
              }, schedule.position.left + schedule.position.width > $scope.size.timelineWidth && (schedule.position.width = $scope.size.timelineWidth - schedule.position.left), schedule.startDateLabel = moment(schedule.start).format(timeformat), schedule.endDateLabel = moment(schedule.end).format(timeformat);
              var element = null;
              shouldHideBookNow(schedule) && (hideBookNow = !0);
              var timeToStart = ScheduleBoardScheduleUtil.getTimeToMeetingStart(schedule);
              ScheduleBoardScheduleUtil.isScheduleInCheckinState(schedule, activeSchedule, timeToStart, $scope.checkingTime) ? ($scope.item.status = "checkin", onStatusChanged($scope.item.status, schedule), element = isReadOnly ? buildingMeetingInfoBlock(schedule) : buildingMeetingCheckinBlock(schedule)) : 0 == timeToStart ? (hideBookNow = !0, activeSchedule = schedule, 1 == schedule.confirmed ? ($scope.item.status = "occupied", onStatusChanged($scope.item.status, schedule), element = buildingMeetingInfoBlock(schedule)) : ($scope.item.status = "checkin", onStatusChanged($scope.item.status, schedule), element = isReadOnly ? buildingMeetingInfoBlock(schedule) : buildingMeetingCheckinBlock(schedule))) : element = buildingMeetingInfoBlock(schedule), elms.push(element);
            }
          }
        }

        return "" == $scope.item.status && ($scope.item.status = "available", onStatusChanged($scope.item.status), isReadOnly || hideBookNow || elms.push(((bookNowElm = document.createElement("div")).classList.add("timeline-schedule", "timeline-schedule-booknow", "schedule-row-height"), bookNowElm._slot = null, bookNowElm.style.minWidth = $scope.size.slotWidth + "px", bookNowElm.style.maxWidth = $scope.size.slotWidth + "px", bookNowElm))), elms;
      }

      function buildCurrentView() {
        var elms = [],
            ctime = new Date().getTime(),
            nextMeeting = null;

        if ($element[0].style.maxWidth = "unset", $element[0].style.minWidth = "unset", $scope.item.schedules) {
          ScheduleBoardScheduleUtil.sortSchedules($scope.item.schedules), $scope.item.status = "", $scope.item.nextMeeting = null;

          for (var timeformat = $scope.timeformat ? $scope.timeformat : "HH:mm A", y = 0; y < $scope.item.schedules.length; y++) {
            var schedule = $scope.item.schedules[y];

            if (!(schedule.start >= $scope.timeline.end)) {
              schedule.startDateLabel = moment(schedule.start).format(timeformat), schedule.endDateLabel = moment(schedule.end).format(timeformat), !nextMeeting && schedule.start >= ctime && (nextMeeting = schedule);
              var timeToStart = ScheduleBoardScheduleUtil.getTimeToMeetingStart(schedule),
                  element = null;
              if (ScheduleBoardScheduleUtil.isScheduleInCheckinState(schedule, activeSchedule, timeToStart, $scope.checkingTime)) $scope.item.status = "checkin", onStatusChanged($scope.item.status, schedule), element = buildingCurrentMeetingInfoBlock(schedule, isReadOnly), elms.push(element);else if (0 == timeToStart) {
                activeSchedule = schedule, 1 == schedule.confirmed ? ($scope.item.status = "occupied", onStatusChanged($scope.item.status, schedule), element = buildingCurrentMeetingInfoBlock(schedule, isReadOnly)) : ($scope.item.status = "checkin", onStatusChanged($scope.item.status, schedule), element = buildingCurrentMeetingInfoBlock(schedule, isReadOnly)), elms.push(element);
                break;
              }
            }
          }
        }

        return $scope.item.nextMeeting = nextMeeting, "" == $scope.item.status && ($scope.item.status = "available", onStatusChanged($scope.item.status), elms.push(function (nextMeeting, readonly) {
          var ctime = new Date().getTime(),
              scheduleElm = document.createElement("div");
          scheduleElm.classList.add("timeline-schedule", "schedule-row-height");
          var scheduleContainerElm = document.createElement("div");

          if (scheduleContainerElm.classList.add("schedule-container-current"), scheduleElm.appendChild(scheduleContainerElm), !readonly) {
            var scheduleNameElm = document.createElement("div");
            scheduleNameElm.classList.add("schedule-booknow"), scheduleNameElm.innerHTML = "<span class='now-plus'>+</span>Book Now", scheduleContainerElm.appendChild(scheduleNameElm);
          }

          var date1,
              date2,
              nextMeetingText = "There are no meetings scheduled today";

          if (nextMeeting && nextMeeting.start - ctime < 36e5) {
            var nextMeetingTime = moment(nextMeeting.start).fromNow();
            nextMeetingText = nextMeeting.name + " starts " + nextMeetingTime;
          } else nextMeeting && (date1 = ctime, date2 = nextMeeting.start, date1 = new Date(date1), date2 = new Date(date2), date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate()) && (nextMeetingText = nextMeeting.name + " starts at " + nextMeeting.startDateLabel);

          var scheduleTimeElm = document.createElement("span");
          return scheduleTimeElm.classList.add("schedule-time-current"), scheduleTimeElm.textContent = nextMeetingText, scheduleContainerElm.appendChild(scheduleTimeElm), scheduleElm;
        }(nextMeeting, isReadOnly))), elms;
      }

      function onStatusChanged(status, schedule) {
        $scope.$emit("timeline.schedule.statuschanged", {
          item: $scope.item,
          status: status,
          schedule: schedule
        });
      }

      $scope.checkingTime = 6e5, $scope.destroy = function () {
        $element.empty(), $element.off("mousedown", $scope.onTimelineClick), animationFrameId && window.cancelAnimationFrame(animationFrameId);
      }, $scope.updateStatus = function () {
        if ($scope.item && $scope.item.schedules) {
          var ctime = new Date().getTime();
          if (activeSchedule) (ctime < activeSchedule.start || ctime > activeSchedule.end) && (activeSchedule = null, $scope.scheduleRebuild());else for (var y = 0; y < $scope.item.schedules.length; y++) {
            var schedule = $scope.item.schedules[y];

            if (!(schedule.start >= $scope.timeline.end)) {
              var timeToStart = ScheduleBoardScheduleUtil.getTimeToMeetingStart(schedule);
              timeToStart >= 0 && timeToStart < $scope.checkingTime && (activeSchedule = schedule, $scope.scheduleRebuild());
            }
          }
        }
      }, $scope.updateReadOnly = function () {
        for (var ctime = new Date().getTime(), i = 0; i < scheduleElems.length; i++) {
          var scheduleElem = scheduleElems[i],
              schedule = scheduleElem._schedule;

          if (schedule && ctime >= schedule.start && ctime <= schedule.end && 1 != schedule.confirmed) {
            var newElement = null;
            newElement = isReadOnly ? buildingMeetingInfoBlock(schedule) : buildingMeetingCheckinBlock(schedule), scheduleElem.parentNode.replaceChild(newElement, scheduleElem), scheduleElems[i] = newElement;
          }
        }
      }, $scope.scheduleRebuild = function () {
        animationFrameId || (animationFrameId = window.requestAnimationFrame(onAnimationFrame));
      }, $scope.onTimelineClick = function ($event) {
        if (!isReadOnly) {
          for (var node = $event.target; null != node && node != $element[0];) {
            if (node._schedule) return void $scope.$emit("timeline.schedule.click", {
              item: $scope.item,
              schedule: node._schedule
            });
            node = node.parentNode;
          }

          var clickOffset = $event.offsetX;
          "current" == $scope.view && (clickOffset = 0);
          var slotOffset = clickOffset / $scope.size.timelineWidth * $scope.size.numberOfSlots,
              slot = {
            start: $scope.timeline.start.getTime() + Math.floor(slotOffset) * $scope.timeline.interval * 1e3,
            end: $scope.timeline.start.getTime() + (Math.floor(slotOffset) + 1) * $scope.timeline.interval * 1e3,
            time: $scope.timeline.start.getTime() + slotOffset * $scope.timeline.interval * 1e3
          };
          $scope.$emit("timeline.slot.click", {
            item: $scope.item,
            slot: slot
          });
        }
      }, $scope.buildView = function () {
        $scope.timeline && $scope.item && $scope.size && ($element.empty(), isReadOnly = $scope.item.readOnly, $scope.readonly && (isReadOnly = $scope.readonly), $scope.item.readOnly && !$scope.readonly ? $element.addClass("asui-schedule-table-item-timeline-readonly") : $element.removeClass("asui-schedule-table-item-timeline-readonly"), scheduleElems = [], activeSchedule = null, scheduleElems = "current" == $scope.view ? buildCurrentView() : buildTimelineView(), $element.append(scheduleElems));
      };
    }
  };
}), window.angular.module("core.ui").component("asuiScheduleTableSlot", {
  bindings: {
    item: "<"
  },
  templateUrl: "component-schedule-table/slot/slot.template",
  controller: function controller() {
    this.$onChanges = function (changes) {}, this.$onInit = function () {};
  }
}), window.angular.module("core.ui").directive("asuiScheduleTableTimelineHeader", function () {
  return {
    restrict: "E",
    templateUrl: "component-schedule-table/timeline-header/header.template",
    scope: {
      slot: "=",
      timeformat: "="
    },
    link: function link(scope, element) {
      scope.$watch("timeformat", function () {
        scope.timeformat ? scope.label = moment(scope.slot.start).format(scope.timeformat) : scope.label = moment(scope.slot.start).format("HH:mm A");
      });
    }
  };
}), angular.module("templates").run(["$templateCache", function ($templateCache) {
  $templateCache.put("card-channel/card-channel.template", '<div ng-if="ngModel" class="asui-card" ng-class="{\'card-icon-only\': iconOnly}">\n    <div class="card-thumbnail" ng-if="!ThumbnailSref" ng-class="{\'card-icon-lg\': iconSize == \'lg\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <i ng-if="!imgLoaded && !imgLoading" class="icon {{icon}}"></i>\n        <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n    </div>\n    <div class="card-thumbnail cursor-pointer" ng-if="ThumbnailSref" ui-sref="{{ThumbnailSref}}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <i ng-if="!imgLoaded && !imgLoading" class="icon {{icon}}"></i>\n        <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n    </div>\n    <div ng-if="::!iconOnly" class="details-container">\n        <div class="details-header">\n            <div class="channel-type">\n                <i class="icon {{iconHeader}}" ng-style="{ \'color\' : iconTypeColor}"></i> {{::Type}}\n            </div>\n            <asui-context-menu ng-if="::contextMenu" menu-groups="contextMenu" options="contextMenuOptions" on-item-click="onMenuItemClick(target, group, value)">\n                <i class="fa fa-ellipsis-v text-secondary"></i>\n            </asui-context-menu>\n        </div>\n        <div class ="details-main">\n            <div class="channel-title" ng-bind-html="Name"\n                ng-class="{\'title-1line\': lineCount === 1, \'title-2lines\': lineCount === 2, \'title-3lines\': lineCount === 3}" \n                uib-popover="{{::tooltip}}" popover-placement="auto" uib-popover-on-truncate>\n            </div>\n            <div ng-if="::ChannelGroups.length" class="channel-channelgroups">\n                Belongs to\n                <span ng-repeat="cg in ::ChannelGroups">\n                    <span ng-bind-html="::cg.Name"/>\n                    <span ng-if="!$last">,</span>\n                </span>\n            </div>\n            <div class="channel-publishto" ng-bind-html="::PublishedTo" ng-if="::!PublishedTo.length"></div>\n        </div>\n        <div class ="details-footer">\n            <div class="footer-primary">\n                {{::LastUpdate}}\n            </div>\n            <div class="footer-secondary">\n                <span ng-bind-html="::secondaryFooter"></span>\n            </div>\n        </div>\n    </div>\n</div>'), $templateCache.put("card-channel-group/card-channel-group.template", '<div class="asui-card" ng-class="{\'card-icon-only\': iconOnly}">\n    <div class="card-thumbnail" ng-if="!ThumbnailSref" ng-style="{ \'background-color\' : Color}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" >\n        <div class="card-thumbnail-image"\n            ng-class="{\'thumbnail-opacity\': (Color && Thumbnail && imgLoaded) }">\n                <i ng-if="!imgLoaded && !imgLoading" class="icon icon-channel-group"></i>\n                <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n        </div>\n    </div>\n    <div class="card-thumbnail cursor-pointer" ng-if="ThumbnailSref" ui-sref="{{ThumbnailSref}}" ng-style="{ \'background-color\' : Color}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" >\n        <div class="card-thumbnail-image"\n            ng-class="{\'thumbnail-opacity\': (Color && Thumbnail && imgLoaded) }">\n                <i ng-if="!imgLoaded && !imgLoading" class="icon icon-channel-group"></i>\n                <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n        </div>\n    </div>\n    <div ng-if="iconOnly !== true" class="details-container">\n        <div class="details-header">\n            <div class="channelgroup-title" ng-bind-html="Name" \n            ng-class="{\'title-1line\': lineCount === 1, \'title-2lines\': lineCount === 2}" \n            uib-popover="{{tooltip}}" popover-placement="auto" uib-popover-on-truncate>\n            </div>\n            <asui-context-menu menu-groups="contextMenu" options="contextMenuOptions" on-item-click="onMenuItemClick(target, group, value)">\n                <i class="fa fa-ellipsis-v text-secondary"></i>\n            </asui-context-menu>\n        </div>\n        <div class ="details-main title-1line" ng-if="PublishedTo">\n            Published to <span ng-bind-html="PublishedTo"></span>\n        </div>\n        <div class ="details-footer">\n            <div class="footer-primary">\n                {{LastUpdate}}\n            </div>\n            <div ng-if="ItemCount" class="footer-secondary">\n                {{ItemCount}}\n            </div>\n        </div>\n    </div>\n</div>'), $templateCache.put("card-content/card-content.template", '<div ng-if="::ngModel" class="asui-card" ng-class="::{\'card-icon-only\': iconOnly, \'card-icon-only-responsive\': iconSize == \'responsive\'}">\n    \x3c!-- Thumbnail --\x3e\n    <div class="card-thumbnail" ng-attr-ui-sref="{{ngModel.thumbnailSref ? ngModel.thumbnailSref : false}}" ng-class="::{\'cursor-pointer\' : ngModel.thumbnailSref, \'card-icon-md\': iconSize == \'md\' || !iconSize, \'card-icon-lg\': iconSize == \'lg\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\', \'card-icon-responsive\': iconSize == \'responsive\'}">\n        <div class="card-thumbnail-image">\n            <i ng-if="icon" class="icon {{::icon}} content-type-icon"></i>\n            <img draggable="false" ondragstart="return false;" ng-if="ngModel.thumbnailURL" class="thumbnail-img" ng-src="{{ngModel.thumbnailURL}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n            <span ng-if="::Duration || Duration === 0" class="video-duration">\n                <span ng-if="::Duration">{{::Duration}}</span>\n                <i ng-if="::Duration === 0" class="icon icon-clock"></i>\n            </span>\n        </div>\n    </div>\n    \x3c!--If not icon only, show details section--\x3e\n    <div ng-if="::!iconOnly" class="details-container">\n        <div class="details-header">\n            <i class="content-icon icon {{::icon}}"></i>\n            <div class="channel-title" ng-bind-html="Name" \n                uib-popover="{{tooltip}}" popover-placement="auto" popover-append-to-body="true" uib-popover-on-truncate>\n            </div>\n            <i class="context-menu fa fa-ellipsis-v text-secondary"\n                asui-context-menu-nested cmn-model="contextMenu" \n                cmn-options="contextMenuOptions" \n                on-cmn-item-select="onMenuItemClick(key)"></i>\n        </div>\n    </div>\n    <div ng-if="loadingSpinner && loadingThumbnail" class="asui-spinner-container">\n        <asui-spinner type="fade-circle" class="sdpinner-sm"></asui-spinner>\n    </div>\n</div>'), $templateCache.put("card-device-group/card-device-group.template", "<div class=\"card-thumbnail-image-circle\" ng-class=\"{'card-icon-lg': iconSize === 'lg', 'card-icon-md': iconSize === 'md', 'card-icon-sm': iconSize === 'sm', 'card-icon-xs': iconSize === 'xs'}\">\n    <i class=\"icon icon-device-group\"></i>\n</div>"), $templateCache.put("card-device/card-device.template", "    <div class=\"card-thumbnail\" ng-if=\"!ThumbnailSref\" ng-class=\"{'card-icon-lg': iconSize == 'lg', 'card-icon-md': iconSize == 'md', 'card-icon-sm': iconSize == 'sm', 'card-icon-xs': iconSize == 'xs'}\" ng-style=\"{ 'background-color' : iconColor}\">\n        <img draggable=\"false\" ng-if=\"Thumbnail\" ng-src=\"{{Thumbnail}}\"/>\n    </div>\n    <div class=\"card-thumbnail cursor-pointer\" ng-if=\"ThumbnailSref\" ui-sref=\"{{ThumbnailSref}}\" ng-class=\"{'card-icon-lg': iconSize == 'lg', 'card-icon-md': iconSize == 'md', 'card-icon-sm': iconSize == 'sm', 'card-icon-xs': iconSize == 'xs'}\" ng-style=\"{ 'background-color' : iconColor}\">\n        <img draggable=\"false\" ng-if=\"Thumbnail\" ng-src=\"{{Thumbnail}}\"/>\n    </div>"), $templateCache.put("card-network/card-network.template", "<div class=\"card-thumbnail-image-circle\" ng-class=\"{'card-icon-lg': iconSize === 'lg', 'card-icon-md': iconSize === 'md', 'card-icon-sm': iconSize === 'sm', 'card-icon-xs': iconSize === 'xs'}\">\n    <i class=\"icon icon-network\"></i>\n</div>"), $templateCache.put("card-user/card-user.template", '<div class="asui-card">\n    <div class="card-thumbnail" ng-class="{\'card-icon-lg\': iconSize === \'lg\', \'card-icon-md\': iconSize === \'md\', \'card-icon-sm\': iconSize === \'sm\', \'card-icon-xs\': iconSize === \'xs\', \'cursor-pointer\': ThumbnailSref !== undefined || ThumbnailSref !== null}" >\n        <div class="card-thumbnail-image-circle" ng-hide="imgLoaded" ng-style="{ \'background-color\' : Color}">\n            <span ng-if="iconSize === \'xs\'" ng-class="{\'icon-line-height\' : ngModel.icon}" ng-bind-html="Initial"></span>\n            <span ng-if="iconSize !== \'xs\'" ng-bind-html="DoubleInitial"></span>\n        </div>\n        <div class="card-thumbnail-image-circle white-bg" ng-show="imgLoaded">\n            <img draggable="false" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImageLoad($event)" ng-error="onImageError($event)"/>\n        </div>\n    </div>\n    <div ng-if="iconOnly !== true" class="details-container">\n    </div>\n</div>'), $templateCache.put("card-user-group/card-user-group.template", "<div class=\"card-thumbnail-image-circle\" ng-class=\"{'card-icon-lg': iconSize === 'lg', 'card-icon-md': iconSize === 'md', 'card-icon-sm': iconSize === 'sm', 'card-icon-xs': iconSize === 'xs'}\">\n    <i class=\"icon icon-users\"></i>\n</div>"), $templateCache.put("component-accordion/accordion.template", '<uib-accordion close-others="$ctrl.options.oneAtATime">\n    <ng-transclude></ng-transclude>\n</uib-accordion>'), $templateCache.put("component-badge/badge.template", ' <div class="asui-badge" ng-class="{\'badge-sm\': size == \'sm\', \'badge-lg\': size == \'lg\', \'asui-badge-hover\': onHover}" ng-switch="type.toLowerCase()">\n    <div class="asui-badge-circle asui-badge-add" ng-switch-when="add">\n        <i class="fa fa-plus"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-remove" ng-switch-when="remove">\n        <i class="fa fa-close"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-check" ng-switch-when="check">\n        <i class="fa fa-check"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-check-inherited" ng-switch-when="check-inherited">\n        <i class="fa fa-check"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-count-unread" ng-switch-when="count-unread">\n        <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n    <div class="asui-badge-circle asui-badge-count-group" ng-switch-when="count-group">\n         <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n    <div class="asui-badge-square asui-badge-count-approvals" ng-switch-when="count-approvals">\n         <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n</div>\n'), $templateCache.put("component-breadcrumbs/breadcrumbs.template", '<ol class="breadcrumb">\n    <li class="breadcrumb-item" ng-repeat="item in $ctrl.items" ng-click="$ctrl.onClick(item)">\n        <a ng-if="item.sref.length > 0" ui-sref="{{item.sref}}">{{item.label}}</a>\n        <a ng-if="!item.sref.length && item.href.length" href="{{item.href}}">{{item.label}}</a>\n        <span ng-if="!item.sref.length && !item.href.length && !item.items.length">{{item.label}}</span>\n        <asui-context-menu \n            ng-if="item.items.length" \n            selected-inputs="item.contextMenu.selectedInputs" \n            options="item.contextMenu.options" \n            ng-model="item.contextMenu.model" \n            menu-groups="item.contextMenu.menuGroups" \n            on-item-click="$ctrl.onContextMenuClick(target, group, value)">\n            {{item.contextMenu.selectedInputs[item.label].buttonText}} <i class="fa fa-caret-down"></i>\n        </asui-context-menu>\n        </div>\n    </li>\n</ol>'), $templateCache.put("component-carousel/carousel.card.template", '<iframe ng-src="{{$sce.trustAsResourceUrl(resolvedSrc)}}" seamless frameBorder="0" scrolling="no" allow="camera"></iframe>\n'), $templateCache.put("component-carousel/carousel.template", '<div class="owl-carousel" data-ng-transclude>\n    \x3c!-- Placeholder template --\x3e\n    <div data-ng-repeat="item in localItems track by item.$$id" emit-last-repeater-element>\n        <div ng-if="item.$showPlaceHolder" ng-style="item.$style" class="asui-carousel-item carousel-item-placeholder"></div>\n        <div ng-if="!item.$showPlaceHolder" ng-include="\'component-carousel/default.template\'"></div>\n    </div>\n</div>\n\n'), $templateCache.put("component-carousel/carousel.video.template", '<video ng-class="{\'aspect-fill\': item.aspect == \'fill\', \'aspect-uniform\': item.aspect == \'uniform\', \'aspect-uniformfill\': item.aspect == \'uniformfill\'}" ng-src="{{src}}" ng-click = "onVideoClick()"></video>\n<div ng-if="showPlayButton && !hideControls" class="play-button" ng-click = "onPlayClick()">\n    <span class="play-btn-holder"><i class="icon icon-play"></i></span>\n</div>'), $templateCache.put("component-carousel/carousel.web.template", '<iframe ng-src="{{$sce.trustAsResourceUrl(resolvedSrc)}}" frameBorder="0" scrolling="no"></iframe>\n'), $templateCache.put("component-carousel/default.template", '\x3c!-- Error temmplate --\x3e\n<div ng-if="item.onError" class="asui-carousel-item" ng-style="item.$style"> \n    <div class="error-template">\n        <i class="icon icon-file-error"></i>\n        Error loading content\n    </div>\n</div>\n\x3c!-- Custom template URL provided --\x3e\n<div ng-if="!item.onError && item.templateUrl" class="asui-carousel-item">\n    <div ng-include="item.templateUrl"/>\n</div>\n\x3c!-- Custom template provided --\x3e\n<div ng-if="!item.onError && item.template" class="asui-carousel-item">\n    <asui-template template="item.template" ></asui-template>\n</div>\n\x3c!-- Use a default template based on content type --\x3e\n<div ng-if="!item.onError && !item.templateUrl && !item.template" class="asui-carousel-item" ng-style="item.$style" ng-switch="item.type.toLowerCase()">\n    <image ng-class="{\'aspect-fill\': item.aspect == \'fill\', \'aspect-uniform\': item.aspect == \'uniform\', \'aspect-uniformfill\': item.aspect == \'uniformfill\'}" ng-switch-when="image" ng-src="{{item.trustedSrc}}"></image>\n    <asui-carousel-video ng-switch-when="video"\n         is-current="item.$isCurrent" \n         is-active="item.$isActive" \n         on-error="onError(item)"\n         hide-controls="options.mode == \'mediaplayer\' ? true : false"\n         on-complete="onItemComplete(item)"\n         item="item">\n    </asui-carousel-video>\n    <asui-carousel-card \n        item="item" \n        ng-switch-when="card" \n        on-error="onError(item)"\n        on-complete="onItemComplete(item)">\n    </asui-carousel-card>\n    <asui-carousel-web ng-switch-when="html" src="{{$sce.trustAsResourceUrl(item.src)}}"></asui-carousel-web>\n    <div class="not-supported-template" ng-switch-default>\n        <i class="icon icon-file"></i>\n        Preview not available\n    </div>\n</div>'), $templateCache.put("component-chart-donut/chart-donut.template", ' <div class="asui-chart-donut">\n    <canvas id="donut" class="chart chart-doughnut" \n        chart-options="chartOptions" \n        chart-data="chartData" \n        chart-labels="chartLabels" \n        chart-colors="chartColors">\n    </canvas>\n    <div class="center-label" ng-if="centerLabel.length">{{centerLabel}}</div>\n</div>\n'), $templateCache.put("component-checkbox/checkbox.template", '<div class="asui-checkbox" ng-class="{\'horizontal\' : options.direction == \'horizontal\'}">\n    <label data-ng-repeat="item in localItems">\n        <input type="checkbox" value="{{item.value}}" ng-change="onCheckboxClick(item)" ng-model="item.checked" />\n        {{item.label}}\n    </label>\n</div>'), $templateCache.put("component-codeview/codeview.template", "<textarea></textarea>"), $templateCache.put("component-colorpicker/colorpicker.template", '<div>\n  <input type="text" class="form-control" ng-model="$scope.localModal" />\n</div>'), $templateCache.put("component-commandbar/commandbar.template", '<div class="asui-command-bar" ng-show="isOpen">\n    <div ng-if="options.triggerElement" class="trigger-pointer up-arrow_box"></div>\n    <div class="content ">\n        <ng-transclude class="content"></ng-transclude>  \n    </div>  \n    <div class="close-btn" ng-click="onCloseClick()" ng-if="options.triggerElement"><i class="icon icon-cross"></i></div>\n</div>'), $templateCache.put("component-contenttile/content-tile.template", '<div class="asui-content-tile">\n    <div class="ct-content-container"> \n        <ng-transclude class="ct-content"></ng-transclude>  \n    </div>\n</div>'), $templateCache.put("component-contextmenu/contextmenu-list.template", '<div ng-repeat="group in menuGroups">\n    <div class="cm-header" ng-if="group.showHeader">{{group.name}}</div>\n    <ul>\n        <li ng-repeat="item in group.items">\n            <a ng-if="!item.disabled" ng-click="itemClick($event, group, item.value)">\n                <span ng-bind-html="item.label" class="item-label"></span>\n                <span class="icon icon-check check-mark" ng-if="isChecked(group, item.value)"></span>\n            </a>\n            <div ng-bind-html="item.label" ng-if="item.disabled" class="cm-item-disabled"></div>\n        </li>\n        <li class="divider" ng-if="!$last && group.insertDivider !== false">></li>\n    </ul>\n</div>'), $templateCache.put("component-contextmenu/contextmenu.template", '<div class="asui-context-menu">\n    <span class="cm-button" \n      popover-class="asui-context-menu-popover"\n      ng-click="onContextMenuClick($event)" \n      popover-trigger="\'outsideClick\'" \n      popover-placement="{{options && options.placement ? options.placement : \'bottom-auto\'}}" \n      uib-popover-template="\'component-contextmenu/contextmenu-list.template\'" \n      popover-append-to-body="options.appendToBody"\n      popover-is-open="isOpen">\n      <ng-transclude></ng-transclude>  \n    </span>\n</div>'), $templateCache.put("component-copy/copy.template", '<div class="asui-copy" \n    ng-bind-html="label" \n    ng-click="onClick()"\n    popover-is-open="isOpen"\n    uib-popover="{{popoverText}}">\n</div>'), $templateCache.put("component-datepicker/datepicker.template", '<div class="asui-date-picker input-group date">\n    <i class="icon icon-calendar" ng-show="showIcon()"></i>\n    <input class="datepicker-input" type="text" ng-disabled="readOnly"\n        ng-readonly="readonly || options.disableManualInput" ng-class="{\'has-calendar-icon\' : showIcon()}"\n        placeholder="{{ngModel ? \'\' : placeholder}}" />\n    <div ng-if="ngModel != null && !readonly" class="date-clear" ng-click="clearInput($event)">\n        <i class="icon icon-remove"></i>\n    </div>\n</div>'), $templateCache.put("component-daterangepicker/daterangepicker.template", '<div class="asui-date-range-picker input-group date">\n    <i class="icon icon-calendar" ng-show="showIcon()" ng-click="onCalendarClick()"></i>\n    <input type="text" placeholder="{{getPlaceholderText()}}" class="date-input" ng-class="{\'has-calendar-icon\' : showIcon()}"  ng-keyup="onKeyUp($event)" readonly />\n    <div ng-if="ngModel.startDate != null" class="date-clear" ng-click="clearInput($event)">\n        <i class="icon icon-remove"></i>\n    </div>\n</div>'), $templateCache.put("component-dayparting/dayparting.template", '<div class="dayparting-container">\n    <div class="dayparting-day-col">\n        <asui-context-menu class="dayparting-filter"\n            selected-inputs="$ctrl.intervalFilter.selectedInputs" \n            options="$ctrl.intervalFilter.options" \n            ng-model="$ctrl.intervalFilter.model" \n            menu-groups="$ctrl.intervalFilter.menuGroups" \n            on-item-click="$ctrl.onIntervalFilterClick(value)">\n            {{$ctrl.intervalFilter.selectedInputs[\'intervalfilter\'].buttonText}} <i class="fa fa-caret-down"></i>\n        </asui-context-menu>\n        <div ng-repeat="item in $ctrl.dataGrid track by item.id"\n            class="dayparting-day-label" \n            ng-class="{\'dayparting-day-everyday\':item.id === \'everyday\'}" \n            ng-click="$ctrl.onDayClick(item)">\n            <span ng-if="$ctrl.options.dayLabel === \'label1Letter\'"">{{item.label1Letter}}</span>\n            <span ng-if="$ctrl.options.dayLabel === \'label3Letters\'"">{{item.label3Letters}}</span>\n            <span ng-if="!$ctrl.options.dayLabel || $ctrl.options.dayLabel === \'full\'"">{{item.label}}</span>\n        </div>\n    </div>\n    <div class="dayparting-time-block">\n        <div class="dayparting-header-row">\n            <div ng-repeat="item in $ctrl.headers track by item.id"\n                class="dayparting-header" \n                ng-style="{\'min-width\': $ctrl.minHeaderWidth}">{{item.label}}</div>\n        </div>\n        <div asui-dayparting-day-slots \n            ng-repeat="item in $ctrl.dataGrid track by item.id"\n            item="item"\n            min-slot-width="$ctrl.minSlotWidth">\n        </div>\n    </div>\n</div>\n<div class=\'dayparting-clear\' ng-click="$ctrl.clear()">Clear all</div>'), $templateCache.put("component-dragdrop/dragdrop.template", '<div class="dnd-alert" ng-show="showAlert">{{alert}}</div>\n<ul ng-if="!multiselect" dnd-list="ngModel.items" \n    dnd-drop="dropCallback(item)" \n    dnd-allowed-types="options.preventReorder === true && options.dragMode.toLowerCase() !== \'none\'? [] : null"\n    dnd-disable-if="isMaxCountReached()">\n    <li ng-repeat="item in ngModel.items" \n        dnd-draggable="item" \n        dnd-moved="dndMoved($index, item)" \n        dnd-copied="dndCopied($index, item)" \n        dnd-selected="dndSelected(item)" \n        dnd-effect-allowed="{{effectAllowed}}" \n        dnd-disable-if="item.disabled === true || options.dragMode.toLowerCase() === \'none\' " \n        ng-class="getItemClass(item)">\n        <div class="drag-item">\n            <div ng-if="options.dragMode.toLowerCase() != \'none\' " class="drag-icon"><i class="icon icon-vertical-drag"></i></div>\n            <div ng-if="!options.template" class="drag-content">\n                <div class="drag-transclude">\n                    <custom-transclude></custom-transclude>\n                </div>\n            </div>\n            <div ng-if="options.template" class="drag-content" ng-include src="options.template"></div>\n            <div ng-if="options.addBtn === true || options.removeBtn === true" class="drag-item-buttons">\n                <asui-badge ng-if="options.addBtn === true" type="add" class="drag-item-add" ng-click="addClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.removeBtn === true" type="remove" class="drag-item-remove" ng-click="removeClick($index, item)"></asui-badge>\n            </div>\n        </div>\n    </li>\n</ul>\n\n<ul ng-if="multiselect" dnd-list dnd-drop="dndMultiselectDrop(ngModel, item, index)" \n    dnd-allowed-types="options.preventReorder === true && options.dragMode.toLowerCase() !== \'none\'? [] : null"\n    dnd-disable-if="isMaxCountReached()">\n    <li ng-repeat="item in ngModel.items" \n        dnd-draggable="dndMultiselectDraggable(ngModel, item)"\n        dnd-dragstart="dndMultiselectDragstart(ngModel, event)" \n        dnd-dragend="dndMultiselectDragEnd(ngModel)" \n        dnd-moved="dndMultiselectMoved(ngModel)"\n        dnd-copied="dndMultiselectCopied(ngModel)" \n        dnd-selected="dndMultiselectSelected(ngModel, item, event)" \n        dnd-effect-allowed="{{effectAllowed}}" \n        dnd-disable-if="dragging === true || item.disabled === true || options.dragMode.toLowerCase() == \'none\' " \n        ng-class="getMultiselectItemClass(item)">\n        <div class="drag-item">\n            <div ng-if="options.dragMode.toLowerCase() != \'none\' " class="drag-icon"><i class="icon icon-vertical-drag"></i></div>\n            <div ng-if="!options.template" class="drag-content">\n                <div class="drag-transclude">\n                    <custom-transclude></custom-transclude>\n                </div>\n            </div>\n            <div ng-if="options.template" class="drag-content" ng-include src="options.template"></div>\n            <div ng-if="options.addBtn === true || options.removeBtn === true" class="drag-item-buttons">\n                <asui-badge ng-if="options.addBtn === true && item.checked !== true" type="add" class="drag-item-add" ng-click="!item.disabled && addClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.addBtn === true && item.checked === true" type="check" class="drag-item-checked" ng-click="!item.disabled && checkedClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.removeBtn === true" type="remove" class="drag-item-remove" ng-click="!item.disabled && removeClick($index, item)"></asui-badge>\n            </div>\n        </div>\n    </li>\n</ul>'), $templateCache.put("component-dragdrop-tree/default.template", '<div class="asui-ui-tree-node">\n    <i ng-class="{\'invisible\': node.nodes.length <= 0, \'icon-caret-right tree-caret\': collapsed, \'icon-caret-down tree-caret\': !collapsed }" ng-click="toggle(this)"></i>\n    <div ng-if="node.dragEnabled === true" class="tree-drag" ui-tree-handle>\n        <i  class="icon-vertical-drag"></i>\n    </div>\n\n    <div class="inline" ng-switch="node.type">\n        <div class="inline" ng-switch-when="custom" >\n            <div class="inline" ng-include="node.template"></div>\n        </div>\n        <div class="inline" ng-switch-when="folder">\n            <i class="icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="library">\n            <i class="icon-library tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="device">\n            <i class="icon-device tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="devicegroup">\n            <i class="icon-folder  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="network">\n            <i class="icon-network tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="user">\n            <i class="icon-user  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="usergroup">\n            <i class="icon-users tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-default>\n            <span class="cursor-default" ng-bind-html="node.label"></span>\n        </div>\n    </div>\n    \n    <ol ui-tree-nodes="" ng-model="node.nodes">\n        <li ng-if="!collapsed" ng-repeat="node in node.nodes" ui-tree-node ui-tree-node data-collapsed="true" data-expand-on-hover="true" ng-include="\'component-dragdrop-tree/default.template\'">\n        </li>\n    </ol>\n</div>'), $templateCache.put("component-dragdrop-tree/drop-list.template", '<div class="asui-ui-tree-node">\n    <div class="inline" ng-switch="node.type">\n        <div class="inline" ng-switch-when="custom">\n            <i class="icon icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="folder">\n            <i class="icon icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="library">\n            <i class="icon icon-library tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="device">\n            <i class="icon icon-device tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="devicegroup">\n            <i class="icon icon-folder  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="network">\n            <i class="icon icon-network tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="user">\n            <i class="icon icon-user  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="usergroup">\n            <i class="icon icon-users tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-default>\n            <span class="cursor-default" ng-bind-html="node.label"></span>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-dropdown/dropdown.template", '<div class="asui-dropdown"ng-class="{\'asui-dropdown-disabled\': disabled == \'true\'}" uib-popover="{{disabled == \'true\' ? disabledTooltip : null}}" popover-trigger="\'mouseenter\'">\n    <select ng-disabled="options.disabled" class="selectpicker as-select" title="{{placeholder}}"></select>\n</div>'), $templateCache.put("component-dropdown-typeahead/custom-template.template", '<asui-card-channel icon-only=true icon-size="xs" ng-model="item.iconModel"></asui-card-channel>\n{{item.label}}'), $templateCache.put("component-dropdown-typeahead/dropdown-typeahead.template", '<div ng-if="$ctrl.selectedItem" ng-repeat=\'item in $ctrl.selectedItemArray\' class="item-container selected-item" ng-class="{\'disabled\': $ctrl.disabled, \'not-active\' : $ctrl.isOpen}">\n    <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n    <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n    <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n        <div ng-if="$ctrl.selectedItem.icon" ng-bind-html="$ctrl.selectedItem.icon" class="item-icon"></div>\n        <div ng-bind-html="$ctrl.selectedItem.label" class="item-label"></div>\n    </div>\n</div>\n<input type="text" \n    class="textbox"\n    ng-disabled="$ctrl.disabled"\n    placeholder="{{$ctrl.selectedItem ? null : $ctrl.placeholder}}" \n    ng-model="$ctrl.keywords" \n    ng-click="$ctrl.onInputClick()"\n    ng-keyup="$ctrl.onKeyUp($event)"\n    ng-change="$ctrl.onKeywordsChange()">\n<i ng-if="!$ctrl.options.allowEmptyValue || ($ctrl.options.allowEmptyValue && !$ctrl.selectedItem) || $ctrl.disabled" class="fa fa-caret-down" ng-click="$ctrl.onInputClick()" ng-class="{\'disabled\': $ctrl.disabled}"></i>\n<i ng-if="$ctrl.options.allowEmptyValue && $ctrl.selectedItem && !$ctrl.disabled" class="icon icon-cross" ng-click="$ctrl.onClearClick()"></i>\n<div class="dropdown-container" ng-class="{\'dropdown-open\': $ctrl.isOpen}">\n    <asui-spinner ng-if="$ctrl.isLoading" class="spinner-sm"></asui-spinner>\n    <div ng-if="!$ctrl.isLoading && $ctrl.filteredItems.length" class="dropdown-container-inner" ng-repeat="item in $ctrl.filteredItems">\n        <div ng-if="item._isGroup" \n            class="dt-group" \n            ng-class="{\'dt-divider\' : item.showDivider && $index != 0}">{{item.label}}\n        </div>\n        <div ng-if="!item._isGroup"\n            class="dropdown-item"\n            ng-class="{\'active\': item._active}"\n            ng-mouseover="$ctrl.onMouseOver(item)"\n            ng-mouseleave="$ctrl.onMouseLeave(item)"\n            ng-click="$ctrl.onItemClick(item)">\n            <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n            <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n            <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n                <div ng-if="item.icon" ng-bind-html="item.icon" class="item-icon"></div>\n                <div ng-bind-html="item.label" class="item-label"></div>\n            </div>\n        </div>\n    </div>\n    <div ng-if="false && !$ctrl.isLoading && $ctrl.filteredItems.length" class="dropdown-container-inner" ng-repeat="group in $ctrl.groups">\n        <div ng-if="group.name" class="dt-group" ng-class="{\'dt-divider\' : $ctrl.options.showDivider && $index != 0}">{{group.name}}</div>\n        <div ng-repeat="item in group.items" \n            class="item-container dropdown-item"\n            ng-class="{\'active\': item._active}"\n            ng-mouseover="$ctrl.onMouseOver(item)"\n            ng-mouseleave="$ctrl.onMouseLeave(item)"\n            ng-click="$ctrl.onItemClick(item)">\n            <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n            <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n            <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n                <div ng-if="item.icon" ng-bind-html="item.icon" class="item-icon"></div>\n                <div ng-bind-html="item.label" class="item-label"></div>\n            </div>\n        </div>\n    </div>\n    <div ng-if="!$ctrl.isLoading && !$ctrl.filteredItems.length && !$ctrl.options.allowCustomValues" class="no-items-cta-container">\n        <div ng-if="$ctrl.options.noItemsCta" class="no-items-cta" ng-bind-html="$ctrl.options.noItemsCta"></div>\n        <div ng-if="!$ctrl.options.noItemsCta" class="no-items-cta"><img src="images/smcta/no-search-results.svg">No match found</div>\n    </div>\n</div>\n    '), $templateCache.put("component-duration/duration-input.template", '<div class="duration-input-popup">\n    <div ng-if="!hideDay" class="duration-number-block duration-day" ng-click="onBlockClick(\'d\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upDay()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-day" type="number" ng-value="getValue(\'d\')" ng-keyup="change($event, \'d\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'d\') <=  0}" ng-click="downDay()" ><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideDay && !hideHour">:</span>\n    <div ng-if="!hideHour" class="duration-number-block duration-hour" ng-click="onBlockClick(\'h\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upHour()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-hour" type="number" ng-value="getValue(\'h\')" ng-keyup="change($event, \'h\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'h\') <=  0}" ng-click="downHour()" ><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideHour && !hideMinute">:</span>\n    <div ng-if="!hideMinute" class="duration-number-block duration-min" ng-click="onBlockClick(\'m\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upMin()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-minute" type="number" ng-value="getValue(\'m\')" ng-keyup="change($event, \'m\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'h\') == 0 && getValue(\'m\') <=  0}" ng-click="downMin()"><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideMinute && !hideSecond">:</span>\n    <div ng-if="!hideSecond" class="duration-number-block duration-second" ng-click="onBlockClick(\'s\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upSec()" ><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-second" type="number" ng-value="getValue(\'s\')" ng-keyup="change($event, \'s\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': ngModel <=  0 || ngModel <= options.minDuration}" ng-click="downSec()"><i class="icon icon-caret-down"></i></div>\n    </div>\n</div>'), $templateCache.put("component-duration/duration.template", '\n<input type="text" class="duration-label" \n        popover-trigger="\'outsideClick\'" popover-placement="{{options && options.placement ? options.placement : \'bottom-left\'}}" \n        uib-popover-template="\'component-duration/duration-input.template\'" popover-is-open="isOpen"\n        ng-value="ngModel ? (ngModel | duration : null : true): \'\'"\n        placeholder="{{options.placeholder?options.placeholder:\'Enter Duration\'}}" readonly />\n<div class="duration-clear" ng-click="clearInput($event)" ng-show="ngModel > 0">\n  <i ng-if="options.showClear" class="icon icon-remove"></i>\n</div>'), $templateCache.put("component-editable-label/editable-label.template", "<div ng-show=\"validationState === 'INITIAL'\" \n    class=\"editable-label\" \n    ng-class=\"{'placeholder': showPlaceholder}\"\n    ng-click=\"onClick()\"\n    tabindex=\"0\"\n    ng-focus=\"onLabelFocus()\">\n    {{showPlaceholder ? placeholder : text}}\n</div>\n<input type=\"text\" \n    ng-show=\"validationState !== 'INITIAL'\" \n    ng-model=\"editedText\"\n    class=\"editable-label-input\"\n    ng-show=\"validationState !== 'INITIAL'\" \n    title=\"{{placeholder}}\" \n    ng-class=\"{'error': validationState === 'ERROR', 'disabled': validationState === 'VALIDATING'}\"\n    ng-keyup=\"onKeyup($event)\"\n    ng-blur=\"onBlur($event)\"\n/>\n<asui-spinner ng-show='isValidating' class=\"spinner-sm\"></asui-spinner> \n<div ng-show=\"validationState === 'EDITING' || validationState === 'ERROR'\" class='editable-label-button-container'> \n    <button class='editable-label-icon iconcheck' ng-hide='isValidating||hideSaveIcon' ng-mousedown='onIgnoreBlur()' ng-keyedown=\"onKeydownSave($event)\" ng-click='onSave()'><i class='icon icon-check'></i></button>  \n    <button class='editable-label-icon iconcross' ng-hide='isValidating||hideCancelIcon' ng-mousedown='onIgnoreBlur()' ng-click='onCancelClick()'><i class='icon icon-cross'></i></button>  \n</div>"), $templateCache.put("component-file-dragdrop/file-dragdrop.template", '<div class="asui-fileupload">\n    <div flow-drop flow-init class="drop" ng-hide="fileUploaded">\n        <div class="upload-icon-container" ng-if="showUploadIcon">\n            <div class="icon icon-upload upload-icon"></div>\n        </div>\n        <div ng-class="dropClass">\n            <span ng-show="preBrowseText">{{preBrowseText}}</span> \n            <span class="browse" flow-btn flow-directory>{{browseText}}<input type="file" multiple="multiple" webkitdirectory="webkitdirectory" class="invisible absolute"></span>\n            <span ng-show="postBrowseText">{{postBrowseText}}</span> \n        </div>\n        <div ng-if="error" class="validation-error upload-error">{{error}}</div>\n    </div>\n    <div class="file-list dragdrop-filelist" ng-show="fileUploaded"></div>\n</div>'), $templateCache.put("component-fileupload/fileupload.template", '<div class="asui-fileupload">\n    <div flow-drop flow-init class="ng-scope drop">\n        <div class="upload-icon-container" ng-if="showUploadIcon">\n            <div class="icon icon-upload upload-icon"></div>\n        </div>\n        <div ng-class="dropClass">\n          {{showDropText()}} \n          <span class="browse" flow-btn flow-directory>{{options.browseText ? options.browseText : \'browse\'}}<input type="file" multiple="multiple" webkitdirectory="webkitdirectory" class="invisible absolute"></span>\n          {{options.extraText}} \n        </div>\n        <div ng-if="error" class="validation-error upload-error">{{error}}</div>\n        <div class="file-list"></div>\n    </div>\n</div>'), $templateCache.put("component-flip/flip.template", "<div class=\"flip-container\" ng-class=\"{'flipped': shouldFlip, 'postTransition' : postTransition}\"> \n    <ng-transclude></ng-transclude>\n</div>\n"), $templateCache.put("component-floorplan-editor/floorplan-editor.template", '<asui-floorplan-editor-poi-layer\n    on-api-ready="onPoiLayerApi(api)"\n    options="options.styles"\n    floorplan="{{floorplan}}"\n    on-new-item-cancel="onLayerNewItemCancel()"\n    on-new-item="onLayerNewItem(item)"\n    on-item-click="onLayerItemClick(item, event)"\n    on-stage-click=onLayerStageClick(event)\n    on-floorplan-load="onPoiFloorplanLoad(size)"\n    on-zoom-update="onLayerZoomUpdate(zoom)"\n    items="items">\n</asui-floorplan-editor-poi-layer>'), $templateCache.put("component-grid/grid.template", '<div class="asui-grid">\n  <div class="grid-container" ng-class="{\'grid-container-horizontal\': options.direction == \'horizontal\'}"> \n    <div ng-if="options.showMask && (options.paging.type != \'virtual\' && options.paging.type != \'ondemand\')" class="loading-mask">\n      <asui-spinner></asui-spinner>\n    </div>\n    <div ng-if="isRetrievingItemsAsyc && totalItems == 0" class="loading-mask">\n      <asui-spinner></asui-spinner>\n    </div>\n\n    <div ng-if="::options.itemTemplateUrl" \n      ng-repeat="item in items | limitTo:ngLimit:ngStartIndex track by ::(item.id ? item.id : itemId(item))"   \n      item="item"\n      on-selection-click="onItemSelectionClick(item, event)"\n      class="grid-item {{::item.customClass}}" \n      ng-include="::item.templateUrl ? item.templateUrl : options.itemTemplateUrl" \n      asui-grid-item-id="{{::(item.id ? item.id : itemId(item))}}" \n      emit-last-repeater-element>\n    </div>\n    \n    <div ng-if="::!options.itemTemplateUrl" \n        ng-repeat="item in items | limitTo:ngLimit:ngStartIndex track by ::(item.id ? item.id : itemId(item))" \n        item="item"\n        on-selection-click="onItemSelectionClick(item, event)"\n        asui-selectable-item ng-transclude="itemDirective" \n        class="grid-item {{::item.customClass}}" \n        asui-grid-item-id="{{::(item.id ? item.id : itemId(item))}}" \n        emit-last-repeater-element>\n    </div>\n\n    <div ng-if="options.paging.currentPage < totalPages && options.paging.type == \'virtual\'" class="grid-virtualscroll-marker"></div>\n  </div>\n\n  \x3c!--Show More--\x3e\n  <div ng-if="!options.showMask && (options.paging.currentPage < totalPages && options.paging.type == \'ondemand\')" class="grid-show-more"><a class="grid-show-more-link" ng-click="showMoreItems()">Show More</a></div>\n  \n  \x3c!--Spinner when set in vertical direction--\x3e\n  <div ng-if="options.direction != \'horizontal\' && (options.paging.type != \'ondemand\' || options.showMask) && options.paging.currentPage < totalPages && (options.paging.type == \'virtual\' || options.paging.type == \'ondemand\')" class="grid-show-more-spinner">\n      <asui-spinner type="fade-line"></asui-spinner>\n  </div>\n  \x3c!--Spinner when set in horizontal mode--\x3e\n  <div ng-if="options.direction == \'horizontal\' && options.showMask" class="grid-show-more-spinner grid-show-more-spinner-horzontal">\n      <asui-spinner type="fade-line"></asui-spinner>\n  </div>\n\n  <div ng-if="(!items || items.length == 0) && !isRetrievingItemsAsyc && hasInit">\n    <div ng-if="!options.noItemsTemplateUrl" ng-transclude="noDataContent"></div>\n    <div ng-if="options.noItemsTemplateUrl" ng-include="options.noItemsTemplateUrl"/>\n  </div>\n  <div class="flex flex-row-reverse">\n    <div ng-if="showPaging()" class="flex flex-align-center noselect margin-t-5 text-secondary">\n      <ul uib-pagination="uib-pagination" total-items="totalItems" items-per-page="options.paging.itemsPerPage" max-size="5" ng-model="options.paging.currentPage" ng-change="pageChanged()" style="margin: 0;" boundary-links="true" previous-text="&lt;" next-text="&gt;" first-text="&lt;&lt;" last-text="&gt;&gt;"></ul>\n    </div>\n  </div>\n</div>'), $templateCache.put("component-grouper/grouper-tooltip.template", '<div class="grouper-tooltip">\n    <div ng-repeat="item in items"  ng-click="item.onClick(item)" ng-class="{\'grouper-item-click\': item.onClick}"  class="grouper-item">\n        <a ng-if="getRenderType(item) === \'link\'" class="grouper-item-link" ui-sref="{{item.sref}}">{{item[displayProperty]}}</a>\n        <span ng-if="getRenderType(item) === \'text\'" class="grouper-item-text">{{item[displayProperty]}}</span>\n    </div>\n</div>\n'), $templateCache.put("component-grouper/grouper.template", '<div>\n    <div class="asui-grouper">\n        <div class="flex flex-align-stretch">\n            <div class="grouper-container" ng-class="{\'grouper-ellipsis\': ellipsis}">\n                <div class="grouper-item" ng-class="{\'grouper-item-click\': item.onClick}" ng-click="item.onClick(item)" ng-repeat="item in itemsCopy track by item.$id" emit-repeater-element-render ng-if="$index<maxItems && !item.$hide">\n                    <span ng-if="getRenderType(item) === \'link\' || getRenderType(item) === \'text\'" >{{$index > 0 ? ", ": ""}}</span>\n                    <div ng-if="getRenderType(item) === \'templateUrl\'" class="grouper-item-templateurl" ng-include src="options.itemTemplateUrl"></div>\n                    <asui-template ng-if="getRenderType(item) === \'template\'" class="grouper-item-template" template="options.itemTemplate"></asui-template>\n                    <a ng-if="getRenderType(item) === \'link\'" class="grouper-item-link" ui-sref="{{item.sref}}">{{item[displayProperty]}}</a>\n                    <span ng-if="getRenderType(item) === \'text\'" class="grouper-item-text">{{item[displayProperty]}}</span>\n                </div>\n            </div>\n            <div class="flex flex-align-center">\n                <span class="grouper-remainder cursor-pointer" popover-is-open="isOpen" popover-trigger="\'outsideClick\'" uib-popover-template="options.tooltipTemplate ? options.tooltipTemplate : defaultTooltipTemplate" popover-placement="{{\'auto \' + options.tooltipPlacement}}"></span>\n            </div>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-horizontalnavbar/horizontalnavbar.template", '\n<ul class="nav nav-pills" ng-show="!searchOpen">\n    <li role="presentation" ng-repeat="item in items" ng-hide="item.visible === false" class="hnb-link {{item.class}}" ng-class="{\'active\' : item.value == ngModel.value}">\n        <a ng-if="item.sref.length > 0" ui-sref="{{item.sref}}" target="{{item.target}}" ng-click="onNavItemClick($event, item)" ng-bind-html="item.label"></a>\n        <a ng-if="!item.sref.length && item.href.length > 0" href="{{item.href}}" target="{{item.target}}" ng-click="onNavItemClick($event,item)" ng-bind-html="item.label"></a>\n        <a ng-if="!item.sref.length && !item.href" ng-click="onNavItemClick($event, item)" ng-bind-html="item.label"></a>\n    </li>\n</ul>\n<div ng-show="!searchOpen" class="horznav-bar-commands">\n    <div ng-repeat="command in options.commands">\n        <div class="horznav-bar-command {{command.class}}" ng-bind-html="command.icon" ng-click="onCommandItemClick($event, command)"></div>\n    </div>\n    <div ng-if="options.showSearchIcon" class="horznav-bar-command" ng-click="onSearchClick($event)">\n        <i class=\'icon icon-search\'></i>\n    </div>\n</div>\n<asui-search-autocomplete \n    ng-if="searchOpen"\n    class="horznav-search-autocomplete-container"\n    options="options.searchAutocomplete" \n    model="searchText"\n    on-item-click="onItemClick(item)"\n    on-clear="onCloseSearch()"\n    on-keyword-change="onSearchTextChange({value: value})"\n    on-search="onSearch({value: value})">\n</asui-search-autocomplete>\n'), $templateCache.put("component-info-label/info-label.template", '<div class="info-label-container"\n    ng-class="{\'multiline\' : options.multiline === true, \'singleline\' : options.multiline !== true}"\n    uib-popover="{{tooltip ? tooltip : labelTooltip}}" \n    popover-is-open="isOpen" \n    uib-popover-template="options.tooltipTemplate"\n    popover-trigger="\'mouseenter\'" \n    popover-placement="auto">\n    <i class="icon icon-info info-label-icon" ng-if="options.showIcon"></i>\n    <div class="info-label" \n        ng-class="{\'label-ellipsis\' : options.multiline != true, \'info-label-left\' : options.iconAlign === \'right\'}" \n        ng-mouseover="onMouseOver()"\n        ng-bind-html="label">\n    </div>\n</div>'), $templateCache.put("component-info-label/tooltip.template", "<div>\n    <strong>Tooltip Template</strong><br>\n    <div>This is an example of a tooltip template.</div>\n</div>\n"), $templateCache.put("component-input/input.template", '<div id="{id}" class="asui-input-checkbox" ng-class="{\'asui-input-checkbox-checked\': ngModel === true}" ng-click="toggleCheckbox()" ng-if="type==\'checkbox\'">\n    <i ng-if="ngModel === true" class="icon icon-check"> </i>\n</div>\n<div id="{id}" contenteditable class="asui-input-text" ng-class="{\'asui-input-text-placeholder\':  !ngModel}" ng-if="type==\'text\'">\n    {{ngModel || placeholder}}\n</div>'), $templateCache.put("component-input-validator/input-validator.template", ""), $templateCache.put("component-loadingmask/loadingmask.template", '<div class="loading-mask-container" ng-show="show">\n    <div class="outer">\n        <asui-spinner type="{{type}}"></asui-spinner>\n    </div>\n    <div ng-if="message" class="message">{{message}}</div>\n</div>\n\n'), $templateCache.put("component-modal/modal-confirmation.template", '<div class="asui-modal-confirmation">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">{{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.cancel()">Cancel</button>\n        <button class="asui-btn btn btn-primary" tabindex="-1" type="button" ng-click="$ctrl.ok()">{{$ctrl.confirmLabel}}</button>\n    </div>\n</div>'), $templateCache.put("component-modal/modal-custom.template", '<div class="asui-modal-custom">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">Sample Custom Modal</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <form id="forms">\n            <div class="preview-box-full" >\n                <label for="name">Name</label>\n                <input id="name" type="text" ng-model="text" placeholder="{{placeholder}}"></input>\n                <label for="desc">Description</label>\n                <textarea id="desc" ng-model="textarea"></textarea>\n            </div>\n        </form>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.cancel()">Cancel</button>\n        <button class="asui-btn btn btn-primary" tabindex="-1" type="button" ng-click="$ctrl.ok()">Save</button>\n    </div>\n</div>'), $templateCache.put("component-modal/modal-error.template", '<div class="asui-modal-error">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title"> <i class="icon icon-alert padding-r-10"></i> {{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.ok()">OK</button>\n    </div>\n</div>'), $templateCache.put("component-modal/modal-notification.template", '<div class="asui-modal-notification">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">{{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.ok()">OK</button>\n    </div>\n</div>'), $templateCache.put("component-multiselect/multiselect.template", '<div class="asui-multiselect">\n    <select class="selectpicker" \n        multiple\n        title="{{placeholder}}" \n        ng-model="ngModel" \n        ng-change="onSelectChange()" \n        ng-disabled="options.disabled"\n        data-selected-text-format="{{options.selectedTextFormat}}"\n        data-max-options="{{options.maxSelection}}">\n    </select>\n    <div ng-show="error" class="validation-error">{{error}}</div>\n</div>'), $templateCache.put("component-notification/error.template", '<div class="asui-notification asui-notification-error">\n    <i class="fa fa-ban notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n'), $templateCache.put("component-notification/info.template", '<div class="asui-notification asui-notification-info">\n    <i class="icon icon-info notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n'), $templateCache.put("component-notification/notification.template", '<growl-notification on-close="notificationOnClose({{notification.$$id}})" ttl="{{notification.timeout > 0 ? notification.timeout * 1000 : 99999999999}}">\n    <div ng-switch="notification.type.toLowerCase()">\n        <div ng-switch-when="success">\n            <div ng-include="\'component-notification/success.template\'"/>\n        </div>\n        <div ng-switch-when="info">\n            <div ng-include="\'component-notification/info.template\'"/>\n        </div>\n        <div ng-switch-when="warning">\n            <div ng-include="\'component-notification/warning.template\'"/>\n        </div>\n        <div ng-switch-when="error">\n            <div ng-include="\'component-notification/error.template\'"/>\n        </div>\n        <div class="asui-notification" ng-switch-default>\n            {{notification.message}}\n        </div>\n    </div>\n</growl-notification>\n'), $templateCache.put("component-notification/success.template", '<div class="asui-notification asui-notification-success">\n    <i class="icon icon-success notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n'), $templateCache.put("component-notification/warning.template", '<div class="asui-notification asui-notification-warning">\n    <i class="icon icon-warning notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n'), $templateCache.put("component-phone-number/phone-number.template", '<input type="tel" id="phone" ng-disabled="$ctrl.ngDisabled">'), $templateCache.put("component-qrcode-scanner/qrcode-scannner.template", '<div class=\'qrcode-scanner-container\'>\n    <asui-loading-mask ng-show="loading"></asui-loading-mask>\n    <canvas ng-show="displayOverlay && !error"></canvas>\n    <video ng-show="!displayOverlay && !error"></video>\n    <div ng-show="error"class="error-container"> \n        <i class="{{errorIcon}}"></i>\n        <span>{{error}}</span>\n    </div>\n</div>'), $templateCache.put("component-radio/radio.template", '<div class="asui-radio" ng-class="{\'asui-radio-inline\' : options.direction == \'horizontal\'}">\n    <label data-ng-repeat="item in items">\n        <input type="radio" ng-model="ngModel.value" ng-value="item.value" ng-disabled="disabled"\n            name="{{name ? name : id}}" ng-change="onRadioChange(this)" />\n        {{item.label}}\n    </label>\n</div>'), $templateCache.put("component-range-slider/range-slider.template", '<div class="asui-range-slider">\n    <input type="range" min="minRange" max="maxRange" class="slider" ng-model="ngModel" ng-change="onSliderChange()">\n</div>'), $templateCache.put("component-richtext/richtext.template", '<div class="asui-richtext" >\n    <div ng-class="{\'sticky-toolbar\': isSticky()}">\n        <div id="{{toolboxId}}" class="style-toolbar" style="display: none;">\n        </div>\n        <textarea class="form-control" ngTrim="false"></textarea>\n        <div ng-if="isDirty && (!requiredValid || !lengthValid)" class="validation-error">\n            <div ng-if="!requiredValid">This field is required.</div>\n            <div ng-if="!lengthValid">Enter between {{validation.minlength}} to {{validation.maxlength}} characters.</div>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-schedule-table/schedule-table.template", '<asui-loading-mask ng-show="$ctrl.isRetrievingItemsAsyc && $ctrl.items.length == 0"></asui-loading-mask>\n<div class="schedule-header-block">\n    <div class="schedule-items-header schedule-header" ng-style="$ctrl.options.theme.itemsHeader" ng-class="{\'invisible\': $ctrl.itemInfoShow}">\n        <div ng-if="!$ctrl.options.readonly" ng-click="$ctrl.filterClick()" class="schedule-filter">{{$ctrl.filterLabel}} <i class="icon icon-caret-down"></i></div>\n        <div ng-if="$ctrl.options.view == \'timeline\' && !$ctrl.mapShow" class="schedule-date-container">\n            <i ng-if="!$ctrl.options.readonly && $ctrl.timelineScrollOffset != 0" ng-click="$ctrl.resetDay()" class="icon icon-recent"></i>\n            <i ng-if="!$ctrl.options.readonly" ng-click="$ctrl.previousDay()" class="icon icon-double-arrow-left"></i>\n            <span class="day-label">{{$ctrl.currentDate}}</span>\n            <i ng-if="!$ctrl.options.readonly" ng-click="$ctrl.nextDay()" class="icon icon-double-arrow-right"></i>\n        </div>\n    </div>\n    <div asui-synchronize-scroll scroll-group="timeline:horizontal" \n        class="schedule-timeline-header schedule-header"\n        ng-style="$ctrl.options.theme.timelineHeader">\n            <asui-schedule-table-timeline-header \n                slot="slot" \n            ng-class="{\'invisible\': $ctrl.options.view != \'timeline\' || $ctrl.itemInfoShow || $ctrl.mapShow}"\n                ng-if="$ctrl.options.view != \'current\'"\n                timeformat="$ctrl.options.timeformat" \n            class="schedule-slot schedule-slot-width asui-schedule-table-timeline-header-edge"\n            ng-repeat="slot in $ctrl.scheduleSlots">\n        </asui-schedule-table-timeline-header>\n    </div>\n</div>\n\n<div class="schedule-item-info-block drop-shadow" ng-class="{\'schedule-item-info-block-show no-background\': $ctrl.itemInfoShow}">\n    <asui-schedule-item-info \n        item="$ctrl.selectedItem" \n        timeformat="$ctrl.options.timeformat" \n        readonly="$ctrl.options.readonly"\n        on-action-click="$ctrl.itemActionClick(action)">\n\n    </asui-schedule-item-info>\n</div>\n\n<div class="schedule-map-block" ng-class="{\'schedule-map-block-full\': $ctrl.filter && !$ctrl.filterCount && !$ctrl.itemInfoShow}">\n    <asui-schedule-map \n        items="$ctrl.items"\n        on-api-ready="$ctrl.onMapApiReady(api)" \n        selected-item="$ctrl.selectedItem" \n        readonly="$ctrl.options.readonly"\n        on-action-click="$ctrl.onMapActionClick(action)"\n        show-map="$ctrl.mapShow"\n        show-map-toggle="$ctrl.options.showMapToggle"\n        is-map-view="$ctrl.options.defaultShowMap"\n        is-current-map-view="$ctrl.options.isCurrentMapView"\n        show-footer="$ctrl.showFooter"\n        filter="$ctrl.filter"\n        reset-filter="$ctrl.resetFilter()"\n        filtered-count="$ctrl.filterCount"\n        total-count="$ctrl.items.length">\n    </asui-schedule-map>\n</div>\n<div ng-if="$ctrl.options.showMapToggle && !$ctrl.itemInfoShow && !$ctrl.options.readonly" ng-style="$ctrl.options.theme.itemsHeader" class="asui-schedule-table-map-toggle" ng-click="$ctrl.onMapToggleClickEvent()" ng-class="$ctrl.options.mapToggleStyle">\n    <i ng-if="!$ctrl.mapShow" class="icon icon-map"></i>\n    <i ng-if="$ctrl.mapShow" class="icon icon-calendar-line"></i>\n</div>\n<div class="schedule-list-block" ng-class="{\'invisible-portrait\': $ctrl.filter && !$ctrl.filterCount && !$ctrl.itemInfoShow && ($ctrl.options.defaultShowMap || $ctrl.options.showMapToggle)}">\n    <div class="schedule-items-block schedule-timeline-container-fixed-height" ng-style="$ctrl.options.theme.items"  ng-class="{\'invisible\': $ctrl.itemInfoShow}">\n        <div ng-show="!$ctrl.filter || $ctrl.filter == item.status" \n            ng-if="!$ctrl.isRetrievingItemsAsyc" \n            asui-schedule-table-item item="item" \n            class="schedule-list-row schedule-row-height" \n            ng-click="$ctrl.onItemSelectClick($event, item)"\n            ng-repeat="item in $ctrl.items track by item.id">\n        </div>\n    </div>\n    <div asui-synchronize-scroll ng-style="$ctrl.options.theme.timeline"  scroll-group="timeline:horizontal" class="schedule-timeline-block schedule-timeline-container-fixed-height" ng-class="{\'invisible\': $ctrl.mapShow}">\n        <div \n            ng-show="!$ctrl.filter || $ctrl.filter == item.status" \n            ng-if="$ctrl.elementSizes.rowHeight > 0 && $ctrl.elementSizes.slotWidth && !$ctrl.isRetrievingItemsAsyc"\n            asui-schedule-table-item-timeline \n            timeline="$ctrl.options.timeline" \n            emit-last-repeater-element \n            item="item" \n            size="$ctrl.elementSizes" \n            timeformat="$ctrl.options.timeformat" \n            readonly="$ctrl.options.readonly" \n            view="$ctrl.options.view"\n            class="schedule-list-row schedule-row-height" \n            ng-repeat="item in $ctrl.items track by item.id">\n        </div>\n    </div>\n    <asui-schedule-table-filter-footer class="asui-schedule-table-filter-footer" ng-if="$ctrl.filter && !$ctrl.mapShow" ng-click="$ctrl.resetFilter()" filter="$ctrl.filter" filter-count="$ctrl.filterCount" total-count="$ctrl.items.length">\n    </asui-schedule-table-filter-footer>\n</div>'), $templateCache.put("component-search/search.template", '<div class="asui-search">\n    <i class="icon icon-search"></i>\n    <input maxlength="{{maxLength}}"  type="text" placeholder="{{placeholder}}" ng-model="ngModel" ng-change="onChange()" ng-keyup="onKeyUp($event)" ng-focus="onInputFocus($event)">\n    <i class="icon icon-cross" ng-show="ngModel.length > 0 || options.alwaysShowClear" ng-click="onClearClick()"></i>\n</div>\n\n\n'), $templateCache.put("component-search-autocomplete/custom-template.template", '<div class="flex flex-row flex-align-center" style="background-color: {{item.bgColor}}">\n    <div class="padding-t-10 padding-b-10 padding-l-20">\n        {{item.name}}\n    </div>\n</div>'), $templateCache.put("component-search-autocomplete/search-autocomplete.template", '<div class="search-autocomplete-container">\n    \x3c!-- Search input  --\x3e\n    <asui-search ng-model="model" options="options" max-length="{{options.maxLength}}"\n        placeholder="{{options.placeholder}}" on-text-change="onTextChange(value)" on-focus="onFocus()"\n        on-search="onSearchEvent(value)" ng-class="{\'search-no-border-radius\': isOpen}" on-clear="onClearEvent()">\n    </asui-search>\n    \x3c!-- Dropdown container for displaying search results --\x3e\n    <div ng-if="isOpen" class="search-autocomplete-dropdown">\n        <asui-loading-mask ng-if="isSearching" show="true" type="spinner"></asui-loading-mask>\n        <div class="search-group-block" ng-repeat="group in searchResults" ng-if="group.items.length > 0">\n            <div class="search-header" ng-if="group.groupName">{{group.groupName}}</div>\n            <div ng-repeat="item in group.items" class="search-item-row" ng-class="{\'active\': item._active}"\n                ng-click="itemClick(item)" ng-mouseover="onMouseOver(item)" ng-mouseleave="onMouseLeave(item)">\n                \x3c!-- Custom template provided --\x3e\n                <div ng-if="item.templateUrl">\n                    <div ng-include="item.templateUrl"></div>\n                </div>\n                \x3c!-- Html provided --\x3e\n                <div ng-if="!item.templateUrl && item.customHtml" class="custom-item" ng-bind-html="item.customHtml">\n                </div>\n                \x3c!-- Use a default template based on resource type --\x3e\n                <div ng-if="!item.templateUrl && !item.customHtml" class="search-item" ng-switch="item._dtoType">\n                    <asui-card-channel ng-switch-when="channelChannel" class="search-item-icon" icon-only=true\n                        icon-size="xs" ng-model="item">\n                    </asui-card-channel>\n                    <asui-card-channel-group ng-switch-when="channelChannelGroup" class="search-item-icon"\n                        icon-only=true icon-size="xs" ng-model="item">\n                    </asui-card-channel-group>\n                    <asui-card-device ng-switch-when="networkDevice" class="search-item-icon" icon-only=true\n                        icon-size="sm" ng-model="item">\n                    </asui-card-device>\n                    <asui-card-user ng-switch-when="userUser" class="search-item-icon" icon-only=true icon-size="xs"\n                        ng-model="item"></asui-card-user>\n                    <asui-card-user-group ng-switch-when="userUserGroup" class="search-item-icon" icon-size="xs">\n                    </asui-card-user-group>\n                    <asui-card-content ng-switch-when="libraryContent" class="search-item-icon" icon-only=true\n                        icon-size="xs" ng-model="item">\n                    </asui-card-content>\n                    <i ng-switch-when="libraryTag|networkTag" ng-switch-when-separator="|"\n                        class="icon icon-tag search-item-icon"></i>\n                    <i ng-switch-when="libraryContentCategory" class="icon icon-circle search-item-icon"\n                        ng-style="{color: \'{{item.color}}\'}"></i>\n                    <img ng-switch-when="libraryCardTemplate" class="search-item-icon card-template-icon"\n                        ng-src="{{item.iconUrl}}">\n                    <div class="search-item-name" ng-if="item.encodedName" ng-bind-html="item.encodedName"></div>\n                    <div class="search-item-name" ng-if="!item.encodedName">{{item.name}}</div>\n                </div>\n\n            </div>\n        </div>\n        <div class="empty-cta-container" ng-if="options.showEmptyPlaceholder">\n            <div class="empty-cta" ng-if="options.emptyPlaceholder" ng-bind-html="options.emptyPlaceholder"></div>\n            <div class="empty-cta" ng-if="!options.emptyPlaceholder"><img src="images/smcta/no-search-results.svg">No\n                match found</div>\n        </div>\n        <div class="search-all-block" ng-if="!options.showEmptyPlaceholder" ng-click="onSearchEvent(model)">\n            <i class="icon icon-search"></i>\n            <span class="search-all-keywords">{{model}}</span>\n            <span class="margin-r-10">-</span>\n            <span>{{options.searchAllLabel}}</span>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-spinner/spinner.template", '<div class="spinner-container" ng-switch="type">\n    <div ng-switch-default  class="spinner-fade-line">\n        <div class="bounce1"></div>\n        <div class="bounce2"></div>\n        <div class="bounce3"></div>\n    </div>\n    <div ng-switch-when="fade-circle" class="sk-fading-circle">\n        <div class="sk-circle1 sk-circle"></div>\n        <div class="sk-circle2 sk-circle"></div>\n        <div class="sk-circle3 sk-circle"></div>\n        <div class="sk-circle4 sk-circle"></div>\n        <div class="sk-circle5 sk-circle"></div>\n        <div class="sk-circle6 sk-circle"></div>\n        <div class="sk-circle7 sk-circle"></div>\n        <div class="sk-circle8 sk-circle"></div>\n        <div class="sk-circle9 sk-circle"></div>\n        <div class="sk-circle10 sk-circle"></div>\n        <div class="sk-circle11 sk-circle"></div>\n        <div class="sk-circle12 sk-circle"></div>\n    </div>\n    <div ng-switch-when="scale-line" class="spinner-rect-wave">\n        <div class="rect1"></div>\n        <div class="rect2"></div>\n        <div class="rect3"></div>\n        <div class="rect4"></div>\n        <div class="rect5"></div>\n    </div>\n</div>\n'), $templateCache.put("component-split-button/split-button.template", '<div class="btn-group">\n    <button class="btn btn-primary main-btn" ng-bind-html="options.buttonText" ng-click="onMainActionClick()" ng-disabled="ngDisabled"></button>\n    <button class="btn btn-primary dropdown-toggle" data-toggle="dropdown" ng-disabled="ngDisabled"><span class="caret"></span></button>\n    <ul class="dropdown-menu">\n        <li ng-repeat="a in options.actions" ng-class="{\'divider\' : a.value === \'divider\'}">\n            <a ng-if="a.value !== \'divider\'" ng-click="onActionClick({action: a.value})" ng-bind-html="a.label"></a>\n        </li>\n    </ul>\n</div>'), $templateCache.put("component-styleeditor/styleeditor.template", '<div class="asui-style-editor">\n    <div class="btn-toolbar" role="toolbar">\n        <div class="btn-group" role="group" ng-if="showFontFamily == true">\n            <button type="button" class="btn btn-default dropdown-toggle" title="Font Family" data-toggle="dropdown"><span id="fontFamilyLabel"><span class="glyphicon glyphicon-font"></span></span>&nbsp<span class="caret"></span></button> \n            <ul class="dropdown-menu font-family">\n                <li ng-repeat="font in options.fontFamily">\n                    <a href="javascript:void(0)" data-value="font" ng-click="onFontFamilyChange($event, font)">{{font}}</a>\n                </li>\n            </ul> \n        </div>\n        <div class="btn-group" role="group" ng-if="showSize == true">\n            <button type="button" class="btn btn-default dropdown-toggle" title="Font Size" data-toggle="dropdown"><span id="sizeLabel"><span class="glyphicon glyphicon-text-size"></span></span>&nbsp<span class="caret"></span></button> \n            <ul class="dropdown-menu font-size">\n                <li ng-repeat="size in options.size">\n                    <a href="javascript:void(0)" data-value="size" ng-click="onFontSizeChange($event, size)">{{size}}</a>\n                </li>\n            </ul> \n        </div>\n        <div class="btn-group" role="group" ng-if="showDecorations == true">\n            <button id="ts-bold" type="button" class="btn btn-default" title="Bold" ng-click="onBoldClick()" data-toggle="button" aria-pressed="{{bold}}" autocomplete="off"><span class="glyphicon glyphicon-bold"></span></button>\n            <button id="ts-italic" type="button" class="btn btn-default" title="Italic" ng-click="onItalicClick()" data-toggle="button" aria-pressed="{{italic}}"><span class="glyphicon glyphicon-italic"></span></button>\n            <button id="ts-underline" type="button" class="btn btn-default font16" title="Underline" ng-click="onUnderlineClick()" data-toggle="button" aria-pressed="{{underline}}" autocomplete="off"><span class="icon icon-underline"></span></button>\n        </div>\n        <div class="btn-group" role="group" ng-if="showAlignment == true" id="alignmentGroup"> \n            <button id="ts-alignleft" type="button" class="btn btn-default" title="Left Align" ng-click="onAlignmentClick($event, \'left\')"><span class="glyphicon glyphicon-align-left"></span></button> \n            <button id="ts-aligncenter" type="button" class="btn btn-default" title="Center Align" ng-click="onAlignmentClick($event, \'center\')"><span class="glyphicon glyphicon-align-center"></span></button> \n            <button id="ts-alignright" type="button" class="btn btn-default" title="Right Align" ng-click="onAlignmentClick($event, \'right\')"><span class="glyphicon glyphicon-align-right"></span></button> \n        </div>\n        <div class="btn-group" role="group"> \n            <button id="color" type="button" class="btn btn-default font16" title="Font Color" ng-if="showColor == true"><span class="icon icon-text-color"></span></button> \n            <button id="bgColor" type="button" class="btn btn-default font16" title="Background Color" ng-if="showBgColor == true"><span class="icon icon-background-color"></span></button>\n            <button id="gridColor" type="button" class="btn btn-default" title="Grid Color" ng-if="showGridColor == true"><span class="fa icon-square"></span></button> \n        </div> \n    </div> \n</div>'), $templateCache.put("component-table/table.template", '<div ng-class="options.customClass" ng-style="{ height: (options.height !== undefined) ? options.height + \'px\': \'auto\' }" class="asui-table-container">\n  <div ng-if="error != null" class="validation-error te-error">{{error}}</div>\n  <div ng-if="options.showMask" class="loading-mask"></div>\n  <div class="table-container">\n    <table class="table asui-table">\n      <thead ng-hide="(!options.showHeader && localItems.length > 0) || (!options.showHeaderWhenNoData && localItems.length == 0)">\n        <tr ng-mouseover="showCheckAll()" ng-mouseleave="hideCheckAll()">\n          <th ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-table-checkbox-header">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(isCheckAllVisible || options.checkBox == \'always\' || checkCount > 0) }" ng-click="toggleCheckAllUpdated($event)" ng-model="checkAll.value" title="Check All"></asui-input>\n          </th>\n          <th ng-if="options.dragSort" class="as-drag-sort-column-header"></th>\n          <th ng-if="options.orderInput" class="as-order-input-column-header"></th>\n          <th ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="(i.sortable !== undefined && !i.sortable) ? [\'cursor-default\',i.class]:[\'cursor-pointer\',i.class] " ng-click="sortByColumn(i)" class="as-column-header"><span ng-bind="i.label"></span><span ng-class="{ \'hidden\': !((i.sortBy !== undefined && options.sortOrder == i.sortBy)  || options.sortOrder == i.name) }"><i ng-class="{ \'fa-caret-down\': options.sortReverse, \'fa-caret-up\': !options.sortReverse }" class="fa inline"></i></span></th>\n          <th ng-if="(options.actionMenus !== undefined && options.actionMenus.length > 0) || (options.groupActionMenus !== undefined && options.groupActionMenus.length > 0)" class="as-action-column-header">\n            <div ng-show="options.groupActionMenus !== undefined && options.groupActionMenus.length > 0 && checkCount > 1">\n              <asui-context-menu id="groupActionMenuId" options="contextMenuOptions" menu-groups="options._FilteredGroupActionMenu" on-item-click="groupActionMenuItemClick(target, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu>\n            </div>\n          </th>\n        </tr>\n      </thead>\n      \n      \x3c!-- Empty table --\x3e\n      <tbody ng-if="localItems.length == 0 && !isRetrievingItemsAsyc">\n        <tr class="as-table-row">\n          <td colspan="100%">\n            <div ng-transclude="noDataContent"></div>\n          </td>\n        </tr>\n      </tbody>\n\n      \x3c!-- DND Dragsort enabled table --\x3e\n      <tbody ng-if="options.dragSort" ng-if="localItems.length > 0" dnd-list="localItems" dnd-inserted="dndInserted(index, external, type)">\n        \x3c!-- Placeholder Row during drag --\x3e\n        <tr class="as-table-row dndPlaceholder">\n          <td colspan="{{colCount}}">\n            <div style="visibility: hidden">Placeholder</div>\n          </td>\n        </tr>\n        \x3c!-- If a custom row template is provided, and no alt row template is provided --\x3e\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row\'" asui-template template="options.rowTemplate" dnd-disable-if="!options.dragSort" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected = item" ng-class="{\'selected\': options.selected === item}" dnd-moved="dndMoved($index, item)" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td dnd-handle="dnd-handle" class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n        </tr>\n        \x3c!-- If a custom row template is provided and an alt row template is provided --\x3e\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row-alt\'" asui-template template="$even ? options.rowTemplate: options.altRowTemplate" dnd-disable-if="!options.dragSort" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected = item" ng-class="{\'selected\': options.selected === item}" dnd-moved="dndMoved($index, item)" ng-class-even="\'as-table-alt-row\'" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td dnd-handle="dnd-handle" class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n        </tr>\n\n        \x3c!-- If no custom row template is provided, render columns as TD by default--\x3e\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-class="item.rowClass" ng-if="colMode == \'td\'" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected == item" ng-class="{\'selected\': options.selected === item}" dnd-disable-if="!options.dragSort" dnd-moved="dndMoved($index, item)" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td dnd-nodrag ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td dnd-nodrag ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n          <td dnd-nodrag ng-if="options.rowTemplate === undefined" ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="i.cellClass">\n            \x3c!-- This Determines Show Or Hide The Column Data--\x3e<span ng-if="options.columns[$index].template === undefined && options.columns[$index].templateUrl === undefined" ng-bind="item[options.columns[$index].name]"></span>\n            \x3c!-- Customizable Column Template--\x3e\n            <div ng-if="options.columns[$index].template !== undefined" asui-template template="options.columns[$index].template"></div>\n          </td>\n          <td ng-if="options.actionMenus.length > 0" class="as-action-column"><span ng-if="item.$tbState._FilteredActionMenu.length > 0" ng-class="{ \'invisible\': checkCount > 1 }">\n              <asui-context-menu options="contextMenuOptions" id="{{item.Id}}" menu-groups="item.$tbState._FilteredActionMenu" on-item-click="actionMenuItemClick(item, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu></span></td>\n        </tr>\n      </tbody>\n\n      \x3c!-- Standard Table --\x3e\n      <tbody ng-if="!options.dragSort" ng-if="localItems.length > 0">\n          \x3c!-- If a custom row template is provided, and no alt row template is provided --\x3e\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row\'" asui-template template="options.rowTemplate" ng-class="{\'selected\': options.selected === item}" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n          </tr>\n          \x3c!-- If a custom row template is provided and an alt row template is provided --\x3e\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row-alt\'" asui-template template="$even ? options.rowTemplate: options.altRowTemplate" ng-class-even="\'as-table-alt-row\'" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n          </tr>\n          \x3c!-- If no custom row template is provided, render columns as TD by default--\x3e\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-class="item.rowClass" ng-if="colMode == \'td\'"  ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n            <td ng-if="options.rowTemplate === undefined" ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="i.cellClass">\n              \x3c!-- This Determines Show Or Hide The Column Data--\x3e<span ng-if="options.columns[$index].template === undefined && options.columns[$index].templateUrl === undefined" ng-bind="item[options.columns[$index].name]"></span>\n              \x3c!-- Customizable Column Template--\x3e\n              <div ng-if="options.columns[$index].template !== undefined" asui-template template="options.columns[$index].template"></div>\n            </td>\n            <td ng-if="options.actionMenus.length > 0" class="as-action-column"><span ng-if="item.$tbState._FilteredActionMenu.length > 0" ng-class="{ \'invisible\': checkCount > 1 }">\n                <asui-context-menu options="contextMenuOptions" id="{{item.Id}}" menu-groups="item.$tbState._FilteredActionMenu" on-item-click="actionMenuItemClick(item, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu></span></td>\n          </tr>\n        </tbody>\n    </table>\n\n  </div>\n  <div class="flex flex-align-stretch flex-justify-content">\n    <div></div>\n    <div ng-if="showPaging()" class="flex flex-align-center noselect margin-t-5 text-secondary">\n      <ul uib-pagination total-items="totalItems" items-per-page="options.paging.itemsPerPage" max-size="5" ng-model="options.paging.currentPage" ng-change="pageChanged()" style="margin: 0;" boundary-links="true" previous-text="<" next-text=">" first-text="<<" last-text=">>"></ul>\n    </div>\n  </div>\n</div>'), $templateCache.put("component-tableeditor/tableeditor.template", '<div class="asui-table-editor">\n    <div class="table-container"></div>\n</div>'), $templateCache.put("component-tagsinput/default-autocomplete.template", '<div class="autocomplete-template">\n    <div class="autocomplete-header" ng-if="data.header">{{data.header}}</div>\n    <div ng-if= "data.customTemplate" class="autocomplete-item" ng-include src="data.customTemplate"></div>\n    <div ng-if= "!data.customTemplate" class="autocomplete-item">\n        <div class="autocomplete-icon" ng-if="data.tagType">\n            <asui-card-user ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'user\'"></asui-card-user>\n            <div class="user-icon" ng-if="!data.icon && data.tagType === \'user\'"><i class="icon icon-user"></i></div>\n            <div class="user-icon" ng-if="data.tagType === \'user-group\'"><i class="icon icon-users"></i></div>\n            <asui-card-device ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && (data.tagType === \'device\' || data.tagType === \'device-group\')"></asui-card-device>\n            <i class="icon icon-device" ng-if="!data.icon && data.tagType === \'device\'"></i>\n            <i class="icon icon-device-group" ng-if="!data.icon && data.tagType === \'device-group\'"></i>\n            <i class="icon icon-tag" ng-if="data.tagType === \'tag\'"></i>\n            <i class="icon icon-network" ng-if="data.tagType === \'network\'"></i>\n            <asui-card-channel ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'channel\'"></asui-card-channel>\n            <i class="icon icon-channels" ng-if="!data.icon && data.tagType === \'channel\'"></i>\n            <asui-card-channel-group ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'channel-group\'"></asui-card-channel-group>\n            <i class="icon icon-channel-group" ng-if="!data.icon && data.tagType === \'channel-group\'"></i>\n            <i class="icon icon-folder" ng-if="data.tagType === \'folder\'"></i>\n            <i class="icon icon-card" ng-if="data.tagType === \'card\'"></i>\n            <i class="icon icon-card-template" ng-if="data.tagType === \'card-template\'"></i>\n        </div>\n        <div class="autocomplete-text">\n            <span>{{$getDisplayText()}}</span>\n        </div>\n        <div ng-if="data.secondaryText" class="autocomplete-text-secondary">\n            <span>{{data.secondaryText}}</span>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-tagsinput/default-tag.template", '<div ng-class="{\'cursor-pointer\' : data.tooltip}" uib-popover-html="data.tooltip" popover-trigger="\'outsideClick\'"\n    popover-placement="auto" popover-append-to-body="true">\n    <div ng-if="data.customTemplate" class="tag-template" ng-include src="data.customTemplate"></div>\n    <div ng-if="!data.customTemplate" class="tag-template">\n        <div class="tag-icon" ng-if="data.tagType">\n            <asui-card-user ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'user\'"></asui-card-user>\n            <i class="icon icon-user" ng-if="!data.icon && data.tagType === \'user\'"></i>\n            <i class="icon icon-users" ng-if="data.tagType === \'user-group\'"></i>\n            <asui-card-device ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && (data.tagType === \'device\' || data.tagType === \'device-group\')"></asui-card-device>\n            <i class="icon icon-device" ng-if="!data.icon && data.tagType === \'device\'"></i>\n            <i class="icon icon-device-group" ng-if="!data.icon && data.tagType === \'device-group\'"></i>\n            <i class="icon icon-tag" ng-if="data.tagType === \'tag\'"></i>\n            <i class="icon icon-network" ng-if="data.tagType === \'network\'"></i>\n            <asui-card-channel ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'channel\'"></asui-card-channel>\n            <i class="icon icon-channels" ng-if="data.tagType === \'channel\' && !data.icon"></i>\n            <asui-card-channel-group ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'channel-group\'"></asui-card-channel-group>\n            <i class="icon icon-channel-group" ng-if="data.tagType === \'channel-group\' && !data.icon"></i>\n            <i class="icon icon-folder" ng-if="data.tagType === \'folder\'"></i>\n            <i class="icon icon-card" ng-if="data.tagType === \'card\'"></i>\n            <i class="icon icon-card-template" ng-if="data.tagType === \'card-template\'"></i>\n        </div>\n        <div class="tag-text">\n            <span>{{$getDisplayText()}}</span>\n            <asui-spinner class="spinner-sm validation-spinner" ng-show="data.validating"></asui-spinner>\n            <a class="remove-button" ng-hide="data.readOnly === true" ng-click="$removeTag()">\n                <i class="icon icon-cross"></i>\n            </a>\n        </div>\n    </div>\n</div>'), $templateCache.put("component-tagsinput/tagsinput.template", '<uib-progressbar class="tagsinput-progress" ng-class="{\'invisible\': progressComplete }"\n    ng-if="options.showProgress" \n    animate="false" value="currentProgress">\n</uib-progressbar>\n<div class="asui-tags-input" ng-click="focusOnTagInput()" ng-if="init">\n    <tags-input class="{{options.styleType}}" ng-model="model" \n        tag-class="{\'readonly-tag\': $tag.readOnly === true, \'invalid-tag\': $tag.invalid, \'new-tag\': $tag.newTag, \'custom-tag\': $tag.customTag}" \n        ng-click="focusOnTagInput()" display-property="{{displayProperty}}" key-property="id"\n        template="{{tagTemplate}}" placeholder="{{placeholder}}" \n        replace-spaces-with-dashes="options.replaceSpacesWithDashes" \n        add-from-autocomplete-only="{{addFromAutocompleteOnly}}" min-length="1" \n        paste-split-pattern="{{options.pasteSplitPattern}}" \n        add-on-space="{{options.addOnSpace}}" \n        add-on-paste="{{options.addOnPaste}}" \n        on-tag-adding="tagAdding($tag)" \n        on-tag-added="tagAdded($tag)" \n        on-tag-removing="tagRemoving($tag)"\n        on-tag-removed="tagRemoved($tag)">\n        <auto-complete \n            load-on-focus="{{autocompleteSettings.loadOnFocus}}"\n            load-on-empty="{{autocompleteSettings.loadOnEmpty}}"\n            source="loadAutocompleteList($query)" \n            template="{{autocompleteTemplate}}" \n            select-first-match="false"\n            min-length="{{autocompleteMinLength}}" \n            max-results-to-show="{{autocompleteMaxResultsToShow}}">\n        </auto-complete>\n    </tags-input>\n</div>\n\n'), $templateCache.put("component-thumbnailupload/thumbnailupload.template", '<div class="asui-thumbnail-upload">\n    <div class="as-thumbnail-container">\n        <div class="as-thumbnail asui-content-tile ct-l-lg" ng-class="getThumbnailClass()" style="background-image: url(\'{{thumbnailUrl}}\')"><div ng-show="showDefaultText" ng-bind-html="options.defaultText"></div></div>\n    </div>\n    <form class="as-thumbnail-form">\n        <asui-file-upload options="uploadOptions" validation="uploadValidation" on-api-ready="onFileUploadApiReady(api)" on-complete="onUploadComplete(file, value)" ng-model="fileList" on-delete="onUploadDelete(file)" on-error="onUploadError(file, message)" target-url="{{targetUrl}}" show-generic-error="false"></asui-file-upload>\n    </form>\n</div>'), $templateCache.put("component-thumbnailupload/thumbnailuploadchannels.template", '<div class="asui-thumbnail-upload">\n    <div class="as-thumbnail-container">\n        <div class="as-thumbnail asui-content-tile ct-p-lg" ng-class="getThumbnailClass()" style="background-image: url(\'{{thumbnailUrl}}\')"><div ng-show="showDefaultText" ng-bind-html="options.defaultText"></div></div>\n    </div>\n    <form class="as-thumbnail-form">\n        <asui-file-upload options="uploadOptions" validation="uploadValidation" on-api-ready="onFileUploadApiReady(api)" on-complete="onUploadComplete(file, value)" ng-model="fileList" on-delete="onUploadDelete(file)" on-error="onUploadError(file, message)" target-url="{{targetUrl}}" show-generic-error="true"></asui-file-upload>\n    </form>\n</div>'), $templateCache.put("component-timezone/timezone.template", '<asui-dropdown items="timeZones" ng-model="ngModel" on-change="onTimezoneChange(value, item)"\n    options="dropdownOptions"\n    placeholder="{{options.placeholder}}">\n</asui-dropdown>'), $templateCache.put("component-verticalnavbar/verticalnavbar.template", '<ul class="vertical-navbar-container">\n    <li ng-repeat="item in items">\n        <div ng-class="{ \'active\': ngModel.value === item.value,  }" ng-if="item.value !== \'separator\'" class="navitem" ui-sref="{{item.sref}}" ng-click="onNavItemClick($event, item)">\n            <div ng-class="item.class">\n                <a href="{{item.href}}" target="{{item.target}}">\n                    <i ng-if="item.icon" class="{{item.icon}} padding-r-20 text-secondary"></i>{{item.label}}\n                </a>\n            </div>\n        </div>\n        <hr ng-if="item.value === \'separator\'">\n    </li>\n</ul>'), $templateCache.put("component-well/well.template", '<div class="well-container">\n    <div class="well-inner">\n        <ng-transclude> \n        </ng-transclude>\n    </div>\n</div>'), $templateCache.put("component-workbook/workbook.template", '<div class="asui-workbook">\n    <div class="workbook-sheet-container">\n        <asui-table-editor ng-repeat="sheet in sheets" \n            ng-if="sheet.selected"\n            options="sheet.options" \n            on-api-ready="onSheetReady(sheet, api)"\n            on-validity-check="onSheetUpdated(sheet, valid, changes)">\n        </asui-table-editor>\n    </div>\n    <div class="workbook-bottom-bar">\n        <div class="new-sheet-btn" title="Add sheet" ng-click="newSheetClick()"><i class="btn-icon fa fa-plus"></i></div>\n        <div class="sheet-collection">\n            <div class="sheet-tab" ng-click="sheetClick(sheet)" ng-repeat="sheet in sheets" ng-class="{\'active\' : sheet.selected}">\n                <span id="{{sheet.$$hashKey}}"  ng-keydown="onSheetNameKeydown($event, sheet)" ng-blur="onSheetNameBlur(sheet)">{{sheet.name}}</span>\n                <asui-context-menu menu-groups="sheet.menu" on-item-click="onSheetMenuClick(sheet, value)">\n                    <i class="fa fa-caret-down"></i>\n                </asui-context-menu>\n            </div>\n        </div>\n    </div>\n</div>\n'), $templateCache.put("component-workflownavbar/workflownavbar.template", '<div class="asui-workflow-navbar">\n    <div class="workflow-title" ng-if="options.title">\n        <span>{{options.title}}</span>\n    </div>\n    <ul class="nav nav-tabs">\n        <li ng-repeat="item in items" role="presentation"  ng-class="getClass($index)">\n            <a>{{item.label}}</a>\n        </li>\n    </ul>\n</div>'), $templateCache.put("custom-background/background.template", '<div class="asui-background asui-fileupload">\n    <div class="parent">\n        <input ng-hide="options.showColor === false" type="text" class="color form-control" name="{{id}}" ng-model="ngModel.bgColor"/>\n        <asui-file-upload class="file" options="bgOptions" ng-model="bgFiles" validation="bgValidation" target-url="{{targetUrl}}" on-complete="onUploadComplete(file, value)" on-delete="onUploadDelete(file)" resolve-file-path="resolveFilePathUpload(path)"></asui-file-upload>\n    </div>\n</div>'), $templateCache.put("custom-documentreader/documentreader.template", '<div class="asui-fileupload">\n    <div flow-drop flow-init class="ng-scope drop-target" ng-class="{\'drop\' : !options.noDrop}">\n        <div ng-class="{\'dropClass\' : !options.noDrop}">\n            <span ng-if="!options.noDrop">{{options.dropText ? options.dropText : \'Drop file here or\'}} </span>\n            <span class="browse" flow-btn>\n                {{options.browseText ? options.browseText : \'Browse\'}}\n                <input type="file" ng-show="false">\n            </span>\n        </div>\n        <div ng-if="options.showErrorMessage && error" class="validation-error upload-error">{{error}}</div>\n    </div>\n</div>'), $templateCache.put("custom-textbox/textbox.template", '<div class="asui-textbox" ng-class="{\'sticky-header\': options.toolbar == \'sticky\', \'hover-header\': options.toolbar == \'hover\'}">\n    <div ng-if="toolbarEnabled; "class="style-toolbar">\n        <asui-style-editor options="options.style" ng-model="textStyle" on-style-change="styleChange(style)"></asui-style-editor>\n    </div>\n    <input class="input-field" ng-if="options.type != \'textarea\'" type="{{options.type ? options.type : \'text\'}}" placeholder="{{placeholder}}" ng-model="ngModel" ng-keyup="onKeyUp($event)" ng-change="onTextChange()" ng-click="onTextboxClick()" ng-trim="{{options.trim ? \'true\' : \'false\'}}" autocomplete="off" />\n    <textarea class="input-field" ng-if="options.type == \'textarea\'" rows="{{rows}}" placeholder="{{placeholder}}" ng-model="ngModel" ng-keyup="onKeyUp($event)" ng-change="onTextChange()"  ng-click="onTextboxClick()" ng-trim="{{options.trim ? \'true\' : \'false\'}}"/>\n    <div ng-if="error && isDirty" class="validation-error">{{error}}</div>\n</div>'), $templateCache.put("component-accordion/accordion-header/accordion-header.template", '<uib-accordion-heading>\n    <div class="header-container">\n        <div ng-if="!$ctrl.options.html" class="header-title">\n            <i ng-if="$ctrl.options.icon" class="header-icon icon {{$ctrl.options.icon}}"></i>\n            <img ng-if="$ctrl.options.imageIcon" class="header-icon header-img" ng-src="{{$ctrl.options.imageIcon}}">\n            <div ng-if="$ctrl.options.title" class="header-text" ng-bind-html="$ctrl.options.title"></div>\n        </div>\n        <div ng-if="$ctrl.options.html" class="header-title" ng-bind-html="$ctrl.options.html"></div>\n        <i class="icon pull-right" ng-class="{\'icon-chevron-down\': $ctrl.isOpen, \'icon-chevron-right\': !$ctrl.isOpen}"></i>\n    </div>\n    <ng-transclude class="header-desc" ng-hide="$ctrl.isOpen"></ng-transclude>\n</uib-accordion-heading>'), $templateCache.put("component-floorplan-editor/poi-layer/poi-layer.template", '<div class="fpe-poi-layer-stage"/>\n<div ng-if="newItem.type" class="fpe-poi-layer-help">\n        <div ng-if="newItem.type.toLowerCase() ==\'trace\' && (newItem.coords.length == 0)" >\n                Click a room on the map to auto detect boundaries. Press Enter or Escape to cancel.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'trace\' && (newItem.coords.length != 0)" >\n                Press Enter to accept or Delete to remove.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'point\' && (newItem.coords.length == 0)" >\n                Click anywhere on the map to add a marker.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'polygon\' && (newItem.coords.length <= 4)" >\n                Click on the map to create a room outline. Press Enter or Escape to cancel.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'polygon\' && (newItem.coords.length >= 6)" >\n                Press Enter to accept or Delete to remove last coordinate.\n        </div>\n</div>'), $templateCache.put("component-schedule-table/item/item.template", '<div class="schedule-item-container">\n    <div class="schedule-item-name">\n        <div class="schedule-item-name-label">\n            {{item.name}}\n        </div>\n        <div class="schedule-item-location">\n            <div class="schedule-item-floor-name" ng-if="item.floorName">\n                {{item.floorName + (item.floorName && item.buildingName ? \', \' : \'\')}}\n            </div>\n            <div class="schedule-item-building-name" ng-if="item.buildingName">\n                {{item.buildingName}}\n            </div>\n        </div>\n    </div>\n    <div class="schedule-item-container-details">\n        <div class="schedule-item-number">{{item.number}}</div>\n        <div class="schedule-item-direction">\n            <i ng-class="directionIcon"></i>\n        </div>\n    </div>\n</div>\n<div class="schedule-item-status schedule-row-height"\n    ng-class="{\'schedule-item-status-available\': !item.status || item.status == \'available\', \'schedule-item-status-occupied\': item.status == \'occupied\', \'schedule-item-status-checkin\': item.status == \'checkin\'}">\n</div>'), $templateCache.put("component-schedule-table/item-info/item-info.template", '<div class="item-info-header">\n    <div class="item-info-name">{{$ctrl.item.name}} <span>{{$ctrl.item.number}}</span></div>\n    <div class="item-info-close" ng-click="$ctrl.onCloseClick()"><i class="icon icon-cross"></i></div>\n</div>\n<div class="item-info-details">\n    <div ng-if="$ctrl.item.floorName" class="item-info-floor-name">\n        {{$ctrl.item.floorName + ($ctrl.item.floorName && $ctrl.item.buildingName ? \', \' : \'\')}}\n    </div>\n    <div ng-if="$ctrl.item.buildingName" class="item-info-building-name">\n        {{$ctrl.item.buildingName}}\n    </div>\n    <div ng-if="$ctrl.facilities" class="item-info-facilities">\n        <div class="facility" ng-repeat="facility in $ctrl.facilities" ng-style="facility.styling">\n            <span ng-if="facility.logo" class="facility-logo" ng-bind-html="facility.logo"></span>\n            <span ng-if="facility.text" class="facility-text">{{facility.text}}</span>\n        </div>\n    </div>\n    <div ng-if="$ctrl.itemScheduleInfo.activeSchedule" class="item-info-current-meeting">\n        <span class="item-info-meetings-schedule-name">{{$ctrl.itemScheduleInfo.activeSchedule.name}}</span>\n        <span class="item-info-meetings-schedule-time">\n            &nbsp;{{$ctrl.itemScheduleInfo.activeSchedule.timeString}}</span>\n    </div>\n    <div ng-if="!$ctrl.itemScheduleInfo.activeSchedule && $ctrl.itemScheduleInfo.status == \'checkin\'"\n        class="item-info-current-meeting">\n        <span class="item-info-meetings-schedule-name">{{$ctrl.itemScheduleInfo.upcomingMeetings[0].name}}</span>\n        <span class="item-info-meetings-schedule-time">\n            &nbsp;{{$ctrl.itemScheduleInfo.upcomingMeetings[0].timeString}}</span>\n    </div>\n    <div ng-if="!$ctrl.itemScheduleInfo.activeSchedule" class="item-info-next-meeting">{{$ctrl.nextMeetingText}}</div>\n    <div class="item-info-buttons" ng-if="!$ctrl.readonly && !$ctrl.item.readOnly">\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'available\'" class="item-info-button"\n            ng-click="$ctrl.onBookClick()">Book</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'occupied\' && $ctrl.isMeetingExtendable"\n            class="item-info-button item-info-button-extend" ng-click="$ctrl.onExtendClick()">Extend</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'occupied\'" class="item-info-button" ng-click="$ctrl.onEndClick()">\n            End</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'checkin\'" class="item-info-button"\n            ng-click="$ctrl.onCheckinClick()">Check-in</div>\n    </div>\n</div>\n<div class="item-info-meetings">\n    <div ng-if="$ctrl.itemScheduleInfo.upcomingMeetings.length > 0" class="item-info-meetings-header">UPCOMING MEETINGS\n    </div>\n    <div class="item-info-meetings-schedule-list">\n        <div class="item-info-meetings-schedule" ng-repeat="schedule in $ctrl.itemScheduleInfo.upcomingMeetings">\n            <span class="item-info-meetings-schedule-name">{{schedule.name}}</span>\n            <span class="item-info-meetings-schedule-time">{{schedule.dateTimeString}}</span>\n        </div>\n    </div>\n</div>\n<div class="item-info-status-bar"\n    ng-class="{\'schedule-item-status-available\': $ctrl.itemScheduleInfo.status == \'available\', \'schedule-item-status-occupied\': $ctrl.itemScheduleInfo.status == \'occupied\', \'schedule-item-status-checkin\': $ctrl.itemScheduleInfo.status == \'checkin\'}">\n</div>'), $templateCache.put("component-schedule-table/filter-footer/filter-footer.template", '<div ng-if="filterCount > 0" class="filter-partial-container">\n    <span>Viewing {{filterCount}} out of {{totalCount}} rooms</span>\n</div>\n<div ng-if="filterCount == 0" class="filter-noresults-container">\n    <span>There are no {{filter}} rooms</span>\n</div>\n<div class="filter-view-all" ng-class="{ \'filter-empty-view-all\' : !filterCount }">View All Rooms</div>\n    '), $templateCache.put("component-schedule-table/slot/slot.template", "X"), $templateCache.put("component-schedule-table/timeline-header/header.template", "<span>{{label}}</span>");
}]);
"use strict";

angular.module('templates').run(['$templateCache', function ($templateCache) {
  $templateCache.put('card-channel/card-channel.template', '<div ng-if="ngModel" class="asui-card" ng-class="{\'card-icon-only\': iconOnly}">\n    <div class="card-thumbnail" ng-if="!ThumbnailSref" ng-class="{\'card-icon-lg\': iconSize == \'lg\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <i ng-if="!imgLoaded && !imgLoading" class="icon {{icon}}"></i>\n        <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n    </div>\n    <div class="card-thumbnail cursor-pointer" ng-if="ThumbnailSref" ui-sref="{{ThumbnailSref}}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <i ng-if="!imgLoaded && !imgLoading" class="icon {{icon}}"></i>\n        <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n    </div>\n    <div ng-if="::!iconOnly" class="details-container">\n        <div class="details-header">\n            <div class="channel-type">\n                <i class="icon {{iconHeader}}" ng-style="{ \'color\' : iconTypeColor}"></i> {{::Type}}\n            </div>\n            <asui-context-menu ng-if="::contextMenu" menu-groups="contextMenu" options="contextMenuOptions" on-item-click="onMenuItemClick(target, group, value)">\n                <i class="fa fa-ellipsis-v text-secondary"></i>\n            </asui-context-menu>\n        </div>\n        <div class ="details-main">\n            <div class="channel-title" ng-bind-html="Name"\n                ng-class="{\'title-1line\': lineCount === 1, \'title-2lines\': lineCount === 2, \'title-3lines\': lineCount === 3}" \n                uib-popover="{{::tooltip}}" popover-placement="auto" uib-popover-on-truncate>\n            </div>\n            <div ng-if="::ChannelGroups.length" class="channel-channelgroups">\n                Belongs to\n                <span ng-repeat="cg in ::ChannelGroups">\n                    <span ng-bind-html="::cg.Name"/>\n                    <span ng-if="!$last">,</span>\n                </span>\n            </div>\n            <div class="channel-publishto" ng-bind-html="::PublishedTo" ng-if="::!PublishedTo.length"></div>\n        </div>\n        <div class ="details-footer">\n            <div class="footer-primary">\n                {{::LastUpdate}}\n            </div>\n            <div class="footer-secondary">\n                <span ng-bind-html="::secondaryFooter"></span>\n            </div>\n        </div>\n    </div>\n</div>');
  $templateCache.put('card-channel-group/card-channel-group.template', '<div class="asui-card" ng-class="{\'card-icon-only\': iconOnly}">\n    <div class="card-thumbnail" ng-if="!ThumbnailSref" ng-style="{ \'background-color\' : Color}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" >\n        <div class="card-thumbnail-image"\n            ng-class="{\'thumbnail-opacity\': (Color && Thumbnail && imgLoaded) }">\n                <i ng-if="!imgLoaded && !imgLoading" class="icon icon-channel-group"></i>\n                <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n        </div>\n    </div>\n    <div class="card-thumbnail cursor-pointer" ng-if="ThumbnailSref" ui-sref="{{ThumbnailSref}}" ng-style="{ \'background-color\' : Color}" ng-class="{\'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" >\n        <div class="card-thumbnail-image"\n            ng-class="{\'thumbnail-opacity\': (Color && Thumbnail && imgLoaded) }">\n                <i ng-if="!imgLoaded && !imgLoading" class="icon icon-channel-group"></i>\n                <img draggable="false" ondragstart="return false;" ng-show="imgLoaded" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n        </div>\n    </div>\n    <div ng-if="iconOnly !== true" class="details-container">\n        <div class="details-header">\n            <div class="channelgroup-title" ng-bind-html="Name" \n            ng-class="{\'title-1line\': lineCount === 1, \'title-2lines\': lineCount === 2}" \n            uib-popover="{{tooltip}}" popover-placement="auto" uib-popover-on-truncate>\n            </div>\n            <asui-context-menu menu-groups="contextMenu" options="contextMenuOptions" on-item-click="onMenuItemClick(target, group, value)">\n                <i class="fa fa-ellipsis-v text-secondary"></i>\n            </asui-context-menu>\n        </div>\n        <div class ="details-main title-1line" ng-if="PublishedTo">\n            Published to <span ng-bind-html="PublishedTo"></span>\n        </div>\n        <div class ="details-footer">\n            <div class="footer-primary">\n                {{LastUpdate}}\n            </div>\n            <div ng-if="ItemCount" class="footer-secondary">\n                {{ItemCount}}\n            </div>\n        </div>\n    </div>\n</div>');
  $templateCache.put('card-content/card-content.template', '<div ng-if="::ngModel" class="asui-card" ng-class="::{\'card-icon-only\': iconOnly, \'card-icon-only-responsive\': iconSize == \'responsive\'}">\n    <!-- Thumbnail -->\n    <div class="card-thumbnail" ng-attr-ui-sref="{{ngModel.thumbnailSref ? ngModel.thumbnailSref : false}}" ng-class="::{\'cursor-pointer\' : ngModel.thumbnailSref, \'card-icon-md\': iconSize == \'md\' || !iconSize, \'card-icon-lg\': iconSize == \'lg\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\', \'card-icon-responsive\': iconSize == \'responsive\'}">\n        <div class="card-thumbnail-image">\n            <i ng-if="icon" class="icon {{::icon}} content-type-icon"></i>\n            <img draggable="false" ondragstart="return false;" ng-if="ngModel.thumbnailURL" class="thumbnail-img" ng-src="{{ngModel.thumbnailURL}}" ng-load="onImgLoad()" ng-error="onImgError()"/>\n            <span ng-if="::Duration || Duration === 0" class="video-duration">\n                <span ng-if="::Duration">{{::Duration}}</span>\n                <i ng-if="::Duration === 0" class="icon icon-clock"></i>\n            </span>\n        </div>\n    </div>\n    <!--If not icon only, show details section-->\n    <div ng-if="::!iconOnly" class="details-container">\n        <div class="details-header">\n            <i class="content-icon icon {{::icon}}"></i>\n            <div class="channel-title" ng-bind-html="Name" \n                uib-popover="{{tooltip}}" popover-placement="auto" popover-append-to-body="true" uib-popover-on-truncate>\n            </div>\n            <i class="context-menu fa fa-ellipsis-v text-secondary"\n                asui-context-menu-nested cmn-model="contextMenu" \n                cmn-options="contextMenuOptions" \n                on-cmn-item-select="onMenuItemClick(key)"></i>\n        </div>\n    </div>\n    <div ng-if="loadingSpinner && loadingThumbnail" class="asui-spinner-container">\n        <asui-spinner type="fade-circle" class="sdpinner-sm"></asui-spinner>\n    </div>\n</div>');
  $templateCache.put('card-device-group/card-device-group.template', '<div class="card-thumbnail-image-circle" ng-class="{\'card-icon-lg\': iconSize === \'lg\', \'card-icon-md\': iconSize === \'md\', \'card-icon-sm\': iconSize === \'sm\', \'card-icon-xs\': iconSize === \'xs\'}">\n    <i class="icon icon-device-group"></i>\n</div>');
  $templateCache.put('card-device/card-device.template', '    <div class="card-thumbnail" ng-if="!ThumbnailSref" ng-class="{\'card-icon-lg\': iconSize == \'lg\', \'card-icon-md\': iconSize == \'md\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <img draggable="false" ng-if="Thumbnail" ng-src="{{Thumbnail}}"/>\n    </div>\n    <div class="card-thumbnail cursor-pointer" ng-if="ThumbnailSref" ui-sref="{{ThumbnailSref}}" ng-class="{\'card-icon-lg\': iconSize == \'lg\', \'card-icon-md\': iconSize == \'md\', \'card-icon-sm\': iconSize == \'sm\', \'card-icon-xs\': iconSize == \'xs\'}" ng-style="{ \'background-color\' : iconColor}">\n        <img draggable="false" ng-if="Thumbnail" ng-src="{{Thumbnail}}"/>\n    </div>');
  $templateCache.put('card-network/card-network.template', '<div class="card-thumbnail-image-circle" ng-class="{\'card-icon-lg\': iconSize === \'lg\', \'card-icon-md\': iconSize === \'md\', \'card-icon-sm\': iconSize === \'sm\', \'card-icon-xs\': iconSize === \'xs\'}">\n    <i class="icon icon-network"></i>\n</div>');
  $templateCache.put('card-user/card-user.template', '<div class="asui-card">\n    <div class="card-thumbnail" ng-class="{\'card-icon-lg\': iconSize === \'lg\', \'card-icon-md\': iconSize === \'md\', \'card-icon-sm\': iconSize === \'sm\', \'card-icon-xs\': iconSize === \'xs\', \'cursor-pointer\': ThumbnailSref !== undefined || ThumbnailSref !== null}" >\n        <div class="card-thumbnail-image-circle" ng-hide="imgLoaded" ng-style="{ \'background-color\' : Color}">\n            <span ng-if="iconSize === \'xs\'" ng-class="{\'icon-line-height\' : ngModel.icon}" ng-bind-html="Initial"></span>\n            <span ng-if="iconSize !== \'xs\'" ng-bind-html="DoubleInitial"></span>\n        </div>\n        <div class="card-thumbnail-image-circle white-bg" ng-show="imgLoaded">\n            <img draggable="false" ng-if="Thumbnail" ng-src="{{Thumbnail}}" ng-load="onImageLoad($event)" ng-error="onImageError($event)"/>\n        </div>\n    </div>\n    <div ng-if="iconOnly !== true" class="details-container">\n    </div>\n</div>');
  $templateCache.put('card-user-group/card-user-group.template', '<div class="card-thumbnail-image-circle" ng-class="{\'card-icon-lg\': iconSize === \'lg\', \'card-icon-md\': iconSize === \'md\', \'card-icon-sm\': iconSize === \'sm\', \'card-icon-xs\': iconSize === \'xs\'}">\n    <i class="icon icon-users"></i>\n</div>');
  $templateCache.put('component-accordion/accordion.template', '<uib-accordion close-others="$ctrl.options.oneAtATime">\n    <ng-transclude></ng-transclude>\n</uib-accordion>');
  $templateCache.put('component-badge/badge.template', ' <div class="asui-badge" ng-class="{\'badge-sm\': size == \'sm\', \'badge-lg\': size == \'lg\', \'asui-badge-hover\': onHover}" ng-switch="type.toLowerCase()">\n    <div class="asui-badge-circle asui-badge-add" ng-switch-when="add">\n        <i class="fa fa-plus"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-remove" ng-switch-when="remove">\n        <i class="fa fa-close"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-check" ng-switch-when="check">\n        <i class="fa fa-check"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-check-inherited" ng-switch-when="check-inherited">\n        <i class="fa fa-check"></i>\n    </div>\n    <div class="asui-badge-circle asui-badge-count-unread" ng-switch-when="count-unread">\n        <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n    <div class="asui-badge-circle asui-badge-count-group" ng-switch-when="count-group">\n         <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n    <div class="asui-badge-square asui-badge-count-approvals" ng-switch-when="count-approvals">\n         <span>{{count > 100 ? \'99+\' : count}}</span>\n    </div>\n</div>\n');
  $templateCache.put('component-breadcrumbs/breadcrumbs.template', '<ol class="breadcrumb">\n    <li class="breadcrumb-item" ng-repeat="item in $ctrl.items" ng-click="$ctrl.onClick(item)">\n        <a ng-if="item.sref.length > 0" ui-sref="{{item.sref}}">{{item.label}}</a>\n        <a ng-if="!item.sref.length && item.href.length" href="{{item.href}}">{{item.label}}</a>\n        <span ng-if="!item.sref.length && !item.href.length && !item.items.length">{{item.label}}</span>\n        <asui-context-menu \n            ng-if="item.items.length" \n            selected-inputs="item.contextMenu.selectedInputs" \n            options="item.contextMenu.options" \n            ng-model="item.contextMenu.model" \n            menu-groups="item.contextMenu.menuGroups" \n            on-item-click="$ctrl.onContextMenuClick(target, group, value)">\n            {{item.contextMenu.selectedInputs[item.label].buttonText}} <i class="fa fa-caret-down"></i>\n        </asui-context-menu>\n        </div>\n    </li>\n</ol>');
  $templateCache.put('component-carousel/carousel.card.template', '<iframe ng-src="{{$sce.trustAsResourceUrl(resolvedSrc)}}" seamless frameBorder="0" scrolling="no" allow="camera"></iframe>\n');
  $templateCache.put('component-carousel/carousel.template', '<div class="owl-carousel" data-ng-transclude>\n    <!-- Placeholder template -->\n    <div data-ng-repeat="item in localItems track by item.$$id" emit-last-repeater-element>\n        <div ng-if="item.$showPlaceHolder" ng-style="item.$style" class="asui-carousel-item carousel-item-placeholder"></div>\n        <div ng-if="!item.$showPlaceHolder" ng-include="\'component-carousel/default.template\'"></div>\n    </div>\n</div>\n\n');
  $templateCache.put('component-carousel/carousel.video.template', '<video ng-class="{\'aspect-fill\': item.aspect == \'fill\', \'aspect-uniform\': item.aspect == \'uniform\', \'aspect-uniformfill\': item.aspect == \'uniformfill\'}" ng-src="{{src}}" ng-click = "onVideoClick()"></video>\n<div ng-if="showPlayButton && !hideControls" class="play-button" ng-click = "onPlayClick()">\n    <span class="play-btn-holder"><i class="icon icon-play"></i></span>\n</div>');
  $templateCache.put('component-carousel/carousel.web.template', '<iframe ng-src="{{$sce.trustAsResourceUrl(resolvedSrc)}}" frameBorder="0" scrolling="no"></iframe>\n');
  $templateCache.put('component-carousel/default.template', '<!-- Error temmplate -->\n<div ng-if="item.onError" class="asui-carousel-item" ng-style="item.$style"> \n    <div class="error-template">\n        <i class="icon icon-file-error"></i>\n        Error loading content\n    </div>\n</div>\n<!-- Custom template URL provided -->\n<div ng-if="!item.onError && item.templateUrl" class="asui-carousel-item">\n    <div ng-include="item.templateUrl"/>\n</div>\n<!-- Custom template provided -->\n<div ng-if="!item.onError && item.template" class="asui-carousel-item">\n    <asui-template template="item.template" ></asui-template>\n</div>\n<!-- Use a default template based on content type -->\n<div ng-if="!item.onError && !item.templateUrl && !item.template" class="asui-carousel-item" ng-style="item.$style" ng-switch="item.type.toLowerCase()">\n    <image ng-class="{\'aspect-fill\': item.aspect == \'fill\', \'aspect-uniform\': item.aspect == \'uniform\', \'aspect-uniformfill\': item.aspect == \'uniformfill\'}" ng-switch-when="image" ng-src="{{item.trustedSrc}}"></image>\n    <asui-carousel-video ng-switch-when="video"\n         is-current="item.$isCurrent" \n         is-active="item.$isActive" \n         on-error="onError(item)"\n         hide-controls="options.mode == \'mediaplayer\' ? true : false"\n         on-complete="onItemComplete(item)"\n         item="item">\n    </asui-carousel-video>\n    <asui-carousel-card \n        item="item" \n        ng-switch-when="card" \n        on-error="onError(item)"\n        on-complete="onItemComplete(item)">\n    </asui-carousel-card>\n    <asui-carousel-web ng-switch-when="html" src="{{$sce.trustAsResourceUrl(item.src)}}"></asui-carousel-web>\n    <div class="not-supported-template" ng-switch-default>\n        <i class="icon icon-file"></i>\n        Preview not available\n    </div>\n</div>');
  $templateCache.put('component-chart-donut/chart-donut.template', ' <div class="asui-chart-donut">\n    <canvas id="donut" class="chart chart-doughnut" \n        chart-options="chartOptions" \n        chart-data="chartData" \n        chart-labels="chartLabels" \n        chart-colors="chartColors">\n    </canvas>\n    <div class="center-label" ng-if="centerLabel.length">{{centerLabel}}</div>\n</div>\n');
  $templateCache.put('component-checkbox/checkbox.template', '<div class="asui-checkbox" ng-class="{\'horizontal\' : options.direction == \'horizontal\'}">\n    <label data-ng-repeat="item in localItems">\n        <input type="checkbox" value="{{item.value}}" ng-change="onCheckboxClick(item)" ng-model="item.checked" />\n        {{item.label}}\n    </label>\n</div>');
  $templateCache.put('component-codeview/codeview.template', '<textarea></textarea>');
  $templateCache.put('component-colorpicker/colorpicker.template', '<div>\n  <input type="text" class="form-control" ng-model="$scope.localModal" />\n</div>');
  $templateCache.put('component-commandbar/commandbar.template', '<div class="asui-command-bar" ng-show="isOpen">\n    <div ng-if="options.triggerElement" class="trigger-pointer up-arrow_box"></div>\n    <div class="content ">\n        <ng-transclude class="content"></ng-transclude>  \n    </div>  \n    <div class="close-btn" ng-click="onCloseClick()" ng-if="options.triggerElement"><i class="icon icon-cross"></i></div>\n</div>');
  $templateCache.put('component-contenttile/content-tile.template', '<div class="asui-content-tile">\n    <div class="ct-content-container"> \n        <ng-transclude class="ct-content"></ng-transclude>  \n    </div>\n</div>');
  $templateCache.put('component-contextmenu/contextmenu-list.template', '<div ng-repeat="group in menuGroups">\n    <div class="cm-header" ng-if="group.showHeader">{{group.name}}</div>\n    <ul>\n        <li ng-repeat="item in group.items">\n            <a ng-if="!item.disabled" ng-click="itemClick($event, group, item.value)">\n                <span ng-bind-html="item.label" class="item-label"></span>\n                <span class="icon icon-check check-mark" ng-if="isChecked(group, item.value)"></span>\n            </a>\n            <div ng-bind-html="item.label" ng-if="item.disabled" class="cm-item-disabled"></div>\n        </li>\n        <li class="divider" ng-if="!$last && group.insertDivider !== false">></li>\n    </ul>\n</div>');
  $templateCache.put('component-contextmenu/contextmenu.template', '<div class="asui-context-menu">\n    <span class="cm-button" \n      popover-class="asui-context-menu-popover"\n      ng-click="onContextMenuClick($event)" \n      popover-trigger="\'outsideClick\'" \n      popover-placement="{{options && options.placement ? options.placement : \'bottom-auto\'}}" \n      uib-popover-template="\'component-contextmenu/contextmenu-list.template\'" \n      popover-append-to-body="options.appendToBody"\n      popover-is-open="isOpen">\n      <ng-transclude></ng-transclude>  \n    </span>\n</div>');
  $templateCache.put('component-copy/copy.template', '<div class="asui-copy" \n    ng-bind-html="label" \n    ng-click="onClick()"\n    popover-is-open="isOpen"\n    uib-popover="{{popoverText}}">\n</div>');
  $templateCache.put('component-datepicker/datepicker.template', '<div class="asui-date-picker input-group date">\n    <i class="icon icon-calendar" ng-show="showIcon()"></i>\n    <input class="datepicker-input" type="text" ng-disabled="readOnly"\n        ng-readonly="readonly || options.disableManualInput" ng-class="{\'has-calendar-icon\' : showIcon()}"\n        placeholder="{{ngModel ? \'\' : placeholder}}" />\n    <div ng-if="ngModel != null && !readonly" class="date-clear" ng-click="clearInput($event)">\n        <i class="icon icon-remove"></i>\n    </div>\n</div>');
  $templateCache.put('component-daterangepicker/daterangepicker.template', '<div class="asui-date-range-picker input-group date">\n    <i class="icon icon-calendar" ng-show="showIcon()" ng-click="onCalendarClick()"></i>\n    <input type="text" placeholder="{{getPlaceholderText()}}" class="date-input" ng-class="{\'has-calendar-icon\' : showIcon()}"  ng-keyup="onKeyUp($event)" readonly />\n    <div ng-if="ngModel.startDate != null" class="date-clear" ng-click="clearInput($event)">\n        <i class="icon icon-remove"></i>\n    </div>\n</div>');
  $templateCache.put('component-dayparting/dayparting.template', '<div class="dayparting-container">\n    <div class="dayparting-day-col">\n        <asui-context-menu class="dayparting-filter"\n            selected-inputs="$ctrl.intervalFilter.selectedInputs" \n            options="$ctrl.intervalFilter.options" \n            ng-model="$ctrl.intervalFilter.model" \n            menu-groups="$ctrl.intervalFilter.menuGroups" \n            on-item-click="$ctrl.onIntervalFilterClick(value)">\n            {{$ctrl.intervalFilter.selectedInputs[\'intervalfilter\'].buttonText}} <i class="fa fa-caret-down"></i>\n        </asui-context-menu>\n        <div ng-repeat="item in $ctrl.dataGrid track by item.id"\n            class="dayparting-day-label" \n            ng-class="{\'dayparting-day-everyday\':item.id === \'everyday\'}" \n            ng-click="$ctrl.onDayClick(item)">\n            <span ng-if="$ctrl.options.dayLabel === \'label1Letter\'"">{{item.label1Letter}}</span>\n            <span ng-if="$ctrl.options.dayLabel === \'label3Letters\'"">{{item.label3Letters}}</span>\n            <span ng-if="!$ctrl.options.dayLabel || $ctrl.options.dayLabel === \'full\'"">{{item.label}}</span>\n        </div>\n    </div>\n    <div class="dayparting-time-block">\n        <div class="dayparting-header-row">\n            <div ng-repeat="item in $ctrl.headers track by item.id"\n                class="dayparting-header" \n                ng-style="{\'min-width\': $ctrl.minHeaderWidth}">{{item.label}}</div>\n        </div>\n        <div asui-dayparting-day-slots \n            ng-repeat="item in $ctrl.dataGrid track by item.id"\n            item="item"\n            min-slot-width="$ctrl.minSlotWidth">\n        </div>\n    </div>\n</div>\n<div class=\'dayparting-clear\' ng-click="$ctrl.clear()">Clear all</div>');
  $templateCache.put('component-dragdrop/dragdrop.template', '<div class="dnd-alert" ng-show="showAlert">{{alert}}</div>\n<ul ng-if="!multiselect" dnd-list="ngModel.items" \n    dnd-drop="dropCallback(item)" \n    dnd-allowed-types="options.preventReorder === true && options.dragMode.toLowerCase() !== \'none\'? [] : null"\n    dnd-disable-if="isMaxCountReached()">\n    <li ng-repeat="item in ngModel.items" \n        dnd-draggable="item" \n        dnd-moved="dndMoved($index, item)" \n        dnd-copied="dndCopied($index, item)" \n        dnd-selected="dndSelected(item)" \n        dnd-effect-allowed="{{effectAllowed}}" \n        dnd-disable-if="item.disabled === true || options.dragMode.toLowerCase() === \'none\' " \n        ng-class="getItemClass(item)">\n        <div class="drag-item">\n            <div ng-if="options.dragMode.toLowerCase() != \'none\' " class="drag-icon"><i class="icon icon-vertical-drag"></i></div>\n            <div ng-if="!options.template" class="drag-content">\n                <div class="drag-transclude">\n                    <custom-transclude></custom-transclude>\n                </div>\n            </div>\n            <div ng-if="options.template" class="drag-content" ng-include src="options.template"></div>\n            <div ng-if="options.addBtn === true || options.removeBtn === true" class="drag-item-buttons">\n                <asui-badge ng-if="options.addBtn === true" type="add" class="drag-item-add" ng-click="addClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.removeBtn === true" type="remove" class="drag-item-remove" ng-click="removeClick($index, item)"></asui-badge>\n            </div>\n        </div>\n    </li>\n</ul>\n\n<ul ng-if="multiselect" dnd-list dnd-drop="dndMultiselectDrop(ngModel, item, index)" \n    dnd-allowed-types="options.preventReorder === true && options.dragMode.toLowerCase() !== \'none\'? [] : null"\n    dnd-disable-if="isMaxCountReached()">\n    <li ng-repeat="item in ngModel.items" \n        dnd-draggable="dndMultiselectDraggable(ngModel, item)"\n        dnd-dragstart="dndMultiselectDragstart(ngModel, event)" \n        dnd-dragend="dndMultiselectDragEnd(ngModel)" \n        dnd-moved="dndMultiselectMoved(ngModel)"\n        dnd-copied="dndMultiselectCopied(ngModel)" \n        dnd-selected="dndMultiselectSelected(ngModel, item, event)" \n        dnd-effect-allowed="{{effectAllowed}}" \n        dnd-disable-if="dragging === true || item.disabled === true || options.dragMode.toLowerCase() == \'none\' " \n        ng-class="getMultiselectItemClass(item)">\n        <div class="drag-item">\n            <div ng-if="options.dragMode.toLowerCase() != \'none\' " class="drag-icon"><i class="icon icon-vertical-drag"></i></div>\n            <div ng-if="!options.template" class="drag-content">\n                <div class="drag-transclude">\n                    <custom-transclude></custom-transclude>\n                </div>\n            </div>\n            <div ng-if="options.template" class="drag-content" ng-include src="options.template"></div>\n            <div ng-if="options.addBtn === true || options.removeBtn === true" class="drag-item-buttons">\n                <asui-badge ng-if="options.addBtn === true && item.checked !== true" type="add" class="drag-item-add" ng-click="!item.disabled && addClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.addBtn === true && item.checked === true" type="check" class="drag-item-checked" ng-click="!item.disabled && checkedClick($index, item)"></asui-badge>\n                <asui-badge ng-if="options.removeBtn === true" type="remove" class="drag-item-remove" ng-click="!item.disabled && removeClick($index, item)"></asui-badge>\n            </div>\n        </div>\n    </li>\n</ul>');
  $templateCache.put('component-dragdrop-tree/default.template', '<div class="asui-ui-tree-node">\n    <i ng-class="{\'invisible\': node.nodes.length <= 0, \'icon-caret-right tree-caret\': collapsed, \'icon-caret-down tree-caret\': !collapsed }" ng-click="toggle(this)"></i>\n    <div ng-if="node.dragEnabled === true" class="tree-drag" ui-tree-handle>\n        <i  class="icon-vertical-drag"></i>\n    </div>\n\n    <div class="inline" ng-switch="node.type">\n        <div class="inline" ng-switch-when="custom" >\n            <div class="inline" ng-include="node.template"></div>\n        </div>\n        <div class="inline" ng-switch-when="folder">\n            <i class="icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="library">\n            <i class="icon-library tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="device">\n            <i class="icon-device tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="devicegroup">\n            <i class="icon-folder  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="network">\n            <i class="icon-network tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="user">\n            <i class="icon-user  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="usergroup">\n            <i class="icon-users tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-default>\n            <span class="cursor-default" ng-bind-html="node.label"></span>\n        </div>\n    </div>\n    \n    <ol ui-tree-nodes="" ng-model="node.nodes">\n        <li ng-if="!collapsed" ng-repeat="node in node.nodes" ui-tree-node ui-tree-node data-collapsed="true" data-expand-on-hover="true" ng-include="\'component-dragdrop-tree/default.template\'">\n        </li>\n    </ol>\n</div>');
  $templateCache.put('component-dragdrop-tree/drop-list.template', '<div class="asui-ui-tree-node">\n    <div class="inline" ng-switch="node.type">\n        <div class="inline" ng-switch-when="custom">\n            <i class="icon icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="folder">\n            <i class="icon icon-folder tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="library">\n            <i class="icon icon-library tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="device">\n            <i class="icon icon-device tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="devicegroup">\n            <i class="icon icon-folder  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="network">\n            <i class="icon icon-network tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="user">\n            <i class="icon icon-user  tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-when="usergroup">\n            <i class="icon icon-users tree-icon" ng-click="toggle(this)"></i>\n            <a class="cursor-default" ng-bind-html="node.label"></a>\n        </div>\n        <div class="inline" ng-switch-default>\n            <span class="cursor-default" ng-bind-html="node.label"></span>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-dropdown/dropdown.template', '<div class="asui-dropdown"ng-class="{\'asui-dropdown-disabled\': disabled == \'true\'}" uib-popover="{{disabled == \'true\' ? disabledTooltip : null}}" popover-trigger="\'mouseenter\'">\n    <select ng-disabled="options.disabled" class="selectpicker as-select" title="{{placeholder}}"></select>\n</div>');
  $templateCache.put('component-dropdown-typeahead/custom-template.template', '<asui-card-channel icon-only=true icon-size="xs" ng-model="item.iconModel"></asui-card-channel>\n{{item.label}}');
  $templateCache.put('component-dropdown-typeahead/dropdown-typeahead.template', '<div ng-if="$ctrl.selectedItem" ng-repeat=\'item in $ctrl.selectedItemArray\' class="item-container selected-item" ng-class="{\'disabled\': $ctrl.disabled, \'not-active\' : $ctrl.isOpen}">\n    <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n    <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n    <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n        <div ng-if="$ctrl.selectedItem.icon" ng-bind-html="$ctrl.selectedItem.icon" class="item-icon"></div>\n        <div ng-bind-html="$ctrl.selectedItem.label" class="item-label"></div>\n    </div>\n</div>\n<input type="text" \n    class="textbox"\n    ng-disabled="$ctrl.disabled"\n    placeholder="{{$ctrl.selectedItem ? null : $ctrl.placeholder}}" \n    ng-model="$ctrl.keywords" \n    ng-click="$ctrl.onInputClick()"\n    ng-keyup="$ctrl.onKeyUp($event)"\n    ng-change="$ctrl.onKeywordsChange()">\n<i ng-if="!$ctrl.options.allowEmptyValue || ($ctrl.options.allowEmptyValue && !$ctrl.selectedItem) || $ctrl.disabled" class="fa fa-caret-down" ng-click="$ctrl.onInputClick()" ng-class="{\'disabled\': $ctrl.disabled}"></i>\n<i ng-if="$ctrl.options.allowEmptyValue && $ctrl.selectedItem && !$ctrl.disabled" class="icon icon-cross" ng-click="$ctrl.onClearClick()"></i>\n<div class="dropdown-container" ng-class="{\'dropdown-open\': $ctrl.isOpen}">\n    <asui-spinner ng-if="$ctrl.isLoading" class="spinner-sm"></asui-spinner>\n    <div ng-if="!$ctrl.isLoading && $ctrl.filteredItems.length" class="dropdown-container-inner" ng-repeat="item in $ctrl.filteredItems">\n        <div ng-if="item._isGroup" \n            class="dt-group" \n            ng-class="{\'dt-divider\' : item.showDivider && $index != 0}">{{item.label}}\n        </div>\n        <div ng-if="!item._isGroup"\n            class="dropdown-item"\n            ng-class="{\'active\': item._active}"\n            ng-mouseover="$ctrl.onMouseOver(item)"\n            ng-mouseleave="$ctrl.onMouseLeave(item)"\n            ng-click="$ctrl.onItemClick(item)">\n            <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n            <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n            <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n                <div ng-if="item.icon" ng-bind-html="item.icon" class="item-icon"></div>\n                <div ng-bind-html="item.label" class="item-label"></div>\n            </div>\n        </div>\n    </div>\n    <div ng-if="false && !$ctrl.isLoading && $ctrl.filteredItems.length" class="dropdown-container-inner" ng-repeat="group in $ctrl.groups">\n        <div ng-if="group.name" class="dt-group" ng-class="{\'dt-divider\' : $ctrl.options.showDivider && $index != 0}">{{group.name}}</div>\n        <div ng-repeat="item in group.items" \n            class="item-container dropdown-item"\n            ng-class="{\'active\': item._active}"\n            ng-mouseover="$ctrl.onMouseOver(item)"\n            ng-mouseleave="$ctrl.onMouseLeave(item)"\n            ng-click="$ctrl.onItemClick(item)">\n            <div ng-if="$ctrl.templateType == \'templateUrl\'" class="custom-template" ng-include src="$ctrl.options.itemTemplateUrl"></div>\n            <asui-template ng-if="$ctrl.templateType == \'template\'" class="custom-template" template="$ctrl.options.itemTemplate"></asui-template>\n            <div ng-if="$ctrl.templateType == \'html\'" class="default-template">\n                <div ng-if="item.icon" ng-bind-html="item.icon" class="item-icon"></div>\n                <div ng-bind-html="item.label" class="item-label"></div>\n            </div>\n        </div>\n    </div>\n    <div ng-if="!$ctrl.isLoading && !$ctrl.filteredItems.length && !$ctrl.options.allowCustomValues" class="no-items-cta-container">\n        <div ng-if="$ctrl.options.noItemsCta" class="no-items-cta" ng-bind-html="$ctrl.options.noItemsCta"></div>\n        <div ng-if="!$ctrl.options.noItemsCta" class="no-items-cta"><img src="images/smcta/no-search-results.svg">No match found</div>\n    </div>\n</div>\n    ');
  $templateCache.put('component-duration/duration-input.template', '<div class="duration-input-popup">\n    <div ng-if="!hideDay" class="duration-number-block duration-day" ng-click="onBlockClick(\'d\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upDay()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-day" type="number" ng-value="getValue(\'d\')" ng-keyup="change($event, \'d\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'d\') <=  0}" ng-click="downDay()" ><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideDay && !hideHour">:</span>\n    <div ng-if="!hideHour" class="duration-number-block duration-hour" ng-click="onBlockClick(\'h\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upHour()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-hour" type="number" ng-value="getValue(\'h\')" ng-keyup="change($event, \'h\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'h\') <=  0}" ng-click="downHour()" ><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideHour && !hideMinute">:</span>\n    <div ng-if="!hideMinute" class="duration-number-block duration-min" ng-click="onBlockClick(\'m\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upMin()"><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-minute" type="number" ng-value="getValue(\'m\')" ng-keyup="change($event, \'m\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': getValue(\'h\') == 0 && getValue(\'m\') <=  0}" ng-click="downMin()"><i class="icon icon-caret-down"></i></div>\n    </div>\n    <span ng-if="!hideMinute && !hideSecond">:</span>\n    <div ng-if="!hideSecond" class="duration-number-block duration-second" ng-click="onBlockClick(\'s\')">\n        <div class="duration-number-up" ng-class="{\'disable-arrow\': options.maxDuration && ngModel >=  options.maxDuration}" ng-click="upSec()" ><i class="icon icon-caret-up"></i></div>\n        <div class="duration-input"><input class="duration-number-input input-second" type="number" ng-value="getValue(\'s\')" ng-keyup="change($event, \'s\')" onClick="this.select();"/></div>\n        <div class="duration-number-down" ng-class="{\'disable-arrow\': ngModel <=  0 || ngModel <= options.minDuration}" ng-click="downSec()"><i class="icon icon-caret-down"></i></div>\n    </div>\n</div>');
  $templateCache.put('component-duration/duration.template', '\n<input type="text" class="duration-label" \n        popover-trigger="\'outsideClick\'" popover-placement="{{options && options.placement ? options.placement : \'bottom-left\'}}" \n        uib-popover-template="\'component-duration/duration-input.template\'" popover-is-open="isOpen"\n        ng-value="ngModel ? (ngModel | duration : null : true): \'\'"\n        placeholder="{{options.placeholder?options.placeholder:\'Enter Duration\'}}" readonly />\n<div class="duration-clear" ng-click="clearInput($event)" ng-show="ngModel > 0">\n  <i ng-if="options.showClear" class="icon icon-remove"></i>\n</div>');
  $templateCache.put('component-editable-label/editable-label.template', '<div ng-show="validationState === \'INITIAL\'" \n    class="editable-label" \n    ng-class="{\'placeholder\': showPlaceholder}"\n    ng-click="onClick()"\n    tabindex="0"\n    ng-focus="onLabelFocus()">\n    {{showPlaceholder ? placeholder : text}}\n</div>\n<input type="text" \n    ng-show="validationState !== \'INITIAL\'" \n    ng-model="editedText"\n    class="editable-label-input"\n    ng-show="validationState !== \'INITIAL\'" \n    title="{{placeholder}}" \n    ng-class="{\'error\': validationState === \'ERROR\', \'disabled\': validationState === \'VALIDATING\'}"\n    ng-keyup="onKeyup($event)"\n    ng-blur="onBlur($event)"\n/>\n<asui-spinner ng-show=\'isValidating\' class="spinner-sm"></asui-spinner> \n<div ng-show="validationState === \'EDITING\' || validationState === \'ERROR\'" class=\'editable-label-button-container\'> \n    <button class=\'editable-label-icon iconcheck\' ng-hide=\'isValidating||hideSaveIcon\' ng-mousedown=\'onIgnoreBlur()\' ng-keyedown="onKeydownSave($event)" ng-click=\'onSave()\'><i class=\'icon icon-check\'></i></button>  \n    <button class=\'editable-label-icon iconcross\' ng-hide=\'isValidating||hideCancelIcon\' ng-mousedown=\'onIgnoreBlur()\' ng-click=\'onCancelClick()\'><i class=\'icon icon-cross\'></i></button>  \n</div>');
  $templateCache.put('component-file-dragdrop/file-dragdrop.template', '<div class="asui-fileupload">\n    <div flow-drop flow-init class="drop" ng-hide="fileUploaded">\n        <div class="upload-icon-container" ng-if="showUploadIcon">\n            <div class="icon icon-upload upload-icon"></div>\n        </div>\n        <div ng-class="dropClass">\n            <span ng-show="preBrowseText">{{preBrowseText}}</span> \n            <span class="browse" flow-btn flow-directory>{{browseText}}<input type="file" multiple="multiple" webkitdirectory="webkitdirectory" class="invisible absolute"></span>\n            <span ng-show="postBrowseText">{{postBrowseText}}</span> \n        </div>\n        <div ng-if="error" class="validation-error upload-error">{{error}}</div>\n    </div>\n    <div class="file-list dragdrop-filelist" ng-show="fileUploaded"></div>\n</div>');
  $templateCache.put('component-fileupload/fileupload.template', '<div class="asui-fileupload">\n    <div flow-drop flow-init class="ng-scope drop">\n        <div class="upload-icon-container" ng-if="showUploadIcon">\n            <div class="icon icon-upload upload-icon"></div>\n        </div>\n        <div ng-class="dropClass">\n          {{showDropText()}} \n          <span class="browse" flow-btn flow-directory>{{options.browseText ? options.browseText : \'browse\'}}<input type="file" multiple="multiple" webkitdirectory="webkitdirectory" class="invisible absolute"></span>\n          {{options.extraText}} \n        </div>\n        <div ng-if="error" class="validation-error upload-error">{{error}}</div>\n        <div class="file-list"></div>\n    </div>\n</div>');
  $templateCache.put('component-flip/flip.template', '<div class="flip-container" ng-class="{\'flipped\': shouldFlip, \'postTransition\' : postTransition}"> \n    <ng-transclude></ng-transclude>\n</div>\n');
  $templateCache.put('component-floorplan-editor/floorplan-editor.template', '<asui-floorplan-editor-poi-layer\n    on-api-ready="onPoiLayerApi(api)"\n    options="options.styles"\n    floorplan="{{floorplan}}"\n    on-new-item-cancel="onLayerNewItemCancel()"\n    on-new-item="onLayerNewItem(item)"\n    on-item-click="onLayerItemClick(item, event)"\n    on-stage-click=onLayerStageClick(event)\n    on-floorplan-load="onPoiFloorplanLoad(size)"\n    on-zoom-update="onLayerZoomUpdate(zoom)"\n    items="items">\n</asui-floorplan-editor-poi-layer>');
  $templateCache.put('component-grid/grid.template', '<div class="asui-grid">\n  <div class="grid-container" ng-class="{\'grid-container-horizontal\': options.direction == \'horizontal\'}"> \n    <div ng-if="options.showMask && (options.paging.type != \'virtual\' && options.paging.type != \'ondemand\')" class="loading-mask">\n      <asui-spinner></asui-spinner>\n    </div>\n    <div ng-if="isRetrievingItemsAsyc && totalItems == 0" class="loading-mask">\n      <asui-spinner></asui-spinner>\n    </div>\n\n    <div ng-if="::options.itemTemplateUrl" \n      ng-repeat="item in items | limitTo:ngLimit:ngStartIndex track by ::(item.id ? item.id : itemId(item))"   \n      item="item"\n      on-selection-click="onItemSelectionClick(item, event)"\n      class="grid-item {{::item.customClass}}" \n      ng-include="::item.templateUrl ? item.templateUrl : options.itemTemplateUrl" \n      asui-grid-item-id="{{::(item.id ? item.id : itemId(item))}}" \n      emit-last-repeater-element>\n    </div>\n    \n    <div ng-if="::!options.itemTemplateUrl" \n        ng-repeat="item in items | limitTo:ngLimit:ngStartIndex track by ::(item.id ? item.id : itemId(item))" \n        item="item"\n        on-selection-click="onItemSelectionClick(item, event)"\n        asui-selectable-item ng-transclude="itemDirective" \n        class="grid-item {{::item.customClass}}" \n        asui-grid-item-id="{{::(item.id ? item.id : itemId(item))}}" \n        emit-last-repeater-element>\n    </div>\n\n    <div ng-if="options.paging.currentPage < totalPages && options.paging.type == \'virtual\'" class="grid-virtualscroll-marker"></div>\n  </div>\n\n  <!--Show More-->\n  <div ng-if="!options.showMask && (options.paging.currentPage < totalPages && options.paging.type == \'ondemand\')" class="grid-show-more"><a class="grid-show-more-link" ng-click="showMoreItems()">Show More</a></div>\n  \n  <!--Spinner when set in vertical direction-->\n  <div ng-if="options.direction != \'horizontal\' && (options.paging.type != \'ondemand\' || options.showMask) && options.paging.currentPage < totalPages && (options.paging.type == \'virtual\' || options.paging.type == \'ondemand\')" class="grid-show-more-spinner">\n      <asui-spinner type="fade-line"></asui-spinner>\n  </div>\n  <!--Spinner when set in horizontal mode-->\n  <div ng-if="options.direction == \'horizontal\' && options.showMask" class="grid-show-more-spinner grid-show-more-spinner-horzontal">\n      <asui-spinner type="fade-line"></asui-spinner>\n  </div>\n\n  <div ng-if="(!items || items.length == 0) && !isRetrievingItemsAsyc && hasInit">\n    <div ng-if="!options.noItemsTemplateUrl" ng-transclude="noDataContent"></div>\n    <div ng-if="options.noItemsTemplateUrl" ng-include="options.noItemsTemplateUrl"/>\n  </div>\n  <div class="flex flex-row-reverse">\n    <div ng-if="showPaging()" class="flex flex-align-center noselect margin-t-5 text-secondary">\n      <ul uib-pagination="uib-pagination" total-items="totalItems" items-per-page="options.paging.itemsPerPage" max-size="5" ng-model="options.paging.currentPage" ng-change="pageChanged()" style="margin: 0;" boundary-links="true" previous-text="&lt;" next-text="&gt;" first-text="&lt;&lt;" last-text="&gt;&gt;"></ul>\n    </div>\n  </div>\n</div>');
  $templateCache.put('component-grouper/grouper-tooltip.template', '<div class="grouper-tooltip">\n    <div ng-repeat="item in items"  ng-click="item.onClick(item)" ng-class="{\'grouper-item-click\': item.onClick}"  class="grouper-item">\n        <a ng-if="getRenderType(item) === \'link\'" class="grouper-item-link" ui-sref="{{item.sref}}">{{item[displayProperty]}}</a>\n        <span ng-if="getRenderType(item) === \'text\'" class="grouper-item-text">{{item[displayProperty]}}</span>\n    </div>\n</div>\n');
  $templateCache.put('component-grouper/grouper.template', '<div>\n    <div class="asui-grouper">\n        <div class="flex flex-align-stretch">\n            <div class="grouper-container" ng-class="{\'grouper-ellipsis\': ellipsis}">\n                <div class="grouper-item" ng-class="{\'grouper-item-click\': item.onClick}" ng-click="item.onClick(item)" ng-repeat="item in itemsCopy track by item.$id" emit-repeater-element-render ng-if="$index<maxItems && !item.$hide">\n                    <span ng-if="getRenderType(item) === \'link\' || getRenderType(item) === \'text\'" >{{$index > 0 ? ", ": ""}}</span>\n                    <div ng-if="getRenderType(item) === \'templateUrl\'" class="grouper-item-templateurl" ng-include src="options.itemTemplateUrl"></div>\n                    <asui-template ng-if="getRenderType(item) === \'template\'" class="grouper-item-template" template="options.itemTemplate"></asui-template>\n                    <a ng-if="getRenderType(item) === \'link\'" class="grouper-item-link" ui-sref="{{item.sref}}">{{item[displayProperty]}}</a>\n                    <span ng-if="getRenderType(item) === \'text\'" class="grouper-item-text">{{item[displayProperty]}}</span>\n                </div>\n            </div>\n            <div class="flex flex-align-center">\n                <span class="grouper-remainder cursor-pointer" popover-is-open="isOpen" popover-trigger="\'outsideClick\'" uib-popover-template="options.tooltipTemplate ? options.tooltipTemplate : defaultTooltipTemplate" popover-placement="{{\'auto \' + options.tooltipPlacement}}"></span>\n            </div>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-horizontalnavbar/horizontalnavbar.template', '\n<ul class="nav nav-pills" ng-show="!searchOpen">\n    <li role="presentation" ng-repeat="item in items" ng-hide="item.visible === false" class="hnb-link {{item.class}}" ng-class="{\'active\' : item.value == ngModel.value}">\n        <a ng-if="item.sref.length > 0" ui-sref="{{item.sref}}" target="{{item.target}}" ng-click="onNavItemClick($event, item)" ng-bind-html="item.label"></a>\n        <a ng-if="!item.sref.length && item.href.length > 0" href="{{item.href}}" target="{{item.target}}" ng-click="onNavItemClick($event,item)" ng-bind-html="item.label"></a>\n        <a ng-if="!item.sref.length && !item.href" ng-click="onNavItemClick($event, item)" ng-bind-html="item.label"></a>\n    </li>\n</ul>\n<div ng-show="!searchOpen" class="horznav-bar-commands">\n    <div ng-repeat="command in options.commands">\n        <div class="horznav-bar-command {{command.class}}" ng-bind-html="command.icon" ng-click="onCommandItemClick($event, command)"></div>\n    </div>\n    <div ng-if="options.showSearchIcon" class="horznav-bar-command" ng-click="onSearchClick($event)">\n        <i class=\'icon icon-search\'></i>\n    </div>\n</div>\n<asui-search-autocomplete \n    ng-if="searchOpen"\n    class="horznav-search-autocomplete-container"\n    options="options.searchAutocomplete" \n    model="searchText"\n    on-item-click="onItemClick(item)"\n    on-clear="onCloseSearch()"\n    on-keyword-change="onSearchTextChange({value: value})"\n    on-search="onSearch({value: value})">\n</asui-search-autocomplete>\n');
  $templateCache.put('component-info-label/info-label.template', '<div class="info-label-container"\n    ng-class="{\'multiline\' : options.multiline === true, \'singleline\' : options.multiline !== true}"\n    uib-popover="{{tooltip ? tooltip : labelTooltip}}" \n    popover-is-open="isOpen" \n    uib-popover-template="options.tooltipTemplate"\n    popover-trigger="\'mouseenter\'" \n    popover-placement="auto">\n    <i class="icon icon-info info-label-icon" ng-if="options.showIcon"></i>\n    <div class="info-label" \n        ng-class="{\'label-ellipsis\' : options.multiline != true, \'info-label-left\' : options.iconAlign === \'right\'}" \n        ng-mouseover="onMouseOver()"\n        ng-bind-html="label">\n    </div>\n</div>');
  $templateCache.put('component-info-label/tooltip.template', '<div>\n    <strong>Tooltip Template</strong><br>\n    <div>This is an example of a tooltip template.</div>\n</div>\n');
  $templateCache.put('component-input/input.template', '<div id="{id}" class="asui-input-checkbox" ng-class="{\'asui-input-checkbox-checked\': ngModel === true}" ng-click="toggleCheckbox()" ng-if="type==\'checkbox\'">\n    <i ng-if="ngModel === true" class="icon icon-check"> </i>\n</div>\n<div id="{id}" contenteditable class="asui-input-text" ng-class="{\'asui-input-text-placeholder\':  !ngModel}" ng-if="type==\'text\'">\n    {{ngModel || placeholder}}\n</div>');
  $templateCache.put('component-input-validator/input-validator.template', '');
  $templateCache.put('component-loadingmask/loadingmask.template', '<div class="loading-mask-container" ng-show="show">\n    <div class="outer">\n        <asui-spinner type="{{type}}"></asui-spinner>\n    </div>\n    <div ng-if="message" class="message">{{message}}</div>\n</div>\n\n');
  $templateCache.put('component-modal/modal-confirmation.template', '<div class="asui-modal-confirmation">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">{{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.cancel()">Cancel</button>\n        <button class="asui-btn btn btn-primary" tabindex="-1" type="button" ng-click="$ctrl.ok()">{{$ctrl.confirmLabel}}</button>\n    </div>\n</div>');
  $templateCache.put('component-modal/modal-custom.template', '<div class="asui-modal-custom">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">Sample Custom Modal</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <form id="forms">\n            <div class="preview-box-full" >\n                <label for="name">Name</label>\n                <input id="name" type="text" ng-model="text" placeholder="{{placeholder}}"></input>\n                <label for="desc">Description</label>\n                <textarea id="desc" ng-model="textarea"></textarea>\n            </div>\n        </form>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.cancel()">Cancel</button>\n        <button class="asui-btn btn btn-primary" tabindex="-1" type="button" ng-click="$ctrl.ok()">Save</button>\n    </div>\n</div>');
  $templateCache.put('component-modal/modal-error.template', '<div class="asui-modal-error">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title"> <i class="icon icon-alert padding-r-10"></i> {{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.ok()">OK</button>\n    </div>\n</div>');
  $templateCache.put('component-modal/modal-notification.template', '<div class="asui-modal-notification">\n    <div class="modal-header">\n        <span class="modal-title" id="modal-title">{{$ctrl.title}}</span>\n    </div>\n    <div class="modal-body" id="modal-body">\n        <div ng-if="$ctrl.contentTemplateUrl" ng-include src="$ctrl.contentTemplateUrl"></div>\n        <div ng-if="!$ctrl.contentTemplateUrl && $ctrl.contentTemplate">\n            <asui-template template="$ctrl.contentTemplate"></asui-template>\n        </div>\n        <div ng-if="!$ctrl.contentTemplateUrl && !$ctrl.contentTemplate">\n            {{$ctrl.content}}\n        </div>\n    </div>\n    <div class="modal-footer">\n        <button class="asui-btn btn btn-default" tabindex="-1" type="button" ng-click="$ctrl.ok()">OK</button>\n    </div>\n</div>');
  $templateCache.put('component-multiselect/multiselect.template', '<div class="asui-multiselect">\n    <select class="selectpicker" \n        multiple\n        title="{{placeholder}}" \n        ng-model="ngModel" \n        ng-change="onSelectChange()" \n        ng-disabled="options.disabled"\n        data-selected-text-format="{{options.selectedTextFormat}}"\n        data-max-options="{{options.maxSelection}}">\n    </select>\n    <div ng-show="error" class="validation-error">{{error}}</div>\n</div>');
  $templateCache.put('component-notification/error.template', '<div class="asui-notification asui-notification-error">\n    <i class="fa fa-ban notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n');
  $templateCache.put('component-notification/info.template', '<div class="asui-notification asui-notification-info">\n    <i class="icon icon-info notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n');
  $templateCache.put('component-notification/notification.template', '<growl-notification on-close="notificationOnClose({{notification.$$id}})" ttl="{{notification.timeout > 0 ? notification.timeout * 1000 : 99999999999}}">\n    <div ng-switch="notification.type.toLowerCase()">\n        <div ng-switch-when="success">\n            <div ng-include="\'component-notification/success.template\'"/>\n        </div>\n        <div ng-switch-when="info">\n            <div ng-include="\'component-notification/info.template\'"/>\n        </div>\n        <div ng-switch-when="warning">\n            <div ng-include="\'component-notification/warning.template\'"/>\n        </div>\n        <div ng-switch-when="error">\n            <div ng-include="\'component-notification/error.template\'"/>\n        </div>\n        <div class="asui-notification" ng-switch-default>\n            {{notification.message}}\n        </div>\n    </div>\n</growl-notification>\n');
  $templateCache.put('component-notification/success.template', '<div class="asui-notification asui-notification-success">\n    <i class="icon icon-success notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n');
  $templateCache.put('component-notification/warning.template', '<div class="asui-notification asui-notification-warning">\n    <i class="icon icon-warning notification-icon" aria-hidden="true"></i>\n    <span ng-bind-html="notification.message"></span>\n    <i ng-if="notification.showClose" class="fa fa-times notification-close" aria-hidden="true" ng-click="$growlNotification.remove()"></i>\n</div>\n');
  $templateCache.put('component-phone-number/phone-number.template', '<input type="tel" id="phone" ng-disabled="$ctrl.ngDisabled">');
  $templateCache.put('component-qrcode-scanner/qrcode-scannner.template', '<div class=\'qrcode-scanner-container\'>\n    <asui-loading-mask ng-show="loading"></asui-loading-mask>\n    <canvas ng-show="displayOverlay && !error"></canvas>\n    <video ng-show="!displayOverlay && !error"></video>\n    <div ng-show="error"class="error-container"> \n        <i class="{{errorIcon}}"></i>\n        <span>{{error}}</span>\n    </div>\n</div>');
  $templateCache.put('component-radio/radio.template', '<div class="asui-radio" ng-class="{\'asui-radio-inline\' : options.direction == \'horizontal\'}">\n    <label data-ng-repeat="item in items">\n        <input type="radio" ng-model="ngModel.value" ng-value="item.value" ng-disabled="disabled"\n            name="{{name ? name : id}}" ng-change="onRadioChange(this)" />\n        {{item.label}}\n    </label>\n</div>');
  $templateCache.put('component-range-slider/range-slider.template', '<div class="asui-range-slider">\n    <input type="range" min="minRange" max="maxRange" class="slider" ng-model="ngModel" ng-change="onSliderChange()">\n</div>');
  $templateCache.put('component-richtext/richtext.template', '<div class="asui-richtext" >\n    <div ng-class="{\'sticky-toolbar\': isSticky()}">\n        <div id="{{toolboxId}}" class="style-toolbar" style="display: none;">\n        </div>\n        <textarea class="form-control" ngTrim="false"></textarea>\n        <div ng-if="isDirty && (!requiredValid || !lengthValid)" class="validation-error">\n            <div ng-if="!requiredValid">This field is required.</div>\n            <div ng-if="!lengthValid">Enter between {{validation.minlength}} to {{validation.maxlength}} characters.</div>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-schedule-table/schedule-table.template', '<asui-loading-mask ng-show="$ctrl.isRetrievingItemsAsyc && $ctrl.items.length == 0"></asui-loading-mask>\n<div class="schedule-header-block">\n    <div class="schedule-items-header schedule-header" ng-style="$ctrl.options.theme.itemsHeader" ng-class="{\'invisible\': $ctrl.itemInfoShow}">\n        <div ng-if="!$ctrl.options.readonly" ng-click="$ctrl.filterClick()" class="schedule-filter">{{$ctrl.filterLabel}} <i class="icon icon-caret-down"></i></div>\n        <div ng-if="$ctrl.options.view == \'timeline\' && !$ctrl.mapShow" class="schedule-date-container">\n            <i ng-if="!$ctrl.options.readonly && $ctrl.timelineScrollOffset != 0" ng-click="$ctrl.resetDay()" class="icon icon-recent"></i>\n            <i ng-if="!$ctrl.options.readonly" ng-click="$ctrl.previousDay()" class="icon icon-double-arrow-left"></i>\n            <span class="day-label">{{$ctrl.currentDate}}</span>\n            <i ng-if="!$ctrl.options.readonly" ng-click="$ctrl.nextDay()" class="icon icon-double-arrow-right"></i>\n        </div>\n    </div>\n    <div asui-synchronize-scroll scroll-group="timeline:horizontal" \n        class="schedule-timeline-header schedule-header"\n        ng-style="$ctrl.options.theme.timelineHeader">\n            <asui-schedule-table-timeline-header \n                slot="slot" \n            ng-class="{\'invisible\': $ctrl.options.view != \'timeline\' || $ctrl.itemInfoShow || $ctrl.mapShow}"\n                ng-if="$ctrl.options.view != \'current\'"\n                timeformat="$ctrl.options.timeformat" \n            class="schedule-slot schedule-slot-width asui-schedule-table-timeline-header-edge"\n            ng-repeat="slot in $ctrl.scheduleSlots">\n        </asui-schedule-table-timeline-header>\n    </div>\n</div>\n\n<div class="schedule-item-info-block drop-shadow" ng-class="{\'schedule-item-info-block-show no-background\': $ctrl.itemInfoShow}">\n    <asui-schedule-item-info \n        item="$ctrl.selectedItem" \n        timeformat="$ctrl.options.timeformat" \n        readonly="$ctrl.options.readonly"\n        on-action-click="$ctrl.itemActionClick(action)">\n\n    </asui-schedule-item-info>\n</div>\n\n<div class="schedule-map-block" ng-class="{\'schedule-map-block-full\': $ctrl.filter && !$ctrl.filterCount && !$ctrl.itemInfoShow}">\n    <asui-schedule-map \n        items="$ctrl.items"\n        on-api-ready="$ctrl.onMapApiReady(api)" \n        selected-item="$ctrl.selectedItem" \n        readonly="$ctrl.options.readonly"\n        on-action-click="$ctrl.onMapActionClick(action)"\n        show-map="$ctrl.mapShow"\n        show-map-toggle="$ctrl.options.showMapToggle"\n        is-map-view="$ctrl.options.defaultShowMap"\n        is-current-map-view="$ctrl.options.isCurrentMapView"\n        show-footer="$ctrl.showFooter"\n        filter="$ctrl.filter"\n        reset-filter="$ctrl.resetFilter()"\n        filtered-count="$ctrl.filterCount"\n        total-count="$ctrl.items.length">\n    </asui-schedule-map>\n</div>\n<div ng-if="$ctrl.options.showMapToggle && !$ctrl.itemInfoShow && !$ctrl.options.readonly" ng-style="$ctrl.options.theme.itemsHeader" class="asui-schedule-table-map-toggle" ng-click="$ctrl.onMapToggleClickEvent()" ng-class="$ctrl.options.mapToggleStyle">\n    <i ng-if="!$ctrl.mapShow" class="icon icon-map"></i>\n    <i ng-if="$ctrl.mapShow" class="icon icon-calendar-line"></i>\n</div>\n<div class="schedule-list-block" ng-class="{\'invisible-portrait\': $ctrl.filter && !$ctrl.filterCount && !$ctrl.itemInfoShow && ($ctrl.options.defaultShowMap || $ctrl.options.showMapToggle)}">\n    <div class="schedule-items-block schedule-timeline-container-fixed-height" ng-style="$ctrl.options.theme.items"  ng-class="{\'invisible\': $ctrl.itemInfoShow}">\n        <div ng-show="!$ctrl.filter || $ctrl.filter == item.status" \n            ng-if="!$ctrl.isRetrievingItemsAsyc" \n            asui-schedule-table-item item="item" \n            class="schedule-list-row schedule-row-height" \n            ng-click="$ctrl.onItemSelectClick($event, item)"\n            ng-repeat="item in $ctrl.items track by item.id">\n        </div>\n    </div>\n    <div asui-synchronize-scroll ng-style="$ctrl.options.theme.timeline"  scroll-group="timeline:horizontal" class="schedule-timeline-block schedule-timeline-container-fixed-height" ng-class="{\'invisible\': $ctrl.mapShow}">\n        <div \n            ng-show="!$ctrl.filter || $ctrl.filter == item.status" \n            ng-if="$ctrl.elementSizes.rowHeight > 0 && $ctrl.elementSizes.slotWidth && !$ctrl.isRetrievingItemsAsyc"\n            asui-schedule-table-item-timeline \n            timeline="$ctrl.options.timeline" \n            emit-last-repeater-element \n            item="item" \n            size="$ctrl.elementSizes" \n            timeformat="$ctrl.options.timeformat" \n            readonly="$ctrl.options.readonly" \n            view="$ctrl.options.view"\n            class="schedule-list-row schedule-row-height" \n            ng-repeat="item in $ctrl.items track by item.id">\n        </div>\n    </div>\n    <asui-schedule-table-filter-footer class="asui-schedule-table-filter-footer" ng-if="$ctrl.filter && !$ctrl.mapShow" ng-click="$ctrl.resetFilter()" filter="$ctrl.filter" filter-count="$ctrl.filterCount" total-count="$ctrl.items.length">\n    </asui-schedule-table-filter-footer>\n</div>');
  $templateCache.put('component-search/search.template', '<div class="asui-search">\n    <i class="icon icon-search"></i>\n    <input maxlength="{{maxLength}}"  type="text" placeholder="{{placeholder}}" ng-model="ngModel" ng-change="onChange()" ng-keyup="onKeyUp($event)" ng-focus="onInputFocus($event)">\n    <i class="icon icon-cross" ng-show="ngModel.length > 0 || options.alwaysShowClear" ng-click="onClearClick()"></i>\n</div>\n\n\n');
  $templateCache.put('component-search-autocomplete/custom-template.template', '<div class="flex flex-row flex-align-center" style="background-color: {{item.bgColor}}">\n    <div class="padding-t-10 padding-b-10 padding-l-20">\n        {{item.name}}\n    </div>\n</div>');
  $templateCache.put('component-search-autocomplete/search-autocomplete.template', '<div class="search-autocomplete-container">\n    <!-- Search input  -->\n    <asui-search ng-model="model" options="options" max-length="{{options.maxLength}}"\n        placeholder="{{options.placeholder}}" on-text-change="onTextChange(value)" on-focus="onFocus()"\n        on-search="onSearchEvent(value)" ng-class="{\'search-no-border-radius\': isOpen}" on-clear="onClearEvent()">\n    </asui-search>\n    <!-- Dropdown container for displaying search results -->\n    <div ng-if="isOpen" class="search-autocomplete-dropdown">\n        <asui-loading-mask ng-if="isSearching" show="true" type="spinner"></asui-loading-mask>\n        <div class="search-group-block" ng-repeat="group in searchResults" ng-if="group.items.length > 0">\n            <div class="search-header" ng-if="group.groupName">{{group.groupName}}</div>\n            <div ng-repeat="item in group.items" class="search-item-row" ng-class="{\'active\': item._active}"\n                ng-click="itemClick(item)" ng-mouseover="onMouseOver(item)" ng-mouseleave="onMouseLeave(item)">\n                <!-- Custom template provided -->\n                <div ng-if="item.templateUrl">\n                    <div ng-include="item.templateUrl"></div>\n                </div>\n                <!-- Html provided -->\n                <div ng-if="!item.templateUrl && item.customHtml" class="custom-item" ng-bind-html="item.customHtml">\n                </div>\n                <!-- Use a default template based on resource type -->\n                <div ng-if="!item.templateUrl && !item.customHtml" class="search-item" ng-switch="item._dtoType">\n                    <asui-card-channel ng-switch-when="channelChannel" class="search-item-icon" icon-only=true\n                        icon-size="xs" ng-model="item">\n                    </asui-card-channel>\n                    <asui-card-channel-group ng-switch-when="channelChannelGroup" class="search-item-icon"\n                        icon-only=true icon-size="xs" ng-model="item">\n                    </asui-card-channel-group>\n                    <asui-card-device ng-switch-when="networkDevice" class="search-item-icon" icon-only=true\n                        icon-size="sm" ng-model="item">\n                    </asui-card-device>\n                    <asui-card-user ng-switch-when="userUser" class="search-item-icon" icon-only=true icon-size="xs"\n                        ng-model="item"></asui-card-user>\n                    <asui-card-user-group ng-switch-when="userUserGroup" class="search-item-icon" icon-size="xs">\n                    </asui-card-user-group>\n                    <asui-card-content ng-switch-when="libraryContent" class="search-item-icon" icon-only=true\n                        icon-size="xs" ng-model="item">\n                    </asui-card-content>\n                    <i ng-switch-when="libraryTag|networkTag" ng-switch-when-separator="|"\n                        class="icon icon-tag search-item-icon"></i>\n                    <i ng-switch-when="libraryContentCategory" class="icon icon-circle search-item-icon"\n                        ng-style="{color: \'{{item.color}}\'}"></i>\n                    <img ng-switch-when="libraryCardTemplate" class="search-item-icon card-template-icon"\n                        ng-src="{{item.iconUrl}}">\n                    <div class="search-item-name" ng-if="item.encodedName" ng-bind-html="item.encodedName"></div>\n                    <div class="search-item-name" ng-if="!item.encodedName">{{item.name}}</div>\n                </div>\n\n            </div>\n        </div>\n        <div class="empty-cta-container" ng-if="options.showEmptyPlaceholder">\n            <div class="empty-cta" ng-if="options.emptyPlaceholder" ng-bind-html="options.emptyPlaceholder"></div>\n            <div class="empty-cta" ng-if="!options.emptyPlaceholder"><img src="images/smcta/no-search-results.svg">No\n                match found</div>\n        </div>\n        <div class="search-all-block" ng-if="!options.showEmptyPlaceholder" ng-click="onSearchEvent(model)">\n            <i class="icon icon-search"></i>\n            <span class="search-all-keywords">{{model}}</span>\n            <span class="margin-r-10">-</span>\n            <span>{{options.searchAllLabel}}</span>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-spinner/spinner.template', '<div class="spinner-container" ng-switch="type">\n    <div ng-switch-default  class="spinner-fade-line">\n        <div class="bounce1"></div>\n        <div class="bounce2"></div>\n        <div class="bounce3"></div>\n    </div>\n    <div ng-switch-when="fade-circle" class="sk-fading-circle">\n        <div class="sk-circle1 sk-circle"></div>\n        <div class="sk-circle2 sk-circle"></div>\n        <div class="sk-circle3 sk-circle"></div>\n        <div class="sk-circle4 sk-circle"></div>\n        <div class="sk-circle5 sk-circle"></div>\n        <div class="sk-circle6 sk-circle"></div>\n        <div class="sk-circle7 sk-circle"></div>\n        <div class="sk-circle8 sk-circle"></div>\n        <div class="sk-circle9 sk-circle"></div>\n        <div class="sk-circle10 sk-circle"></div>\n        <div class="sk-circle11 sk-circle"></div>\n        <div class="sk-circle12 sk-circle"></div>\n    </div>\n    <div ng-switch-when="scale-line" class="spinner-rect-wave">\n        <div class="rect1"></div>\n        <div class="rect2"></div>\n        <div class="rect3"></div>\n        <div class="rect4"></div>\n        <div class="rect5"></div>\n    </div>\n</div>\n');
  $templateCache.put('component-split-button/split-button.template', '<div class="btn-group">\n    <button class="btn btn-primary main-btn" ng-bind-html="options.buttonText" ng-click="onMainActionClick()" ng-disabled="ngDisabled"></button>\n    <button class="btn btn-primary dropdown-toggle" data-toggle="dropdown" ng-disabled="ngDisabled"><span class="caret"></span></button>\n    <ul class="dropdown-menu">\n        <li ng-repeat="a in options.actions" ng-class="{\'divider\' : a.value === \'divider\'}">\n            <a ng-if="a.value !== \'divider\'" ng-click="onActionClick({action: a.value})" ng-bind-html="a.label"></a>\n        </li>\n    </ul>\n</div>');
  $templateCache.put('component-styleeditor/styleeditor.template', '<div class="asui-style-editor">\n    <div class="btn-toolbar" role="toolbar">\n        <div class="btn-group" role="group" ng-if="showFontFamily == true">\n            <button type="button" class="btn btn-default dropdown-toggle" title="Font Family" data-toggle="dropdown"><span id="fontFamilyLabel"><span class="glyphicon glyphicon-font"></span></span>&nbsp<span class="caret"></span></button> \n            <ul class="dropdown-menu font-family">\n                <li ng-repeat="font in options.fontFamily">\n                    <a href="javascript:void(0)" data-value="font" ng-click="onFontFamilyChange($event, font)">{{font}}</a>\n                </li>\n            </ul> \n        </div>\n        <div class="btn-group" role="group" ng-if="showSize == true">\n            <button type="button" class="btn btn-default dropdown-toggle" title="Font Size" data-toggle="dropdown"><span id="sizeLabel"><span class="glyphicon glyphicon-text-size"></span></span>&nbsp<span class="caret"></span></button> \n            <ul class="dropdown-menu font-size">\n                <li ng-repeat="size in options.size">\n                    <a href="javascript:void(0)" data-value="size" ng-click="onFontSizeChange($event, size)">{{size}}</a>\n                </li>\n            </ul> \n        </div>\n        <div class="btn-group" role="group" ng-if="showDecorations == true">\n            <button id="ts-bold" type="button" class="btn btn-default" title="Bold" ng-click="onBoldClick()" data-toggle="button" aria-pressed="{{bold}}" autocomplete="off"><span class="glyphicon glyphicon-bold"></span></button>\n            <button id="ts-italic" type="button" class="btn btn-default" title="Italic" ng-click="onItalicClick()" data-toggle="button" aria-pressed="{{italic}}"><span class="glyphicon glyphicon-italic"></span></button>\n            <button id="ts-underline" type="button" class="btn btn-default font16" title="Underline" ng-click="onUnderlineClick()" data-toggle="button" aria-pressed="{{underline}}" autocomplete="off"><span class="icon icon-underline"></span></button>\n        </div>\n        <div class="btn-group" role="group" ng-if="showAlignment == true" id="alignmentGroup"> \n            <button id="ts-alignleft" type="button" class="btn btn-default" title="Left Align" ng-click="onAlignmentClick($event, \'left\')"><span class="glyphicon glyphicon-align-left"></span></button> \n            <button id="ts-aligncenter" type="button" class="btn btn-default" title="Center Align" ng-click="onAlignmentClick($event, \'center\')"><span class="glyphicon glyphicon-align-center"></span></button> \n            <button id="ts-alignright" type="button" class="btn btn-default" title="Right Align" ng-click="onAlignmentClick($event, \'right\')"><span class="glyphicon glyphicon-align-right"></span></button> \n        </div>\n        <div class="btn-group" role="group"> \n            <button id="color" type="button" class="btn btn-default font16" title="Font Color" ng-if="showColor == true"><span class="icon icon-text-color"></span></button> \n            <button id="bgColor" type="button" class="btn btn-default font16" title="Background Color" ng-if="showBgColor == true"><span class="icon icon-background-color"></span></button>\n            <button id="gridColor" type="button" class="btn btn-default" title="Grid Color" ng-if="showGridColor == true"><span class="fa icon-square"></span></button> \n        </div> \n    </div> \n</div>');
  $templateCache.put('component-table/table.template', '<div ng-class="options.customClass" ng-style="{ height: (options.height !== undefined) ? options.height + \'px\': \'auto\' }" class="asui-table-container">\n  <div ng-if="error != null" class="validation-error te-error">{{error}}</div>\n  <div ng-if="options.showMask" class="loading-mask"></div>\n  <div class="table-container">\n    <table class="table asui-table">\n      <thead ng-hide="(!options.showHeader && localItems.length > 0) || (!options.showHeaderWhenNoData && localItems.length == 0)">\n        <tr ng-mouseover="showCheckAll()" ng-mouseleave="hideCheckAll()">\n          <th ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-table-checkbox-header">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(isCheckAllVisible || options.checkBox == \'always\' || checkCount > 0) }" ng-click="toggleCheckAllUpdated($event)" ng-model="checkAll.value" title="Check All"></asui-input>\n          </th>\n          <th ng-if="options.dragSort" class="as-drag-sort-column-header"></th>\n          <th ng-if="options.orderInput" class="as-order-input-column-header"></th>\n          <th ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="(i.sortable !== undefined && !i.sortable) ? [\'cursor-default\',i.class]:[\'cursor-pointer\',i.class] " ng-click="sortByColumn(i)" class="as-column-header"><span ng-bind="i.label"></span><span ng-class="{ \'hidden\': !((i.sortBy !== undefined && options.sortOrder == i.sortBy)  || options.sortOrder == i.name) }"><i ng-class="{ \'fa-caret-down\': options.sortReverse, \'fa-caret-up\': !options.sortReverse }" class="fa inline"></i></span></th>\n          <th ng-if="(options.actionMenus !== undefined && options.actionMenus.length > 0) || (options.groupActionMenus !== undefined && options.groupActionMenus.length > 0)" class="as-action-column-header">\n            <div ng-show="options.groupActionMenus !== undefined && options.groupActionMenus.length > 0 && checkCount > 1">\n              <asui-context-menu id="groupActionMenuId" options="contextMenuOptions" menu-groups="options._FilteredGroupActionMenu" on-item-click="groupActionMenuItemClick(target, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu>\n            </div>\n          </th>\n        </tr>\n      </thead>\n      \n      <!-- Empty table -->\n      <tbody ng-if="localItems.length == 0 && !isRetrievingItemsAsyc">\n        <tr class="as-table-row">\n          <td colspan="100%">\n            <div ng-transclude="noDataContent"></div>\n          </td>\n        </tr>\n      </tbody>\n\n      <!-- DND Dragsort enabled table -->\n      <tbody ng-if="options.dragSort" ng-if="localItems.length > 0" dnd-list="localItems" dnd-inserted="dndInserted(index, external, type)">\n        <!-- Placeholder Row during drag -->\n        <tr class="as-table-row dndPlaceholder">\n          <td colspan="{{colCount}}">\n            <div style="visibility: hidden">Placeholder</div>\n          </td>\n        </tr>\n        <!-- If a custom row template is provided, and no alt row template is provided -->\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row\'" asui-template template="options.rowTemplate" dnd-disable-if="!options.dragSort" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected = item" ng-class="{\'selected\': options.selected === item}" dnd-moved="dndMoved($index, item)" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td dnd-handle="dnd-handle" class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n        </tr>\n        <!-- If a custom row template is provided and an alt row template is provided -->\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row-alt\'" asui-template template="$even ? options.rowTemplate: options.altRowTemplate" dnd-disable-if="!options.dragSort" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected = item" ng-class="{\'selected\': options.selected === item}" dnd-moved="dndMoved($index, item)" ng-class-even="\'as-table-alt-row\'" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td dnd-handle="dnd-handle" class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n        </tr>\n\n        <!-- If no custom row template is provided, render columns as TD by default-->\n        <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex" ng-hide="ngLimit && $index >= ngLimit-1" ng-class="item.rowClass" ng-if="colMode == \'td\'" dnd-draggable="item" dnd-effect-allowed="move" dnd-selected="options.selected == item" ng-class="{\'selected\': options.selected === item}" dnd-disable-if="!options.dragSort" dnd-moved="dndMoved($index, item)" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n          <td dnd-nodrag ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n            <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n          </td>\n          <td class="as-drag-sort-column">\n            <div class="drag-icon"><i class="fa fa-bars"></i></div>\n          </td>\n          <td dnd-nodrag ng-if="options.orderInput" class="as-order-input-column">\n            <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n          </td>\n          <td dnd-nodrag ng-if="options.rowTemplate === undefined" ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="i.cellClass">\n            <!-- This Determines Show Or Hide The Column Data--><span ng-if="options.columns[$index].template === undefined && options.columns[$index].templateUrl === undefined" ng-bind="item[options.columns[$index].name]"></span>\n            <!-- Customizable Column Template-->\n            <div ng-if="options.columns[$index].template !== undefined" asui-template template="options.columns[$index].template"></div>\n          </td>\n          <td ng-if="options.actionMenus.length > 0" class="as-action-column"><span ng-if="item.$tbState._FilteredActionMenu.length > 0" ng-class="{ \'invisible\': checkCount > 1 }">\n              <asui-context-menu options="contextMenuOptions" id="{{item.Id}}" menu-groups="item.$tbState._FilteredActionMenu" on-item-click="actionMenuItemClick(item, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu></span></td>\n        </tr>\n      </tbody>\n\n      <!-- Standard Table -->\n      <tbody ng-if="!options.dragSort" ng-if="localItems.length > 0">\n          <!-- If a custom row template is provided, and no alt row template is provided -->\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row\'" asui-template template="options.rowTemplate" ng-class="{\'selected\': options.selected === item}" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n          </tr>\n          <!-- If a custom row template is provided and an alt row template is provided -->\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-if="colMode == \'tpl-row-alt\'" asui-template template="$even ? options.rowTemplate: options.altRowTemplate" ng-class-even="\'as-table-alt-row\'" ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n          </tr>\n          <!-- If no custom row template is provided, render columns as TD by default-->\n          <tr emit-last-repeater-element ng-repeat="item in localItems | limitTo:ngLimit:ngStartIndex track by item.$tbState.$id" ng-hide="ngLimit && $index >= ngLimit-1" ng-class="item.rowClass" ng-if="colMode == \'td\'"  ng-mouseover="showCheckBox(item.$tbState._Id)" ng-mouseleave="hideCheckBox(item.$tbState._Id)" class="as-table-row">\n            <td ng-if="options.checkBox == \'always\' || options.checkBox == \'onhover\'" class="as-checkbox-column">\n              <asui-input type="checkbox" ng-class="{ \'invisible\' : !(checkCount > 0 || isCheckBoxVisible[item.$tbState._Id] || options.checkBox == \'always\'), \'selected-notselectable\': item._selectable === false}" ng-click="toggleCheck($index, $event)" ng-model="item.$tbState._Checked" class="as-table-checkbox"></asui-input>\n            </td>\n            <td ng-if="options.orderInput" class="as-order-input-column">\n              <input type="text" ng-model="item.$tbState._SortOrder" ng-keypress="onSortOrderPress($event)" ng-paste="onSortOrderPaste($event)" select-on-focus asui-on-enter="updateSortOrder(item,item.$tbState._SortOrder)" ng-blur="refreshSortOrder()" class="as-order-input"/>\n            </td>\n            <td ng-if="options.rowTemplate === undefined" ng-repeat="i in options.columns" ng-show="i.visible === undefined || i.visible" ng-class="i.cellClass">\n              <!-- This Determines Show Or Hide The Column Data--><span ng-if="options.columns[$index].template === undefined && options.columns[$index].templateUrl === undefined" ng-bind="item[options.columns[$index].name]"></span>\n              <!-- Customizable Column Template-->\n              <div ng-if="options.columns[$index].template !== undefined" asui-template template="options.columns[$index].template"></div>\n            </td>\n            <td ng-if="options.actionMenus.length > 0" class="as-action-column"><span ng-if="item.$tbState._FilteredActionMenu.length > 0" ng-class="{ \'invisible\': checkCount > 1 }">\n                <asui-context-menu options="contextMenuOptions" id="{{item.Id}}" menu-groups="item.$tbState._FilteredActionMenu" on-item-click="actionMenuItemClick(item, value)"><i class="fa fa-ellipsis-h"></i></asui-context-menu></span></td>\n          </tr>\n        </tbody>\n    </table>\n\n  </div>\n  <div class="flex flex-align-stretch flex-justify-content">\n    <div></div>\n    <div ng-if="showPaging()" class="flex flex-align-center noselect margin-t-5 text-secondary">\n      <ul uib-pagination total-items="totalItems" items-per-page="options.paging.itemsPerPage" max-size="5" ng-model="options.paging.currentPage" ng-change="pageChanged()" style="margin: 0;" boundary-links="true" previous-text="<" next-text=">" first-text="<<" last-text=">>"></ul>\n    </div>\n  </div>\n</div>');
  $templateCache.put('component-tableeditor/tableeditor.template', '<div class="asui-table-editor">\n    <div class="table-container"></div>\n</div>');
  $templateCache.put('component-tagsinput/default-autocomplete.template', '<div class="autocomplete-template">\n    <div class="autocomplete-header" ng-if="data.header">{{data.header}}</div>\n    <div ng-if= "data.customTemplate" class="autocomplete-item" ng-include src="data.customTemplate"></div>\n    <div ng-if= "!data.customTemplate" class="autocomplete-item">\n        <div class="autocomplete-icon" ng-if="data.tagType">\n            <asui-card-user ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'user\'"></asui-card-user>\n            <div class="user-icon" ng-if="!data.icon && data.tagType === \'user\'"><i class="icon icon-user"></i></div>\n            <div class="user-icon" ng-if="data.tagType === \'user-group\'"><i class="icon icon-users"></i></div>\n            <asui-card-device ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && (data.tagType === \'device\' || data.tagType === \'device-group\')"></asui-card-device>\n            <i class="icon icon-device" ng-if="!data.icon && data.tagType === \'device\'"></i>\n            <i class="icon icon-device-group" ng-if="!data.icon && data.tagType === \'device-group\'"></i>\n            <i class="icon icon-tag" ng-if="data.tagType === \'tag\'"></i>\n            <i class="icon icon-network" ng-if="data.tagType === \'network\'"></i>\n            <asui-card-channel ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'channel\'"></asui-card-channel>\n            <i class="icon icon-channels" ng-if="!data.icon && data.tagType === \'channel\'"></i>\n            <asui-card-channel-group ng-model="data.icon" icon-only=true icon-size="xs" ng-if="data.icon && data.tagType === \'channel-group\'"></asui-card-channel-group>\n            <i class="icon icon-channel-group" ng-if="!data.icon && data.tagType === \'channel-group\'"></i>\n            <i class="icon icon-folder" ng-if="data.tagType === \'folder\'"></i>\n            <i class="icon icon-card" ng-if="data.tagType === \'card\'"></i>\n            <i class="icon icon-card-template" ng-if="data.tagType === \'card-template\'"></i>\n        </div>\n        <div class="autocomplete-text">\n            <span>{{$getDisplayText()}}</span>\n        </div>\n        <div ng-if="data.secondaryText" class="autocomplete-text-secondary">\n            <span>{{data.secondaryText}}</span>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-tagsinput/default-tag.template', '<div ng-class="{\'cursor-pointer\' : data.tooltip}" uib-popover-html="data.tooltip" popover-trigger="\'outsideClick\'"\n    popover-placement="auto" popover-append-to-body="true">\n    <div ng-if="data.customTemplate" class="tag-template" ng-include src="data.customTemplate"></div>\n    <div ng-if="!data.customTemplate" class="tag-template">\n        <div class="tag-icon" ng-if="data.tagType">\n            <asui-card-user ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'user\'"></asui-card-user>\n            <i class="icon icon-user" ng-if="!data.icon && data.tagType === \'user\'"></i>\n            <i class="icon icon-users" ng-if="data.tagType === \'user-group\'"></i>\n            <asui-card-device ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && (data.tagType === \'device\' || data.tagType === \'device-group\')"></asui-card-device>\n            <i class="icon icon-device" ng-if="!data.icon && data.tagType === \'device\'"></i>\n            <i class="icon icon-device-group" ng-if="!data.icon && data.tagType === \'device-group\'"></i>\n            <i class="icon icon-tag" ng-if="data.tagType === \'tag\'"></i>\n            <i class="icon icon-network" ng-if="data.tagType === \'network\'"></i>\n            <asui-card-channel ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'channel\'"></asui-card-channel>\n            <i class="icon icon-channels" ng-if="data.tagType === \'channel\' && !data.icon"></i>\n            <asui-card-channel-group ng-model="data.icon" icon-only=true icon-size="xs"\n                ng-if="data.icon && data.tagType === \'channel-group\'"></asui-card-channel-group>\n            <i class="icon icon-channel-group" ng-if="data.tagType === \'channel-group\' && !data.icon"></i>\n            <i class="icon icon-folder" ng-if="data.tagType === \'folder\'"></i>\n            <i class="icon icon-card" ng-if="data.tagType === \'card\'"></i>\n            <i class="icon icon-card-template" ng-if="data.tagType === \'card-template\'"></i>\n        </div>\n        <div class="tag-text">\n            <span>{{$getDisplayText()}}</span>\n            <asui-spinner class="spinner-sm validation-spinner" ng-show="data.validating"></asui-spinner>\n            <a class="remove-button" ng-hide="data.readOnly === true" ng-click="$removeTag()">\n                <i class="icon icon-cross"></i>\n            </a>\n        </div>\n    </div>\n</div>');
  $templateCache.put('component-tagsinput/tagsinput.template', '<uib-progressbar class="tagsinput-progress" ng-class="{\'invisible\': progressComplete }"\n    ng-if="options.showProgress" \n    animate="false" value="currentProgress">\n</uib-progressbar>\n<div class="asui-tags-input" ng-click="focusOnTagInput()" ng-if="init">\n    <tags-input class="{{options.styleType}}" ng-model="model" \n        tag-class="{\'readonly-tag\': $tag.readOnly === true, \'invalid-tag\': $tag.invalid, \'new-tag\': $tag.newTag, \'custom-tag\': $tag.customTag}" \n        ng-click="focusOnTagInput()" display-property="{{displayProperty}}" key-property="id"\n        template="{{tagTemplate}}" placeholder="{{placeholder}}" \n        replace-spaces-with-dashes="options.replaceSpacesWithDashes" \n        add-from-autocomplete-only="{{addFromAutocompleteOnly}}" min-length="1" \n        paste-split-pattern="{{options.pasteSplitPattern}}" \n        add-on-space="{{options.addOnSpace}}" \n        add-on-paste="{{options.addOnPaste}}" \n        on-tag-adding="tagAdding($tag)" \n        on-tag-added="tagAdded($tag)" \n        on-tag-removing="tagRemoving($tag)"\n        on-tag-removed="tagRemoved($tag)">\n        <auto-complete \n            load-on-focus="{{autocompleteSettings.loadOnFocus}}"\n            load-on-empty="{{autocompleteSettings.loadOnEmpty}}"\n            source="loadAutocompleteList($query)" \n            template="{{autocompleteTemplate}}" \n            select-first-match="false"\n            min-length="{{autocompleteMinLength}}" \n            max-results-to-show="{{autocompleteMaxResultsToShow}}">\n        </auto-complete>\n    </tags-input>\n</div>\n\n');
  $templateCache.put('component-thumbnailupload/thumbnailupload.template', '<div class="asui-thumbnail-upload">\n    <div class="as-thumbnail-container">\n        <div class="as-thumbnail asui-content-tile ct-l-lg" ng-class="getThumbnailClass()" style="background-image: url(\'{{thumbnailUrl}}\')"><div ng-show="showDefaultText" ng-bind-html="options.defaultText"></div></div>\n    </div>\n    <form class="as-thumbnail-form">\n        <asui-file-upload options="uploadOptions" validation="uploadValidation" on-api-ready="onFileUploadApiReady(api)" on-complete="onUploadComplete(file, value)" ng-model="fileList" on-delete="onUploadDelete(file)" on-error="onUploadError(file, message)" target-url="{{targetUrl}}" show-generic-error="false"></asui-file-upload>\n    </form>\n</div>');
  $templateCache.put('component-thumbnailupload/thumbnailuploadchannels.template', '<div class="asui-thumbnail-upload">\n    <div class="as-thumbnail-container">\n        <div class="as-thumbnail asui-content-tile ct-p-lg" ng-class="getThumbnailClass()" style="background-image: url(\'{{thumbnailUrl}}\')"><div ng-show="showDefaultText" ng-bind-html="options.defaultText"></div></div>\n    </div>\n    <form class="as-thumbnail-form">\n        <asui-file-upload options="uploadOptions" validation="uploadValidation" on-api-ready="onFileUploadApiReady(api)" on-complete="onUploadComplete(file, value)" ng-model="fileList" on-delete="onUploadDelete(file)" on-error="onUploadError(file, message)" target-url="{{targetUrl}}" show-generic-error="true"></asui-file-upload>\n    </form>\n</div>');
  $templateCache.put('component-timezone/timezone.template', '<asui-dropdown items="timeZones" ng-model="ngModel" on-change="onTimezoneChange(value, item)"\n    options="dropdownOptions"\n    placeholder="{{options.placeholder}}">\n</asui-dropdown>');
  $templateCache.put('component-verticalnavbar/verticalnavbar.template', '<ul class="vertical-navbar-container">\n    <li ng-repeat="item in items">\n        <div ng-class="{ \'active\': ngModel.value === item.value,  }" ng-if="item.value !== \'separator\'" class="navitem" ui-sref="{{item.sref}}" ng-click="onNavItemClick($event, item)">\n            <div ng-class="item.class">\n                <a href="{{item.href}}" target="{{item.target}}">\n                    <i ng-if="item.icon" class="{{item.icon}} padding-r-20 text-secondary"></i>{{item.label}}\n                </a>\n            </div>\n        </div>\n        <hr ng-if="item.value === \'separator\'">\n    </li>\n</ul>');
  $templateCache.put('component-well/well.template', '<div class="well-container">\n    <div class="well-inner">\n        <ng-transclude> \n        </ng-transclude>\n    </div>\n</div>');
  $templateCache.put('component-workbook/workbook.template', '<div class="asui-workbook">\n    <div class="workbook-sheet-container">\n        <asui-table-editor ng-repeat="sheet in sheets" \n            ng-if="sheet.selected"\n            options="sheet.options" \n            on-api-ready="onSheetReady(sheet, api)"\n            on-validity-check="onSheetUpdated(sheet, valid, changes)">\n        </asui-table-editor>\n    </div>\n    <div class="workbook-bottom-bar">\n        <div class="new-sheet-btn" title="Add sheet" ng-click="newSheetClick()"><i class="btn-icon fa fa-plus"></i></div>\n        <div class="sheet-collection">\n            <div class="sheet-tab" ng-click="sheetClick(sheet)" ng-repeat="sheet in sheets" ng-class="{\'active\' : sheet.selected}">\n                <span id="{{sheet.$$hashKey}}"  ng-keydown="onSheetNameKeydown($event, sheet)" ng-blur="onSheetNameBlur(sheet)">{{sheet.name}}</span>\n                <asui-context-menu menu-groups="sheet.menu" on-item-click="onSheetMenuClick(sheet, value)">\n                    <i class="fa fa-caret-down"></i>\n                </asui-context-menu>\n            </div>\n        </div>\n    </div>\n</div>\n');
  $templateCache.put('component-workflownavbar/workflownavbar.template', '<div class="asui-workflow-navbar">\n    <div class="workflow-title" ng-if="options.title">\n        <span>{{options.title}}</span>\n    </div>\n    <ul class="nav nav-tabs">\n        <li ng-repeat="item in items" role="presentation"  ng-class="getClass($index)">\n            <a>{{item.label}}</a>\n        </li>\n    </ul>\n</div>');
  $templateCache.put('custom-background/background.template', '<div class="asui-background asui-fileupload">\n    <div class="parent">\n        <input ng-hide="options.showColor === false" type="text" class="color form-control" name="{{id}}" ng-model="ngModel.bgColor"/>\n        <asui-file-upload class="file" options="bgOptions" ng-model="bgFiles" validation="bgValidation" target-url="{{targetUrl}}" on-complete="onUploadComplete(file, value)" on-delete="onUploadDelete(file)" resolve-file-path="resolveFilePathUpload(path)"></asui-file-upload>\n    </div>\n</div>');
  $templateCache.put('custom-documentreader/documentreader.template', '<div class="asui-fileupload">\n    <div flow-drop flow-init class="ng-scope drop-target" ng-class="{\'drop\' : !options.noDrop}">\n        <div ng-class="{\'dropClass\' : !options.noDrop}">\n            <span ng-if="!options.noDrop">{{options.dropText ? options.dropText : \'Drop file here or\'}} </span>\n            <span class="browse" flow-btn>\n                {{options.browseText ? options.browseText : \'Browse\'}}\n                <input type="file" ng-show="false">\n            </span>\n        </div>\n        <div ng-if="options.showErrorMessage && error" class="validation-error upload-error">{{error}}</div>\n    </div>\n</div>');
  $templateCache.put('custom-textbox/textbox.template', '<div class="asui-textbox" ng-class="{\'sticky-header\': options.toolbar == \'sticky\', \'hover-header\': options.toolbar == \'hover\'}">\n    <div ng-if="toolbarEnabled; "class="style-toolbar">\n        <asui-style-editor options="options.style" ng-model="textStyle" on-style-change="styleChange(style)"></asui-style-editor>\n    </div>\n    <input class="input-field" ng-if="options.type != \'textarea\'" type="{{options.type ? options.type : \'text\'}}" placeholder="{{placeholder}}" ng-model="ngModel" ng-keyup="onKeyUp($event)" ng-change="onTextChange()" ng-click="onTextboxClick()" ng-trim="{{options.trim ? \'true\' : \'false\'}}" autocomplete="off" />\n    <textarea class="input-field" ng-if="options.type == \'textarea\'" rows="{{rows}}" placeholder="{{placeholder}}" ng-model="ngModel" ng-keyup="onKeyUp($event)" ng-change="onTextChange()"  ng-click="onTextboxClick()" ng-trim="{{options.trim ? \'true\' : \'false\'}}"/>\n    <div ng-if="error && isDirty" class="validation-error">{{error}}</div>\n</div>');
  $templateCache.put('component-accordion/accordion-header/accordion-header.template', '<uib-accordion-heading>\n    <div class="header-container">\n        <div ng-if="!$ctrl.options.html" class="header-title">\n            <i ng-if="$ctrl.options.icon" class="header-icon icon {{$ctrl.options.icon}}"></i>\n            <img ng-if="$ctrl.options.imageIcon" class="header-icon header-img" ng-src="{{$ctrl.options.imageIcon}}">\n            <div ng-if="$ctrl.options.title" class="header-text" ng-bind-html="$ctrl.options.title"></div>\n        </div>\n        <div ng-if="$ctrl.options.html" class="header-title" ng-bind-html="$ctrl.options.html"></div>\n        <i class="icon pull-right" ng-class="{\'icon-chevron-down\': $ctrl.isOpen, \'icon-chevron-right\': !$ctrl.isOpen}"></i>\n    </div>\n    <ng-transclude class="header-desc" ng-hide="$ctrl.isOpen"></ng-transclude>\n</uib-accordion-heading>');
  $templateCache.put('component-floorplan-editor/poi-layer/poi-layer.template', '<div class="fpe-poi-layer-stage"/>\n<div ng-if="newItem.type" class="fpe-poi-layer-help">\n        <div ng-if="newItem.type.toLowerCase() ==\'trace\' && (newItem.coords.length == 0)" >\n                Click a room on the map to auto detect boundaries. Press Enter or Escape to cancel.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'trace\' && (newItem.coords.length != 0)" >\n                Press Enter to accept or Delete to remove.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'point\' && (newItem.coords.length == 0)" >\n                Click anywhere on the map to add a marker.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'polygon\' && (newItem.coords.length <= 4)" >\n                Click on the map to create a room outline. Press Enter or Escape to cancel.\n        </div>\n        <div ng-if="newItem.type.toLowerCase() ==\'polygon\' && (newItem.coords.length >= 6)" >\n                Press Enter to accept or Delete to remove last coordinate.\n        </div>\n</div>');
  $templateCache.put('component-schedule-table/item/item.template', '<div class="schedule-item-container">\n    <div class="schedule-item-name">\n        <div class="schedule-item-name-label">\n            {{item.name}}\n        </div>\n        <div class="schedule-item-location">\n            <div class="schedule-item-floor-name" ng-if="item.floorName">\n                {{item.floorName + (item.floorName && item.buildingName ? \', \' : \'\')}}\n            </div>\n            <div class="schedule-item-building-name" ng-if="item.buildingName">\n                {{item.buildingName}}\n            </div>\n        </div>\n    </div>\n    <div class="schedule-item-container-details">\n        <div class="schedule-item-number">{{item.number}}</div>\n        <div class="schedule-item-direction">\n            <i ng-class="directionIcon"></i>\n        </div>\n    </div>\n</div>\n<div class="schedule-item-status schedule-row-height"\n    ng-class="{\'schedule-item-status-available\': !item.status || item.status == \'available\', \'schedule-item-status-occupied\': item.status == \'occupied\', \'schedule-item-status-checkin\': item.status == \'checkin\'}">\n</div>');
  $templateCache.put('component-schedule-table/item-info/item-info.template', '<div class="item-info-header">\n    <div class="item-info-name">{{$ctrl.item.name}} <span>{{$ctrl.item.number}}</span></div>\n    <div class="item-info-close" ng-click="$ctrl.onCloseClick()"><i class="icon icon-cross"></i></div>\n</div>\n<div class="item-info-details">\n    <div ng-if="$ctrl.item.floorName" class="item-info-floor-name">\n        {{$ctrl.item.floorName + ($ctrl.item.floorName && $ctrl.item.buildingName ? \', \' : \'\')}}\n    </div>\n    <div ng-if="$ctrl.item.buildingName" class="item-info-building-name">\n        {{$ctrl.item.buildingName}}\n    </div>\n    <div ng-if="$ctrl.facilities" class="item-info-facilities">\n        <div class="facility" ng-repeat="facility in $ctrl.facilities" ng-style="facility.styling">\n            <span ng-if="facility.logo" class="facility-logo" ng-bind-html="facility.logo"></span>\n            <span ng-if="facility.text" class="facility-text">{{facility.text}}</span>\n        </div>\n    </div>\n    <div ng-if="$ctrl.itemScheduleInfo.activeSchedule" class="item-info-current-meeting">\n        <span class="item-info-meetings-schedule-name">{{$ctrl.itemScheduleInfo.activeSchedule.name}}</span>\n        <span class="item-info-meetings-schedule-time">\n            &nbsp;{{$ctrl.itemScheduleInfo.activeSchedule.timeString}}</span>\n    </div>\n    <div ng-if="!$ctrl.itemScheduleInfo.activeSchedule && $ctrl.itemScheduleInfo.status == \'checkin\'"\n        class="item-info-current-meeting">\n        <span class="item-info-meetings-schedule-name">{{$ctrl.itemScheduleInfo.upcomingMeetings[0].name}}</span>\n        <span class="item-info-meetings-schedule-time">\n            &nbsp;{{$ctrl.itemScheduleInfo.upcomingMeetings[0].timeString}}</span>\n    </div>\n    <div ng-if="!$ctrl.itemScheduleInfo.activeSchedule" class="item-info-next-meeting">{{$ctrl.nextMeetingText}}</div>\n    <div class="item-info-buttons" ng-if="!$ctrl.readonly && !$ctrl.item.readOnly">\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'available\'" class="item-info-button"\n            ng-click="$ctrl.onBookClick()">Book</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'occupied\' && $ctrl.isMeetingExtendable"\n            class="item-info-button item-info-button-extend" ng-click="$ctrl.onExtendClick()">Extend</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'occupied\'" class="item-info-button" ng-click="$ctrl.onEndClick()">\n            End</div>\n        <div ng-if="$ctrl.itemScheduleInfo.status == \'checkin\'" class="item-info-button"\n            ng-click="$ctrl.onCheckinClick()">Check-in</div>\n    </div>\n</div>\n<div class="item-info-meetings">\n    <div ng-if="$ctrl.itemScheduleInfo.upcomingMeetings.length > 0" class="item-info-meetings-header">UPCOMING MEETINGS\n    </div>\n    <div class="item-info-meetings-schedule-list">\n        <div class="item-info-meetings-schedule" ng-repeat="schedule in $ctrl.itemScheduleInfo.upcomingMeetings">\n            <span class="item-info-meetings-schedule-name">{{schedule.name}}</span>\n            <span class="item-info-meetings-schedule-time">{{schedule.dateTimeString}}</span>\n        </div>\n    </div>\n</div>\n<div class="item-info-status-bar"\n    ng-class="{\'schedule-item-status-available\': $ctrl.itemScheduleInfo.status == \'available\', \'schedule-item-status-occupied\': $ctrl.itemScheduleInfo.status == \'occupied\', \'schedule-item-status-checkin\': $ctrl.itemScheduleInfo.status == \'checkin\'}">\n</div>');
  $templateCache.put('component-schedule-table/filter-footer/filter-footer.template', '<div ng-if="filterCount > 0" class="filter-partial-container">\n    <span>Viewing {{filterCount}} out of {{totalCount}} rooms</span>\n</div>\n<div ng-if="filterCount == 0" class="filter-noresults-container">\n    <span>There are no {{filter}} rooms</span>\n</div>\n<div class="filter-view-all" ng-class="{ \'filter-empty-view-all\' : !filterCount }">View All Rooms</div>\n    ');
  $templateCache.put('component-schedule-table/slot/slot.template', 'X');
  $templateCache.put('component-schedule-table/timeline-header/header.template', '<span>{{label}}</span>');
}]);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).Konva = e();
}(void 0, function () {
  "use strict";
  /*
     * Konva JavaScript Framework v7.2.2
     * http://konvajs.org/
     * Licensed under the MIT
     * Date: Fri Dec 18 2020
     *
     * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
     * Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva)
     *
     * @license
     */

  var t = Math.PI / 180;

  var e = function e(t) {
    var e = t.indexOf("msie ");
    if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);

    if (t.indexOf("trident/") > 0) {
      var i = t.indexOf("rv:");
      return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10);
    }

    var n = t.indexOf("edge/");
    return n > 0 && parseInt(t.substring(n + 5, t.indexOf(".", n)), 10);
  },
      i = function i(t) {
    var i = t.toLowerCase(),
        n = /(chrome)[ /]([\w.]+)/.exec(i) || /(webkit)[ /]([\w.]+)/.exec(i) || /(opera)(?:.*version|)[ /]([\w.]+)/.exec(i) || /(msie) ([\w.]+)/.exec(i) || i.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(i) || [],
        r = !!t.match(/Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i),
        o = !!t.match(/IEMobile/i);
    return {
      browser: n[1] || "",
      version: n[2] || "0",
      isIE: e(i),
      mobile: r,
      ieMobile: o
    };
  },
      n = "undefined" != typeof global ? global : "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope ? self : {},
      r = {
    _global: n,
    version: "7.2.2",
    isBrowser: "undefined" != typeof window && ("[object Window]" === {}.toString.call(window) || "[object global]" === {}.toString.call(window)),
    isUnminified: /param/.test(function (t) {}.toString()),
    dblClickWindow: 400,
    getAngle: function getAngle(e) {
      return r.angleDeg ? e * t : e;
    },
    enableTrace: !1,
    _pointerEventsEnabled: !1,
    hitOnDragEnabled: !1,
    captureTouchEventsEnabled: !1,
    listenClickTap: !1,
    inDblClickWindow: !1,
    pixelRatio: void 0,
    dragDistance: 3,
    angleDeg: !0,
    showWarnings: !0,
    dragButtons: [0, 1],
    isDragging: function isDragging() {
      return r.DD.isDragging;
    },
    isDragReady: function isDragReady() {
      return !!r.DD.node;
    },
    UA: i(n.navigator && n.navigator.userAgent || ""),
    document: n.document,
    _injectGlobal: function _injectGlobal(t) {
      n.Konva = t;
    },
    _parseUA: i
  },
      o = {},
      a = function a(t) {
    o[t.prototype.getClassName()] = t, r[t.prototype.getClassName()] = t;
  },
      s = function () {
    function t() {}

    return t.toCollection = function (e) {
      var i,
          n = new t(),
          r = e.length;

      for (i = 0; i < r; i++) {
        n.push(e[i]);
      }

      return n;
    }, t._mapMethod = function (e) {
      t.prototype[e] = function () {
        var t,
            i = this.length,
            n = [].slice.call(arguments);

        for (t = 0; t < i; t++) {
          this[t][e].apply(this[t], n);
        }

        return this;
      };
    }, t.mapMethods = function (e) {
      var i = e.prototype;

      for (var n in i) {
        t._mapMethod(n);
      }
    }, t;
  }();

  s.prototype = [], s.prototype.each = function (t) {
    for (var e = 0; e < this.length; e++) {
      t(this[e], e);
    }
  }, s.prototype.toArray = function () {
    var t,
        e = [],
        i = this.length;

    for (t = 0; t < i; t++) {
      e.push(this[t]);
    }

    return e;
  };

  var h = function () {
    function t(t) {
      void 0 === t && (t = [1, 0, 0, 1, 0, 0]), this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0];
    }

    return t.prototype.reset = function () {
      this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0;
    }, t.prototype.copy = function () {
      return new t(this.m);
    }, t.prototype.copyInto = function (t) {
      t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5];
    }, t.prototype.point = function (t) {
      var e = this.m;
      return {
        x: e[0] * t.x + e[2] * t.y + e[4],
        y: e[1] * t.x + e[3] * t.y + e[5]
      };
    }, t.prototype.translate = function (t, e) {
      return this.m[4] += this.m[0] * t + this.m[2] * e, this.m[5] += this.m[1] * t + this.m[3] * e, this;
    }, t.prototype.scale = function (t, e) {
      return this.m[0] *= t, this.m[1] *= t, this.m[2] *= e, this.m[3] *= e, this;
    }, t.prototype.rotate = function (t) {
      var e = Math.cos(t),
          i = Math.sin(t),
          n = this.m[0] * e + this.m[2] * i,
          r = this.m[1] * e + this.m[3] * i,
          o = this.m[0] * -i + this.m[2] * e,
          a = this.m[1] * -i + this.m[3] * e;
      return this.m[0] = n, this.m[1] = r, this.m[2] = o, this.m[3] = a, this;
    }, t.prototype.getTranslation = function () {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    }, t.prototype.skew = function (t, e) {
      var i = this.m[0] + this.m[2] * e,
          n = this.m[1] + this.m[3] * e,
          r = this.m[2] + this.m[0] * t,
          o = this.m[3] + this.m[1] * t;
      return this.m[0] = i, this.m[1] = n, this.m[2] = r, this.m[3] = o, this;
    }, t.prototype.multiply = function (t) {
      var e = this.m[0] * t.m[0] + this.m[2] * t.m[1],
          i = this.m[1] * t.m[0] + this.m[3] * t.m[1],
          n = this.m[0] * t.m[2] + this.m[2] * t.m[3],
          r = this.m[1] * t.m[2] + this.m[3] * t.m[3],
          o = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4],
          a = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5];
      return this.m[0] = e, this.m[1] = i, this.m[2] = n, this.m[3] = r, this.m[4] = o, this.m[5] = a, this;
    }, t.prototype.invert = function () {
      var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),
          e = this.m[3] * t,
          i = -this.m[1] * t,
          n = -this.m[2] * t,
          r = this.m[0] * t,
          o = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
          a = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      return this.m[0] = e, this.m[1] = i, this.m[2] = n, this.m[3] = r, this.m[4] = o, this.m[5] = a, this;
    }, t.prototype.getMatrix = function () {
      return this.m;
    }, t.prototype.setAbsolutePosition = function (t, e) {
      var i = this.m[0],
          n = this.m[1],
          r = this.m[2],
          o = this.m[3],
          a = this.m[4],
          s = (i * (e - this.m[5]) - n * (t - a)) / (i * o - n * r),
          h = (t - a - r * s) / i;
      return this.translate(h, s);
    }, t.prototype.decompose = function () {
      var t = this.m[0],
          e = this.m[1],
          i = this.m[2],
          n = this.m[3],
          r = t * n - e * i,
          o = {
        x: this.m[4],
        y: this.m[5],
        rotation: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };

      if (0 != t || 0 != e) {
        var a = Math.sqrt(t * t + e * e);
        o.rotation = e > 0 ? Math.acos(t / a) : -Math.acos(t / a), o.scaleX = a, o.scaleY = r / a, o.skewX = (t * i + e * n) / r, o.skewY = 0;
      } else if (0 != i || 0 != n) {
        var s = Math.sqrt(i * i + n * n);
        o.rotation = Math.PI / 2 - (n > 0 ? Math.acos(-i / s) : -Math.acos(i / s)), o.scaleX = r / s, o.scaleY = s, o.skewX = 0, o.skewY = (t * i + e * n) / r;
      }

      return o.rotation = f._getRotation(o.rotation), o;
    }, t;
  }(),
      l = Math.PI / 180,
      c = 180 / Math.PI,
      d = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 132, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 255, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [119, 128, 144],
    slategrey: [119, 128, 144],
    snow: [255, 255, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 5]
  },
      u = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/,
      p = [],
      f = {
    _isElement: function _isElement(t) {
      return !(!t || 1 != t.nodeType);
    },
    _isFunction: function _isFunction(t) {
      return !!(t && t.constructor && t.call && t.apply);
    },
    _isPlainObject: function _isPlainObject(t) {
      return !!t && t.constructor === Object;
    },
    _isArray: function _isArray(t) {
      return "[object Array]" === Object.prototype.toString.call(t);
    },
    _isNumber: function _isNumber(t) {
      return "[object Number]" === Object.prototype.toString.call(t) && !isNaN(t) && isFinite(t);
    },
    _isString: function _isString(t) {
      return "[object String]" === Object.prototype.toString.call(t);
    },
    _isBoolean: function _isBoolean(t) {
      return "[object Boolean]" === Object.prototype.toString.call(t);
    },
    isObject: function isObject(t) {
      return t instanceof Object;
    },
    isValidSelector: function isValidSelector(t) {
      if ("string" != typeof t) return !1;
      var e = t[0];
      return "#" === e || "." === e || e === e.toUpperCase();
    },
    _sign: function _sign(t) {
      return 0 === t ? 0 : t > 0 ? 1 : -1;
    },
    requestAnimFrame: function requestAnimFrame(t) {
      p.push(t), 1 === p.length && requestAnimationFrame(function () {
        var t = p;
        p = [], t.forEach(function (t) {
          t();
        });
      });
    },
    createCanvasElement: function createCanvasElement() {
      var t = document.createElement("canvas");

      try {
        t.style = t.style || {};
      } catch (t) {}

      return t;
    },
    createImageElement: function createImageElement() {
      return document.createElement("img");
    },
    _isInDocument: function _isInDocument(t) {
      for (; t = t.parentNode;) {
        if (t == document) return !0;
      }

      return !1;
    },
    _simplifyArray: function _simplifyArray(t) {
      var e,
          i,
          n = [],
          r = t.length,
          o = f;

      for (e = 0; e < r; e++) {
        i = t[e], o._isNumber(i) ? i = Math.round(1e3 * i) / 1e3 : o._isString(i) || (i = i.toString()), n.push(i);
      }

      return n;
    },
    _urlToImage: function _urlToImage(t, e) {
      var i = new n.Image();
      i.onload = function () {
        e(i);
      }, i.src = t;
    },
    _rgbToHex: function _rgbToHex(t, e, i) {
      return ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1);
    },
    _hexToRgb: function _hexToRgb(t) {
      t = t.replace("#", "");
      var e = parseInt(t, 16);
      return {
        r: e >> 16 & 255,
        g: e >> 8 & 255,
        b: 255 & e
      };
    },
    getRandomColor: function getRandomColor() {
      for (var t = (16777215 * Math.random() << 0).toString(16); t.length < 6;) {
        t = "0" + t;
      }

      return "#" + t;
    },
    get: function get(t, e) {
      return void 0 === t ? e : t;
    },
    getRGB: function getRGB(t) {
      var e;
      return t in d ? {
        r: (e = d[t])[0],
        g: e[1],
        b: e[2]
      } : "#" === t[0] ? this._hexToRgb(t.substring(1)) : "rgb(" === t.substr(0, 4) ? (e = u.exec(t.replace(/ /g, "")), {
        r: parseInt(e[1], 10),
        g: parseInt(e[2], 10),
        b: parseInt(e[3], 10)
      }) : {
        r: 0,
        g: 0,
        b: 0
      };
    },
    colorToRGBA: function colorToRGBA(t) {
      return t = t || "black", f._namedColorToRBA(t) || f._hex3ColorToRGBA(t) || f._hex6ColorToRGBA(t) || f._rgbColorToRGBA(t) || f._rgbaColorToRGBA(t) || f._hslColorToRGBA(t);
    },
    _namedColorToRBA: function _namedColorToRBA(t) {
      var e = d[t.toLowerCase()];
      return e ? {
        r: e[0],
        g: e[1],
        b: e[2],
        a: 1
      } : null;
    },
    _rgbColorToRGBA: function _rgbColorToRGBA(t) {
      if (0 === t.indexOf("rgb(")) {
        var e = (t = t.match(/rgb\(([^)]+)\)/)[1]).split(/ *, */).map(Number);
        return {
          r: e[0],
          g: e[1],
          b: e[2],
          a: 1
        };
      }
    },
    _rgbaColorToRGBA: function _rgbaColorToRGBA(t) {
      if (0 === t.indexOf("rgba(")) {
        var e = (t = t.match(/rgba\(([^)]+)\)/)[1]).split(/ *, */).map(Number);
        return {
          r: e[0],
          g: e[1],
          b: e[2],
          a: e[3]
        };
      }
    },
    _hex6ColorToRGBA: function _hex6ColorToRGBA(t) {
      if ("#" === t[0] && 7 === t.length) return {
        r: parseInt(t.slice(1, 3), 16),
        g: parseInt(t.slice(3, 5), 16),
        b: parseInt(t.slice(5, 7), 16),
        a: 1
      };
    },
    _hex3ColorToRGBA: function _hex3ColorToRGBA(t) {
      if ("#" === t[0] && 4 === t.length) return {
        r: parseInt(t[1] + t[1], 16),
        g: parseInt(t[2] + t[2], 16),
        b: parseInt(t[3] + t[3], 16),
        a: 1
      };
    },
    _hslColorToRGBA: function _hslColorToRGBA(t) {
      if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(t)) {
        var e = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t),
            i = (e[0], e.slice(1)),
            n = Number(i[0]) / 360,
            r = Number(i[1]) / 100,
            o = Number(i[2]) / 100,
            a = void 0,
            s = void 0,
            h = void 0;
        if (0 === r) return h = 255 * o, {
          r: Math.round(h),
          g: Math.round(h),
          b: Math.round(h),
          a: 1
        };

        for (var l = 2 * o - (a = o < .5 ? o * (1 + r) : o + r - o * r), c = [0, 0, 0], d = 0; d < 3; d++) {
          (s = n + 1 / 3 * -(d - 1)) < 0 && s++, s > 1 && s--, h = 6 * s < 1 ? l + 6 * (a - l) * s : 2 * s < 1 ? a : 3 * s < 2 ? l + (a - l) * (2 / 3 - s) * 6 : l, c[d] = 255 * h;
        }

        return {
          r: Math.round(c[0]),
          g: Math.round(c[1]),
          b: Math.round(c[2]),
          a: 1
        };
      }
    },
    haveIntersection: function haveIntersection(t, e) {
      return !(e.x > t.x + t.width || e.x + e.width < t.x || e.y > t.y + t.height || e.y + e.height < t.y);
    },
    cloneObject: function cloneObject(t) {
      var e = {};

      for (var i in t) {
        this._isPlainObject(t[i]) ? e[i] = this.cloneObject(t[i]) : this._isArray(t[i]) ? e[i] = this.cloneArray(t[i]) : e[i] = t[i];
      }

      return e;
    },
    cloneArray: function cloneArray(t) {
      return t.slice(0);
    },
    _degToRad: function _degToRad(t) {
      return t * l;
    },
    _radToDeg: function _radToDeg(t) {
      return t * c;
    },
    _getRotation: function _getRotation(t) {
      return r.angleDeg ? f._radToDeg(t) : t;
    },
    _capitalize: function _capitalize(t) {
      return t.charAt(0).toUpperCase() + t.slice(1);
    },
    "throw": function _throw(t) {
      throw new Error("Konva error: " + t);
    },
    error: function error(t) {
      console.error("Konva error: " + t);
    },
    warn: function warn(t) {
      r.showWarnings && console.warn("Konva warning: " + t);
    },
    extend: function extend(t, e) {
      function i() {
        this.constructor = t;
      }

      i.prototype = e.prototype;
      var n = t.prototype;

      for (var r in t.prototype = new i(), n) {
        n.hasOwnProperty(r) && (t.prototype[r] = n[r]);
      }

      t.__super__ = e.prototype, t["super"] = e;
    },
    _getControlPoints: function _getControlPoints(t, e, i, n, r, o, a) {
      var s = Math.sqrt(Math.pow(i - t, 2) + Math.pow(n - e, 2)),
          h = Math.sqrt(Math.pow(r - i, 2) + Math.pow(o - n, 2)),
          l = a * s / (s + h),
          c = a * h / (s + h);
      return [i - l * (r - t), n - l * (o - e), i + c * (r - t), n + c * (o - e)];
    },
    _expandPoints: function _expandPoints(t, e) {
      var i,
          n,
          r = t.length,
          o = [];

      for (i = 2; i < r - 2; i += 2) {
        n = f._getControlPoints(t[i - 2], t[i - 1], t[i], t[i + 1], t[i + 2], t[i + 3], e), isNaN(n[0]) || (o.push(n[0]), o.push(n[1]), o.push(t[i]), o.push(t[i + 1]), o.push(n[2]), o.push(n[3]));
      }

      return o;
    },
    each: function each(t, e) {
      for (var i in t) {
        e(i, t[i]);
      }
    },
    _inRange: function _inRange(t, e, i) {
      return e <= t && t < i;
    },
    _getProjectionToSegment: function _getProjectionToSegment(t, e, i, n, r, o) {
      var a,
          s,
          h,
          l = (t - i) * (t - i) + (e - n) * (e - n);
      if (0 == l) a = t, s = e, h = (r - i) * (r - i) + (o - n) * (o - n);else {
        var c = ((r - t) * (i - t) + (o - e) * (n - e)) / l;
        c < 0 ? (a = t, s = e, h = (t - r) * (t - r) + (e - o) * (e - o)) : c > 1 ? (a = i, s = n, h = (i - r) * (i - r) + (n - o) * (n - o)) : h = ((a = t + c * (i - t)) - r) * (a - r) + ((s = e + c * (n - e)) - o) * (s - o);
      }
      return [a, s, h];
    },
    _getProjectionToLine: function _getProjectionToLine(t, e, i) {
      var n = f.cloneObject(t),
          r = Number.MAX_VALUE;
      return e.forEach(function (o, a) {
        if (i || a !== e.length - 1) {
          var s = e[(a + 1) % e.length],
              h = f._getProjectionToSegment(o.x, o.y, s.x, s.y, t.x, t.y),
              l = h[0],
              c = h[1],
              d = h[2];

          d < r && (n.x = l, n.y = c, r = d);
        }
      }), n;
    },
    _prepareArrayForTween: function _prepareArrayForTween(t, e, i) {
      var n,
          r = [],
          o = [];

      if (t.length > e.length) {
        var a = e;
        e = t, t = a;
      }

      for (n = 0; n < t.length; n += 2) {
        r.push({
          x: t[n],
          y: t[n + 1]
        });
      }

      for (n = 0; n < e.length; n += 2) {
        o.push({
          x: e[n],
          y: e[n + 1]
        });
      }

      var s = [];
      return o.forEach(function (t) {
        var e = f._getProjectionToLine(t, r, i);

        s.push(e.x), s.push(e.y);
      }), s;
    },
    _prepareToStringify: function _prepareToStringify(t) {
      var e;

      for (var i in t.visitedByCircularReferenceRemoval = !0, t) {
        if (t.hasOwnProperty(i) && t[i] && "object" == _typeof(t[i])) if (e = Object.getOwnPropertyDescriptor(t, i), t[i].visitedByCircularReferenceRemoval || f._isElement(t[i])) {
          if (!e.configurable) return null;
          delete t[i];
        } else if (null === f._prepareToStringify(t[i])) {
          if (!e.configurable) return null;
          delete t[i];
        }
      }

      return delete t.visitedByCircularReferenceRemoval, t;
    },
    _assign: function _assign(t, e) {
      for (var i in e) {
        t[i] = e[i];
      }

      return t;
    },
    _getFirstPointerId: function _getFirstPointerId(t) {
      return t.touches ? t.changedTouches[0].identifier : 999;
    }
  };

  function g(t) {
    return f._isString(t) ? '"' + t + '"' : "[object Number]" === Object.prototype.toString.call(t) || f._isBoolean(t) ? t : Object.prototype.toString.call(t);
  }

  function v(t) {
    return t > 255 ? 255 : t < 0 ? 0 : Math.round(t);
  }

  function y() {
    if (r.isUnminified) return function (t, e) {
      return f._isNumber(t) || f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a number.'), t;
    };
  }

  function m(t) {
    if (r.isUnminified) return function (e, i) {
      var n = f._isNumber(e),
          r = f._isArray(e) && e.length == t;

      return n || r || f.warn(g(e) + ' is a not valid value for "' + i + '" attribute. The value should be a number or Array<number>(' + t + ")"), e;
    };
  }

  function _() {
    if (r.isUnminified) return function (t, e) {
      return f._isNumber(t) || "auto" === t || f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a number or "auto".'), t;
    };
  }

  function b() {
    if (r.isUnminified) return function (t, e) {
      return f._isString(t) || f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a string.'), t;
    };
  }

  function x() {
    if (r.isUnminified) return function (t, e) {
      var i = f._isString(t),
          n = "[object CanvasGradient]" === Object.prototype.toString.call(t);

      return i || n || f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a string or a native gradient.'), t;
    };
  }

  function S() {
    if (r.isUnminified) return function (t, e) {
      return !0 === t || !1 === t || f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a boolean.'), t;
    };
  }

  var w = {
    addGetterSetter: function addGetterSetter(t, e, i, n, r) {
      w.addGetter(t, e, i), w.addSetter(t, e, n, r), w.addOverloadedGetterSetter(t, e);
    },
    addGetter: function addGetter(t, e, i) {
      var n = "get" + f._capitalize(e);

      t.prototype[n] = t.prototype[n] || function () {
        var t = this.attrs[e];
        return void 0 === t ? i : t;
      };
    },
    addSetter: function addSetter(t, e, i, n) {
      var r = "set" + f._capitalize(e);

      t.prototype[r] || w.overWriteSetter(t, e, i, n);
    },
    overWriteSetter: function overWriteSetter(t, e, i, n) {
      var r = "set" + f._capitalize(e);

      t.prototype[r] = function (t) {
        return i && null != t && (t = i.call(this, t, e)), this._setAttr(e, t), n && n.call(this), this;
      };
    },
    addComponentsGetterSetter: function addComponentsGetterSetter(t, e, i, n, o) {
      var a,
          s,
          h = i.length,
          l = f._capitalize,
          c = "get" + l(e),
          d = "set" + l(e);

      t.prototype[c] = function () {
        var t = {};

        for (a = 0; a < h; a++) {
          t[s = i[a]] = this.getAttr(e + l(s));
        }

        return t;
      };

      var u = function (t) {
        if (r.isUnminified) return function (e, i) {
          return f.isObject(e) || f.warn(g(e) + ' is a not valid value for "' + i + '" attribute. The value should be an object with properties ' + t), e;
        };
      }(i);

      t.prototype[d] = function (t) {
        var i,
            r = this.attrs[e];

        for (i in n && (t = n.call(this, t)), u && u.call(this, t, e), t) {
          t.hasOwnProperty(i) && this._setAttr(e + l(i), t[i]);
        }

        return this._fireChangeEvent(e, r, t), o && o.call(this), this;
      }, w.addOverloadedGetterSetter(t, e);
    },
    addOverloadedGetterSetter: function addOverloadedGetterSetter(t, e) {
      var i = f._capitalize(e),
          n = "set" + i,
          r = "get" + i;

      t.prototype[e] = function () {
        return arguments.length ? (this[n](arguments[0]), this) : this[r]();
      };
    },
    addDeprecatedGetterSetter: function addDeprecatedGetterSetter(t, e, i, n) {
      f.error("Adding deprecated " + e);

      var r = "get" + f._capitalize(e),
          o = e + " property is deprecated and will be removed soon. Look at Konva change log for more information.";

      t.prototype[r] = function () {
        f.error(o);
        var t = this.attrs[e];
        return void 0 === t ? i : t;
      }, w.addSetter(t, e, n, function () {
        f.error(o);
      }), w.addOverloadedGetterSetter(t, e);
    },
    backCompat: function backCompat(t, e) {
      f.each(e, function (e, i) {
        var n = t.prototype[i],
            r = "get" + f._capitalize(e),
            o = "set" + f._capitalize(e);

        function a() {
          n.apply(this, arguments), f.error('"' + e + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.');
        }

        t.prototype[e] = a, t.prototype[r] = a, t.prototype[o] = a;
      });
    },
    afterSetFilter: function afterSetFilter() {
      this._filterUpToDate = !1;
    }
  },
      _C = function C(t, e) {
    return (_C = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (t, e) {
      t.__proto__ = e;
    } || function (t, e) {
      for (var i in e) {
        e.hasOwnProperty(i) && (t[i] = e[i]);
      }
    })(t, e);
  };

  function P(t, e) {
    function i() {
      this.constructor = t;
    }

    _C(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());
  }

  var _k = function k() {
    return (_k = Object.assign || function (t) {
      for (var e, i = 1, n = arguments.length; i < n; i++) {
        for (var r in e = arguments[i]) {
          Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
        }
      }

      return t;
    }).apply(this, arguments);
  };

  var T = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"],
      A = function () {
    function t(t) {
      this.canvas = t, this._context = t._canvas.getContext("2d"), r.enableTrace && (this.traceArr = [], this._enableTrace());
    }

    return t.prototype.fillShape = function (t) {
      t.fillEnabled() && this._fill(t);
    }, t.prototype._fill = function (t) {}, t.prototype.strokeShape = function (t) {
      t.hasStroke() && this._stroke(t);
    }, t.prototype._stroke = function (t) {}, t.prototype.fillStrokeShape = function (t) {
      t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t));
    }, t.prototype.getTrace = function (t) {
      var e,
          i,
          n,
          r,
          o = this.traceArr,
          a = o.length,
          s = "";

      for (e = 0; e < a; e++) {
        (n = (i = o[e]).method) ? (r = i.args, s += n, t ? s += "()" : f._isArray(r[0]) ? s += "([" + r.join(",") + "])" : s += "(" + r.join(",") + ")") : (s += i.property, t || (s += "=" + i.val)), s += ";";
      }

      return s;
    }, t.prototype.clearTrace = function () {
      this.traceArr = [];
    }, t.prototype._trace = function (t) {
      var e = this.traceArr;
      e.push(t), e.length >= 100 && e.shift();
    }, t.prototype.reset = function () {
      var t = this.getCanvas().getPixelRatio();
      this.setTransform(1 * t, 0, 0, 1 * t, 0, 0);
    }, t.prototype.getCanvas = function () {
      return this.canvas;
    }, t.prototype.clear = function (t) {
      var e = this.getCanvas();
      t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, e.getWidth() / e.pixelRatio, e.getHeight() / e.pixelRatio);
    }, t.prototype._applyLineCap = function (t) {
      var e = t.getLineCap();
      e && this.setAttr("lineCap", e);
    }, t.prototype._applyOpacity = function (t) {
      var e = t.getAbsoluteOpacity();
      1 !== e && this.setAttr("globalAlpha", e);
    }, t.prototype._applyLineJoin = function (t) {
      var e = t.attrs.lineJoin;
      e && this.setAttr("lineJoin", e);
    }, t.prototype.setAttr = function (t, e) {
      this._context[t] = e;
    }, t.prototype.arc = function (t, e, i, n, r, o) {
      this._context.arc(t, e, i, n, r, o);
    }, t.prototype.arcTo = function (t, e, i, n, r) {
      this._context.arcTo(t, e, i, n, r);
    }, t.prototype.beginPath = function () {
      this._context.beginPath();
    }, t.prototype.bezierCurveTo = function (t, e, i, n, r, o) {
      this._context.bezierCurveTo(t, e, i, n, r, o);
    }, t.prototype.clearRect = function (t, e, i, n) {
      this._context.clearRect(t, e, i, n);
    }, t.prototype.clip = function () {
      this._context.clip();
    }, t.prototype.closePath = function () {
      this._context.closePath();
    }, t.prototype.createImageData = function (t, e) {
      var i = arguments;
      return 2 === i.length ? this._context.createImageData(t, e) : 1 === i.length ? this._context.createImageData(t) : void 0;
    }, t.prototype.createLinearGradient = function (t, e, i, n) {
      return this._context.createLinearGradient(t, e, i, n);
    }, t.prototype.createPattern = function (t, e) {
      return this._context.createPattern(t, e);
    }, t.prototype.createRadialGradient = function (t, e, i, n, r, o) {
      return this._context.createRadialGradient(t, e, i, n, r, o);
    }, t.prototype.drawImage = function (t, e, i, n, r, o, a, s, h) {
      var l = arguments,
          c = this._context;
      3 === l.length ? c.drawImage(t, e, i) : 5 === l.length ? c.drawImage(t, e, i, n, r) : 9 === l.length && c.drawImage(t, e, i, n, r, o, a, s, h);
    }, t.prototype.ellipse = function (t, e, i, n, r, o, a, s) {
      this._context.ellipse(t, e, i, n, r, o, a, s);
    }, t.prototype.isPointInPath = function (t, e) {
      return this._context.isPointInPath(t, e);
    }, t.prototype.fill = function () {
      this._context.fill();
    }, t.prototype.fillRect = function (t, e, i, n) {
      this._context.fillRect(t, e, i, n);
    }, t.prototype.strokeRect = function (t, e, i, n) {
      this._context.strokeRect(t, e, i, n);
    }, t.prototype.fillText = function (t, e, i) {
      this._context.fillText(t, e, i);
    }, t.prototype.measureText = function (t) {
      return this._context.measureText(t);
    }, t.prototype.getImageData = function (t, e, i, n) {
      return this._context.getImageData(t, e, i, n);
    }, t.prototype.lineTo = function (t, e) {
      this._context.lineTo(t, e);
    }, t.prototype.moveTo = function (t, e) {
      this._context.moveTo(t, e);
    }, t.prototype.rect = function (t, e, i, n) {
      this._context.rect(t, e, i, n);
    }, t.prototype.putImageData = function (t, e, i) {
      this._context.putImageData(t, e, i);
    }, t.prototype.quadraticCurveTo = function (t, e, i, n) {
      this._context.quadraticCurveTo(t, e, i, n);
    }, t.prototype.restore = function () {
      this._context.restore();
    }, t.prototype.rotate = function (t) {
      this._context.rotate(t);
    }, t.prototype.save = function () {
      this._context.save();
    }, t.prototype.scale = function (t, e) {
      this._context.scale(t, e);
    }, t.prototype.setLineDash = function (t) {
      this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t);
    }, t.prototype.getLineDash = function () {
      return this._context.getLineDash();
    }, t.prototype.setTransform = function (t, e, i, n, r, o) {
      this._context.setTransform(t, e, i, n, r, o);
    }, t.prototype.stroke = function () {
      this._context.stroke();
    }, t.prototype.strokeText = function (t, e, i, n) {
      this._context.strokeText(t, e, i, n);
    }, t.prototype.transform = function (t, e, i, n, r, o) {
      this._context.transform(t, e, i, n, r, o);
    }, t.prototype.translate = function (t, e) {
      this._context.translate(t, e);
    }, t.prototype._enableTrace = function () {
      var t,
          e,
          i = this,
          n = T.length,
          r = f._simplifyArray,
          o = this.setAttr,
          a = function a(t) {
        var n,
            o = i[t];

        i[t] = function () {
          return e = r(Array.prototype.slice.call(arguments, 0)), n = o.apply(i, arguments), i._trace({
            method: t,
            args: e
          }), n;
        };
      };

      for (t = 0; t < n; t++) {
        a(T[t]);
      }

      i.setAttr = function () {
        o.apply(i, arguments);
        var t = arguments[0],
            e = arguments[1];
        "shadowOffsetX" !== t && "shadowOffsetY" !== t && "shadowBlur" !== t || (e /= this.canvas.getPixelRatio()), i._trace({
          property: t,
          val: e
        });
      };
    }, t.prototype._applyGlobalCompositeOperation = function (t) {
      var e = t.getGlobalCompositeOperation();
      "source-over" !== e && this.setAttr("globalCompositeOperation", e);
    }, t;
  }();

  ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"].forEach(function (t) {
    Object.defineProperty(A.prototype, t, {
      get: function get() {
        return this._context[t];
      },
      set: function set(e) {
        this._context[t] = e;
      }
    });
  });

  var M,
      G = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._fillColor = function (t) {
      var e = t.fill();
      this.setAttr("fillStyle", e), t._fillFunc(this);
    }, e.prototype._fillPattern = function (t) {
      var e = t.getFillPatternX(),
          i = t.getFillPatternY(),
          n = r.getAngle(t.getFillPatternRotation()),
          o = t.getFillPatternOffsetX(),
          a = t.getFillPatternOffsetY();
      t.getFillPatternScaleX(), t.getFillPatternScaleY();
      (e || i) && this.translate(e || 0, i || 0), n && this.rotate(n), (o || a) && this.translate(-1 * o, -1 * a), this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this);
    }, e.prototype._fillLinearGradient = function (t) {
      var e = t._getLinearGradient();

      e && (this.setAttr("fillStyle", e), t._fillFunc(this));
    }, e.prototype._fillRadialGradient = function (t) {
      var e = t._getRadialGradient();

      e && (this.setAttr("fillStyle", e), t._fillFunc(this));
    }, e.prototype._fill = function (t) {
      var e = t.fill(),
          i = t.getFillPriority();
      if (e && "color" === i) this._fillColor(t);else {
        var n = t.getFillPatternImage();
        if (n && "pattern" === i) this._fillPattern(t);else {
          var r = t.getFillLinearGradientColorStops();
          if (r && "linear-gradient" === i) this._fillLinearGradient(t);else {
            var o = t.getFillRadialGradientColorStops();
            o && "radial-gradient" === i ? this._fillRadialGradient(t) : e ? this._fillColor(t) : n ? this._fillPattern(t) : r ? this._fillLinearGradient(t) : o && this._fillRadialGradient(t);
          }
        }
      }
    }, e.prototype._strokeLinearGradient = function (t) {
      var e = t.getStrokeLinearGradientStartPoint(),
          i = t.getStrokeLinearGradientEndPoint(),
          n = t.getStrokeLinearGradientColorStops(),
          r = this.createLinearGradient(e.x, e.y, i.x, i.y);

      if (n) {
        for (var o = 0; o < n.length; o += 2) {
          r.addColorStop(n[o], n[o + 1]);
        }

        this.setAttr("strokeStyle", r);
      }
    }, e.prototype._stroke = function (t) {
      var e = t.dash(),
          i = t.getStrokeScaleEnabled();

      if (t.hasStroke()) {
        if (!i) {
          this.save();
          var n = this.getCanvas().getPixelRatio();
          this.setTransform(n, 0, 0, n, 0, 0);
        }

        this._applyLineCap(t), e && t.dashEnabled() && (this.setLineDash(e), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)"), t.getStrokeLinearGradientColorStops() ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore();
      }
    }, e.prototype._applyShadow = function (t) {
      var e = f,
          i = e.get(t.getShadowRGBA(), "black"),
          n = e.get(t.getShadowBlur(), 5),
          r = e.get(t.getShadowOffset(), {
        x: 0,
        y: 0
      }),
          o = t.getAbsoluteScale(),
          a = this.canvas.getPixelRatio(),
          s = o.x * a,
          h = o.y * a;
      this.setAttr("shadowColor", i), this.setAttr("shadowBlur", n * Math.min(Math.abs(s), Math.abs(h))), this.setAttr("shadowOffsetX", r.x * s), this.setAttr("shadowOffsetY", r.y * h);
    }, e;
  }(A),
      R = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._fill = function (t) {
      this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore();
    }, e.prototype.strokeShape = function (t) {
      t.hasHitStroke() && this._stroke(t);
    }, e.prototype._stroke = function (t) {
      if (t.hasHitStroke()) {
        var e = t.getStrokeScaleEnabled();

        if (!e) {
          this.save();
          var i = this.getCanvas().getPixelRatio();
          this.setTransform(i, 0, 0, i, 0, 0);
        }

        this._applyLineCap(t);

        var n = t.hitStrokeWidth(),
            r = "auto" === n ? t.strokeWidth() : n;
        this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), e || this.restore();
      }
    }, e;
  }(A);

  var L = function () {
    function t(t) {
      this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1;

      var e = (t || {}).pixelRatio || r.pixelRatio || function () {
        if (M) return M;
        var t = f.createCanvasElement().getContext("2d");
        return M = (r._global.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1);
      }();

      this.pixelRatio = e, this._canvas = f.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0";
    }

    return t.prototype.getContext = function () {
      return this.context;
    }, t.prototype.getPixelRatio = function () {
      return this.pixelRatio;
    }, t.prototype.setPixelRatio = function (t) {
      var e = this.pixelRatio;
      this.pixelRatio = t, this.setSize(this.getWidth() / e, this.getHeight() / e);
    }, t.prototype.setWidth = function (t) {
      this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px";
      var e = this.pixelRatio;

      this.getContext()._context.scale(e, e);
    }, t.prototype.setHeight = function (t) {
      this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px";
      var e = this.pixelRatio;

      this.getContext()._context.scale(e, e);
    }, t.prototype.getWidth = function () {
      return this.width;
    }, t.prototype.getHeight = function () {
      return this.height;
    }, t.prototype.setSize = function (t, e) {
      this.setWidth(t || 0), this.setHeight(e || 0);
    }, t.prototype.toDataURL = function (t, e) {
      try {
        return this._canvas.toDataURL(t, e);
      } catch (t) {
        try {
          return this._canvas.toDataURL();
        } catch (t) {
          return f.error("Unable to get data URL. " + t.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "";
        }
      }
    }, t;
  }();

  w.addGetterSetter(L, "pixelRatio", void 0, y());

  var E = function (t) {
    function e(e) {
      void 0 === e && (e = {
        width: 0,
        height: 0
      });
      var i = t.call(this, e) || this;
      return i.context = new G(i), i.setSize(e.width, e.height), i;
    }

    return P(e, t), e;
  }(L),
      O = function (t) {
    function e(e) {
      void 0 === e && (e = {
        width: 0,
        height: 0
      });
      var i = t.call(this, e) || this;
      return i.hitCanvas = !0, i.context = new R(i), i.setSize(e.width, e.height), i;
    }

    return P(e, t), e;
  }(L),
      D = {
    get isDragging() {
      var t = !1;
      return D._dragElements.forEach(function (e) {
        "dragging" === e.dragStatus && (t = !0);
      }), t;
    },

    justDragged: !1,

    get node() {
      var t;
      return D._dragElements.forEach(function (e) {
        t = e.node;
      }), t;
    },

    _dragElements: new Map(),
    _drag: function _drag(t) {
      var e = [];
      D._dragElements.forEach(function (i, n) {
        var r = i.node,
            o = r.getStage();
        o.setPointersPositions(t), void 0 === i.pointerId && (i.pointerId = f._getFirstPointerId(t));

        var a = o._changedPointerPositions.find(function (t) {
          return t.id === i.pointerId;
        });

        if (a) {
          if ("dragging" !== i.dragStatus) {
            var s = r.dragDistance();
            if (Math.max(Math.abs(a.x - i.startPointerPos.x), Math.abs(a.y - i.startPointerPos.y)) < s) return;
            if (r.startDrag({
              evt: t
            }), !r.isDragging()) return;
          }

          r._setDragPosition(t, i), e.push(r);
        }
      }), e.forEach(function (e) {
        e.fire("dragmove", {
          type: "dragmove",
          target: e,
          evt: t
        }, !0);
      });
    },
    _endDragBefore: function _endDragBefore(t) {
      D._dragElements.forEach(function (e, i) {
        var n = e.node.getStage();

        if (t && n.setPointersPositions(t), n._changedPointerPositions.find(function (t) {
          return t.id === e.pointerId;
        })) {
          "dragging" !== e.dragStatus && "stopped" !== e.dragStatus || (D.justDragged = !0, r.listenClickTap = !1, e.dragStatus = "stopped");
          var o = e.node.getLayer() || e.node instanceof r.Stage && e.node;
          o && o.batchDraw();
        }
      });
    },
    _endDragAfter: function _endDragAfter(t) {
      D._dragElements.forEach(function (e, i) {
        "stopped" === e.dragStatus && e.node.fire("dragend", {
          type: "dragend",
          target: e.node,
          evt: t
        }, !0), "dragging" !== e.dragStatus && D._dragElements["delete"](i);
      });
    }
  };

  r.isBrowser && (window.addEventListener("mouseup", D._endDragBefore, !0), window.addEventListener("touchend", D._endDragBefore, !0), window.addEventListener("mousemove", D._drag), window.addEventListener("touchmove", D._drag), window.addEventListener("mouseup", D._endDragAfter, !1), window.addEventListener("touchend", D._endDragAfter, !1));

  var I = {},
      F = {},
      B = function B(t, e) {
    t && I[t] === e && delete I[t];
  },
      N = function N(t, e) {
    e && (F[e] || (F[e] = []), F[e].push(t));
  },
      z = function z(t, e) {
    if (t) {
      var i = F[t];

      if (i) {
        for (var n = 0; n < i.length; n++) {
          i[n]._id === e && i.splice(n, 1);
        }

        0 === i.length && delete F[t];
      }
    }
  },
      W = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(" "),
      H = new s(),
      Y = 1,
      X = function () {
    function t(t) {
      this._id = Y++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map(), this._attachedDepsListeners = new Map(), this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this.children = H, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0;
    }

    return t.prototype.hasChildren = function () {
      return !1;
    }, t.prototype.getChildren = function () {
      return H;
    }, t.prototype._clearCache = function (t) {
      "transform" !== t && "absoluteTransform" !== t || !this._cache.get(t) ? t ? this._cache["delete"](t) : this._cache.clear() : this._cache.get(t).dirty = !0;
    }, t.prototype._getCache = function (t, e) {
      var i = this._cache.get(t);

      return (void 0 === i || ("transform" === t || "absoluteTransform" === t) && !0 === i.dirty) && (i = e.call(this), this._cache.set(t, i)), i;
    }, t.prototype._calculate = function (t, e, i) {
      var n = this;

      if (!this._attachedDepsListeners.get(t)) {
        var r = e.map(function (t) {
          return t + "Change.konva";
        }).join(" ");
        this.on(r, function () {
          n._clearCache(t);
        }), this._attachedDepsListeners.set(t, !0);
      }

      return this._getCache(t, i);
    }, t.prototype._getCanvasCache = function () {
      return this._cache.get("canvas");
    }, t.prototype._clearSelfAndDescendantCache = function (t, e) {
      this._clearCache(t), e && "absoluteTransform" === t && this.fire("_clearTransformCache"), this.isCached() || this.children && this.children.each(function (e) {
        e._clearSelfAndDescendantCache(t, !0);
      });
    }, t.prototype.clearCache = function () {
      return this._cache["delete"]("canvas"), this._clearSelfAndDescendantCache(), this;
    }, t.prototype.cache = function (t) {
      var e = t || {},
          i = {};
      void 0 !== e.x && void 0 !== e.y && void 0 !== e.width && void 0 !== e.height || (i = this.getClientRect({
        skipTransform: !0,
        relativeTo: this.getParent()
      }));
      var n = Math.ceil(e.width || i.width),
          r = Math.ceil(e.height || i.height),
          o = e.pixelRatio,
          a = void 0 === e.x ? i.x : e.x,
          s = void 0 === e.y ? i.y : e.y,
          h = e.offset || 0,
          l = e.drawBorder || !1;

      if (n && r) {
        a -= h, s -= h;
        var c = new E({
          pixelRatio: o,
          width: n += 2 * h,
          height: r += 2 * h
        }),
            d = new E({
          pixelRatio: o,
          width: 0,
          height: 0
        }),
            u = new O({
          pixelRatio: 1,
          width: n,
          height: r
        }),
            p = c.getContext(),
            g = u.getContext();
        return u.isCache = !0, c.isCache = !0, this._cache["delete"]("canvas"), this._filterUpToDate = !1, !1 === e.imageSmoothingEnabled && (c.getContext()._context.imageSmoothingEnabled = !1, d.getContext()._context.imageSmoothingEnabled = !1), p.save(), g.save(), p.translate(-a, -s), g.translate(-a, -s), this._isUnderCache = !0, this._clearSelfAndDescendantCache("absoluteOpacity"), this._clearSelfAndDescendantCache("absoluteScale"), this.drawScene(c, this), this.drawHit(u, this), this._isUnderCache = !1, p.restore(), g.restore(), l && (p.save(), p.beginPath(), p.rect(0, 0, n, r), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set("canvas", {
          scene: c,
          filter: d,
          hit: u,
          x: a,
          y: s
        }), this;
      }

      f.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.");
    }, t.prototype.isCached = function () {
      return this._cache.has("canvas");
    }, t.prototype.getClientRect = function (t) {
      throw new Error('abstract "getClientRect" method call');
    }, t.prototype._transformedRect = function (t, e) {
      var i,
          n,
          r,
          o,
          a = [{
        x: t.x,
        y: t.y
      }, {
        x: t.x + t.width,
        y: t.y
      }, {
        x: t.x + t.width,
        y: t.y + t.height
      }, {
        x: t.x,
        y: t.y + t.height
      }],
          s = this.getAbsoluteTransform(e);
      return a.forEach(function (t) {
        var e = s.point(t);
        void 0 === i && (i = r = e.x, n = o = e.y), i = Math.min(i, e.x), n = Math.min(n, e.y), r = Math.max(r, e.x), o = Math.max(o, e.y);
      }), {
        x: i,
        y: n,
        width: r - i,
        height: o - n
      };
    }, t.prototype._drawCachedSceneCanvas = function (t) {
      t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this);

      var e = this._getCanvasCache();

      t.translate(e.x, e.y);

      var i = this._getCachedSceneCanvas(),
          n = i.pixelRatio;

      t.drawImage(i._canvas, 0, 0, i.width / n, i.height / n), t.restore();
    }, t.prototype._drawCachedHitCanvas = function (t) {
      var e = this._getCanvasCache(),
          i = e.hit;

      t.save(), t.translate(e.x, e.y), t.drawImage(i._canvas, 0, 0), t.restore();
    }, t.prototype._getCachedSceneCanvas = function () {
      var t,
          e,
          i,
          n,
          r = this.filters(),
          o = this._getCanvasCache(),
          a = o.scene,
          s = o.filter,
          h = s.getContext();

      if (r) {
        if (!this._filterUpToDate) {
          var l = a.pixelRatio;
          s.setSize(a.width / a.pixelRatio, a.height / a.pixelRatio);

          try {
            for (t = r.length, h.clear(), h.drawImage(a._canvas, 0, 0, a.getWidth() / l, a.getHeight() / l), e = h.getImageData(0, 0, s.getWidth(), s.getHeight()), i = 0; i < t; i++) {
              "function" == typeof (n = r[i]) ? (n.call(this, e), h.putImageData(e, 0, 0)) : f.error("Filter should be type of function, but got " + _typeof(n) + " instead. Please check correct filters");
            }
          } catch (t) {
            f.error("Unable to apply filter. " + t.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.");
          }

          this._filterUpToDate = !0;
        }

        return s;
      }

      return a;
    }, t.prototype.on = function (t, e) {
      if (this._cache && this._cache["delete"]("allEventListeners"), 3 === arguments.length) return this._delegate.apply(this, arguments);
      var i,
          n,
          r,
          o,
          a = t.split(" "),
          s = a.length;

      for (i = 0; i < s; i++) {
        r = (n = a[i].split("."))[0], o = n[1] || "", this.eventListeners[r] || (this.eventListeners[r] = []), this.eventListeners[r].push({
          name: o,
          handler: e
        });
      }

      return this;
    }, t.prototype.off = function (t, e) {
      var i,
          n,
          r,
          o,
          a,
          s = (t || "").split(" "),
          h = s.length;
      if (this._cache && this._cache["delete"]("allEventListeners"), !t) for (n in this.eventListeners) {
        this._off(n);
      }

      for (i = 0; i < h; i++) {
        if (o = (r = s[i].split("."))[0], a = r[1], o) this.eventListeners[o] && this._off(o, a, e);else for (n in this.eventListeners) {
          this._off(n, a, e);
        }
      }

      return this;
    }, t.prototype.dispatchEvent = function (t) {
      var e = {
        target: this,
        type: t.type,
        evt: t
      };
      return this.fire(t.type, e), this;
    }, t.prototype.addEventListener = function (t, e) {
      return this.on(t, function (t) {
        e.call(this, t.evt);
      }), this;
    }, t.prototype.removeEventListener = function (t) {
      return this.off(t), this;
    }, t.prototype._delegate = function (t, e, i) {
      var n = this;
      this.on(t, function (t) {
        for (var r = t.target.findAncestors(e, !0, n), o = 0; o < r.length; o++) {
          (t = f.cloneObject(t)).currentTarget = r[o], i.call(r[o], t);
        }
      });
    }, t.prototype.remove = function () {
      return this.isDragging() && this.stopDrag(), D._dragElements["delete"](this._id), this._remove(), this;
    }, t.prototype._clearCaches = function () {
      this._clearSelfAndDescendantCache("absoluteTransform"), this._clearSelfAndDescendantCache("absoluteOpacity"), this._clearSelfAndDescendantCache("absoluteScale"), this._clearSelfAndDescendantCache("stage"), this._clearSelfAndDescendantCache("visible"), this._clearSelfAndDescendantCache("listening");
    }, t.prototype._remove = function () {
      this._clearCaches();

      var t = this.getParent();
      t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null);
    }, t.prototype.destroy = function () {
      B(this.id(), this);

      for (var t = (this.name() || "").split(/\s/g), e = 0; e < t.length; e++) {
        var i = t[e];
        z(i, this._id);
      }

      return this.remove(), this;
    }, t.prototype.getAttr = function (t) {
      var e = "get" + f._capitalize(t);

      return f._isFunction(this[e]) ? this[e]() : this.attrs[t];
    }, t.prototype.getAncestors = function () {
      for (var t = this.getParent(), e = new s(); t;) {
        e.push(t), t = t.getParent();
      }

      return e;
    }, t.prototype.getAttrs = function () {
      return this.attrs || {};
    }, t.prototype.setAttrs = function (t) {
      var e = this;
      return this._batchTransformChanges(function () {
        var i, n;
        if (!t) return e;

        for (i in t) {
          "children" !== i && (n = "set" + f._capitalize(i), f._isFunction(e[n]) ? e[n](t[i]) : e._setAttr(i, t[i]));
        }
      }), this;
    }, t.prototype.isListening = function () {
      return this._getCache("listening", this._isListening);
    }, t.prototype._isListening = function (t) {
      if (!this.listening()) return !1;
      var e = this.getParent();
      return !e || e === t || this === t || e._isListening(t);
    }, t.prototype.isVisible = function () {
      return this._getCache("visible", this._isVisible);
    }, t.prototype._isVisible = function (t) {
      if (!this.visible()) return !1;
      var e = this.getParent();
      return !e || e === t || this === t || e._isVisible(t);
    }, t.prototype.shouldDrawHit = function (t, e) {
      if (void 0 === e && (e = !1), t) return this._isVisible(t) && this._isListening(t);
      var i = this.getLayer(),
          n = !1;

      D._dragElements.forEach(function (t) {
        "dragging" === t.dragStatus && ("Stage" === t.node.nodeType || t.node.getLayer() === i) && (n = !0);
      });

      var o = !e && !r.hitOnDragEnabled && n;
      return this.isListening() && this.isVisible() && !o;
    }, t.prototype.show = function () {
      return this.visible(!0), this;
    }, t.prototype.hide = function () {
      return this.visible(!1), this;
    }, t.prototype.getZIndex = function () {
      return this.index || 0;
    }, t.prototype.getAbsoluteZIndex = function () {
      var t,
          e,
          i,
          n,
          r = this.getDepth(),
          o = this,
          a = 0;
      return "Stage" !== o.nodeType && function s(h) {
        for (t = [], e = h.length, i = 0; i < e; i++) {
          n = h[i], a++, "Shape" !== n.nodeType && (t = t.concat(n.getChildren().toArray())), n._id === o._id && (i = e);
        }

        t.length > 0 && t[0].getDepth() <= r && s(t);
      }(o.getStage().getChildren()), a;
    }, t.prototype.getDepth = function () {
      for (var t = 0, e = this.parent; e;) {
        t++, e = e.parent;
      }

      return t;
    }, t.prototype._batchTransformChanges = function (t) {
      this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform", !0)), this._needClearTransformCache = !1;
    }, t.prototype.setPosition = function (t) {
      var e = this;
      return this._batchTransformChanges(function () {
        e.x(t.x), e.y(t.y);
      }), this;
    }, t.prototype.getPosition = function () {
      return {
        x: this.x(),
        y: this.y()
      };
    }, t.prototype.getAbsolutePosition = function (t) {
      for (var e = !1, i = this.parent; i;) {
        if (i.isCached()) {
          e = !0;
          break;
        }

        i = i.parent;
      }

      e && !t && (t = !0);
      var n = this.getAbsoluteTransform(t).getMatrix(),
          r = new h(),
          o = this.offset();
      return r.m = n.slice(), r.translate(o.x, o.y), r.getTranslation();
    }, t.prototype.setAbsolutePosition = function (t) {
      var e = this._clearTransform();

      this.attrs.x = e.x, this.attrs.y = e.y, delete e.x, delete e.y, this._clearCache("transform");

      var i = this._getAbsoluteTransform().copy();

      return i.invert(), i.translate(t.x, t.y), t = {
        x: this.attrs.x + i.getTranslation().x,
        y: this.attrs.y + i.getTranslation().y
      }, this._setTransform(e), this.setPosition({
        x: t.x,
        y: t.y
      }), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform"), this;
    }, t.prototype._setTransform = function (t) {
      var e;

      for (e in t) {
        this.attrs[e] = t[e];
      }
    }, t.prototype._clearTransform = function () {
      var t = {
        x: this.x(),
        y: this.y(),
        rotation: this.rotation(),
        scaleX: this.scaleX(),
        scaleY: this.scaleY(),
        offsetX: this.offsetX(),
        offsetY: this.offsetY(),
        skewX: this.skewX(),
        skewY: this.skewY()
      };
      return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t;
    }, t.prototype.move = function (t) {
      var e = t.x,
          i = t.y,
          n = this.x(),
          r = this.y();
      return void 0 !== e && (n += e), void 0 !== i && (r += i), this.setPosition({
        x: n,
        y: r
      }), this;
    }, t.prototype._eachAncestorReverse = function (t, e) {
      var i,
          n,
          r = [],
          o = this.getParent();

      if (!e || e._id !== this._id) {
        for (r.unshift(this); o && (!e || o._id !== e._id);) {
          r.unshift(o), o = o.parent;
        }

        for (i = r.length, n = 0; n < i; n++) {
          t(r[n]);
        }
      }
    }, t.prototype.rotate = function (t) {
      return this.rotation(this.rotation() + t), this;
    }, t.prototype.moveToTop = function () {
      if (!this.parent) return f.warn("Node has no parent. moveToTop function is ignored."), !1;
      var t = this.index;
      return this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0;
    }, t.prototype.moveUp = function () {
      if (!this.parent) return f.warn("Node has no parent. moveUp function is ignored."), !1;
      var t = this.index;
      return t < this.parent.getChildren().length - 1 && (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0);
    }, t.prototype.moveDown = function () {
      if (!this.parent) return f.warn("Node has no parent. moveDown function is ignored."), !1;
      var t = this.index;
      return t > 0 && (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0);
    }, t.prototype.moveToBottom = function () {
      if (!this.parent) return f.warn("Node has no parent. moveToBottom function is ignored."), !1;
      var t = this.index;
      return t > 0 && (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0);
    }, t.prototype.setZIndex = function (t) {
      if (!this.parent) return f.warn("Node has no parent. zIndex parameter is ignored."), this;
      (t < 0 || t >= this.parent.children.length) && f.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + ".");
      var e = this.index;
      return this.parent.children.splice(e, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this;
    }, t.prototype.getAbsoluteOpacity = function () {
      return this._getCache("absoluteOpacity", this._getAbsoluteOpacity);
    }, t.prototype._getAbsoluteOpacity = function () {
      var t = this.opacity(),
          e = this.getParent();
      return e && !e._isUnderCache && (t *= e.getAbsoluteOpacity()), t;
    }, t.prototype.moveTo = function (t) {
      return this.getParent() !== t && (this._remove(), t.add(this)), this;
    }, t.prototype.toObject = function () {
      var t,
          e,
          i,
          n,
          r = {},
          o = this.getAttrs();

      for (t in r.attrs = {}, o) {
        e = o[t], f.isObject(e) && !f._isPlainObject(e) && !f._isArray(e) || (i = "function" == typeof this[t] && this[t], delete o[t], n = i ? i.call(this) : null, o[t] = e, n !== e && (r.attrs[t] = e));
      }

      return r.className = this.getClassName(), f._prepareToStringify(r);
    }, t.prototype.toJSON = function () {
      return JSON.stringify(this.toObject());
    }, t.prototype.getParent = function () {
      return this.parent;
    }, t.prototype.findAncestors = function (t, e, i) {
      var n = [];
      e && this._isMatch(t) && n.push(this);

      for (var r = this.parent; r;) {
        if (r === i) return n;
        r._isMatch(t) && n.push(r), r = r.parent;
      }

      return n;
    }, t.prototype.isAncestorOf = function (t) {
      return !1;
    }, t.prototype.findAncestor = function (t, e, i) {
      return this.findAncestors(t, e, i)[0];
    }, t.prototype._isMatch = function (t) {
      if (!t) return !1;
      if ("function" == typeof t) return t(this);
      var e,
          i,
          n = t.replace(/ /g, "").split(","),
          r = n.length;

      for (e = 0; e < r; e++) {
        if (i = n[e], f.isValidSelector(i) || (f.warn('Selector "' + i + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), f.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), f.warn("Konva is awesome, right?")), "#" === i.charAt(0)) {
          if (this.id() === i.slice(1)) return !0;
        } else if ("." === i.charAt(0)) {
          if (this.hasName(i.slice(1))) return !0;
        } else if (this.className === i || this.nodeType === i) return !0;
      }

      return !1;
    }, t.prototype.getLayer = function () {
      var t = this.getParent();
      return t ? t.getLayer() : null;
    }, t.prototype.getStage = function () {
      return this._getCache("stage", this._getStage);
    }, t.prototype._getStage = function () {
      var t = this.getParent();
      return t ? t.getStage() : void 0;
    }, t.prototype.fire = function (t, e, i) {
      return void 0 === e && (e = {}), e.target = e.target || this, i ? this._fireAndBubble(t, e) : this._fire(t, e), this;
    }, t.prototype.getAbsoluteTransform = function (t) {
      return t ? this._getAbsoluteTransform(t) : this._getCache("absoluteTransform", this._getAbsoluteTransform);
    }, t.prototype._getAbsoluteTransform = function (t) {
      var e;
      if (t) return e = new h(), this._eachAncestorReverse(function (t) {
        var i = t.transformsEnabled();
        "all" === i ? e.multiply(t.getTransform()) : "position" === i && e.translate(t.x() - t.offsetX(), t.y() - t.offsetY());
      }, t), e;
      e = this._cache.get("absoluteTransform") || new h(), this.parent ? this.parent.getAbsoluteTransform().copyInto(e) : e.reset();
      var i = this.transformsEnabled();
      if ("all" === i) e.multiply(this.getTransform());else if ("position" === i) {
        var n = this.attrs.x || 0,
            r = this.attrs.y || 0,
            o = this.attrs.offsetX || 0,
            a = this.attrs.offsetY || 0;
        e.translate(n - o, r - a);
      }
      return e.dirty = !1, e;
    }, t.prototype.getAbsoluteScale = function (t) {
      for (var e = this; e;) {
        e._isUnderCache && (t = e), e = e.getParent();
      }

      var i = this.getAbsoluteTransform(t).decompose();
      return {
        x: i.scaleX,
        y: i.scaleY
      };
    }, t.prototype.getAbsoluteRotation = function () {
      return this.getAbsoluteTransform().decompose().rotation;
    }, t.prototype.getTransform = function () {
      return this._getCache("transform", this._getTransform);
    }, t.prototype._getTransform = function () {
      var t,
          e,
          i = this._cache.get("transform") || new h();
      i.reset();
      var n = this.x(),
          o = this.y(),
          a = r.getAngle(this.rotation()),
          s = null !== (t = this.attrs.scaleX) && void 0 !== t ? t : 1,
          l = null !== (e = this.attrs.scaleY) && void 0 !== e ? e : 1,
          c = this.attrs.skewX || 0,
          d = this.attrs.skewY || 0,
          u = this.attrs.offsetX || 0,
          p = this.attrs.offsetY || 0;
      return 0 === n && 0 === o || i.translate(n, o), 0 !== a && i.rotate(a), 0 === c && 0 === d || i.skew(c, d), 1 === s && 1 === l || i.scale(s, l), 0 === u && 0 === p || i.translate(-1 * u, -1 * p), i.dirty = !1, i;
    }, t.prototype.clone = function (t) {
      var e,
          i,
          n,
          r,
          o,
          a = f.cloneObject(this.attrs);

      for (e in t) {
        a[e] = t[e];
      }

      var s = new this.constructor(a);

      for (e in this.eventListeners) {
        for (n = (i = this.eventListeners[e]).length, r = 0; r < n; r++) {
          (o = i[r]).name.indexOf("konva") < 0 && (s.eventListeners[e] || (s.eventListeners[e] = []), s.eventListeners[e].push(o));
        }
      }

      return s;
    }, t.prototype._toKonvaCanvas = function (t) {
      t = t || {};
      var e = this.getClientRect(),
          i = this.getStage(),
          n = void 0 !== t.x ? t.x : e.x,
          r = void 0 !== t.y ? t.y : e.y,
          o = t.pixelRatio || 1,
          a = new E({
        width: t.width || e.width || (i ? i.width() : 0),
        height: t.height || e.height || (i ? i.height() : 0),
        pixelRatio: o
      }),
          s = a.getContext();
      return s.save(), (n || r) && s.translate(-1 * n, -1 * r), this.drawScene(a), s.restore(), a;
    }, t.prototype.toCanvas = function (t) {
      return this._toKonvaCanvas(t)._canvas;
    }, t.prototype.toDataURL = function (t) {
      var e = (t = t || {}).mimeType || null,
          i = t.quality || null,
          n = this._toKonvaCanvas(t).toDataURL(e, i);

      return t.callback && t.callback(n), n;
    }, t.prototype.toImage = function (t) {
      if (!t || !t.callback) throw "callback required for toImage method config argument";
      var e = t.callback;
      delete t.callback, f._urlToImage(this.toDataURL(t), function (t) {
        e(t);
      });
    }, t.prototype.setSize = function (t) {
      return this.width(t.width), this.height(t.height), this;
    }, t.prototype.getSize = function () {
      return {
        width: this.width(),
        height: this.height()
      };
    }, t.prototype.getClassName = function () {
      return this.className || this.nodeType;
    }, t.prototype.getType = function () {
      return this.nodeType;
    }, t.prototype.getDragDistance = function () {
      return void 0 !== this.attrs.dragDistance ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : r.dragDistance;
    }, t.prototype._off = function (t, e, i) {
      var n,
          r,
          o,
          a = this.eventListeners[t];

      for (n = 0; n < a.length; n++) {
        if (r = a[n].name, o = a[n].handler, !("konva" === r && "konva" !== e || e && r !== e || i && i !== o)) {
          if (a.splice(n, 1), 0 === a.length) {
            delete this.eventListeners[t];
            break;
          }

          n--;
        }
      }
    }, t.prototype._fireChangeEvent = function (t, e, i) {
      this._fire(t + "Change", {
        oldVal: e,
        newVal: i
      });
    }, t.prototype.setId = function (t) {
      var e = this.id();
      return B(e, this), function (t, e) {
        e && (I[e] = t);
      }(this, t), this._setAttr("id", t), this;
    }, t.prototype.setName = function (t) {
      var e,
          i,
          n = (this.name() || "").split(/\s/g),
          r = (t || "").split(/\s/g);

      for (i = 0; i < n.length; i++) {
        e = n[i], -1 === r.indexOf(e) && e && z(e, this._id);
      }

      for (i = 0; i < r.length; i++) {
        e = r[i], -1 === n.indexOf(e) && e && N(this, e);
      }

      return this._setAttr("name", t), this;
    }, t.prototype.addName = function (t) {
      if (!this.hasName(t)) {
        var e = this.name(),
            i = e ? e + " " + t : t;
        this.setName(i);
      }

      return this;
    }, t.prototype.hasName = function (t) {
      if (!t) return !1;
      var e = this.name();
      return !!e && -1 !== (e || "").split(/\s/g).indexOf(t);
    }, t.prototype.removeName = function (t) {
      var e = (this.name() || "").split(/\s/g),
          i = e.indexOf(t);
      return -1 !== i && (e.splice(i, 1), this.setName(e.join(" "))), this;
    }, t.prototype.setAttr = function (t, e) {
      var i = this["set" + f._capitalize(t)];

      return f._isFunction(i) ? i.call(this, e) : this._setAttr(t, e), this;
    }, t.prototype._setAttr = function (t, e, i) {
      var n = this.attrs[t];
      (n !== e || f.isObject(e)) && (null == e ? delete this.attrs[t] : this.attrs[t] = e, this._shouldFireChangeEvents && this._fireChangeEvent(t, n, e));
    }, t.prototype._setComponentAttr = function (t, e, i) {
      var n;
      void 0 !== i && ((n = this.attrs[t]) || (this.attrs[t] = this.getAttr(t)), this.attrs[t][e] = i, this._fireChangeEvent(t, n, i));
    }, t.prototype._fireAndBubble = function (t, e, i) {
      if (e && "Shape" === this.nodeType && (e.target = this), !(("mouseenter" === t || "mouseleave" === t) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || "Stage" === this.nodeType && !i))) {
        this._fire(t, e);

        var n = ("mouseenter" === t || "mouseleave" === t) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent);
        (e && !e.cancelBubble || !e) && this.parent && this.parent.isListening() && !n && (i && i.parent ? this._fireAndBubble.call(this.parent, t, e, i) : this._fireAndBubble.call(this.parent, t, e));
      }
    }, t.prototype._getProtoListeners = function (t) {
      var e = this._cache.get("allEventListeners");

      if (!e) {
        e = {};

        for (var i = Object.getPrototypeOf(this); i;) {
          if (i.eventListeners) {
            for (var n in i.eventListeners) {
              var r = i.eventListeners[n],
                  o = e[n] || [];
              e[n] = r.concat(o);
            }

            i = Object.getPrototypeOf(i);
          } else i = Object.getPrototypeOf(i);
        }

        this._cache.set("allEventListeners", e);
      }

      return e[t];
    }, t.prototype._fire = function (t, e) {
      (e = e || {}).currentTarget = this, e.type = t;

      var i = this._getProtoListeners(t);

      if (i) for (var n = 0; n < i.length; n++) {
        i[n].handler.call(this, e);
      }
      var r = this.eventListeners[t];
      if (r) for (n = 0; n < r.length; n++) {
        r[n].handler.call(this, e);
      }
    }, t.prototype.draw = function () {
      return this.drawScene(), this.drawHit(), this;
    }, t.prototype._createDragElement = function (t) {
      var e = t ? t.pointerId : void 0,
          i = this.getStage(),
          n = this.getAbsolutePosition(),
          r = i._getPointerById(e) || i._changedPointerPositions[0] || n;

      D._dragElements.set(this._id, {
        node: this,
        startPointerPos: r,
        offset: {
          x: r.x - n.x,
          y: r.y - n.y
        },
        dragStatus: "ready",
        pointerId: e
      });
    }, t.prototype.startDrag = function (t, e) {
      void 0 === e && (e = !0), D._dragElements.has(this._id) || this._createDragElement(t), D._dragElements.get(this._id).dragStatus = "dragging", this.fire("dragstart", {
        type: "dragstart",
        target: this,
        evt: t && t.evt
      }, e);
    }, t.prototype._setDragPosition = function (t, e) {
      var i = this.getStage()._getPointerById(e.pointerId);

      if (i) {
        var n = {
          x: i.x - e.offset.x,
          y: i.y - e.offset.y
        },
            r = this.dragBoundFunc();

        if (void 0 !== r) {
          var o = r.call(this, n, t);
          o ? n = o : f.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.");
        }

        this._lastPos && this._lastPos.x === n.x && this._lastPos.y === n.y || (this.setAbsolutePosition(n), this.getLayer() ? this.getLayer().batchDraw() : this.getStage() && this.getStage().batchDraw()), this._lastPos = n;
      }
    }, t.prototype.stopDrag = function (t) {
      var e = D._dragElements.get(this._id);

      e && (e.dragStatus = "stopped"), D._endDragBefore(t), D._endDragAfter(t);
    }, t.prototype.setDraggable = function (t) {
      this._setAttr("draggable", t), this._dragChange();
    }, t.prototype.isDragging = function () {
      var t = D._dragElements.get(this._id);

      return !!t && "dragging" === t.dragStatus;
    }, t.prototype._listenDrag = function () {
      this._dragCleanup(), this.on("mousedown.konva touchstart.konva", function (t) {
        var e = this;

        if ((!(void 0 !== t.evt.button) || r.dragButtons.indexOf(t.evt.button) >= 0) && !this.isDragging()) {
          var i = !1;
          D._dragElements.forEach(function (t) {
            e.isAncestorOf(t.node) && (i = !0);
          }), i || this._createDragElement(t);
        }
      });
    }, t.prototype._dragChange = function () {
      if (this.attrs.draggable) this._listenDrag();else {
        if (this._dragCleanup(), !this.getStage()) return;

        var t = D._dragElements.get(this._id),
            e = t && "dragging" === t.dragStatus,
            i = t && "ready" === t.dragStatus;

        e ? this.stopDrag() : i && D._dragElements["delete"](this._id);
      }
    }, t.prototype._dragCleanup = function () {
      this.off("mousedown.konva"), this.off("touchstart.konva");
    }, t.create = function (t, e) {
      return f._isString(t) && (t = JSON.parse(t)), this._createNode(t, e);
    }, t._createNode = function (e, i) {
      var n,
          r,
          a,
          s = t.prototype.getClassName.call(e),
          h = e.children;
      if (i && (e.attrs.container = i), o[s] || (f.warn('Can not find a node with class name "' + s + '". Fallback to "Shape".'), s = "Shape"), n = new (0, o[s])(e.attrs), h) for (r = h.length, a = 0; a < r; a++) {
        n.add(t._createNode(h[a]));
      }
      return n;
    }, t;
  }();

  X.prototype.nodeType = "Node", X.prototype._attrsAffectingSize = [], X.prototype.eventListeners = {}, X.prototype.on.call(X.prototype, W, function () {
    this._batchingTransformChange ? this._needClearTransformCache = !0 : (this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform"));
  }), X.prototype.on.call(X.prototype, "visibleChange.konva", function () {
    this._clearSelfAndDescendantCache("visible");
  }), X.prototype.on.call(X.prototype, "listeningChange.konva", function () {
    this._clearSelfAndDescendantCache("listening");
  }), X.prototype.on.call(X.prototype, "opacityChange.konva", function () {
    this._clearSelfAndDescendantCache("absoluteOpacity");
  });
  var j = w.addGetterSetter;
  j(X, "zIndex"), j(X, "absolutePosition"), j(X, "position"), j(X, "x", 0, y()), j(X, "y", 0, y()), j(X, "globalCompositeOperation", "source-over", b()), j(X, "opacity", 1, y()), j(X, "name", "", b()), j(X, "id", "", b()), j(X, "rotation", 0, y()), w.addComponentsGetterSetter(X, "scale", ["x", "y"]), j(X, "scaleX", 1, y()), j(X, "scaleY", 1, y()), w.addComponentsGetterSetter(X, "skew", ["x", "y"]), j(X, "skewX", 0, y()), j(X, "skewY", 0, y()), w.addComponentsGetterSetter(X, "offset", ["x", "y"]), j(X, "offsetX", 0, y()), j(X, "offsetY", 0, y()), j(X, "dragDistance", null, y()), j(X, "width", 0, y()), j(X, "height", 0, y()), j(X, "listening", !0, S()), j(X, "preventDefault", !0, S()), j(X, "filters", null, function (t) {
    return this._filterUpToDate = !1, t;
  }), j(X, "visible", !0, S()), j(X, "transformsEnabled", "all", b()), j(X, "size"), j(X, "dragBoundFunc"), j(X, "draggable", !1, S()), w.backCompat(X, {
    rotateDeg: "rotate",
    setRotationDeg: "setRotation",
    getRotationDeg: "getRotation"
  }), s.mapMethods(X);

  var U = function (t) {
    function e() {
      var e = null !== t && t.apply(this, arguments) || this;
      return e.children = new s(), e;
    }

    return P(e, t), e.prototype.getChildren = function (t) {
      if (!t) return this.children;
      var e = new s();
      return this.children.each(function (i) {
        t(i) && e.push(i);
      }), e;
    }, e.prototype.hasChildren = function () {
      return this.getChildren().length > 0;
    }, e.prototype.removeChildren = function () {
      for (var t, e = 0; e < this.children.length; e++) {
        (t = this.children[e]).parent = null, t.index = 0, t.remove();
      }

      return this.children = new s(), this;
    }, e.prototype.destroyChildren = function () {
      for (var t, e = 0; e < this.children.length; e++) {
        (t = this.children[e]).parent = null, t.index = 0, t.destroy();
      }

      return this.children = new s(), this;
    }, e.prototype.add = function () {
      for (var t = [], e = 0; e < arguments.length; e++) {
        t[e] = arguments[e];
      }

      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }

        return this;
      }

      var n = t[0];
      if (n.getParent()) return n.moveTo(this), this;
      var r = this.children;
      return this._validateAdd(n), n._clearCaches(), n.index = r.length, n.parent = this, r.push(n), this._fire("add", {
        child: n
      }), this;
    }, e.prototype.destroy = function () {
      return this.hasChildren() && this.destroyChildren(), t.prototype.destroy.call(this), this;
    }, e.prototype.find = function (t) {
      return this._generalFind(t, !1);
    }, e.prototype.get = function (t) {
      return f.warn("collection.get() method is deprecated. Please use collection.find() instead."), this.find(t);
    }, e.prototype.findOne = function (t) {
      var e = this._generalFind(t, !0);

      return e.length > 0 ? e[0] : void 0;
    }, e.prototype._generalFind = function (t, e) {
      var i = [];
      return this._descendants(function (n) {
        var r = n._isMatch(t);

        return r && i.push(n), !(!r || !e);
      }), s.toCollection(i);
    }, e.prototype._descendants = function (t) {
      for (var e = 0; e < this.children.length; e++) {
        var i = this.children[e];
        if (t(i)) return !0;
        if (i.hasChildren() && i._descendants(t)) return !0;
      }

      return !1;
    }, e.prototype.toObject = function () {
      var t = X.prototype.toObject.call(this);
      t.children = [];

      for (var e = this.getChildren(), i = e.length, n = 0; n < i; n++) {
        var r = e[n];
        t.children.push(r.toObject());
      }

      return t;
    }, e.prototype.isAncestorOf = function (t) {
      for (var e = t.getParent(); e;) {
        if (e._id === this._id) return !0;
        e = e.getParent();
      }

      return !1;
    }, e.prototype.clone = function (t) {
      var e = X.prototype.clone.call(this, t);
      return this.getChildren().each(function (t) {
        e.add(t.clone());
      }), e;
    }, e.prototype.getAllIntersections = function (t) {
      var e = [];
      return this.find("Shape").each(function (i) {
        i.isVisible() && i.intersects(t) && e.push(i);
      }), e;
    }, e.prototype._setChildrenIndices = function () {
      this.children.each(function (t, e) {
        t.index = e;
      });
    }, e.prototype.drawScene = function (t, e) {
      var i = this.getLayer(),
          n = t || i && i.getCanvas(),
          r = n && n.getContext(),
          o = this._getCanvasCache(),
          a = o && o.scene,
          s = n && n.isCache;

      if (!this.isVisible() && !s) return this;

      if (a) {
        r.save();
        var h = this.getAbsoluteTransform(e).getMatrix();
        r.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this._drawCachedSceneCanvas(r), r.restore();
      } else this._drawChildren("drawScene", n, e);

      return this;
    }, e.prototype.drawHit = function (t, e) {
      if (!this.shouldDrawHit(e)) return this;

      var i = this.getLayer(),
          n = t || i && i.hitCanvas,
          r = n && n.getContext(),
          o = this._getCanvasCache();

      if (o && o.hit) {
        r.save();
        var a = this.getAbsoluteTransform(e).getMatrix();
        r.transform(a[0], a[1], a[2], a[3], a[4], a[5]), this._drawCachedHitCanvas(r), r.restore();
      } else this._drawChildren("drawHit", n, e);

      return this;
    }, e.prototype._drawChildren = function (t, e, i) {
      var n = e && e.getContext(),
          r = this.clipWidth(),
          o = this.clipHeight(),
          a = this.clipFunc(),
          s = r && o || a,
          h = i === this;

      if (s) {
        n.save();
        var l = this.getAbsoluteTransform(i),
            c = l.getMatrix();
        if (n.transform(c[0], c[1], c[2], c[3], c[4], c[5]), n.beginPath(), a) a.call(this, n, this);else {
          var d = this.clipX(),
              u = this.clipY();
          n.rect(d, u, r, o);
        }
        n.clip(), c = l.copy().invert().getMatrix(), n.transform(c[0], c[1], c[2], c[3], c[4], c[5]);
      }

      var p = !h && "source-over" !== this.globalCompositeOperation() && "drawScene" === t;
      p && (n.save(), n._applyGlobalCompositeOperation(this)), this.children.each(function (n) {
        n[t](e, i);
      }), p && n.restore(), s && n.restore();
    }, e.prototype.getClientRect = function (t) {
      var e,
          i,
          n,
          r,
          o = (t = t || {}).skipTransform,
          a = t.relativeTo,
          s = {
        x: 1 / 0,
        y: 1 / 0,
        width: 0,
        height: 0
      },
          h = this;
      this.children.each(function (o) {
        if (o.visible()) {
          var a = o.getClientRect({
            relativeTo: h,
            skipShadow: t.skipShadow,
            skipStroke: t.skipStroke
          });
          0 === a.width && 0 === a.height || (void 0 === e ? (e = a.x, i = a.y, n = a.x + a.width, r = a.y + a.height) : (e = Math.min(e, a.x), i = Math.min(i, a.y), n = Math.max(n, a.x + a.width), r = Math.max(r, a.y + a.height)));
        }
      });

      for (var l = this.find("Shape"), c = !1, d = 0; d < l.length; d++) {
        if (l[d]._isVisible(this)) {
          c = !0;
          break;
        }
      }

      return s = c && void 0 !== e ? {
        x: e,
        y: i,
        width: n - e,
        height: r - i
      } : {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      }, o ? s : this._transformedRect(s, a);
    }, e;
  }(X);

  w.addComponentsGetterSetter(U, "clip", ["x", "y", "width", "height"]), w.addGetterSetter(U, "clipX", void 0, y()), w.addGetterSetter(U, "clipY", void 0, y()), w.addGetterSetter(U, "clipWidth", void 0, y()), w.addGetterSetter(U, "clipHeight", void 0, y()), w.addGetterSetter(U, "clipFunc"), s.mapMethods(U);
  var q = new Map(),
      K = void 0 !== r._global.PointerEvent;

  function V(t) {
    return q.get(t);
  }

  function Q(t) {
    return {
      evt: t,
      pointerId: t.pointerId
    };
  }

  function J(t, e) {
    return q.get(t) === e;
  }

  function Z(t, e) {
    $(t), e.getStage() && (q.set(t, e), K && e._fire("gotpointercapture", Q(new PointerEvent("gotpointercapture"))));
  }

  function $(t, e) {
    var i = q.get(t);

    if (i) {
      var n = i.getStage();
      n && n.content, q["delete"](t), K && i._fire("lostpointercapture", Q(new PointerEvent("lostpointercapture")));
    }
  }

  var tt = ["mouseenter", "mousedown", "mousemove", "mouseup", "mouseout", "touchstart", "touchmove", "touchend", "mouseover", "wheel", "contextmenu", "pointerdown", "pointermove", "pointerup", "pointercancel", "lostpointercapture"],
      et = tt.length;

  function it(t, e) {
    t.content.addEventListener(e, function (i) {
      t["_" + e](i);
    }, !1);
  }

  var nt = [];

  function rt(t) {
    return void 0 === t && (t = {}), (t.clipFunc || t.clipWidth || t.clipHeight) && f.warn("Stage does not support clipping. Please use clip for Layers or Groups."), t;
  }

  var ot = function (t) {
    function e(e) {
      var i = t.call(this, rt(e)) || this;
      return i._pointerPositions = [], i._changedPointerPositions = [], i._buildDOM(), i._bindContentEvents(), nt.push(i), i.on("widthChange.konva heightChange.konva", i._resizeDOM), i.on("visibleChange.konva", i._checkVisibility), i.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", function () {
        rt(i.attrs);
      }), i._checkVisibility(), i;
    }

    return P(e, t), e.prototype._validateAdd = function (t) {
      var e = "Layer" === t.getType(),
          i = "FastLayer" === t.getType();
      e || i || f["throw"]("You may only add layers to the stage.");
    }, e.prototype._checkVisibility = function () {
      if (this.content) {
        var t = this.visible() ? "" : "none";
        this.content.style.display = t;
      }
    }, e.prototype.setContainer = function (t) {
      if ("string" == typeof t) {
        if ("." === t.charAt(0)) {
          var e = t.slice(1);
          t = document.getElementsByClassName(e)[0];
        } else {
          var i;
          i = "#" !== t.charAt(0) ? t : t.slice(1), t = document.getElementById(i);
        }

        if (!t) throw "Can not find container in document with id " + i;
      }

      return this._setAttr("container", t), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), t.appendChild(this.content)), this;
    }, e.prototype.shouldDrawHit = function () {
      return !0;
    }, e.prototype.clear = function () {
      var t,
          e = this.children,
          i = e.length;

      for (t = 0; t < i; t++) {
        e[t].clear();
      }

      return this;
    }, e.prototype.clone = function (t) {
      return t || (t = {}), t.container = document.createElement("div"), U.prototype.clone.call(this, t);
    }, e.prototype.destroy = function () {
      t.prototype.destroy.call(this);
      var e = this.content;
      e && f._isInDocument(e) && this.container().removeChild(e);
      var i = nt.indexOf(this);
      return i > -1 && nt.splice(i, 1), this;
    }, e.prototype.getPointerPosition = function () {
      var t = this._pointerPositions[0] || this._changedPointerPositions[0];
      return t ? {
        x: t.x,
        y: t.y
      } : (f.warn("Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);"), null);
    }, e.prototype._getPointerById = function (t) {
      return this._pointerPositions.find(function (e) {
        return e.id === t;
      });
    }, e.prototype.getPointersPositions = function () {
      return this._pointerPositions;
    }, e.prototype.getStage = function () {
      return this;
    }, e.prototype.getContent = function () {
      return this.content;
    }, e.prototype._toKonvaCanvas = function (t) {
      (t = t || {}).x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height();

      var e = new E({
        width: t.width,
        height: t.height,
        pixelRatio: t.pixelRatio || 1
      }),
          i = e.getContext()._context,
          n = this.children;

      return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), n.each(function (e) {
        if (e.isVisible()) {
          var n = e._toKonvaCanvas(t);

          i.drawImage(n._canvas, t.x, t.y, n.getWidth() / n.getPixelRatio(), n.getHeight() / n.getPixelRatio());
        }
      }), e;
    }, e.prototype.getIntersection = function (t, e) {
      if (!t) return null;
      var i,
          n,
          r = this.children;

      for (i = r.length - 1; i >= 0; i--) {
        if (n = r[i].getIntersection(t, e)) return n;
      }

      return null;
    }, e.prototype._resizeDOM = function () {
      var t = this.width(),
          e = this.height();
      this.content && (this.content.style.width = t + "px", this.content.style.height = e + "px"), this.bufferCanvas.setSize(t, e), this.bufferHitCanvas.setSize(t, e), this.children.each(function (i) {
        i.setSize({
          width: t,
          height: e
        }), i.draw();
      });
    }, e.prototype.add = function (e) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }

        return this;
      }

      t.prototype.add.call(this, e);
      var n = this.children.length;
      return n > 5 && f.warn("The stage has " + n + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), e.setSize({
        width: this.width(),
        height: this.height()
      }), e.draw(), r.isBrowser && this.content.appendChild(e.canvas._canvas), this;
    }, e.prototype.getParent = function () {
      return null;
    }, e.prototype.getLayer = function () {
      return null;
    }, e.prototype.hasPointerCapture = function (t) {
      return J(t, this);
    }, e.prototype.setPointerCapture = function (t) {
      Z(t, this);
    }, e.prototype.releaseCapture = function (t) {
      $(t);
    }, e.prototype.getLayers = function () {
      return this.getChildren();
    }, e.prototype._bindContentEvents = function () {
      if (r.isBrowser) for (var t = 0; t < et; t++) {
        it(this, tt[t]);
      }
    }, e.prototype._mouseenter = function (t) {
      this.setPointersPositions(t), this._fire("mouseenter", {
        evt: t,
        target: this,
        currentTarget: this
      });
    }, e.prototype._mouseover = function (t) {
      this.setPointersPositions(t), this._fire("contentMouseover", {
        evt: t
      }), this._fire("mouseover", {
        evt: t,
        target: this,
        currentTarget: this
      });
    }, e.prototype._mouseout = function (t) {
      var e;
      this.setPointersPositions(t);
      var i = (null === (e = this.targetShape) || void 0 === e ? void 0 : e.getStage()) ? this.targetShape : null,
          n = !D.isDragging || r.hitOnDragEnabled;
      i && n ? (i._fireAndBubble("mouseout", {
        evt: t
      }), i._fireAndBubble("mouseleave", {
        evt: t
      }), this._fire("mouseleave", {
        evt: t,
        target: this,
        currentTarget: this
      }), this.targetShape = null) : n && (this._fire("mouseleave", {
        evt: t,
        target: this,
        currentTarget: this
      }), this._fire("mouseout", {
        evt: t,
        target: this,
        currentTarget: this
      })), this.pointerPos = void 0, this._pointerPositions = [], this._fire("contentMouseout", {
        evt: t
      });
    }, e.prototype._mousemove = function (t) {
      var e;
      if (r.UA.ieMobile) return this._touchmove(t);
      this.setPointersPositions(t);

      var i,
          n = f._getFirstPointerId(t),
          o = (null === (e = this.targetShape) || void 0 === e ? void 0 : e.getStage()) ? this.targetShape : null,
          a = !D.isDragging || r.hitOnDragEnabled;

      if (a) {
        if ((i = this.getIntersection(this.getPointerPosition())) && i.isListening()) a && o !== i ? (o && (o._fireAndBubble("mouseout", {
          evt: t,
          pointerId: n
        }, i), o._fireAndBubble("mouseleave", {
          evt: t,
          pointerId: n
        }, i)), i._fireAndBubble("mouseover", {
          evt: t,
          pointerId: n
        }, o), i._fireAndBubble("mouseenter", {
          evt: t,
          pointerId: n
        }, o), i._fireAndBubble("mousemove", {
          evt: t,
          pointerId: n
        }), this.targetShape = i) : i._fireAndBubble("mousemove", {
          evt: t,
          pointerId: n
        });else o && a && (o._fireAndBubble("mouseout", {
          evt: t,
          pointerId: n
        }), o._fireAndBubble("mouseleave", {
          evt: t,
          pointerId: n
        }), this._fire("mouseover", {
          evt: t,
          target: this,
          currentTarget: this,
          pointerId: n
        }), this.targetShape = null), this._fire("mousemove", {
          evt: t,
          target: this,
          currentTarget: this,
          pointerId: n
        });

        this._fire("contentMousemove", {
          evt: t
        });
      }

      t.cancelable && t.preventDefault();
    }, e.prototype._mousedown = function (t) {
      if (r.UA.ieMobile) return this._touchstart(t);
      this.setPointersPositions(t);

      var e = f._getFirstPointerId(t),
          i = this.getIntersection(this.getPointerPosition());

      D.justDragged = !1, r.listenClickTap = !0, i && i.isListening() ? (this.clickStartShape = i, i._fireAndBubble("mousedown", {
        evt: t,
        pointerId: e
      })) : this._fire("mousedown", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: e
      }), this._fire("contentMousedown", {
        evt: t
      });
    }, e.prototype._mouseup = function (t) {
      if (r.UA.ieMobile) return this._touchend(t);
      this.setPointersPositions(t);

      var e = f._getFirstPointerId(t),
          i = this.getIntersection(this.getPointerPosition()),
          n = this.clickStartShape,
          o = this.clickEndShape,
          a = !1;

      r.inDblClickWindow ? (a = !0, clearTimeout(this.dblTimeout)) : D.justDragged || (r.inDblClickWindow = !0, clearTimeout(this.dblTimeout)), this.dblTimeout = setTimeout(function () {
        r.inDblClickWindow = !1;
      }, r.dblClickWindow), i && i.isListening() ? (this.clickEndShape = i, i._fireAndBubble("mouseup", {
        evt: t,
        pointerId: e
      }), r.listenClickTap && n && n._id === i._id && (i._fireAndBubble("click", {
        evt: t,
        pointerId: e
      }), a && o && o === i && i._fireAndBubble("dblclick", {
        evt: t,
        pointerId: e
      }))) : (this.clickEndShape = null, this._fire("mouseup", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: e
      }), r.listenClickTap && this._fire("click", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: e
      }), a && this._fire("dblclick", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: e
      })), this._fire("contentMouseup", {
        evt: t
      }), r.listenClickTap && (this._fire("contentClick", {
        evt: t
      }), a && this._fire("contentDblclick", {
        evt: t
      })), r.listenClickTap = !1, t.cancelable && t.preventDefault();
    }, e.prototype._contextmenu = function (t) {
      this.setPointersPositions(t);
      var e = this.getIntersection(this.getPointerPosition());
      e && e.isListening() ? e._fireAndBubble("contextmenu", {
        evt: t
      }) : this._fire("contextmenu", {
        evt: t,
        target: this,
        currentTarget: this
      }), this._fire("contentContextmenu", {
        evt: t
      });
    }, e.prototype._touchstart = function (t) {
      var e = this;
      this.setPointersPositions(t);
      var i = !1;
      this._changedPointerPositions.forEach(function (n) {
        var o = e.getIntersection(n);
        r.listenClickTap = !0, D.justDragged = !1, o && o.isListening() && (r.captureTouchEventsEnabled && o.setPointerCapture(n.id), e.tapStartShape = o, o._fireAndBubble("touchstart", {
          evt: t,
          pointerId: n.id
        }, e), i = !0, o.isListening() && o.preventDefault() && t.cancelable && t.preventDefault());
      }), i || this._fire("touchstart", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      }), this._fire("contentTouchstart", {
        evt: t
      });
    }, e.prototype._touchmove = function (t) {
      var e = this;

      if (this.setPointersPositions(t), !D.isDragging || r.hitOnDragEnabled) {
        var i = !1,
            n = {};
        this._changedPointerPositions.forEach(function (r) {
          var o = V(r.id) || e.getIntersection(r);
          o && o.isListening() && (n[o._id] || (n[o._id] = !0, o._fireAndBubble("touchmove", {
            evt: t,
            pointerId: r.id
          }), i = !0, o.isListening() && o.preventDefault() && t.cancelable && t.preventDefault()));
        }), i || this._fire("touchmove", {
          evt: t,
          target: this,
          currentTarget: this,
          pointerId: this._changedPointerPositions[0].id
        }), this._fire("contentTouchmove", {
          evt: t
        });
      }

      D.isDragging && D.node.preventDefault() && t.cancelable && t.preventDefault();
    }, e.prototype._touchend = function (t) {
      var e = this;
      this.setPointersPositions(t);
      var i = this.tapEndShape,
          n = !1;
      r.inDblClickWindow ? (n = !0, clearTimeout(this.dblTimeout)) : D.justDragged || (r.inDblClickWindow = !0, clearTimeout(this.dblTimeout)), this.dblTimeout = setTimeout(function () {
        r.inDblClickWindow = !1;
      }, r.dblClickWindow);
      var o = !1,
          a = {},
          s = !1,
          h = !1;
      this._changedPointerPositions.forEach(function (l) {
        var c = V(l.id) || e.getIntersection(l);
        c && c.releaseCapture(l.id), c && c.isListening() && (a[c._id] || (a[c._id] = !0, e.tapEndShape = c, c._fireAndBubble("touchend", {
          evt: t,
          pointerId: l.id
        }), o = !0, r.listenClickTap && c === e.tapStartShape && (s = !0, c._fireAndBubble("tap", {
          evt: t,
          pointerId: l.id
        }), n && i && i === c && (h = !0, c._fireAndBubble("dbltap", {
          evt: t,
          pointerId: l.id
        }))), c.isListening() && c.preventDefault() && t.cancelable && t.preventDefault()));
      }), o || this._fire("touchend", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      }), r.listenClickTap && !s && (this.tapEndShape = null, this._fire("tap", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      })), n && !h && this._fire("dbltap", {
        evt: t,
        target: this,
        currentTarget: this,
        pointerId: this._changedPointerPositions[0].id
      }), this._fire("contentTouchend", {
        evt: t
      }), r.listenClickTap && (this._fire("contentTap", {
        evt: t
      }), n && this._fire("contentDbltap", {
        evt: t
      })), this.preventDefault() && t.cancelable && t.preventDefault(), r.listenClickTap = !1;
    }, e.prototype._wheel = function (t) {
      this.setPointersPositions(t);
      var e = this.getIntersection(this.getPointerPosition());
      e && e.isListening() ? e._fireAndBubble("wheel", {
        evt: t
      }) : this._fire("wheel", {
        evt: t,
        target: this,
        currentTarget: this
      }), this._fire("contentWheel", {
        evt: t
      });
    }, e.prototype._pointerdown = function (t) {
      if (r._pointerEventsEnabled) {
        this.setPointersPositions(t);
        var e = V(t.pointerId) || this.getIntersection(this.getPointerPosition());
        e && e._fireAndBubble("pointerdown", Q(t));
      }
    }, e.prototype._pointermove = function (t) {
      if (r._pointerEventsEnabled) {
        this.setPointersPositions(t);
        var e = V(t.pointerId) || this.getIntersection(this.getPointerPosition());
        e && e._fireAndBubble("pointermove", Q(t));
      }
    }, e.prototype._pointerup = function (t) {
      if (r._pointerEventsEnabled) {
        this.setPointersPositions(t);
        var e = V(t.pointerId) || this.getIntersection(this.getPointerPosition());
        e && e._fireAndBubble("pointerup", Q(t)), $(t.pointerId);
      }
    }, e.prototype._pointercancel = function (t) {
      if (r._pointerEventsEnabled) {
        this.setPointersPositions(t);
        var e = V(t.pointerId) || this.getIntersection(this.getPointerPosition());
        e && e._fireAndBubble("pointerup", Q(t)), $(t.pointerId);
      }
    }, e.prototype._lostpointercapture = function (t) {
      $(t.pointerId);
    }, e.prototype.setPointersPositions = function (t) {
      var e = this,
          i = this._getContentPosition(),
          n = null,
          r = null;

      void 0 !== (t = t || window.event).touches ? (this._pointerPositions = [], this._changedPointerPositions = [], s.prototype.each.call(t.touches, function (t) {
        e._pointerPositions.push({
          id: t.identifier,
          x: (t.clientX - i.left) / i.scaleX,
          y: (t.clientY - i.top) / i.scaleY
        });
      }), s.prototype.each.call(t.changedTouches || t.touches, function (t) {
        e._changedPointerPositions.push({
          id: t.identifier,
          x: (t.clientX - i.left) / i.scaleX,
          y: (t.clientY - i.top) / i.scaleY
        });
      })) : (n = (t.clientX - i.left) / i.scaleX, r = (t.clientY - i.top) / i.scaleY, this.pointerPos = {
        x: n,
        y: r
      }, this._pointerPositions = [{
        x: n,
        y: r,
        id: f._getFirstPointerId(t)
      }], this._changedPointerPositions = [{
        x: n,
        y: r,
        id: f._getFirstPointerId(t)
      }]);
    }, e.prototype._setPointerPosition = function (t) {
      f.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t);
    }, e.prototype._getContentPosition = function () {
      if (!this.content || !this.content.getBoundingClientRect) return {
        top: 0,
        left: 0,
        scaleX: 1,
        scaleY: 1
      };
      var t = this.content.getBoundingClientRect();
      return {
        top: t.top,
        left: t.left,
        scaleX: t.width / this.content.clientWidth || 1,
        scaleY: t.height / this.content.clientHeight || 1
      };
    }, e.prototype._buildDOM = function () {
      if (this.bufferCanvas = new E({
        width: this.width(),
        height: this.height()
      }), this.bufferHitCanvas = new O({
        pixelRatio: 1,
        width: this.width(),
        height: this.height()
      }), r.isBrowser) {
        var t = this.container();
        if (!t) throw "Stage has no container. A container is required.";
        t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM();
      }
    }, e.prototype.cache = function () {
      return f.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this;
    }, e.prototype.clearCache = function () {
      return this;
    }, e.prototype.batchDraw = function () {
      return this.children.each(function (t) {
        t.batchDraw();
      }), this;
    }, e;
  }(U);

  ot.prototype.nodeType = "Stage", a(ot), w.addGetterSetter(ot, "container");
  var at;

  function st() {
    return at || (at = f.createCanvasElement().getContext("2d"));
  }

  var ht = {};

  var lt = function (t) {
    function e(e) {
      for (var i, n = t.call(this, e) || this; !(i = f.getRandomColor()) || i in ht;) {
        ;
      }

      return n.colorKey = i, ht[i] = n, n;
    }

    return P(e, t), e.prototype.getContext = function () {
      return this.getLayer().getContext();
    }, e.prototype.getCanvas = function () {
      return this.getLayer().getCanvas();
    }, e.prototype.getSceneFunc = function () {
      return this.attrs.sceneFunc || this._sceneFunc;
    }, e.prototype.getHitFunc = function () {
      return this.attrs.hitFunc || this._hitFunc;
    }, e.prototype.hasShadow = function () {
      return this._getCache("hasShadow", this._hasShadow);
    }, e.prototype._hasShadow = function () {
      return this.shadowEnabled() && 0 !== this.shadowOpacity() && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());
    }, e.prototype._getFillPattern = function () {
      return this._getCache("patternImage", this.__getFillPattern);
    }, e.prototype.__getFillPattern = function () {
      if (this.fillPatternImage()) {
        var t = st().createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat");
        return t && t.setTransform && t.setTransform({
          a: this.fillPatternScaleX(),
          b: 0,
          c: 0,
          d: this.fillPatternScaleY(),
          e: 0,
          f: 0
        }), t;
      }
    }, e.prototype._getLinearGradient = function () {
      return this._getCache("linearGradient", this.__getLinearGradient);
    }, e.prototype.__getLinearGradient = function () {
      var t = this.fillLinearGradientColorStops();

      if (t) {
        for (var e = st(), i = this.fillLinearGradientStartPoint(), n = this.fillLinearGradientEndPoint(), r = e.createLinearGradient(i.x, i.y, n.x, n.y), o = 0; o < t.length; o += 2) {
          r.addColorStop(t[o], t[o + 1]);
        }

        return r;
      }
    }, e.prototype._getRadialGradient = function () {
      return this._getCache("radialGradient", this.__getRadialGradient);
    }, e.prototype.__getRadialGradient = function () {
      var t = this.fillRadialGradientColorStops();

      if (t) {
        for (var e = st(), i = this.fillRadialGradientStartPoint(), n = this.fillRadialGradientEndPoint(), r = e.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), n.x, n.y, this.fillRadialGradientEndRadius()), o = 0; o < t.length; o += 2) {
          r.addColorStop(t[o], t[o + 1]);
        }

        return r;
      }
    }, e.prototype.getShadowRGBA = function () {
      return this._getCache("shadowRGBA", this._getShadowRGBA);
    }, e.prototype._getShadowRGBA = function () {
      if (this.hasShadow()) {
        var t = f.colorToRGBA(this.shadowColor());
        return "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")";
      }
    }, e.prototype.hasFill = function () {
      var t = this;
      return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], function () {
        return t.fillEnabled() && !!(t.fill() || t.fillPatternImage() || t.fillLinearGradientColorStops() || t.fillRadialGradientColorStops());
      });
    }, e.prototype.hasStroke = function () {
      var t = this;
      return this._calculate("hasStroke", ["strokeEnabled", "strokeWidth", "stroke", "strokeLinearGradientColorStops"], function () {
        return t.strokeEnabled() && t.strokeWidth() && !(!t.stroke() && !t.strokeLinearGradientColorStops());
      });
    }, e.prototype.hasHitStroke = function () {
      var t = this.hitStrokeWidth();
      return "auto" === t ? this.hasStroke() : this.strokeEnabled() && !!t;
    }, e.prototype.intersects = function (t) {
      var e = this.getStage().bufferHitCanvas;
      return e.getContext().clear(), this.drawHit(e, null, !0), e.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data[3] > 0;
    }, e.prototype.destroy = function () {
      return X.prototype.destroy.call(this), delete ht[this.colorKey], delete this.colorKey, this;
    }, e.prototype._useBufferCanvas = function (t) {
      var e;
      if (!this.getStage()) return !1;
      if (!(null === (e = this.attrs.perfectDrawEnabled) || void 0 === e || e)) return !1;
      var i = t || this.hasFill(),
          n = this.hasStroke(),
          r = 1 !== this.getAbsoluteOpacity();
      if (i && n && r) return !0;
      var o = this.hasShadow(),
          a = this.shadowForStrokeEnabled();
      return !!(i && n && o && a);
    }, e.prototype.setStrokeHitEnabled = function (t) {
      f.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0);
    }, e.prototype.getStrokeHitEnabled = function () {
      return 0 !== this.hitStrokeWidth();
    }, e.prototype.getSelfRect = function () {
      var t = this.size();
      return {
        x: this._centroid ? -t.width / 2 : 0,
        y: this._centroid ? -t.height / 2 : 0,
        width: t.width,
        height: t.height
      };
    }, e.prototype.getClientRect = function (t) {
      void 0 === t && (t = {});
      var e = t.skipTransform,
          i = t.relativeTo,
          n = this.getSelfRect(),
          r = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0,
          o = n.width + r,
          a = n.height + r,
          s = !t.skipShadow && this.hasShadow(),
          h = s ? this.shadowOffsetX() : 0,
          l = s ? this.shadowOffsetY() : 0,
          c = o + Math.abs(h),
          d = a + Math.abs(l),
          u = s && this.shadowBlur() || 0,
          p = c + 2 * u,
          f = d + 2 * u,
          g = 0;
      Math.round(r / 2) !== r / 2 && (g = 1);
      var v = {
        width: p + g,
        height: f + g,
        x: -Math.round(r / 2 + u) + Math.min(h, 0) + n.x,
        y: -Math.round(r / 2 + u) + Math.min(l, 0) + n.y
      };
      return e ? v : this._transformedRect(v, i);
    }, e.prototype.drawScene = function (t, e) {
      var i,
          n,
          r = this.getLayer(),
          o = t || r.getCanvas(),
          a = o.getContext(),
          s = this._getCanvasCache(),
          h = this.getSceneFunc(),
          l = this.hasShadow(),
          c = o.isCache,
          d = o.isCache,
          u = e === this;

      if (!this.isVisible() && !c) return this;

      if (s) {
        a.save();
        var p = this.getAbsoluteTransform(e).getMatrix();
        return a.transform(p[0], p[1], p[2], p[3], p[4], p[5]), this._drawCachedSceneCanvas(a), a.restore(), this;
      }

      if (!h) return this;

      if (a.save(), this._useBufferCanvas() && !d) {
        (n = (i = this.getStage().bufferCanvas).getContext()).clear(), n.save(), n._applyLineJoin(this);
        var f = this.getAbsoluteTransform(e).getMatrix();
        n.transform(f[0], f[1], f[2], f[3], f[4], f[5]), h.call(this, n, this), n.restore();
        var g = i.pixelRatio;
        l && a._applyShadow(this), a._applyOpacity(this), a._applyGlobalCompositeOperation(this), a.drawImage(i._canvas, 0, 0, i.width / g, i.height / g);
      } else {
        if (a._applyLineJoin(this), !u) {
          f = this.getAbsoluteTransform(e).getMatrix();
          a.transform(f[0], f[1], f[2], f[3], f[4], f[5]), a._applyOpacity(this), a._applyGlobalCompositeOperation(this);
        }

        l && a._applyShadow(this), h.call(this, a, this);
      }

      return a.restore(), this;
    }, e.prototype.drawHit = function (t, e, i) {
      if (void 0 === i && (i = !1), !this.shouldDrawHit(e, i)) return this;

      var n = this.getLayer(),
          r = t || n.hitCanvas,
          o = r && r.getContext(),
          a = this.hitFunc() || this.sceneFunc(),
          s = this._getCanvasCache(),
          h = s && s.hit;

      if (this.colorKey || (console.log(this), f.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. See the shape in logs above. If you want to reuse shape you should call remove() instead of destroy()")), h) {
        o.save();
        var l = this.getAbsoluteTransform(e).getMatrix();
        return o.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(o), o.restore(), this;
      }

      if (!a) return this;

      if (o.save(), o._applyLineJoin(this), !(this === e)) {
        var c = this.getAbsoluteTransform(e).getMatrix();
        o.transform(c[0], c[1], c[2], c[3], c[4], c[5]);
      }

      return a.call(this, o, this), o.restore(), this;
    }, e.prototype.drawHitFromCache = function (t) {
      void 0 === t && (t = 0);

      var e,
          i,
          n,
          r,
          o,
          a = this._getCanvasCache(),
          s = this._getCachedSceneCanvas(),
          h = a.hit,
          l = h.getContext(),
          c = h.getWidth(),
          d = h.getHeight();

      l.clear(), l.drawImage(s._canvas, 0, 0, c, d);

      try {
        for (n = (i = (e = l.getImageData(0, 0, c, d)).data).length, r = f._hexToRgb(this.colorKey), o = 0; o < n; o += 4) {
          i[o + 3] > t ? (i[o] = r.r, i[o + 1] = r.g, i[o + 2] = r.b, i[o + 3] = 255) : i[o + 3] = 0;
        }

        l.putImageData(e, 0, 0);
      } catch (t) {
        f.error("Unable to draw hit graph from cached scene canvas. " + t.message);
      }

      return this;
    }, e.prototype.hasPointerCapture = function (t) {
      return J(t, this);
    }, e.prototype.setPointerCapture = function (t) {
      Z(t, this);
    }, e.prototype.releaseCapture = function (t) {
      $(t);
    }, e;
  }(X);

  lt.prototype._fillFunc = function (t) {
    t.fill();
  }, lt.prototype._strokeFunc = function (t) {
    t.stroke();
  }, lt.prototype._fillFuncHit = function (t) {
    t.fill();
  }, lt.prototype._strokeFuncHit = function (t) {
    t.stroke();
  }, lt.prototype._centroid = !1, lt.prototype.nodeType = "Shape", a(lt), lt.prototype.eventListeners = {}, lt.prototype.on.call(lt.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", function () {
    this._clearCache("hasShadow");
  }), lt.prototype.on.call(lt.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", function () {
    this._clearCache("shadowRGBA");
  }), lt.prototype.on.call(lt.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva", function () {
    this._clearCache("patternImage");
  }), lt.prototype.on.call(lt.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", function () {
    this._clearCache("linearGradient");
  }), lt.prototype.on.call(lt.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", function () {
    this._clearCache("radialGradient");
  }), w.addGetterSetter(lt, "stroke", void 0, x()), w.addGetterSetter(lt, "strokeWidth", 2, y()), w.addGetterSetter(lt, "fillAfterStrokeEnabled", !1), w.addGetterSetter(lt, "hitStrokeWidth", "auto", _()), w.addGetterSetter(lt, "strokeHitEnabled", !0, S()), w.addGetterSetter(lt, "perfectDrawEnabled", !0, S()), w.addGetterSetter(lt, "shadowForStrokeEnabled", !0, S()), w.addGetterSetter(lt, "lineJoin"), w.addGetterSetter(lt, "lineCap"), w.addGetterSetter(lt, "sceneFunc"), w.addGetterSetter(lt, "hitFunc"), w.addGetterSetter(lt, "dash"), w.addGetterSetter(lt, "dashOffset", 0, y()), w.addGetterSetter(lt, "shadowColor", void 0, b()), w.addGetterSetter(lt, "shadowBlur", 0, y()), w.addGetterSetter(lt, "shadowOpacity", 1, y()), w.addComponentsGetterSetter(lt, "shadowOffset", ["x", "y"]), w.addGetterSetter(lt, "shadowOffsetX", 0, y()), w.addGetterSetter(lt, "shadowOffsetY", 0, y()), w.addGetterSetter(lt, "fillPatternImage"), w.addGetterSetter(lt, "fill", void 0, x()), w.addGetterSetter(lt, "fillPatternX", 0, y()), w.addGetterSetter(lt, "fillPatternY", 0, y()), w.addGetterSetter(lt, "fillLinearGradientColorStops"), w.addGetterSetter(lt, "strokeLinearGradientColorStops"), w.addGetterSetter(lt, "fillRadialGradientStartRadius", 0), w.addGetterSetter(lt, "fillRadialGradientEndRadius", 0), w.addGetterSetter(lt, "fillRadialGradientColorStops"), w.addGetterSetter(lt, "fillPatternRepeat", "repeat"), w.addGetterSetter(lt, "fillEnabled", !0), w.addGetterSetter(lt, "strokeEnabled", !0), w.addGetterSetter(lt, "shadowEnabled", !0), w.addGetterSetter(lt, "dashEnabled", !0), w.addGetterSetter(lt, "strokeScaleEnabled", !0), w.addGetterSetter(lt, "fillPriority", "color"), w.addComponentsGetterSetter(lt, "fillPatternOffset", ["x", "y"]), w.addGetterSetter(lt, "fillPatternOffsetX", 0, y()), w.addGetterSetter(lt, "fillPatternOffsetY", 0, y()), w.addComponentsGetterSetter(lt, "fillPatternScale", ["x", "y"]), w.addGetterSetter(lt, "fillPatternScaleX", 1, y()), w.addGetterSetter(lt, "fillPatternScaleY", 1, y()), w.addComponentsGetterSetter(lt, "fillLinearGradientStartPoint", ["x", "y"]), w.addComponentsGetterSetter(lt, "strokeLinearGradientStartPoint", ["x", "y"]), w.addGetterSetter(lt, "fillLinearGradientStartPointX", 0), w.addGetterSetter(lt, "strokeLinearGradientStartPointX", 0), w.addGetterSetter(lt, "fillLinearGradientStartPointY", 0), w.addGetterSetter(lt, "strokeLinearGradientStartPointY", 0), w.addComponentsGetterSetter(lt, "fillLinearGradientEndPoint", ["x", "y"]), w.addComponentsGetterSetter(lt, "strokeLinearGradientEndPoint", ["x", "y"]), w.addGetterSetter(lt, "fillLinearGradientEndPointX", 0), w.addGetterSetter(lt, "strokeLinearGradientEndPointX", 0), w.addGetterSetter(lt, "fillLinearGradientEndPointY", 0), w.addGetterSetter(lt, "strokeLinearGradientEndPointY", 0), w.addComponentsGetterSetter(lt, "fillRadialGradientStartPoint", ["x", "y"]), w.addGetterSetter(lt, "fillRadialGradientStartPointX", 0), w.addGetterSetter(lt, "fillRadialGradientStartPointY", 0), w.addComponentsGetterSetter(lt, "fillRadialGradientEndPoint", ["x", "y"]), w.addGetterSetter(lt, "fillRadialGradientEndPointX", 0), w.addGetterSetter(lt, "fillRadialGradientEndPointY", 0), w.addGetterSetter(lt, "fillPatternRotation", 0), w.backCompat(lt, {
    dashArray: "dash",
    getDashArray: "getDash",
    setDashArray: "getDash",
    drawFunc: "sceneFunc",
    getDrawFunc: "getSceneFunc",
    setDrawFunc: "setSceneFunc",
    drawHitFunc: "hitFunc",
    getDrawHitFunc: "getHitFunc",
    setDrawHitFunc: "setHitFunc"
  }), s.mapMethods(lt);

  var ct = [{
    x: 0,
    y: 0
  }, {
    x: -1,
    y: -1
  }, {
    x: 1,
    y: -1
  }, {
    x: 1,
    y: 1
  }, {
    x: -1,
    y: 1
  }],
      dt = ct.length,
      ut = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i.canvas = new E(), i.hitCanvas = new O({
        pixelRatio: 1
      }), i._waitingForDraw = !1, i.on("visibleChange.konva", i._checkVisibility), i._checkVisibility(), i.on("imageSmoothingEnabledChange.konva", i._setSmoothEnabled), i._setSmoothEnabled(), i;
    }

    return P(e, t), e.prototype.createPNGStream = function () {
      return this.canvas._canvas.createPNGStream();
    }, e.prototype.getCanvas = function () {
      return this.canvas;
    }, e.prototype.getHitCanvas = function () {
      return this.hitCanvas;
    }, e.prototype.getContext = function () {
      return this.getCanvas().getContext();
    }, e.prototype.clear = function (t) {
      return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this;
    }, e.prototype.setZIndex = function (e) {
      t.prototype.setZIndex.call(this, e);
      var i = this.getStage();
      return i && (i.content.removeChild(this.getCanvas()._canvas), e < i.children.length - 1 ? i.content.insertBefore(this.getCanvas()._canvas, i.children[e + 1].getCanvas()._canvas) : i.content.appendChild(this.getCanvas()._canvas)), this;
    }, e.prototype.moveToTop = function () {
      X.prototype.moveToTop.call(this);
      var t = this.getStage();
      return t && (t.content.removeChild(this.getCanvas()._canvas), t.content.appendChild(this.getCanvas()._canvas)), !0;
    }, e.prototype.moveUp = function () {
      if (!X.prototype.moveUp.call(this)) return !1;
      var t = this.getStage();
      return !!t && (t.content.removeChild(this.getCanvas()._canvas), this.index < t.children.length - 1 ? t.content.insertBefore(this.getCanvas()._canvas, t.children[this.index + 1].getCanvas()._canvas) : t.content.appendChild(this.getCanvas()._canvas), !0);
    }, e.prototype.moveDown = function () {
      if (X.prototype.moveDown.call(this)) {
        var t = this.getStage();

        if (t) {
          var e = t.children;
          t.content.removeChild(this.getCanvas()._canvas), t.content.insertBefore(this.getCanvas()._canvas, e[this.index + 1].getCanvas()._canvas);
        }

        return !0;
      }

      return !1;
    }, e.prototype.moveToBottom = function () {
      if (X.prototype.moveToBottom.call(this)) {
        var t = this.getStage();

        if (t) {
          var e = t.children;
          t.content.removeChild(this.getCanvas()._canvas), t.content.insertBefore(this.getCanvas()._canvas, e[1].getCanvas()._canvas);
        }

        return !0;
      }

      return !1;
    }, e.prototype.getLayer = function () {
      return this;
    }, e.prototype.remove = function () {
      var t = this.getCanvas()._canvas;

      return X.prototype.remove.call(this), t && t.parentNode && f._isInDocument(t) && t.parentNode.removeChild(t), this;
    }, e.prototype.getStage = function () {
      return this.parent;
    }, e.prototype.setSize = function (t) {
      var e = t.width,
          i = t.height;
      return this.canvas.setSize(e, i), this.hitCanvas.setSize(e, i), this._setSmoothEnabled(), this;
    }, e.prototype._validateAdd = function (t) {
      var e = t.getType();
      "Group" !== e && "Shape" !== e && f["throw"]("You may only add groups and shapes to a layer.");
    }, e.prototype._toKonvaCanvas = function (t) {
      return (t = t || {}).width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = void 0 !== t.x ? t.x : this.x(), t.y = void 0 !== t.y ? t.y : this.y(), X.prototype._toKonvaCanvas.call(this, t);
    }, e.prototype._checkVisibility = function () {
      var t = this.visible();
      this.canvas._canvas.style.display = t ? "block" : "none";
    }, e.prototype._setSmoothEnabled = function () {
      this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();
    }, e.prototype.getWidth = function () {
      if (this.parent) return this.parent.width();
    }, e.prototype.setWidth = function () {
      f.warn('Can not change width of layer. Use "stage.width(value)" function instead.');
    }, e.prototype.getHeight = function () {
      if (this.parent) return this.parent.height();
    }, e.prototype.setHeight = function () {
      f.warn('Can not change height of layer. Use "stage.height(value)" function instead.');
    }, e.prototype.batchDraw = function () {
      var t = this;
      return this._waitingForDraw || (this._waitingForDraw = !0, f.requestAnimFrame(function () {
        t.draw(), t._waitingForDraw = !1;
      })), this;
    }, e.prototype.getIntersection = function (t, e) {
      if (!this.isListening() || !this.isVisible()) return null;

      for (var i = 1, n = !1;;) {
        for (var r = 0; r < dt; r++) {
          var o = ct[r],
              a = this._getIntersection({
            x: t.x + o.x * i,
            y: t.y + o.y * i
          }),
              s = a.shape;

          if (s && e) return s.findAncestor(e, !0);
          if (s) return s;
          if (n = !!a.antialiased, !a.antialiased) break;
        }

        if (!n) return null;
        i += 1;
      }
    }, e.prototype._getIntersection = function (t) {
      var e = this.hitCanvas.pixelRatio,
          i = this.hitCanvas.context.getImageData(Math.round(t.x * e), Math.round(t.y * e), 1, 1).data,
          n = i[3];

      if (255 === n) {
        var r = f._rgbToHex(i[0], i[1], i[2]),
            o = ht["#" + r];

        return o ? {
          shape: o
        } : {
          antialiased: !0
        };
      }

      return n > 0 ? {
        antialiased: !0
      } : {};
    }, e.prototype.drawScene = function (t, e) {
      var i = this.getLayer(),
          n = t || i && i.getCanvas();
      return this._fire("beforeDraw", {
        node: this
      }), this.clearBeforeDraw() && n.getContext().clear(), U.prototype.drawScene.call(this, n, e), this._fire("draw", {
        node: this
      }), this;
    }, e.prototype.drawHit = function (t, e) {
      var i = this.getLayer(),
          n = t || i && i.hitCanvas;
      return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), U.prototype.drawHit.call(this, n, e), this;
    }, e.prototype.enableHitGraph = function () {
      return this.hitGraphEnabled(!0), this;
    }, e.prototype.disableHitGraph = function () {
      return this.hitGraphEnabled(!1), this;
    }, e.prototype.setHitGraphEnabled = function (t) {
      f.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t);
    }, e.prototype.getHitGraphEnabled = function (t) {
      return f.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening();
    }, e.prototype.toggleHitCanvas = function () {
      if (this.parent) {
        var t = this.parent;
        !!this.hitCanvas._canvas.parentNode ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas);
      }
    }, e;
  }(U);

  ut.prototype.nodeType = "Layer", a(ut), w.addGetterSetter(ut, "imageSmoothingEnabled", !0), w.addGetterSetter(ut, "clearBeforeDraw", !0), w.addGetterSetter(ut, "hitGraphEnabled", !0, S()), s.mapMethods(ut);

  var pt = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i.listening(!1), f.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.'), i;
    }

    return P(e, t), e;
  }(ut);

  pt.prototype.nodeType = "FastLayer", a(pt), s.mapMethods(pt);

  var ft = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._validateAdd = function (t) {
      var e = t.getType();
      "Group" !== e && "Shape" !== e && f["throw"]("You may only add groups and shapes to groups.");
    }, e;
  }(U);

  ft.prototype.nodeType = "Group", a(ft), s.mapMethods(ft);

  var gt = n.performance && n.performance.now ? function () {
    return n.performance.now();
  } : function () {
    return new Date().getTime();
  },
      vt = function () {
    function t(e, i) {
      this.id = t.animIdCounter++, this.frame = {
        time: 0,
        timeDiff: 0,
        lastTime: gt(),
        frameRate: 0
      }, this.func = e, this.setLayers(i);
    }

    return t.prototype.setLayers = function (t) {
      var e = [];
      return e = t ? t.length > 0 ? t : [t] : [], this.layers = e, this;
    }, t.prototype.getLayers = function () {
      return this.layers;
    }, t.prototype.addLayer = function (t) {
      var e,
          i = this.layers,
          n = i.length;

      for (e = 0; e < n; e++) {
        if (i[e]._id === t._id) return !1;
      }

      return this.layers.push(t), !0;
    }, t.prototype.isRunning = function () {
      var e,
          i = t.animations,
          n = i.length;

      for (e = 0; e < n; e++) {
        if (i[e].id === this.id) return !0;
      }

      return !1;
    }, t.prototype.start = function () {
      return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = gt(), t._addAnimation(this), this;
    }, t.prototype.stop = function () {
      return t._removeAnimation(this), this;
    }, t.prototype._updateFrameObject = function (t) {
      this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff;
    }, t._addAnimation = function (t) {
      this.animations.push(t), this._handleAnimation();
    }, t._removeAnimation = function (t) {
      var e,
          i = t.id,
          n = this.animations,
          r = n.length;

      for (e = 0; e < r; e++) {
        if (n[e].id === i) {
          this.animations.splice(e, 1);
          break;
        }
      }
    }, t._runFrames = function () {
      var t,
          e,
          i,
          n,
          r,
          o,
          a,
          s,
          h = {},
          l = this.animations;

      for (n = 0; n < l.length; n++) {
        if (e = (t = l[n]).layers, i = t.func, t._updateFrameObject(gt()), o = e.length, !i || !1 !== i.call(t, t.frame)) for (r = 0; r < o; r++) {
          void 0 !== (a = e[r])._id && (h[a._id] = a);
        }
      }

      for (s in h) {
        h.hasOwnProperty(s) && h[s].draw();
      }
    }, t._animationLoop = function () {
      var e = t;
      e.animations.length ? (e._runFrames(), requestAnimationFrame(e._animationLoop)) : e.animRunning = !1;
    }, t._handleAnimation = function () {
      this.animRunning || (this.animRunning = !0, requestAnimationFrame(this._animationLoop));
    }, t.animations = [], t.animIdCounter = 0, t.animRunning = !1, t;
  }(),
      yt = {
    node: 1,
    duration: 1,
    easing: 1,
    onFinish: 1,
    yoyo: 1
  },
      mt = 0,
      _t = ["fill", "stroke", "shadowColor"],
      bt = function () {
    function t(t, e, i, n, r, o, a) {
      this.prop = t, this.propFunc = e, this.begin = n, this._pos = n, this.duration = o, this._change = 0, this.prevPos = 0, this.yoyo = a, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = r - this.begin, this.pause();
    }

    return t.prototype.fire = function (t) {
      var e = this[t];
      e && e();
    }, t.prototype.setTime = function (t) {
      t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update());
    }, t.prototype.getTime = function () {
      return this._time;
    }, t.prototype.setPosition = function (t) {
      this.prevPos = this._pos, this.propFunc(t), this._pos = t;
    }, t.prototype.getPosition = function (t) {
      return void 0 === t && (t = this._time), this.func(t, this.begin, this._change, this.duration);
    }, t.prototype.play = function () {
      this.state = 2, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay");
    }, t.prototype.reverse = function () {
      this.state = 3, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse");
    }, t.prototype.seek = function (t) {
      this.pause(), this._time = t, this.update(), this.fire("onSeek");
    }, t.prototype.reset = function () {
      this.pause(), this._time = 0, this.update(), this.fire("onReset");
    }, t.prototype.finish = function () {
      this.pause(), this._time = this.duration, this.update(), this.fire("onFinish");
    }, t.prototype.update = function () {
      this.setPosition(this.getPosition(this._time)), this.fire("onUpdate");
    }, t.prototype.onEnterFrame = function () {
      var t = this.getTimer() - this._startTime;

      2 === this.state ? this.setTime(t) : 3 === this.state && this.setTime(this.duration - t);
    }, t.prototype.pause = function () {
      this.state = 1, this.fire("onPause");
    }, t.prototype.getTimer = function () {
      return new Date().getTime();
    }, t;
  }(),
      xt = function () {
    function t(e) {
      var i,
          n,
          o = this,
          a = e.node,
          s = a._id,
          h = e.easing || St.Linear,
          l = !!e.yoyo;
      i = void 0 === e.duration ? .3 : 0 === e.duration ? .001 : e.duration, this.node = a, this._id = mt++;
      var c = a.getLayer() || (a instanceof r.Stage ? a.getLayers() : null);

      for (n in c || f.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new vt(function () {
        o.tween.onEnterFrame();
      }, c), this.tween = new bt(n, function (t) {
        o._tweenFunc(t);
      }, h, 0, 1, 1e3 * i, l), this._addListeners(), t.attrs[s] || (t.attrs[s] = {}), t.attrs[s][this._id] || (t.attrs[s][this._id] = {}), t.tweens[s] || (t.tweens[s] = {}), e) {
        void 0 === yt[n] && this._addAttr(n, e[n]);
      }

      this.reset(), this.onFinish = e.onFinish, this.onReset = e.onReset, this.onUpdate = e.onUpdate;
    }

    return t.prototype._addAttr = function (e, i) {
      var n,
          r,
          o,
          a,
          s,
          h,
          l,
          c,
          d = this.node,
          u = d._id;
      if ((o = t.tweens[u][e]) && delete t.attrs[u][o][e], n = d.getAttr(e), f._isArray(i)) {
        if (r = [], s = Math.max(i.length, n.length), "points" === e && i.length !== n.length && (i.length > n.length ? (l = n, n = f._prepareArrayForTween(n, i, d.closed())) : (h = i, i = f._prepareArrayForTween(i, n, d.closed()))), 0 === e.indexOf("fill")) for (a = 0; a < s; a++) {
          if (a % 2 == 0) r.push(i[a] - n[a]);else {
            var p = f.colorToRGBA(n[a]);
            c = f.colorToRGBA(i[a]), n[a] = p, r.push({
              r: c.r - p.r,
              g: c.g - p.g,
              b: c.b - p.b,
              a: c.a - p.a
            });
          }
        } else for (a = 0; a < s; a++) {
          r.push(i[a] - n[a]);
        }
      } else -1 !== _t.indexOf(e) ? (n = f.colorToRGBA(n), r = {
        r: (c = f.colorToRGBA(i)).r - n.r,
        g: c.g - n.g,
        b: c.b - n.b,
        a: c.a - n.a
      }) : r = i - n;
      t.attrs[u][this._id][e] = {
        start: n,
        diff: r,
        end: i,
        trueEnd: h,
        trueStart: l
      }, t.tweens[u][e] = this._id;
    }, t.prototype._tweenFunc = function (e) {
      var i,
          n,
          r,
          o,
          a,
          s,
          h,
          l,
          c = this.node,
          d = t.attrs[c._id][this._id];

      for (i in d) {
        if (r = (n = d[i]).start, o = n.diff, l = n.end, f._isArray(r)) {
          if (a = [], h = Math.max(r.length, l.length), 0 === i.indexOf("fill")) for (s = 0; s < h; s++) {
            s % 2 == 0 ? a.push((r[s] || 0) + o[s] * e) : a.push("rgba(" + Math.round(r[s].r + o[s].r * e) + "," + Math.round(r[s].g + o[s].g * e) + "," + Math.round(r[s].b + o[s].b * e) + "," + (r[s].a + o[s].a * e) + ")");
          } else for (s = 0; s < h; s++) {
            a.push((r[s] || 0) + o[s] * e);
          }
        } else a = -1 !== _t.indexOf(i) ? "rgba(" + Math.round(r.r + o.r * e) + "," + Math.round(r.g + o.g * e) + "," + Math.round(r.b + o.b * e) + "," + (r.a + o.a * e) + ")" : r + o * e;
        c.setAttr(i, a);
      }
    }, t.prototype._addListeners = function () {
      var e = this;
      this.tween.onPlay = function () {
        e.anim.start();
      }, this.tween.onReverse = function () {
        e.anim.start();
      }, this.tween.onPause = function () {
        e.anim.stop();
      }, this.tween.onFinish = function () {
        var i = e.node,
            n = t.attrs[i._id][e._id];
        n.points && n.points.trueEnd && i.setAttr("points", n.points.trueEnd), e.onFinish && e.onFinish.call(e);
      }, this.tween.onReset = function () {
        var i = e.node,
            n = t.attrs[i._id][e._id];
        n.points && n.points.trueStart && i.points(n.points.trueStart), e.onReset && e.onReset();
      }, this.tween.onUpdate = function () {
        e.onUpdate && e.onUpdate.call(e);
      };
    }, t.prototype.play = function () {
      return this.tween.play(), this;
    }, t.prototype.reverse = function () {
      return this.tween.reverse(), this;
    }, t.prototype.reset = function () {
      return this.tween.reset(), this;
    }, t.prototype.seek = function (t) {
      return this.tween.seek(1e3 * t), this;
    }, t.prototype.pause = function () {
      return this.tween.pause(), this;
    }, t.prototype.finish = function () {
      return this.tween.finish(), this;
    }, t.prototype.destroy = function () {
      var e,
          i = this.node._id,
          n = this._id,
          r = t.tweens[i];

      for (e in this.pause(), r) {
        delete t.tweens[i][e];
      }

      delete t.attrs[i][n];
    }, t.attrs = {}, t.tweens = {}, t;
  }();

  X.prototype.to = function (t) {
    var e = t.onFinish;
    t.node = this, t.onFinish = function () {
      this.destroy(), e && e();
    }, new xt(t).play();
  };

  var St = {
    BackEaseIn: function BackEaseIn(t, e, i, n) {
      var r = 1.70158;
      return i * (t /= n) * t * ((r + 1) * t - r) + e;
    },
    BackEaseOut: function BackEaseOut(t, e, i, n) {
      var r = 1.70158;
      return i * ((t = t / n - 1) * t * ((r + 1) * t + r) + 1) + e;
    },
    BackEaseInOut: function BackEaseInOut(t, e, i, n) {
      var r = 1.70158;
      return (t /= n / 2) < 1 ? i / 2 * (t * t * ((1 + (r *= 1.525)) * t - r)) + e : i / 2 * ((t -= 2) * t * ((1 + (r *= 1.525)) * t + r) + 2) + e;
    },
    ElasticEaseIn: function ElasticEaseIn(t, e, i, n, r, o) {
      var a = 0;
      return 0 === t ? e : 1 == (t /= n) ? e + i : (o || (o = .3 * n), !r || r < Math.abs(i) ? (r = i, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(i / r), -r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * n - a) * (2 * Math.PI) / o) + e);
    },
    ElasticEaseOut: function ElasticEaseOut(t, e, i, n, r, o) {
      var a = 0;
      return 0 === t ? e : 1 == (t /= n) ? e + i : (o || (o = .3 * n), !r || r < Math.abs(i) ? (r = i, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(i / r), r * Math.pow(2, -10 * t) * Math.sin((t * n - a) * (2 * Math.PI) / o) + i + e);
    },
    ElasticEaseInOut: function ElasticEaseInOut(t, e, i, n, r, o) {
      var a = 0;
      return 0 === t ? e : 2 == (t /= n / 2) ? e + i : (o || (o = n * (.3 * 1.5)), !r || r < Math.abs(i) ? (r = i, a = o / 4) : a = o / (2 * Math.PI) * Math.asin(i / r), t < 1 ? r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * n - a) * (2 * Math.PI) / o) * -.5 + e : r * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * n - a) * (2 * Math.PI) / o) * .5 + i + e);
    },
    BounceEaseOut: function BounceEaseOut(t, e, i, n) {
      return (t /= n) < 1 / 2.75 ? i * (7.5625 * t * t) + e : t < 2 / 2.75 ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e;
    },
    BounceEaseIn: function BounceEaseIn(t, e, i, n) {
      return i - St.BounceEaseOut(n - t, 0, i, n) + e;
    },
    BounceEaseInOut: function BounceEaseInOut(t, e, i, n) {
      return t < n / 2 ? .5 * St.BounceEaseIn(2 * t, 0, i, n) + e : .5 * St.BounceEaseOut(2 * t - n, 0, i, n) + .5 * i + e;
    },
    EaseIn: function EaseIn(t, e, i, n) {
      return i * (t /= n) * t + e;
    },
    EaseOut: function EaseOut(t, e, i, n) {
      return -i * (t /= n) * (t - 2) + e;
    },
    EaseInOut: function EaseInOut(t, e, i, n) {
      return (t /= n / 2) < 1 ? i / 2 * t * t + e : -i / 2 * (--t * (t - 2) - 1) + e;
    },
    StrongEaseIn: function StrongEaseIn(t, e, i, n) {
      return i * (t /= n) * t * t * t * t + e;
    },
    StrongEaseOut: function StrongEaseOut(t, e, i, n) {
      return i * ((t = t / n - 1) * t * t * t * t + 1) + e;
    },
    StrongEaseInOut: function StrongEaseInOut(t, e, i, n) {
      return (t /= n / 2) < 1 ? i / 2 * t * t * t * t * t + e : i / 2 * ((t -= 2) * t * t * t * t + 2) + e;
    },
    Linear: function Linear(t, e, i, n) {
      return i * t / n + e;
    }
  },
      wt = f._assign(r, {
    Collection: s,
    Util: f,
    Transform: h,
    Node: X,
    ids: I,
    names: F,
    Container: U,
    Stage: ot,
    stages: nt,
    Layer: ut,
    FastLayer: pt,
    Group: ft,
    DD: D,
    Shape: lt,
    shapes: ht,
    Animation: vt,
    Tween: xt,
    Easings: St,
    Context: A,
    Canvas: L
  }),
      Ct = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = r.getAngle(this.angle()),
          i = this.clockwise();
      t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, e, i), t.arc(0, 0, this.innerRadius(), e, 0, !i), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.outerRadius();
    }, e.prototype.getHeight = function () {
      return 2 * this.outerRadius();
    }, e.prototype.setWidth = function (t) {
      this.outerRadius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.outerRadius(t / 2);
    }, e;
  }(lt);

  Ct.prototype._centroid = !0, Ct.prototype.className = "Arc", Ct.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], a(Ct), w.addGetterSetter(Ct, "innerRadius", 0, y()), w.addGetterSetter(Ct, "outerRadius", 0, y()), w.addGetterSetter(Ct, "angle", 0, y()), w.addGetterSetter(Ct, "clockwise", !1, S()), s.mapMethods(Ct);

  var Pt = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", function () {
        this._clearCache("tensionPoints");
      }), i;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e,
          i,
          n,
          r = this.points(),
          o = r.length,
          a = this.tension(),
          s = this.closed(),
          h = this.bezier();

      if (o) {
        if (t.beginPath(), t.moveTo(r[0], r[1]), 0 !== a && o > 4) {
          for (i = (e = this.getTensionPoints()).length, n = s ? 0 : 4, s || t.quadraticCurveTo(e[0], e[1], e[2], e[3]); n < i - 2;) {
            t.bezierCurveTo(e[n++], e[n++], e[n++], e[n++], e[n++], e[n++]);
          }

          s || t.quadraticCurveTo(e[i - 2], e[i - 1], r[o - 2], r[o - 1]);
        } else if (h) for (n = 2; n < o;) {
          t.bezierCurveTo(r[n++], r[n++], r[n++], r[n++], r[n++], r[n++]);
        } else for (n = 2; n < o; n += 2) {
          t.lineTo(r[n], r[n + 1]);
        }

        s ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this);
      }
    }, e.prototype.getTensionPoints = function () {
      return this._getCache("tensionPoints", this._getTensionPoints);
    }, e.prototype._getTensionPoints = function () {
      return this.closed() ? this._getTensionPointsClosed() : f._expandPoints(this.points(), this.tension());
    }, e.prototype._getTensionPointsClosed = function () {
      var t = this.points(),
          e = t.length,
          i = this.tension(),
          n = f._getControlPoints(t[e - 2], t[e - 1], t[0], t[1], t[2], t[3], i),
          r = f._getControlPoints(t[e - 4], t[e - 3], t[e - 2], t[e - 1], t[0], t[1], i),
          o = f._expandPoints(t, i);

      return [n[2], n[3]].concat(o).concat([r[0], r[1], t[e - 2], t[e - 1], r[2], r[3], n[0], n[1], t[0], t[1]]);
    }, e.prototype.getWidth = function () {
      return this.getSelfRect().width;
    }, e.prototype.getHeight = function () {
      return this.getSelfRect().height;
    }, e.prototype.getSelfRect = function () {
      var t = this.points();
      if (t.length < 4) return {
        x: t[0] || 0,
        y: t[1] || 0,
        width: 0,
        height: 0
      };

      for (var e, i, n = (t = 0 !== this.tension() ? function () {
        for (var t = 0, e = 0, i = arguments.length; e < i; e++) {
          t += arguments[e].length;
        }

        var n = Array(t),
            r = 0;

        for (e = 0; e < i; e++) {
          for (var o = arguments[e], a = 0, s = o.length; a < s; a++, r++) {
            n[r] = o[a];
          }
        }

        return n;
      }([t[0], t[1]], this._getTensionPoints(), [t[t.length - 2], t[t.length - 1]]) : this.points())[0], r = t[0], o = t[1], a = t[1], s = 0; s < t.length / 2; s++) {
        e = t[2 * s], i = t[2 * s + 1], n = Math.min(n, e), r = Math.max(r, e), o = Math.min(o, i), a = Math.max(a, i);
      }

      return {
        x: n,
        y: o,
        width: r - n,
        height: a - o
      };
    }, e;
  }(lt);

  Pt.prototype.className = "Line", Pt.prototype._attrsAffectingSize = ["points", "bezier", "tension"], a(Pt), w.addGetterSetter(Pt, "closed", !1), w.addGetterSetter(Pt, "bezier", !1), w.addGetterSetter(Pt, "tension", 0, y()), w.addGetterSetter(Pt, "points", [], function () {
    if (r.isUnminified) return function (t, e) {
      return f._isArray(t) ? t.forEach(function (t) {
        f._isNumber(t) || f.warn('"' + e + '" attribute has non numeric element ' + t + ". Make sure that all elements are numbers.");
      }) : f.warn(g(t) + ' is a not valid value for "' + e + '" attribute. The value should be a array of numbers.'), t;
    };
  }()), s.mapMethods(Pt);

  var kt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (e) {
      t.prototype._sceneFunc.call(this, e);

      var i = 2 * Math.PI,
          n = this.points(),
          r = n,
          o = 0 !== this.tension() && n.length > 4;
      o && (r = this.getTensionPoints());
      var a,
          s,
          h = n.length;
      o ? (a = n[h - 2] - (r[r.length - 2] + r[r.length - 4]) / 2, s = n[h - 1] - (r[r.length - 1] + r[r.length - 3]) / 2) : (a = n[h - 2] - n[h - 4], s = n[h - 1] - n[h - 3]);
      var l = (Math.atan2(s, a) + i) % i,
          c = this.pointerLength(),
          d = this.pointerWidth();
      e.save(), e.beginPath(), e.translate(n[h - 2], n[h - 1]), e.rotate(l), e.moveTo(0, 0), e.lineTo(-c, d / 2), e.lineTo(-c, -d / 2), e.closePath(), e.restore(), this.pointerAtBeginning() && (e.save(), e.translate(n[0], n[1]), o ? (a = (r[0] + r[2]) / 2 - n[0], s = (r[1] + r[3]) / 2 - n[1]) : (a = n[2] - n[0], s = n[3] - n[1]), e.rotate((Math.atan2(-s, -a) + i) % i), e.moveTo(0, 0), e.lineTo(-c, d / 2), e.lineTo(-c, -d / 2), e.closePath(), e.restore());
      var u = this.dashEnabled();
      u && (this.attrs.dashEnabled = !1, e.setLineDash([])), e.fillStrokeShape(this), u && (this.attrs.dashEnabled = !0);
    }, e.prototype.getSelfRect = function () {
      var e = t.prototype.getSelfRect.call(this),
          i = this.pointerWidth() / 2;
      return {
        x: e.x - i,
        y: e.y - i,
        width: e.width + 2 * i,
        height: e.height + 2 * i
      };
    }, e;
  }(Pt);

  kt.prototype.className = "Arrow", a(kt), w.addGetterSetter(kt, "pointerLength", 10, y()), w.addGetterSetter(kt, "pointerWidth", 10, y()), w.addGetterSetter(kt, "pointerAtBeginning", !1), s.mapMethods(kt);

  var Tt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, 2 * Math.PI, !1), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.radius();
    }, e.prototype.getHeight = function () {
      return 2 * this.radius();
    }, e.prototype.setWidth = function (t) {
      this.radius() !== t / 2 && this.radius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.radius() !== t / 2 && this.radius(t / 2);
    }, e;
  }(lt);

  Tt.prototype._centroid = !0, Tt.prototype.className = "Circle", Tt.prototype._attrsAffectingSize = ["radius"], a(Tt), w.addGetterSetter(Tt, "radius", 0, y()), s.mapMethods(Tt);

  var At = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.radiusX(),
          i = this.radiusY();
      t.beginPath(), t.save(), e !== i && t.scale(1, i / e), t.arc(0, 0, e, 0, 2 * Math.PI, !1), t.restore(), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.radiusX();
    }, e.prototype.getHeight = function () {
      return 2 * this.radiusY();
    }, e.prototype.setWidth = function (t) {
      this.radiusX(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.radiusY(t / 2);
    }, e;
  }(lt);

  At.prototype.className = "Ellipse", At.prototype._centroid = !0, At.prototype._attrsAffectingSize = ["radiusX", "radiusY"], a(At), w.addComponentsGetterSetter(At, "radius", ["x", "y"]), w.addGetterSetter(At, "radiusX", 0, y()), w.addGetterSetter(At, "radiusY", 0, y()), s.mapMethods(At);

  var Mt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._useBufferCanvas = function () {
      return t.prototype._useBufferCanvas.call(this, !0);
    }, e.prototype._sceneFunc = function (t) {
      var e,
          i = this.getWidth(),
          n = this.getHeight(),
          r = this.attrs.image;

      if (r) {
        var o = this.attrs.cropWidth,
            a = this.attrs.cropHeight;
        e = o && a ? [r, this.cropX(), this.cropY(), o, a, 0, 0, i, n] : [r, 0, 0, i, n];
      }

      (this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, i, n), t.closePath(), t.fillStrokeShape(this)), r && t.drawImage.apply(t, e);
    }, e.prototype._hitFunc = function (t) {
      var e = this.width(),
          i = this.height();
      t.beginPath(), t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      var t, e;
      return null !== (t = this.attrs.width) && void 0 !== t ? t : (null === (e = this.image()) || void 0 === e ? void 0 : e.width) || 0;
    }, e.prototype.getHeight = function () {
      var t, e;
      return null !== (t = this.attrs.height) && void 0 !== t ? t : (null === (e = this.image()) || void 0 === e ? void 0 : e.height) || 0;
    }, e.fromURL = function (t, i) {
      var n = f.createImageElement();
      n.onload = function () {
        var t = new e({
          image: n
        });
        i(t);
      }, n.crossOrigin = "Anonymous", n.src = t;
    }, e;
  }(lt);

  Mt.prototype.className = "Image", a(Mt), w.addGetterSetter(Mt, "image"), w.addComponentsGetterSetter(Mt, "crop", ["x", "y", "width", "height"]), w.addGetterSetter(Mt, "cropX", 0, y()), w.addGetterSetter(Mt, "cropY", 0, y()), w.addGetterSetter(Mt, "cropWidth", 0, y()), w.addGetterSetter(Mt, "cropHeight", 0, y()), s.mapMethods(Mt);

  var Gt = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height"],
      Rt = Gt.length,
      Lt = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i.on("add.konva", function (t) {
        this._addListeners(t.child), this._sync();
      }), i;
    }

    return P(e, t), e.prototype.getText = function () {
      return this.find("Text")[0];
    }, e.prototype.getTag = function () {
      return this.find("Tag")[0];
    }, e.prototype._addListeners = function (t) {
      var e,
          i = this,
          n = function n() {
        i._sync();
      };

      for (e = 0; e < Rt; e++) {
        t.on(Gt[e] + "Change.konva", n);
      }
    }, e.prototype.getWidth = function () {
      return this.getText().width();
    }, e.prototype.getHeight = function () {
      return this.getText().height();
    }, e.prototype._sync = function () {
      var t,
          e,
          i,
          n,
          r,
          o,
          a,
          s = this.getText(),
          h = this.getTag();

      if (s && h) {
        switch (t = s.width(), e = s.height(), i = h.pointerDirection(), n = h.pointerWidth(), a = h.pointerHeight(), r = 0, o = 0, i) {
          case "up":
            r = t / 2, o = -1 * a;
            break;

          case "right":
            r = t + n, o = e / 2;
            break;

          case "down":
            r = t / 2, o = e + a;
            break;

          case "left":
            r = -1 * n, o = e / 2;
        }

        h.setAttrs({
          x: -1 * r,
          y: -1 * o,
          width: t,
          height: e
        }), s.setAttrs({
          x: -1 * r,
          y: -1 * o
        });
      }
    }, e;
  }(ft);

  Lt.prototype.className = "Label", a(Lt), s.mapMethods(Lt);

  var Et = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.width(),
          i = this.height(),
          n = this.pointerDirection(),
          r = this.pointerWidth(),
          o = this.pointerHeight(),
          a = this.cornerRadius(),
          s = 0,
          h = 0,
          l = 0,
          c = 0;
      "number" == typeof a ? s = h = l = c = Math.min(a, e / 2, i / 2) : (s = Math.min(a[0] || 0, e / 2, i / 2), h = Math.min(a[1] || 0, e / 2, i / 2), c = Math.min(a[2] || 0, e / 2, i / 2), l = Math.min(a[3] || 0, e / 2, i / 2)), t.beginPath(), t.moveTo(s, 0), "up" === n && (t.lineTo((e - r) / 2, 0), t.lineTo(e / 2, -1 * o), t.lineTo((e + r) / 2, 0)), t.lineTo(e - h, 0), t.arc(e - h, h, h, 3 * Math.PI / 2, 0, !1), "right" === n && (t.lineTo(e, (i - o) / 2), t.lineTo(e + r, i / 2), t.lineTo(e, (i + o) / 2)), t.lineTo(e, i - c), t.arc(e - c, i - c, c, 0, Math.PI / 2, !1), "down" === n && (t.lineTo((e + r) / 2, i), t.lineTo(e / 2, i + o), t.lineTo((e - r) / 2, i)), t.lineTo(l, i), t.arc(l, i - l, l, Math.PI / 2, Math.PI, !1), "left" === n && (t.lineTo(0, (i + o) / 2), t.lineTo(-1 * r, i / 2), t.lineTo(0, (i - o) / 2)), t.lineTo(0, s), t.arc(s, s, s, Math.PI, 3 * Math.PI / 2, !1), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getSelfRect = function () {
      var t = 0,
          e = 0,
          i = this.pointerWidth(),
          n = this.pointerHeight(),
          r = this.pointerDirection(),
          o = this.width(),
          a = this.height();
      return "up" === r ? (e -= n, a += n) : "down" === r ? a += n : "left" === r ? (t -= 1.5 * i, o += i) : "right" === r && (o += 1.5 * i), {
        x: t,
        y: e,
        width: o,
        height: a
      };
    }, e;
  }(lt);

  Et.prototype.className = "Tag", a(Et), w.addGetterSetter(Et, "pointerDirection", "none"), w.addGetterSetter(Et, "pointerWidth", 0, y()), w.addGetterSetter(Et, "pointerHeight", 0, y()), w.addGetterSetter(Et, "cornerRadius", 0, m(4)), s.mapMethods(Et);

  var Ot = function (t) {
    function e(i) {
      var n = t.call(this, i) || this;
      n.dataArray = [], n.pathLength = 0, n.dataArray = e.parsePathData(n.data()), n.pathLength = 0;

      for (var r = 0; r < n.dataArray.length; ++r) {
        n.pathLength += n.dataArray[r].pathLength;
      }

      return n.on("dataChange.konva", function () {
        this.dataArray = e.parsePathData(this.data()), this.pathLength = 0;

        for (var t = 0; t < this.dataArray.length; ++t) {
          this.pathLength += this.dataArray[t].pathLength;
        }
      }), n;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.dataArray;
      t.beginPath();

      for (var i = !1, n = 0; n < e.length; n++) {
        var r = e[n].command,
            o = e[n].points;

        switch (r) {
          case "L":
            t.lineTo(o[0], o[1]);
            break;

          case "M":
            t.moveTo(o[0], o[1]);
            break;

          case "C":
            t.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
            break;

          case "Q":
            t.quadraticCurveTo(o[0], o[1], o[2], o[3]);
            break;

          case "A":
            var a = o[0],
                s = o[1],
                h = o[2],
                l = o[3],
                c = o[4],
                d = o[5],
                u = o[6],
                p = o[7],
                f = h > l ? h : l,
                g = h > l ? 1 : h / l,
                v = h > l ? l / h : 1;
            t.translate(a, s), t.rotate(u), t.scale(g, v), t.arc(0, 0, f, c, c + d, 1 - p), t.scale(1 / g, 1 / v), t.rotate(-u), t.translate(-a, -s);
            break;

          case "z":
            i = !0, t.closePath();
        }
      }

      i || this.hasFill() ? t.fillStrokeShape(this) : t.strokeShape(this);
    }, e.prototype.getSelfRect = function () {
      var t = [];
      this.dataArray.forEach(function (i) {
        if ("A" === i.command) {
          var n = i.points[4],
              r = i.points[5],
              o = i.points[4] + r,
              a = Math.PI / 180;
          if (Math.abs(n - o) < a && (a = Math.abs(n - o)), r < 0) for (var s = n - a; s > o; s -= a) {
            var h = e.getPointOnEllipticalArc(i.points[0], i.points[1], i.points[2], i.points[3], s, 0);
            t.push(h.x, h.y);
          } else for (s = n + a; s < o; s += a) {
            h = e.getPointOnEllipticalArc(i.points[0], i.points[1], i.points[2], i.points[3], s, 0);
            t.push(h.x, h.y);
          }
        } else if ("C" === i.command) for (s = 0; s <= 1; s += .01) {
          h = e.getPointOnCubicBezier(s, i.start.x, i.start.y, i.points[0], i.points[1], i.points[2], i.points[3], i.points[4], i.points[5]);
          t.push(h.x, h.y);
        } else t = t.concat(i.points);
      });

      for (var i, n, r = t[0], o = t[0], a = t[1], s = t[1], h = 0; h < t.length / 2; h++) {
        i = t[2 * h], n = t[2 * h + 1], isNaN(i) || (r = Math.min(r, i), o = Math.max(o, i)), isNaN(n) || (a = Math.min(a, n), s = Math.max(s, n));
      }

      return {
        x: Math.round(r),
        y: Math.round(a),
        width: Math.round(o - r),
        height: Math.round(s - a)
      };
    }, e.prototype.getLength = function () {
      return this.pathLength;
    }, e.prototype.getPointAtLength = function (t) {
      var i,
          n = 0,
          r = this.dataArray.length;
      if (!r) return null;

      for (; n < r && t > this.dataArray[n].pathLength;) {
        t -= this.dataArray[n].pathLength, ++n;
      }

      if (n === r) return {
        x: (i = this.dataArray[n - 1].points.slice(-2))[0],
        y: i[1]
      };
      if (t < .01) return {
        x: (i = this.dataArray[n].points.slice(0, 2))[0],
        y: i[1]
      };
      var o = this.dataArray[n],
          a = o.points;

      switch (o.command) {
        case "L":
          return e.getPointOnLine(t, o.start.x, o.start.y, a[0], a[1]);

        case "C":
          return e.getPointOnCubicBezier(t / o.pathLength, o.start.x, o.start.y, a[0], a[1], a[2], a[3], a[4], a[5]);

        case "Q":
          return e.getPointOnQuadraticBezier(t / o.pathLength, o.start.x, o.start.y, a[0], a[1], a[2], a[3]);

        case "A":
          var s = a[0],
              h = a[1],
              l = a[2],
              c = a[3],
              d = a[4],
              u = a[5],
              p = a[6];
          return d += u * t / o.pathLength, e.getPointOnEllipticalArc(s, h, l, c, d, p);
      }

      return null;
    }, e.getLineLength = function (t, e, i, n) {
      return Math.sqrt((i - t) * (i - t) + (n - e) * (n - e));
    }, e.getPointOnLine = function (t, e, i, n, r, o, a) {
      void 0 === o && (o = e), void 0 === a && (a = i);
      var s = (r - i) / (n - e + 1e-8),
          h = Math.sqrt(t * t / (1 + s * s));
      n < e && (h *= -1);
      var l,
          c = s * h;
      if (n === e) l = {
        x: o,
        y: a + c
      };else if ((a - i) / (o - e + 1e-8) === s) l = {
        x: o + h,
        y: a + c
      };else {
        var d,
            u,
            p = this.getLineLength(e, i, n, r),
            f = (o - e) * (n - e) + (a - i) * (r - i);
        d = e + (f /= p * p) * (n - e), u = i + f * (r - i);
        var g = this.getLineLength(o, a, d, u),
            v = Math.sqrt(t * t - g * g);
        h = Math.sqrt(v * v / (1 + s * s)), n < e && (h *= -1), l = {
          x: d + h,
          y: u + (c = s * h)
        };
      }
      return l;
    }, e.getPointOnCubicBezier = function (t, e, i, n, r, o, a, s, h) {
      function l(t) {
        return t * t * t;
      }

      function c(t) {
        return 3 * t * t * (1 - t);
      }

      function d(t) {
        return 3 * t * (1 - t) * (1 - t);
      }

      function u(t) {
        return (1 - t) * (1 - t) * (1 - t);
      }

      return {
        x: s * l(t) + o * c(t) + n * d(t) + e * u(t),
        y: h * l(t) + a * c(t) + r * d(t) + i * u(t)
      };
    }, e.getPointOnQuadraticBezier = function (t, e, i, n, r, o, a) {
      function s(t) {
        return t * t;
      }

      function h(t) {
        return 2 * t * (1 - t);
      }

      function l(t) {
        return (1 - t) * (1 - t);
      }

      return {
        x: o * s(t) + n * h(t) + e * l(t),
        y: a * s(t) + r * h(t) + i * l(t)
      };
    }, e.getPointOnEllipticalArc = function (t, e, i, n, r, o) {
      var a = Math.cos(o),
          s = Math.sin(o),
          h = i * Math.cos(r),
          l = n * Math.sin(r);
      return {
        x: t + (h * a - l * s),
        y: e + (h * s + l * a)
      };
    }, e.parsePathData = function (t) {
      if (!t) return [];
      var e = t,
          i = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
      e = e.replace(new RegExp(" ", "g"), ",");

      for (var n = 0; n < i.length; n++) {
        e = e.replace(new RegExp(i[n], "g"), "|" + i[n]);
      }

      var r,
          o = e.split("|"),
          a = [],
          s = [],
          h = 0,
          l = 0,
          c = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;

      for (n = 1; n < o.length; n++) {
        var d = o[n],
            u = d.charAt(0);

        for (d = d.slice(1), s.length = 0; r = c.exec(d);) {
          s.push(r[0]);
        }

        for (var p = [], f = 0, g = s.length; f < g; f++) {
          var v = parseFloat(s[f]);
          isNaN(v) ? p.push(0) : p.push(v);
        }

        for (; p.length > 0 && !isNaN(p[0]);) {
          var y,
              m,
              _,
              b,
              x,
              S,
              w,
              C,
              P,
              k,
              T = null,
              A = [],
              M = h,
              G = l;

          switch (u) {
            case "l":
              h += p.shift(), l += p.shift(), T = "L", A.push(h, l);
              break;

            case "L":
              h = p.shift(), l = p.shift(), A.push(h, l);
              break;

            case "m":
              var R = p.shift(),
                  L = p.shift();
              if (h += R, l += L, T = "M", a.length > 2 && "z" === a[a.length - 1].command) for (var E = a.length - 2; E >= 0; E--) {
                if ("M" === a[E].command) {
                  h = a[E].points[0] + R, l = a[E].points[1] + L;
                  break;
                }
              }
              A.push(h, l), u = "l";
              break;

            case "M":
              h = p.shift(), l = p.shift(), T = "M", A.push(h, l), u = "L";
              break;

            case "h":
              h += p.shift(), T = "L", A.push(h, l);
              break;

            case "H":
              h = p.shift(), T = "L", A.push(h, l);
              break;

            case "v":
              l += p.shift(), T = "L", A.push(h, l);
              break;

            case "V":
              l = p.shift(), T = "L", A.push(h, l);
              break;

            case "C":
              A.push(p.shift(), p.shift(), p.shift(), p.shift()), h = p.shift(), l = p.shift(), A.push(h, l);
              break;

            case "c":
              A.push(h + p.shift(), l + p.shift(), h + p.shift(), l + p.shift()), h += p.shift(), l += p.shift(), T = "C", A.push(h, l);
              break;

            case "S":
              m = h, _ = l, "C" === (y = a[a.length - 1]).command && (m = h + (h - y.points[2]), _ = l + (l - y.points[3])), A.push(m, _, p.shift(), p.shift()), h = p.shift(), l = p.shift(), T = "C", A.push(h, l);
              break;

            case "s":
              m = h, _ = l, "C" === (y = a[a.length - 1]).command && (m = h + (h - y.points[2]), _ = l + (l - y.points[3])), A.push(m, _, h + p.shift(), l + p.shift()), h += p.shift(), l += p.shift(), T = "C", A.push(h, l);
              break;

            case "Q":
              A.push(p.shift(), p.shift()), h = p.shift(), l = p.shift(), A.push(h, l);
              break;

            case "q":
              A.push(h + p.shift(), l + p.shift()), h += p.shift(), l += p.shift(), T = "Q", A.push(h, l);
              break;

            case "T":
              m = h, _ = l, "Q" === (y = a[a.length - 1]).command && (m = h + (h - y.points[0]), _ = l + (l - y.points[1])), h = p.shift(), l = p.shift(), T = "Q", A.push(m, _, h, l);
              break;

            case "t":
              m = h, _ = l, "Q" === (y = a[a.length - 1]).command && (m = h + (h - y.points[0]), _ = l + (l - y.points[1])), h += p.shift(), l += p.shift(), T = "Q", A.push(m, _, h, l);
              break;

            case "A":
              b = p.shift(), x = p.shift(), S = p.shift(), w = p.shift(), C = p.shift(), P = h, k = l, h = p.shift(), l = p.shift(), T = "A", A = this.convertEndpointToCenterParameterization(P, k, h, l, w, C, b, x, S);
              break;

            case "a":
              b = p.shift(), x = p.shift(), S = p.shift(), w = p.shift(), C = p.shift(), P = h, k = l, h += p.shift(), l += p.shift(), T = "A", A = this.convertEndpointToCenterParameterization(P, k, h, l, w, C, b, x, S);
          }

          a.push({
            command: T || u,
            points: A,
            start: {
              x: M,
              y: G
            },
            pathLength: this.calcLength(M, G, T || u, A)
          });
        }

        "z" !== u && "Z" !== u || a.push({
          command: "z",
          points: [],
          start: void 0,
          pathLength: 0
        });
      }

      return a;
    }, e.calcLength = function (t, i, n, r) {
      var o,
          a,
          s,
          h,
          l = e;

      switch (n) {
        case "L":
          return l.getLineLength(t, i, r[0], r[1]);

        case "C":
          for (o = 0, a = l.getPointOnCubicBezier(0, t, i, r[0], r[1], r[2], r[3], r[4], r[5]), h = .01; h <= 1; h += .01) {
            s = l.getPointOnCubicBezier(h, t, i, r[0], r[1], r[2], r[3], r[4], r[5]), o += l.getLineLength(a.x, a.y, s.x, s.y), a = s;
          }

          return o;

        case "Q":
          for (o = 0, a = l.getPointOnQuadraticBezier(0, t, i, r[0], r[1], r[2], r[3]), h = .01; h <= 1; h += .01) {
            s = l.getPointOnQuadraticBezier(h, t, i, r[0], r[1], r[2], r[3]), o += l.getLineLength(a.x, a.y, s.x, s.y), a = s;
          }

          return o;

        case "A":
          o = 0;
          var c = r[4],
              d = r[5],
              u = r[4] + d,
              p = Math.PI / 180;
          if (Math.abs(c - u) < p && (p = Math.abs(c - u)), a = l.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), d < 0) for (h = c - p; h > u; h -= p) {
            s = l.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), o += l.getLineLength(a.x, a.y, s.x, s.y), a = s;
          } else for (h = c + p; h < u; h += p) {
            s = l.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], h, 0), o += l.getLineLength(a.x, a.y, s.x, s.y), a = s;
          }
          return s = l.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], u, 0), o += l.getLineLength(a.x, a.y, s.x, s.y);
      }

      return 0;
    }, e.convertEndpointToCenterParameterization = function (t, e, i, n, r, o, a, s, h) {
      var l = h * (Math.PI / 180),
          c = Math.cos(l) * (t - i) / 2 + Math.sin(l) * (e - n) / 2,
          d = -1 * Math.sin(l) * (t - i) / 2 + Math.cos(l) * (e - n) / 2,
          u = c * c / (a * a) + d * d / (s * s);
      u > 1 && (a *= Math.sqrt(u), s *= Math.sqrt(u));
      var p = Math.sqrt((a * a * (s * s) - a * a * (d * d) - s * s * (c * c)) / (a * a * (d * d) + s * s * (c * c)));
      r === o && (p *= -1), isNaN(p) && (p = 0);

      var f = p * a * d / s,
          g = p * -s * c / a,
          v = (t + i) / 2 + Math.cos(l) * f - Math.sin(l) * g,
          y = (e + n) / 2 + Math.sin(l) * f + Math.cos(l) * g,
          m = function m(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
      },
          _ = function _(t, e) {
        return (t[0] * e[0] + t[1] * e[1]) / (m(t) * m(e));
      },
          b = function b(t, e) {
        return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(_(t, e));
      },
          x = b([1, 0], [(c - f) / a, (d - g) / s]),
          S = [(c - f) / a, (d - g) / s],
          w = [(-1 * c - f) / a, (-1 * d - g) / s],
          C = b(S, w);

      return _(S, w) <= -1 && (C = Math.PI), _(S, w) >= 1 && (C = 0), 0 === o && C > 0 && (C -= 2 * Math.PI), 1 === o && C < 0 && (C += 2 * Math.PI), [v, y, a, s, x, C, l, o];
    }, e;
  }(lt);

  Ot.prototype.className = "Path", Ot.prototype._attrsAffectingSize = ["data"], a(Ot), w.addGetterSetter(Ot, "data"), s.mapMethods(Ot);

  var Dt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.cornerRadius(),
          i = this.width(),
          n = this.height();

      if (t.beginPath(), e) {
        var r = 0,
            o = 0,
            a = 0,
            s = 0;
        "number" == typeof e ? r = o = a = s = Math.min(e, i / 2, n / 2) : (r = Math.min(e[0] || 0, i / 2, n / 2), o = Math.min(e[1] || 0, i / 2, n / 2), s = Math.min(e[2] || 0, i / 2, n / 2), a = Math.min(e[3] || 0, i / 2, n / 2)), t.moveTo(r, 0), t.lineTo(i - o, 0), t.arc(i - o, o, o, 3 * Math.PI / 2, 0, !1), t.lineTo(i, n - s), t.arc(i - s, n - s, s, 0, Math.PI / 2, !1), t.lineTo(a, n), t.arc(a, n - a, a, Math.PI / 2, Math.PI, !1), t.lineTo(0, r), t.arc(r, r, r, Math.PI, 3 * Math.PI / 2, !1);
      } else t.rect(0, 0, i, n);

      t.closePath(), t.fillStrokeShape(this);
    }, e;
  }(lt);

  Dt.prototype.className = "Rect", a(Dt), w.addGetterSetter(Dt, "cornerRadius", 0, m(4)), s.mapMethods(Dt);

  var It = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this._getPoints();

      t.beginPath(), t.moveTo(e[0].x, e[0].y);

      for (var i = 1; i < e.length; i++) {
        t.lineTo(e[i].x, e[i].y);
      }

      t.closePath(), t.fillStrokeShape(this);
    }, e.prototype._getPoints = function () {
      for (var t = this.attrs.sides, e = this.attrs.radius || 0, i = [], n = 0; n < t; n++) {
        i.push({
          x: e * Math.sin(2 * n * Math.PI / t),
          y: -1 * e * Math.cos(2 * n * Math.PI / t)
        });
      }

      return i;
    }, e.prototype.getSelfRect = function () {
      var t = this._getPoints(),
          e = t[0].x,
          i = t[0].y,
          n = t[0].x,
          r = t[0].y;

      return t.forEach(function (t) {
        e = Math.min(e, t.x), i = Math.max(i, t.x), n = Math.min(n, t.y), r = Math.max(r, t.y);
      }), {
        x: e,
        y: n,
        width: i - e,
        height: r - n
      };
    }, e.prototype.getWidth = function () {
      return 2 * this.radius();
    }, e.prototype.getHeight = function () {
      return 2 * this.radius();
    }, e.prototype.setWidth = function (t) {
      this.radius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.radius(t / 2);
    }, e;
  }(lt);

  It.prototype.className = "RegularPolygon", It.prototype._centroid = !0, It.prototype._attrsAffectingSize = ["radius"], a(It), w.addGetterSetter(It, "radius", 0, y()), w.addGetterSetter(It, "sides", 0, y()), s.mapMethods(It);

  var Ft = 2 * Math.PI,
      Bt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, Ft, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), Ft, 0, !0), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.outerRadius();
    }, e.prototype.getHeight = function () {
      return 2 * this.outerRadius();
    }, e.prototype.setWidth = function (t) {
      this.outerRadius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.outerRadius(t / 2);
    }, e;
  }(lt);

  Bt.prototype.className = "Ring", Bt.prototype._centroid = !0, Bt.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], a(Bt), w.addGetterSetter(Bt, "innerRadius", 0, y()), w.addGetterSetter(Bt, "outerRadius", 0, y()), s.mapMethods(Bt);

  var Nt = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i._updated = !0, i.anim = new vt(function () {
        var t = i._updated;
        return i._updated = !1, t;
      }), i.on("animationChange.konva", function () {
        this.frameIndex(0);
      }), i.on("frameIndexChange.konva", function () {
        this._updated = !0;
      }), i.on("frameRateChange.konva", function () {
        this.anim.isRunning() && (clearInterval(this.interval), this._setInterval());
      }), i;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.animation(),
          i = this.frameIndex(),
          n = 4 * i,
          r = this.animations()[e],
          o = this.frameOffsets(),
          a = r[n + 0],
          s = r[n + 1],
          h = r[n + 2],
          l = r[n + 3],
          c = this.image();
      if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, h, l), t.closePath(), t.fillStrokeShape(this)), c) if (o) {
        var d = o[e],
            u = 2 * i;
        t.drawImage(c, a, s, h, l, d[u + 0], d[u + 1], h, l);
      } else t.drawImage(c, a, s, h, l, 0, 0, h, l);
    }, e.prototype._hitFunc = function (t) {
      var e = this.animation(),
          i = this.frameIndex(),
          n = 4 * i,
          r = this.animations()[e],
          o = this.frameOffsets(),
          a = r[n + 2],
          s = r[n + 3];

      if (t.beginPath(), o) {
        var h = o[e],
            l = 2 * i;
        t.rect(h[l + 0], h[l + 1], a, s);
      } else t.rect(0, 0, a, s);

      t.closePath(), t.fillShape(this);
    }, e.prototype._useBufferCanvas = function () {
      return t.prototype._useBufferCanvas.call(this, !0);
    }, e.prototype._setInterval = function () {
      var t = this;
      this.interval = setInterval(function () {
        t._updateIndex();
      }, 1e3 / this.frameRate());
    }, e.prototype.start = function () {
      if (!this.isRunning()) {
        var t = this.getLayer();
        this.anim.setLayers(t), this._setInterval(), this.anim.start();
      }
    }, e.prototype.stop = function () {
      this.anim.stop(), clearInterval(this.interval);
    }, e.prototype.isRunning = function () {
      return this.anim.isRunning();
    }, e.prototype._updateIndex = function () {
      var t = this.frameIndex(),
          e = this.animation();
      t < this.animations()[e].length / 4 - 1 ? this.frameIndex(t + 1) : this.frameIndex(0);
    }, e;
  }(lt);

  Nt.prototype.className = "Sprite", a(Nt), w.addGetterSetter(Nt, "animation"), w.addGetterSetter(Nt, "animations"), w.addGetterSetter(Nt, "frameOffsets"), w.addGetterSetter(Nt, "image"), w.addGetterSetter(Nt, "frameIndex", 0, y()), w.addGetterSetter(Nt, "frameRate", 17, y()), w.backCompat(Nt, {
    index: "frameIndex",
    getIndex: "getFrameIndex",
    setIndex: "setFrameIndex"
  }), s.mapMethods(Nt);

  var zt = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.innerRadius(),
          i = this.outerRadius(),
          n = this.numPoints();
      t.beginPath(), t.moveTo(0, 0 - i);

      for (var r = 1; r < 2 * n; r++) {
        var o = r % 2 == 0 ? i : e,
            a = o * Math.sin(r * Math.PI / n),
            s = -1 * o * Math.cos(r * Math.PI / n);
        t.lineTo(a, s);
      }

      t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.outerRadius();
    }, e.prototype.getHeight = function () {
      return 2 * this.outerRadius();
    }, e.prototype.setWidth = function (t) {
      this.outerRadius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.outerRadius(t / 2);
    }, e;
  }(lt);

  function Wt(t) {
    return Array.from(t);
  }

  zt.prototype.className = "Star", zt.prototype._centroid = !0, zt.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], a(zt), w.addGetterSetter(zt, "numPoints", 5, y()), w.addGetterSetter(zt, "innerRadius", 0, y()), w.addGetterSetter(zt, "outerRadius", 0, y()), s.mapMethods(zt);
  var Ht,
      Yt = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"],
      Xt = Yt.length;

  function jt() {
    return Ht || (Ht = f.createCanvasElement().getContext("2d"));
  }

  var Ut = function (t) {
    function e(e) {
      var i = t.call(this, function (t) {
        return (t = t || {}).fillLinearGradientColorStops || t.fillRadialGradientColorStops || t.fillPatternImage || (t.fill = t.fill || "black"), t;
      }(e)) || this;
      i._partialTextX = 0, i._partialTextY = 0;

      for (var n = 0; n < Xt; n++) {
        i.on(Yt[n] + "Change.konva", i._setTextData);
      }

      return i._setTextData(), i;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      var e = this.textArr,
          i = e.length;

      if (this.text()) {
        var n,
            r = this.padding(),
            o = this.fontSize(),
            a = this.lineHeight() * o,
            s = this.verticalAlign(),
            h = 0,
            l = this.align(),
            c = this.getWidth(),
            d = this.letterSpacing(),
            u = this.fill(),
            p = this.textDecoration(),
            f = -1 !== p.indexOf("underline"),
            g = -1 !== p.indexOf("line-through"),
            v = 0,
            y = (v = a / 2, 0),
            m = 0;

        for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", "middle"), t.setAttr("textAlign", "left"), "middle" === s ? h = (this.getHeight() - i * a - 2 * r) / 2 : "bottom" === s && (h = this.getHeight() - i * a - 2 * r), t.translate(r, h + r), n = 0; n < i; n++) {
          y = 0, m = 0;

          var _,
              b,
              x,
              S = e[n],
              w = S.text,
              C = S.width,
              P = n !== i - 1;

          if (t.save(), "right" === l ? y += c - C - 2 * r : "center" === l && (y += (c - C - 2 * r) / 2), f && (t.save(), t.beginPath(), t.moveTo(y, v + m + Math.round(o / 2)), b = 0 === (_ = w.split(" ").length - 1), x = "justify" === l && P && !b ? c - 2 * r : C, t.lineTo(y + Math.round(x), v + m + Math.round(o / 2)), t.lineWidth = o / 15, t.strokeStyle = u, t.stroke(), t.restore()), g && (t.save(), t.beginPath(), t.moveTo(y, v + m), b = 0 === (_ = w.split(" ").length - 1), x = "justify" === l && P && !b ? c - 2 * r : C, t.lineTo(y + Math.round(x), v + m), t.lineWidth = o / 15, t.strokeStyle = u, t.stroke(), t.restore()), 0 !== d || "justify" === l) {
            _ = w.split(" ").length - 1;

            for (var k = Wt(w), T = 0; T < k.length; T++) {
              var A = k[T];
              " " === A && n !== i - 1 && "justify" === l && (y += (c - 2 * r - C) / _), this._partialTextX = y, this._partialTextY = v + m, this._partialText = A, t.fillStrokeShape(this), y += this.measureSize(A).width + d;
            }
          } else this._partialTextX = y, this._partialTextY = v + m, this._partialText = w, t.fillStrokeShape(this);

          t.restore(), i > 1 && (v += a);
        }
      }
    }, e.prototype._hitFunc = function (t) {
      var e = this.getWidth(),
          i = this.getHeight();
      t.beginPath(), t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.setText = function (t) {
      var e = f._isString(t) ? t : null == t ? "" : t + "";
      return this._setAttr("text", e), this;
    }, e.prototype.getWidth = function () {
      return "auto" === this.attrs.width || void 0 === this.attrs.width ? this.getTextWidth() + 2 * this.padding() : this.attrs.width;
    }, e.prototype.getHeight = function () {
      return "auto" === this.attrs.height || void 0 === this.attrs.height ? this.fontSize() * this.textArr.length * this.lineHeight() + 2 * this.padding() : this.attrs.height;
    }, e.prototype.getTextWidth = function () {
      return this.textWidth;
    }, e.prototype.getTextHeight = function () {
      return f.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }, e.prototype.measureSize = function (t) {
      var e,
          i = jt(),
          n = this.fontSize();
      return i.save(), i.font = this._getContextFont(), e = i.measureText(t), i.restore(), {
        width: e.width,
        height: n
      };
    }, e.prototype._getContextFont = function () {
      return r.UA.isIE ? this.fontStyle() + " " + this.fontSize() + "px " + this.fontFamily() : this.fontStyle() + " " + this.fontVariant() + " " + this.fontSize() + "px " + this.fontFamily().split(",").map(function (t) {
        var e = (t = t.trim()).indexOf(" ") >= 0,
            i = t.indexOf('"') >= 0 || t.indexOf("'") >= 0;
        return e && !i && (t = '"' + t + '"'), t;
      }).join(", ");
    }, e.prototype._addTextLine = function (t) {
      "justify" === this.align() && (t = t.trim());

      var e = this._getTextWidth(t);

      return this.textArr.push({
        text: t,
        width: e
      });
    }, e.prototype._getTextWidth = function (t) {
      var e = this.letterSpacing(),
          i = t.length;
      return jt().measureText(t).width + (i ? e * (i - 1) : 0);
    }, e.prototype._setTextData = function () {
      var t = this.text().split("\n"),
          e = +this.fontSize(),
          i = 0,
          n = this.lineHeight() * e,
          r = this.attrs.width,
          o = this.attrs.height,
          a = "auto" !== r && void 0 !== r,
          s = "auto" !== o && void 0 !== o,
          h = this.padding(),
          l = r - 2 * h,
          c = o - 2 * h,
          d = 0,
          u = this.wrap(),
          p = "none" !== u,
          f = "char" !== u && p,
          g = this.ellipsis();
      this.textArr = [], jt().font = this._getContextFont();

      for (var v = g ? this._getTextWidth("") : 0, y = 0, m = t.length; y < m; ++y) {
        var _ = t[y],
            b = this._getTextWidth(_);

        if (a && b > l) for (; _.length > 0;) {
          for (var x = 0, S = _.length, w = "", C = 0; x < S;) {
            var P = x + S >>> 1,
                k = _.slice(0, P + 1),
                T = this._getTextWidth(k) + v;

            T <= l ? (x = P + 1, w = k, C = T) : S = P;
          }

          if (!w) break;

          if (f) {
            var A,
                M = _[w.length];
            (A = (" " === M || "-" === M) && C <= l ? w.length : Math.max(w.lastIndexOf(" "), w.lastIndexOf("-")) + 1) > 0 && (x = A, w = w.slice(0, x), C = this._getTextWidth(w));
          }

          if (w = w.trimRight(), this._addTextLine(w), i = Math.max(i, C), d += n, !p || s && d + n > c) {
            var G = this.textArr[this.textArr.length - 1];
            if (G) if (g) this._getTextWidth(G.text + "") < l || (G.text = G.text.slice(0, G.text.length - 3)), this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(G.text + "");
            break;
          }

          if ((_ = (_ = _.slice(x)).trimLeft()).length > 0 && (b = this._getTextWidth(_)) <= l) {
            this._addTextLine(_), d += n, i = Math.max(i, b);
            break;
          }
        } else this._addTextLine(_), d += n, i = Math.max(i, b);
        if (s && d + n > c) break;
      }

      this.textHeight = e, this.textWidth = i;
    }, e.prototype.getStrokeScaleEnabled = function () {
      return !0;
    }, e;
  }(lt);

  Ut.prototype._fillFunc = function (t) {
    t.fillText(this._partialText, this._partialTextX, this._partialTextY);
  }, Ut.prototype._strokeFunc = function (t) {
    t.strokeText(this._partialText, this._partialTextX, this._partialTextY);
  }, Ut.prototype.className = "Text", Ut.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight"], a(Ut), w.overWriteSetter(Ut, "width", _()), w.overWriteSetter(Ut, "height", _()), w.addGetterSetter(Ut, "fontFamily", "Arial"), w.addGetterSetter(Ut, "fontSize", 12, y()), w.addGetterSetter(Ut, "fontStyle", "normal"), w.addGetterSetter(Ut, "fontVariant", "normal"), w.addGetterSetter(Ut, "padding", 0, y()), w.addGetterSetter(Ut, "align", "left"), w.addGetterSetter(Ut, "verticalAlign", "top"), w.addGetterSetter(Ut, "lineHeight", 1, y()), w.addGetterSetter(Ut, "wrap", "word"), w.addGetterSetter(Ut, "ellipsis", !1, S()), w.addGetterSetter(Ut, "letterSpacing", 0, y()), w.addGetterSetter(Ut, "text", "", b()), w.addGetterSetter(Ut, "textDecoration", ""), s.mapMethods(Ut);

  function qt(t) {
    t.fillText(this.partialText, 0, 0);
  }

  function Kt(t) {
    t.strokeText(this.partialText, 0, 0);
  }

  var Vt = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i.dummyCanvas = f.createCanvasElement(), i.dataArray = [], i.dataArray = Ot.parsePathData(i.attrs.data), i.on("dataChange.konva", function () {
        this.dataArray = Ot.parsePathData(this.attrs.data), this._setTextData();
      }), i.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva", i._setTextData), e && e.getKerning && (f.warn('getKerning TextPath API is deprecated. Please use "kerningFunc" instead.'), i.kerningFunc(e.getKerning)), i._setTextData(), i;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save();
      var e = this.textDecoration(),
          i = this.fill(),
          n = this.fontSize(),
          r = this.glyphInfo;
      "underline" === e && t.beginPath();

      for (var o = 0; o < r.length; o++) {
        t.save();
        var a = r[o].p0;
        t.translate(a.x, a.y), t.rotate(r[o].rotation), this.partialText = r[o].text, t.fillStrokeShape(this), "underline" === e && (0 === o && t.moveTo(0, n / 2 + 1), t.lineTo(n, n / 2 + 1)), t.restore();
      }

      "underline" === e && (t.strokeStyle = i, t.lineWidth = n / 20, t.stroke()), t.restore();
    }, e.prototype._hitFunc = function (t) {
      t.beginPath();
      var e = this.glyphInfo;

      if (e.length >= 1) {
        var i = e[0].p0;
        t.moveTo(i.x, i.y);
      }

      for (var n = 0; n < e.length; n++) {
        var r = e[n].p1;
        t.lineTo(r.x, r.y);
      }

      t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke();
    }, e.prototype.getTextWidth = function () {
      return this.textWidth;
    }, e.prototype.getTextHeight = function () {
      return f.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight;
    }, e.prototype.setText = function (t) {
      return Ut.prototype.setText.call(this, t);
    }, e.prototype._getContextFont = function () {
      return Ut.prototype._getContextFont.call(this);
    }, e.prototype._getTextSize = function (t) {
      var e = this.dummyCanvas.getContext("2d");
      e.save(), e.font = this._getContextFont();
      var i = e.measureText(t);
      return e.restore(), {
        width: i.width,
        height: parseInt(this.attrs.fontSize, 10)
      };
    }, e.prototype._setTextData = function () {
      var t = this,
          e = this._getTextSize(this.attrs.text),
          i = this.letterSpacing(),
          n = this.align(),
          r = this.kerningFunc();

      this.textWidth = e.width, this.textHeight = e.height;
      var o = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0);
      this.glyphInfo = [];

      for (var a = 0, s = 0; s < t.dataArray.length; s++) {
        t.dataArray[s].pathLength > 0 && (a += t.dataArray[s].pathLength);
      }

      var h = 0;
      "center" === n && (h = Math.max(0, a / 2 - o / 2)), "right" === n && (h = Math.max(0, a - o));

      for (var l, c, d, u = Wt(this.text()), p = this.text().split(" ").length - 1, f = -1, g = 0, v = function v() {
        g = 0;

        for (var e = t.dataArray, i = f + 1; i < e.length; i++) {
          if (e[i].pathLength > 0) return f = i, e[i];
          "M" === e[i].command && (l = {
            x: e[i].points[0],
            y: e[i].points[1]
          });
        }

        return {};
      }, y = function y(e) {
        var r = t._getTextSize(e).width + i;
        " " === e && "justify" === n && (r += (a - o) / p);
        var s = 0,
            h = 0;

        for (c = void 0; Math.abs(r - s) / r > .01 && h < 20;) {
          h++;

          for (var u = s; void 0 === d;) {
            (d = v()) && u + d.pathLength < r && (u += d.pathLength, d = void 0);
          }

          if (d === {} || void 0 === l) return;
          var f = !1;

          switch (d.command) {
            case "L":
              Ot.getLineLength(l.x, l.y, d.points[0], d.points[1]) > r ? c = Ot.getPointOnLine(r, l.x, l.y, d.points[0], d.points[1], l.x, l.y) : d = void 0;
              break;

            case "A":
              var y = d.points[4],
                  m = d.points[5],
                  _ = d.points[4] + m;

              0 === g ? g = y + 1e-8 : r > s ? g += Math.PI / 180 * m / Math.abs(m) : g -= Math.PI / 360 * m / Math.abs(m), (m < 0 && g < _ || m >= 0 && g > _) && (g = _, f = !0), c = Ot.getPointOnEllipticalArc(d.points[0], d.points[1], d.points[2], d.points[3], g, d.points[6]);
              break;

            case "C":
              0 === g ? g = r > d.pathLength ? 1e-8 : r / d.pathLength : r > s ? g += (r - s) / d.pathLength / 2 : g = Math.max(g - (s - r) / d.pathLength / 2, 0), g > 1 && (g = 1, f = !0), c = Ot.getPointOnCubicBezier(g, d.start.x, d.start.y, d.points[0], d.points[1], d.points[2], d.points[3], d.points[4], d.points[5]);
              break;

            case "Q":
              0 === g ? g = r / d.pathLength : r > s ? g += (r - s) / d.pathLength : g -= (s - r) / d.pathLength, g > 1 && (g = 1, f = !0), c = Ot.getPointOnQuadraticBezier(g, d.start.x, d.start.y, d.points[0], d.points[1], d.points[2], d.points[3]);
          }

          void 0 !== c && (s = Ot.getLineLength(l.x, l.y, c.x, c.y)), f && (f = !1, d = void 0);
        }
      }, m = h / (t._getTextSize("C").width + i) - 1, _ = 0; _ < m && (y("C"), void 0 !== l && void 0 !== c); _++) {
        l = c;
      }

      for (var b = 0; b < u.length && (y(u[b]), void 0 !== l && void 0 !== c); b++) {
        var x = Ot.getLineLength(l.x, l.y, c.x, c.y),
            S = 0;
        if (r) try {
          S = r(u[b - 1], u[b]) * this.fontSize();
        } catch (t) {
          S = 0;
        }
        l.x += S, c.x += S, this.textWidth += S;
        var w = Ot.getPointOnLine(S + x / 2, l.x, l.y, c.x, c.y),
            C = Math.atan2(c.y - l.y, c.x - l.x);
        this.glyphInfo.push({
          transposeX: w.x,
          transposeY: w.y,
          text: u[b],
          rotation: C,
          p0: l,
          p1: c
        }), l = c;
      }
    }, e.prototype.getSelfRect = function () {
      if (!this.glyphInfo.length) return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var t = [];
      this.glyphInfo.forEach(function (e) {
        t.push(e.p0.x), t.push(e.p0.y), t.push(e.p1.x), t.push(e.p1.y);
      });

      for (var e, i, n = t[0] || 0, r = t[0] || 0, o = t[1] || 0, a = t[1] || 0, s = 0; s < t.length / 2; s++) {
        e = t[2 * s], i = t[2 * s + 1], n = Math.min(n, e), r = Math.max(r, e), o = Math.min(o, i), a = Math.max(a, i);
      }

      var h = this.fontSize();
      return {
        x: n - h / 2,
        y: o - h / 2,
        width: r - n + h,
        height: a - o + h
      };
    }, e;
  }(lt);

  Vt.prototype._fillFunc = qt, Vt.prototype._strokeFunc = Kt, Vt.prototype._fillFuncHit = qt, Vt.prototype._strokeFuncHit = Kt, Vt.prototype.className = "TextPath", Vt.prototype._attrsAffectingSize = ["text", "fontSize", "data"], a(Vt), w.addGetterSetter(Vt, "data"), w.addGetterSetter(Vt, "fontFamily", "Arial"), w.addGetterSetter(Vt, "fontSize", 12, y()), w.addGetterSetter(Vt, "fontStyle", "normal"), w.addGetterSetter(Vt, "align", "left"), w.addGetterSetter(Vt, "letterSpacing", 0, y()), w.addGetterSetter(Vt, "textBaseline", "middle"), w.addGetterSetter(Vt, "fontVariant", "normal"), w.addGetterSetter(Vt, "text", ""), w.addGetterSetter(Vt, "textDecoration", null), w.addGetterSetter(Vt, "kerningFunc", null), s.mapMethods(Vt);
  var Qt = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange"].map(function (t) {
    return t + ".tr-konva";
  }).join(" "),
      Jt = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"].map(function (t) {
    return t + ".tr-konva";
  }).join(" "),
      Zt = {
    "top-left": -45,
    "top-center": 0,
    "top-right": 45,
    "middle-right": -90,
    "middle-left": 90,
    "bottom-left": -135,
    "bottom-center": 180,
    "bottom-right": 135
  },
      $t = ("ontouchstart" in r._global);
  var te = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"];

  function ee(t, e, i) {
    var n = i.x + (t.x - i.x) * Math.cos(e) - (t.y - i.y) * Math.sin(e),
        r = i.y + (t.x - i.x) * Math.sin(e) + (t.y - i.y) * Math.cos(e);
    return _k(_k({}, t), {
      rotation: t.rotation + e,
      x: n,
      y: r
    });
  }

  function ie(t, e) {
    return ee(t, e, function (t) {
      return {
        x: t.x + t.width / 2 * Math.cos(t.rotation) + t.height / 2 * Math.sin(-t.rotation),
        y: t.y + t.height / 2 * Math.cos(t.rotation) + t.width / 2 * Math.sin(t.rotation)
      };
    }(t));
  }

  var ne = function (t) {
    function e(e) {
      var i = t.call(this, e) || this;
      return i._transforming = !1, i._createElements(), i._handleMouseMove = i._handleMouseMove.bind(i), i._handleMouseUp = i._handleMouseUp.bind(i), i.update = i.update.bind(i), i.on(Qt, i.update), i.getNode() && i.update(), i;
    }

    return P(e, t), e.prototype.attachTo = function (t) {
      return this.setNode(t), this;
    }, e.prototype.setNode = function (t) {
      return f.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t]);
    }, e.prototype.getNode = function () {
      return this._nodes && this._nodes[0];
    }, e.prototype.setNodes = function (t) {
      var e = this;
      return void 0 === t && (t = []), this._nodes && this._nodes.length && this.detach(), this._nodes = t, 1 === t.length ? this.rotation(t[0].rotation()) : this.rotation(0), this._nodes.forEach(function (t) {
        var i = t._attrsAffectingSize.map(function (t) {
          return t + "Change.tr-konva";
        }).join(" "),
            n = function n() {
          1 === e.nodes().length && e.rotation(e.nodes()[0].rotation()), e._resetTransformCache(), e._transforming || e.isDragging() || e.update();
        };

        t.on(i, n), t.on(Jt, n), t.on("_clearTransformCache.tr-konva", n), t.on("xChange.tr-konva yChange.tr-konva", n), e._proxyDrag(t);
      }), this._resetTransformCache(), !!this.findOne(".top-left") && this.update(), this;
    }, e.prototype._proxyDrag = function (t) {
      var e,
          i = this;
      t.on("dragstart.tr-konva", function (n) {
        e = t.getAbsolutePosition(), i.isDragging() || t === i.findOne(".back") || i.startDrag(n, !1);
      }), t.on("dragmove.tr-konva", function (n) {
        if (e) {
          var r = t.getAbsolutePosition(),
              o = r.x - e.x,
              a = r.y - e.y;
          i.nodes().forEach(function (e) {
            if (e !== t && !e.isDragging()) {
              var i = e.getAbsolutePosition();
              e.setAbsolutePosition({
                x: i.x + o,
                y: i.y + a
              }), e.startDrag(n);
            }
          }), e = null;
        }
      });
    }, e.prototype.getNodes = function () {
      return this._nodes || [];
    }, e.prototype.getActiveAnchor = function () {
      return this._movingAnchorName;
    }, e.prototype.detach = function () {
      this._nodes && this._nodes.forEach(function (t) {
        t.off(".tr-konva");
      }), this._nodes = [], this._resetTransformCache();
    }, e.prototype._resetTransformCache = function () {
      this._clearCache("nodesRect"), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform");
    }, e.prototype._getNodeRect = function () {
      return this._getCache("nodesRect", this.__getNodeRect);
    }, e.prototype.__getNodeShape = function (t, e, i) {
      void 0 === e && (e = this.rotation());
      var n = t.getClientRect({
        skipTransform: !0,
        skipShadow: !0,
        skipStroke: this.ignoreStroke()
      }),
          o = t.getAbsoluteScale(i),
          a = t.getAbsolutePosition(i),
          s = n.x * o.x - t.offsetX() * o.x,
          h = n.y * o.y - t.offsetY() * o.y,
          l = (r.getAngle(t.getAbsoluteRotation()) + 2 * Math.PI) % (2 * Math.PI);
      return ee({
        x: a.x + s * Math.cos(l) + h * Math.sin(-l),
        y: a.y + h * Math.cos(l) + s * Math.sin(l),
        width: n.width * o.x,
        height: n.height * o.y,
        rotation: l
      }, -r.getAngle(e), {
        x: 0,
        y: 0
      });
    }, e.prototype.__getNodeRect = function () {
      var t = this;
      if (!this.getNode()) return {
        x: -1e8,
        y: -1e8,
        width: 0,
        height: 0,
        rotation: 0
      };
      var e = [];
      this.nodes().map(function (i) {
        var n = i.getClientRect({
          skipTransform: !0,
          skipShadow: !0,
          skipStroke: t.ignoreStroke()
        }),
            r = [{
          x: n.x,
          y: n.y
        }, {
          x: n.x + n.width,
          y: n.y
        }, {
          x: n.x + n.width,
          y: n.y + n.height
        }, {
          x: n.x,
          y: n.y + n.height
        }],
            o = i.getAbsoluteTransform();
        r.forEach(function (t) {
          var i = o.point(t);
          e.push(i);
        });
      });
      var i,
          n,
          o,
          a,
          s = new h();
      s.rotate(-r.getAngle(this.rotation())), e.forEach(function (t) {
        var e = s.point(t);
        void 0 === i && (i = o = e.x, n = a = e.y), i = Math.min(i, e.x), n = Math.min(n, e.y), o = Math.max(o, e.x), a = Math.max(a, e.y);
      }), s.invert();
      var l = s.point({
        x: i,
        y: n
      });
      return {
        x: l.x,
        y: l.y,
        width: o - i,
        height: a - n,
        rotation: r.getAngle(this.rotation())
      };
    }, e.prototype.getX = function () {
      return this._getNodeRect().x;
    }, e.prototype.getY = function () {
      return this._getNodeRect().y;
    }, e.prototype.getWidth = function () {
      return this._getNodeRect().width;
    }, e.prototype.getHeight = function () {
      return this._getNodeRect().height;
    }, e.prototype._createElements = function () {
      this._createBack(), te.forEach(function (t) {
        this._createAnchor(t);
      }.bind(this)), this._createAnchor("rotater");
    }, e.prototype._createAnchor = function (t) {
      var e = this,
          i = new Dt({
        stroke: "rgb(0, 161, 255)",
        fill: "white",
        strokeWidth: 1,
        name: t + " _anchor",
        dragDistance: 0,
        draggable: !0,
        hitStrokeWidth: $t ? 10 : "auto"
      }),
          n = this;
      i.on("mousedown touchstart", function (t) {
        n._handleMouseDown(t);
      }), i.on("dragstart", function (t) {
        i.stopDrag(), t.cancelBubble = !0;
      }), i.on("dragend", function (t) {
        t.cancelBubble = !0;
      }), i.on("mouseenter", function () {
        var n = r.getAngle(e.rotation()),
            o = function (t, e) {
          if ("rotater" === t) return "crosshair";
          e += f._degToRad(Zt[t] || 0);
          var i = (f._radToDeg(e) % 360 + 360) % 360;
          return f._inRange(i, 337.5, 360) || f._inRange(i, 0, 22.5) ? "ns-resize" : f._inRange(i, 22.5, 67.5) ? "nesw-resize" : f._inRange(i, 67.5, 112.5) ? "ew-resize" : f._inRange(i, 112.5, 157.5) ? "nwse-resize" : f._inRange(i, 157.5, 202.5) ? "ns-resize" : f._inRange(i, 202.5, 247.5) ? "nesw-resize" : f._inRange(i, 247.5, 292.5) ? "ew-resize" : f._inRange(i, 292.5, 337.5) ? "nwse-resize" : (f.error("Transformer has unknown angle for cursor detection: " + i), "pointer");
        }(t, n);

        i.getStage().content.style.cursor = o, e._cursorChange = !0;
      }), i.on("mouseout", function () {
        i.getStage().content.style.cursor = "", e._cursorChange = !1;
      }), this.add(i);
    }, e.prototype._createBack = function () {
      var t = this,
          e = new lt({
        name: "back",
        width: 0,
        height: 0,
        draggable: !0,
        sceneFunc: function sceneFunc(t) {
          var e = this.getParent(),
              i = e.padding();
          t.beginPath(), t.rect(-i, -i, this.width() + 2 * i, this.height() + 2 * i), t.moveTo(this.width() / 2, -i), e.rotateEnabled() && t.lineTo(this.width() / 2, -e.rotateAnchorOffset() * f._sign(this.height()) - i), t.fillStrokeShape(this);
        },
        hitFunc: function hitFunc(e, i) {
          if (t.shouldOverdrawWholeArea()) {
            var n = t.padding();
            e.beginPath(), e.rect(-n, -n, i.width() + 2 * n, i.height() + 2 * n), e.fillStrokeShape(i);
          }
        }
      });
      this.add(e), this._proxyDrag(e), e.on("dragstart", function (t) {
        t.cancelBubble = !0;
      }), e.on("dragmove", function (t) {
        t.cancelBubble = !0;
      }), e.on("dragend", function (t) {
        t.cancelBubble = !0;
      });
    }, e.prototype._handleMouseDown = function (t) {
      this._movingAnchorName = t.target.name().split(" ")[0];

      var e = this._getNodeRect(),
          i = e.width,
          n = e.height,
          r = Math.sqrt(Math.pow(i, 2) + Math.pow(n, 2));

      this.sin = Math.abs(n / r), this.cos = Math.abs(i / r), window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0), this._transforming = !0;
      var o = t.target.getAbsolutePosition(),
          a = t.target.getStage().getPointerPosition();
      this._anchorDragOffset = {
        x: a.x - o.x,
        y: a.y - o.y
      }, this._fire("transformstart", {
        evt: t,
        target: this.getNode()
      }), this._nodes.forEach(function (e) {
        e._fire("transformstart", {
          evt: t,
          target: e
        });
      });
    }, e.prototype._handleMouseMove = function (t) {
      var e,
          i,
          n,
          o = this.findOne("." + this._movingAnchorName),
          a = o.getStage();
      a.setPointersPositions(t);
      var s = a.getPointerPosition(),
          h = {
        x: s.x - this._anchorDragOffset.x,
        y: s.y - this._anchorDragOffset.y
      },
          l = o.getAbsolutePosition();
      o.setAbsolutePosition(h);
      var c = o.getAbsolutePosition();
      if (l.x !== c.x || l.y !== c.y) if ("rotater" !== this._movingAnchorName) {
        var d = this.keepRatio() || t.shiftKey,
            u = this.centeredScaling() || t.altKey;

        if ("top-left" === this._movingAnchorName) {
          if (d) {
            var p = u ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-right").x(),
              y: this.findOne(".bottom-right").y()
            };
            n = Math.sqrt(Math.pow(p.x - o.x(), 2) + Math.pow(p.y - o.y(), 2));
            var f = this.findOne(".top-left").x() > p.x ? -1 : 1,
                g = this.findOne(".top-left").y() > p.y ? -1 : 1;
            e = n * this.cos * f, i = n * this.sin * g, this.findOne(".top-left").x(p.x - e), this.findOne(".top-left").y(p.y - i);
          }
        } else if ("top-center" === this._movingAnchorName) this.findOne(".top-left").y(o.y());else if ("top-right" === this._movingAnchorName) {
          if (d) {
            p = u ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".bottom-left").x(),
              y: this.findOne(".bottom-left").y()
            };
            n = Math.sqrt(Math.pow(o.x() - p.x, 2) + Math.pow(p.y - o.y(), 2));
            f = this.findOne(".top-right").x() < p.x ? -1 : 1, g = this.findOne(".top-right").y() > p.y ? -1 : 1;
            e = n * this.cos * f, i = n * this.sin * g, this.findOne(".top-right").x(p.x + e), this.findOne(".top-right").y(p.y - i);
          }

          var v = o.position();
          this.findOne(".top-left").y(v.y), this.findOne(".bottom-right").x(v.x);
        } else if ("middle-left" === this._movingAnchorName) this.findOne(".top-left").x(o.x());else if ("middle-right" === this._movingAnchorName) this.findOne(".bottom-right").x(o.x());else if ("bottom-left" === this._movingAnchorName) {
          if (d) {
            p = u ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-right").x(),
              y: this.findOne(".top-right").y()
            };
            n = Math.sqrt(Math.pow(p.x - o.x(), 2) + Math.pow(o.y() - p.y, 2));
            f = p.x < o.x() ? -1 : 1, g = o.y() < p.y ? -1 : 1;
            e = n * this.cos * f, i = n * this.sin * g, o.x(p.x - e), o.y(p.y + i);
          }

          v = o.position(), this.findOne(".top-left").x(v.x), this.findOne(".bottom-right").y(v.y);
        } else if ("bottom-center" === this._movingAnchorName) this.findOne(".bottom-right").y(o.y());else if ("bottom-right" === this._movingAnchorName) {
          if (d) {
            p = u ? {
              x: this.width() / 2,
              y: this.height() / 2
            } : {
              x: this.findOne(".top-left").x(),
              y: this.findOne(".top-left").y()
            };
            n = Math.sqrt(Math.pow(o.x() - p.x, 2) + Math.pow(o.y() - p.y, 2));
            f = this.findOne(".bottom-right").x() < p.x ? -1 : 1, g = this.findOne(".bottom-right").y() < p.y ? -1 : 1;
            e = n * this.cos * f, i = n * this.sin * g, this.findOne(".bottom-right").x(p.x + e), this.findOne(".bottom-right").y(p.y + i);
          }
        } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName));

        if (u = this.centeredScaling() || t.altKey) {
          var y = this.findOne(".top-left"),
              m = this.findOne(".bottom-right"),
              _ = y.x(),
              b = y.y(),
              x = this.getWidth() - m.x(),
              S = this.getHeight() - m.y();

          m.move({
            x: -_,
            y: -b
          }), y.move({
            x: x,
            y: S
          });
        }

        var w = this.findOne(".top-left").getAbsolutePosition();
        e = w.x, i = w.y;
        var C = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(),
            P = this.findOne(".bottom-right").y() - this.findOne(".top-left").y();

        this._fitNodesInto({
          x: e,
          y: i,
          width: C,
          height: P,
          rotation: r.getAngle(this.rotation())
        }, t);
      } else {
        var k = this._getNodeRect();

        e = o.x() - k.width / 2, i = -o.y() + k.height / 2;
        var T = Math.atan2(-i, e) + Math.PI / 2;
        k.height < 0 && (T -= Math.PI);
        var A = r.getAngle(this.rotation()) + T,
            M = r.getAngle(this.rotationSnapTolerance()),
            G = ie(k, function (t, e, i) {
          for (var n = e, o = 0; o < t.length; o++) {
            var a = r.getAngle(t[o]),
                s = Math.abs(a - e) % (2 * Math.PI);
            Math.min(s, 2 * Math.PI - s) < i && (n = a);
          }

          return n;
        }(this.rotationSnaps(), A, M) - k.rotation);

        this._fitNodesInto(G, t);
      }
    }, e.prototype._handleMouseUp = function (t) {
      this._removeEvents(t);
    }, e.prototype.getAbsoluteTransform = function () {
      return this.getTransform();
    }, e.prototype._removeEvents = function (t) {
      if (this._transforming) {
        this._transforming = !1, window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0);
        var e = this.getNode();
        this._fire("transformend", {
          evt: t,
          target: e
        }), e && this._nodes.forEach(function (e) {
          e._fire("transformend", {
            evt: t,
            target: e
          });
        }), this._movingAnchorName = null;
      }
    }, e.prototype._fitNodesInto = function (t, e) {
      var i = this,
          n = this._getNodeRect();

      if (f._inRange(t.width, 2 * -this.padding() - 1, 1)) this.update();else if (f._inRange(t.height, 2 * -this.padding() - 1, 1)) this.update();else {
        var o = new h();

        if (o.rotate(r.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) {
          var a = o.point({
            x: 2 * -this.padding(),
            y: 0
          });
          t.x += a.x, t.y += a.y, t.width += 2 * this.padding(), this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= a.x, this._anchorDragOffset.y -= a.y;
        } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) {
          a = o.point({
            x: 2 * this.padding(),
            y: 0
          });
          this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= a.x, this._anchorDragOffset.y -= a.y, t.width += 2 * this.padding();
        }

        if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) {
          a = o.point({
            x: 0,
            y: 2 * -this.padding()
          });
          t.x += a.x, t.y += a.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= a.x, this._anchorDragOffset.y -= a.y, t.height += 2 * this.padding();
        } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) {
          a = o.point({
            x: 0,
            y: 2 * this.padding()
          });
          this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= a.x, this._anchorDragOffset.y -= a.y, t.height += 2 * this.padding();
        }

        if (this.boundBoxFunc()) {
          var s = this.boundBoxFunc()(n, t);
          s ? t = s : f.warn("boundBoxFunc returned falsy. You should return new bound rect from it!");
        }

        var l = new h();
        l.translate(n.x, n.y), l.rotate(n.rotation), l.scale(n.width / 1e7, n.height / 1e7);
        var c = new h();
        c.translate(t.x, t.y), c.rotate(t.rotation), c.scale(t.width / 1e7, t.height / 1e7);
        var d = c.multiply(l.invert());
        this._nodes.forEach(function (t) {
          var n,
              r = t.getParent().getAbsoluteTransform(),
              o = t.getTransform().copy();
          o.translate(t.offsetX(), t.offsetY());
          var a = new h();
          a.multiply(r.copy().invert()).multiply(d).multiply(r).multiply(o);
          var s = a.decompose();
          t.setAttrs(s), i._fire("transform", {
            evt: e,
            target: t
          }), t._fire("transform", {
            evt: e,
            target: t
          }), null === (n = t.getLayer()) || void 0 === n || n.batchDraw();
        }), this.rotation(f._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw();
      }
    }, e.prototype.forceUpdate = function () {
      this._resetTransformCache(), this.update();
    }, e.prototype._batchChangeChild = function (t, e) {
      this.findOne(t).setAttrs(e);
    }, e.prototype.update = function () {
      var t,
          e = this,
          i = this._getNodeRect();

      this.rotation(f._getRotation(i.rotation));
      var n = i.width,
          r = i.height,
          o = this.enabledAnchors(),
          a = this.resizeEnabled(),
          s = this.padding(),
          h = this.anchorSize();
      this.find("._anchor").each(function (t) {
        t.setAttrs({
          width: h,
          height: h,
          offsetX: h / 2,
          offsetY: h / 2,
          stroke: e.anchorStroke(),
          strokeWidth: e.anchorStrokeWidth(),
          fill: e.anchorFill(),
          cornerRadius: e.anchorCornerRadius()
        });
      }), this._batchChangeChild(".top-left", {
        x: 0,
        y: 0,
        offsetX: h / 2 + s,
        offsetY: h / 2 + s,
        visible: a && o.indexOf("top-left") >= 0
      }), this._batchChangeChild(".top-center", {
        x: n / 2,
        y: 0,
        offsetY: h / 2 + s,
        visible: a && o.indexOf("top-center") >= 0
      }), this._batchChangeChild(".top-right", {
        x: n,
        y: 0,
        offsetX: h / 2 - s,
        offsetY: h / 2 + s,
        visible: a && o.indexOf("top-right") >= 0
      }), this._batchChangeChild(".middle-left", {
        x: 0,
        y: r / 2,
        offsetX: h / 2 + s,
        visible: a && o.indexOf("middle-left") >= 0
      }), this._batchChangeChild(".middle-right", {
        x: n,
        y: r / 2,
        offsetX: h / 2 - s,
        visible: a && o.indexOf("middle-right") >= 0
      }), this._batchChangeChild(".bottom-left", {
        x: 0,
        y: r,
        offsetX: h / 2 + s,
        offsetY: h / 2 - s,
        visible: a && o.indexOf("bottom-left") >= 0
      }), this._batchChangeChild(".bottom-center", {
        x: n / 2,
        y: r,
        offsetY: h / 2 - s,
        visible: a && o.indexOf("bottom-center") >= 0
      }), this._batchChangeChild(".bottom-right", {
        x: n,
        y: r,
        offsetX: h / 2 - s,
        offsetY: h / 2 - s,
        visible: a && o.indexOf("bottom-right") >= 0
      }), this._batchChangeChild(".rotater", {
        x: n / 2,
        y: -this.rotateAnchorOffset() * f._sign(r) - s,
        visible: this.rotateEnabled()
      }), this._batchChangeChild(".back", {
        width: n,
        height: r,
        visible: this.borderEnabled(),
        stroke: this.borderStroke(),
        strokeWidth: this.borderStrokeWidth(),
        dash: this.borderDash(),
        x: 0,
        y: 0
      }), null === (t = this.getLayer()) || void 0 === t || t.batchDraw();
    }, e.prototype.isTransforming = function () {
      return this._transforming;
    }, e.prototype.stopTransform = function () {
      if (this._transforming) {
        this._removeEvents();

        var t = this.findOne("." + this._movingAnchorName);
        t && t.stopDrag();
      }
    }, e.prototype.destroy = function () {
      return this.getStage() && this._cursorChange && (this.getStage().content.style.cursor = ""), ft.prototype.destroy.call(this), this.detach(), this._removeEvents(), this;
    }, e.prototype.toObject = function () {
      return X.prototype.toObject.call(this);
    }, e;
  }(ft);

  ne.prototype.className = "Transformer", a(ne), w.addGetterSetter(ne, "enabledAnchors", te, function (t) {
    return t instanceof Array || f.warn("enabledAnchors value should be an array"), t instanceof Array && t.forEach(function (t) {
      -1 === te.indexOf(t) && f.warn("Unknown anchor name: " + t + ". Available names are: " + te.join(", "));
    }), t || [];
  }), w.addGetterSetter(ne, "resizeEnabled", !0), w.addGetterSetter(ne, "anchorSize", 10, y()), w.addGetterSetter(ne, "rotateEnabled", !0), w.addGetterSetter(ne, "rotationSnaps", []), w.addGetterSetter(ne, "rotateAnchorOffset", 50, y()), w.addGetterSetter(ne, "rotationSnapTolerance", 5, y()), w.addGetterSetter(ne, "borderEnabled", !0), w.addGetterSetter(ne, "anchorStroke", "rgb(0, 161, 255)"), w.addGetterSetter(ne, "anchorStrokeWidth", 1, y()), w.addGetterSetter(ne, "anchorFill", "white"), w.addGetterSetter(ne, "anchorCornerRadius", 0, y()), w.addGetterSetter(ne, "borderStroke", "rgb(0, 161, 255)"), w.addGetterSetter(ne, "borderStrokeWidth", 1, y()), w.addGetterSetter(ne, "borderDash"), w.addGetterSetter(ne, "keepRatio", !0), w.addGetterSetter(ne, "centeredScaling", !1), w.addGetterSetter(ne, "ignoreStroke", !1), w.addGetterSetter(ne, "padding", 0, y()), w.addGetterSetter(ne, "node"), w.addGetterSetter(ne, "nodes"), w.addGetterSetter(ne, "boundBoxFunc"), w.addGetterSetter(ne, "shouldOverdrawWholeArea", !1), w.backCompat(ne, {
    lineEnabled: "borderEnabled",
    rotateHandlerOffset: "rotateAnchorOffset",
    enabledHandlers: "enabledAnchors"
  }), s.mapMethods(ne);

  var re = function (t) {
    function e() {
      return null !== t && t.apply(this, arguments) || this;
    }

    return P(e, t), e.prototype._sceneFunc = function (t) {
      t.beginPath(), t.arc(0, 0, this.radius(), 0, r.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this);
    }, e.prototype.getWidth = function () {
      return 2 * this.radius();
    }, e.prototype.getHeight = function () {
      return 2 * this.radius();
    }, e.prototype.setWidth = function (t) {
      this.radius(t / 2);
    }, e.prototype.setHeight = function (t) {
      this.radius(t / 2);
    }, e;
  }(lt);

  function oe() {
    this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }

  re.prototype.className = "Wedge", re.prototype._centroid = !0, re.prototype._attrsAffectingSize = ["radius"], a(re), w.addGetterSetter(re, "radius", 0, y()), w.addGetterSetter(re, "angle", 0, y()), w.addGetterSetter(re, "clockwise", !1), w.backCompat(re, {
    angleDeg: "angle",
    getAngleDeg: "getAngle",
    setAngleDeg: "setAngle"
  }), s.mapMethods(re);
  var ae = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259],
      se = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
  w.addGetterSetter(X, "blurRadius", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "brightness", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "contrast", 0, y(), w.afterSetFilter);

  function he(t, e, i, n, r) {
    var o = i - e,
        a = r - n;
    return 0 === o ? n + a / 2 : 0 === a ? n : a * ((t - e) / o) + n;
  }

  w.addGetterSetter(X, "embossStrength", .5, y(), w.afterSetFilter), w.addGetterSetter(X, "embossWhiteLevel", .5, y(), w.afterSetFilter), w.addGetterSetter(X, "embossDirection", "top-left", null, w.afterSetFilter), w.addGetterSetter(X, "embossBlend", !1, null, w.afterSetFilter);
  w.addGetterSetter(X, "enhance", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "hue", 0, y(), w.afterSetFilter), w.addGetterSetter(X, "saturation", 0, y(), w.afterSetFilter), w.addGetterSetter(X, "luminance", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "hue", 0, y(), w.afterSetFilter), w.addGetterSetter(X, "saturation", 0, y(), w.afterSetFilter), w.addGetterSetter(X, "value", 0, y(), w.afterSetFilter);

  function le(t, e, i) {
    var n = 4 * (i * t.width + e),
        r = [];
    return r.push(t.data[n++], t.data[n++], t.data[n++], t.data[n++]), r;
  }

  function ce(t, e) {
    return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2));
  }

  w.addGetterSetter(X, "kaleidoscopePower", 2, y(), w.afterSetFilter), w.addGetterSetter(X, "kaleidoscopeAngle", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "threshold", 0, y(), w.afterSetFilter);
  w.addGetterSetter(X, "noise", .2, y(), w.afterSetFilter);
  w.addGetterSetter(X, "pixelSize", 8, y(), w.afterSetFilter);
  w.addGetterSetter(X, "levels", .5, y(), w.afterSetFilter);
  w.addGetterSetter(X, "red", 0, function (t) {
    return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t);
  }), w.addGetterSetter(X, "green", 0, function (t) {
    return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t);
  }), w.addGetterSetter(X, "blue", 0, v, w.afterSetFilter);
  w.addGetterSetter(X, "red", 0, function (t) {
    return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t);
  }), w.addGetterSetter(X, "green", 0, function (t) {
    return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t);
  }), w.addGetterSetter(X, "blue", 0, v, w.afterSetFilter), w.addGetterSetter(X, "alpha", 1, function (t) {
    return this._filterUpToDate = !1, t > 1 ? 1 : t < 0 ? 0 : t;
  });
  return w.addGetterSetter(X, "threshold", .5, y(), w.afterSetFilter), wt.Util._assign(wt, {
    Arc: Ct,
    Arrow: kt,
    Circle: Tt,
    Ellipse: At,
    Image: Mt,
    Label: Lt,
    Tag: Et,
    Line: Pt,
    Path: Ot,
    Rect: Dt,
    RegularPolygon: It,
    Ring: Bt,
    Sprite: Nt,
    Star: zt,
    Text: Ut,
    TextPath: Vt,
    Transformer: ne,
    Wedge: re,
    Filters: {
      Blur: function Blur(t) {
        var e = Math.round(this.blurRadius());
        e > 0 && function (t, e) {
          var i,
              n,
              r,
              o,
              a,
              s,
              h,
              l,
              c,
              d,
              u,
              p,
              f,
              g,
              v,
              y,
              m,
              _,
              b,
              x,
              S,
              w,
              C,
              P,
              k = t.data,
              T = t.width,
              A = t.height,
              M = e + e + 1,
              G = T - 1,
              R = A - 1,
              L = e + 1,
              E = L * (L + 1) / 2,
              O = new oe(),
              D = null,
              I = O,
              F = null,
              B = null,
              N = ae[e],
              z = se[e];

          for (r = 1; r < M; r++) {
            I = I.next = new oe(), r === L && (D = I);
          }

          for (I.next = O, h = s = 0, n = 0; n < A; n++) {
            for (y = m = _ = b = l = c = d = u = 0, p = L * (x = k[s]), f = L * (S = k[s + 1]), g = L * (w = k[s + 2]), v = L * (C = k[s + 3]), l += E * x, c += E * S, d += E * w, u += E * C, I = O, r = 0; r < L; r++) {
              I.r = x, I.g = S, I.b = w, I.a = C, I = I.next;
            }

            for (r = 1; r < L; r++) {
              o = s + ((G < r ? G : r) << 2), l += (I.r = x = k[o]) * (P = L - r), c += (I.g = S = k[o + 1]) * P, d += (I.b = w = k[o + 2]) * P, u += (I.a = C = k[o + 3]) * P, y += x, m += S, _ += w, b += C, I = I.next;
            }

            for (F = O, B = D, i = 0; i < T; i++) {
              k[s + 3] = C = u * N >> z, 0 !== C ? (C = 255 / C, k[s] = (l * N >> z) * C, k[s + 1] = (c * N >> z) * C, k[s + 2] = (d * N >> z) * C) : k[s] = k[s + 1] = k[s + 2] = 0, l -= p, c -= f, d -= g, u -= v, p -= F.r, f -= F.g, g -= F.b, v -= F.a, o = h + ((o = i + e + 1) < G ? o : G) << 2, l += y += F.r = k[o], c += m += F.g = k[o + 1], d += _ += F.b = k[o + 2], u += b += F.a = k[o + 3], F = F.next, p += x = B.r, f += S = B.g, g += w = B.b, v += C = B.a, y -= x, m -= S, _ -= w, b -= C, B = B.next, s += 4;
            }

            h += T;
          }

          for (i = 0; i < T; i++) {
            for (m = _ = b = y = c = d = u = l = 0, p = L * (x = k[s = i << 2]), f = L * (S = k[s + 1]), g = L * (w = k[s + 2]), v = L * (C = k[s + 3]), l += E * x, c += E * S, d += E * w, u += E * C, I = O, r = 0; r < L; r++) {
              I.r = x, I.g = S, I.b = w, I.a = C, I = I.next;
            }

            for (a = T, r = 1; r <= e; r++) {
              s = a + i << 2, l += (I.r = x = k[s]) * (P = L - r), c += (I.g = S = k[s + 1]) * P, d += (I.b = w = k[s + 2]) * P, u += (I.a = C = k[s + 3]) * P, y += x, m += S, _ += w, b += C, I = I.next, r < R && (a += T);
            }

            for (s = i, F = O, B = D, n = 0; n < A; n++) {
              k[(o = s << 2) + 3] = C = u * N >> z, C > 0 ? (C = 255 / C, k[o] = (l * N >> z) * C, k[o + 1] = (c * N >> z) * C, k[o + 2] = (d * N >> z) * C) : k[o] = k[o + 1] = k[o + 2] = 0, l -= p, c -= f, d -= g, u -= v, p -= F.r, f -= F.g, g -= F.b, v -= F.a, o = i + ((o = n + L) < R ? o : R) * T << 2, l += y += F.r = k[o], c += m += F.g = k[o + 1], d += _ += F.b = k[o + 2], u += b += F.a = k[o + 3], F = F.next, p += x = B.r, f += S = B.g, g += w = B.b, v += C = B.a, y -= x, m -= S, _ -= w, b -= C, B = B.next, s += T;
            }
          }
        }(t, e);
      },
      Brighten: function Brighten(t) {
        var e,
            i = 255 * this.brightness(),
            n = t.data,
            r = n.length;

        for (e = 0; e < r; e += 4) {
          n[e] += i, n[e + 1] += i, n[e + 2] += i;
        }
      },
      Contrast: function Contrast(t) {
        var e,
            i = Math.pow((this.contrast() + 100) / 100, 2),
            n = t.data,
            r = n.length,
            o = 150,
            a = 150,
            s = 150;

        for (e = 0; e < r; e += 4) {
          o = n[e], a = n[e + 1], s = n[e + 2], o /= 255, o -= .5, o *= i, o += .5, a /= 255, a -= .5, a *= i, a += .5, s /= 255, s -= .5, s *= i, s += .5, o = (o *= 255) < 0 ? 0 : o > 255 ? 255 : o, a = (a *= 255) < 0 ? 0 : a > 255 ? 255 : a, s = (s *= 255) < 0 ? 0 : s > 255 ? 255 : s, n[e] = o, n[e + 1] = a, n[e + 2] = s;
        }
      },
      Emboss: function Emboss(t) {
        var e = 10 * this.embossStrength(),
            i = 255 * this.embossWhiteLevel(),
            n = this.embossDirection(),
            r = this.embossBlend(),
            o = 0,
            a = 0,
            s = t.data,
            h = t.width,
            l = t.height,
            c = 4 * h,
            d = l;

        switch (n) {
          case "top-left":
            o = -1, a = -1;
            break;

          case "top":
            o = -1, a = 0;
            break;

          case "top-right":
            o = -1, a = 1;
            break;

          case "right":
            o = 0, a = 1;
            break;

          case "bottom-right":
            o = 1, a = 1;
            break;

          case "bottom":
            o = 1, a = 0;
            break;

          case "bottom-left":
            o = 1, a = -1;
            break;

          case "left":
            o = 0, a = -1;
            break;

          default:
            f.error("Unknown emboss direction: " + n);
        }

        do {
          var u = (d - 1) * c,
              p = o;
          d + p < 1 && (p = 0), d + p > l && (p = 0);
          var g = (d - 1 + p) * h * 4,
              v = h;

          do {
            var y = u + 4 * (v - 1),
                m = a;
            v + m < 1 && (m = 0), v + m > h && (m = 0);

            var _ = g + 4 * (v - 1 + m),
                b = s[y] - s[_],
                x = s[y + 1] - s[_ + 1],
                S = s[y + 2] - s[_ + 2],
                w = b,
                C = w > 0 ? w : -w;

            if ((x > 0 ? x : -x) > C && (w = x), (S > 0 ? S : -S) > C && (w = S), w *= e, r) {
              var P = s[y] + w,
                  k = s[y + 1] + w,
                  T = s[y + 2] + w;
              s[y] = P > 255 ? 255 : P < 0 ? 0 : P, s[y + 1] = k > 255 ? 255 : k < 0 ? 0 : k, s[y + 2] = T > 255 ? 255 : T < 0 ? 0 : T;
            } else {
              var A = i - w;
              A < 0 ? A = 0 : A > 255 && (A = 255), s[y] = s[y + 1] = s[y + 2] = A;
            }
          } while (--v);
        } while (--d);
      },
      Enhance: function Enhance(t) {
        var e,
            i,
            n,
            r,
            o = t.data,
            a = o.length,
            s = o[0],
            h = s,
            l = o[1],
            c = l,
            d = o[2],
            u = d,
            p = this.enhance();

        if (0 !== p) {
          for (r = 0; r < a; r += 4) {
            (e = o[r + 0]) < s ? s = e : e > h && (h = e), (i = o[r + 1]) < l ? l = i : i > c && (c = i), (n = o[r + 2]) < d ? d = n : n > u && (u = n);
          }

          var f, g, v, y, m, _, b, x, S;

          for (h === s && (h = 255, s = 0), c === l && (c = 255, l = 0), u === d && (u = 255, d = 0), p > 0 ? (g = h + p * (255 - h), v = s - p * (s - 0), m = c + p * (255 - c), _ = l - p * (l - 0), x = u + p * (255 - u), S = d - p * (d - 0)) : (g = h + p * (h - (f = .5 * (h + s))), v = s + p * (s - f), m = c + p * (c - (y = .5 * (c + l))), _ = l + p * (l - y), x = u + p * (u - (b = .5 * (u + d))), S = d + p * (d - b)), r = 0; r < a; r += 4) {
            o[r + 0] = he(o[r + 0], s, h, v, g), o[r + 1] = he(o[r + 1], l, c, _, m), o[r + 2] = he(o[r + 2], d, u, S, x);
          }
        }
      },
      Grayscale: function Grayscale(t) {
        var e,
            i,
            n = t.data,
            r = n.length;

        for (e = 0; e < r; e += 4) {
          i = .34 * n[e] + .5 * n[e + 1] + .16 * n[e + 2], n[e] = i, n[e + 1] = i, n[e + 2] = i;
        }
      },
      HSL: function HSL(t) {
        var e,
            i,
            n,
            r,
            o,
            a = t.data,
            s = a.length,
            h = Math.pow(2, this.saturation()),
            l = Math.abs(this.hue() + 360) % 360,
            c = 127 * this.luminance(),
            d = 1 * h * Math.cos(l * Math.PI / 180),
            u = 1 * h * Math.sin(l * Math.PI / 180),
            p = .299 + .701 * d + .167 * u,
            f = .587 - .587 * d + .33 * u,
            g = .114 - .114 * d - .497 * u,
            v = .299 - .299 * d - .328 * u,
            y = .587 + .413 * d + .035 * u,
            m = .114 - .114 * d + .293 * u,
            _ = .299 - .3 * d + 1.25 * u,
            b = .587 - .586 * d - 1.05 * u,
            x = .114 + .886 * d - .2 * u;

        for (e = 0; e < s; e += 4) {
          i = a[e + 0], n = a[e + 1], r = a[e + 2], o = a[e + 3], a[e + 0] = p * i + f * n + g * r + c, a[e + 1] = v * i + y * n + m * r + c, a[e + 2] = _ * i + b * n + x * r + c, a[e + 3] = o;
        }
      },
      HSV: function HSV(t) {
        var e,
            i,
            n,
            r,
            o,
            a = t.data,
            s = a.length,
            h = Math.pow(2, this.value()),
            l = Math.pow(2, this.saturation()),
            c = Math.abs(this.hue() + 360) % 360,
            d = h * l * Math.cos(c * Math.PI / 180),
            u = h * l * Math.sin(c * Math.PI / 180),
            p = .299 * h + .701 * d + .167 * u,
            f = .587 * h - .587 * d + .33 * u,
            g = .114 * h - .114 * d - .497 * u,
            v = .299 * h - .299 * d - .328 * u,
            y = .587 * h + .413 * d + .035 * u,
            m = .114 * h - .114 * d + .293 * u,
            _ = .299 * h - .3 * d + 1.25 * u,
            b = .587 * h - .586 * d - 1.05 * u,
            x = .114 * h + .886 * d - .2 * u;

        for (e = 0; e < s; e += 4) {
          i = a[e + 0], n = a[e + 1], r = a[e + 2], o = a[e + 3], a[e + 0] = p * i + f * n + g * r, a[e + 1] = v * i + y * n + m * r, a[e + 2] = _ * i + b * n + x * r, a[e + 3] = o;
        }
      },
      Invert: function Invert(t) {
        var e,
            i = t.data,
            n = i.length;

        for (e = 0; e < n; e += 4) {
          i[e] = 255 - i[e], i[e + 1] = 255 - i[e + 1], i[e + 2] = 255 - i[e + 2];
        }
      },
      Kaleidoscope: function Kaleidoscope(t) {
        var e,
            i,
            n,
            r,
            o,
            a,
            s,
            h,
            l,
            c = t.width,
            d = t.height,
            u = Math.round(this.kaleidoscopePower()),
            p = Math.round(this.kaleidoscopeAngle()),
            g = Math.floor(c * (p % 360) / 360);

        if (!(u < 1)) {
          var v = f.createCanvasElement();
          v.width = c, v.height = d;
          var y = v.getContext("2d").getImageData(0, 0, c, d);
          !function (t, e, i) {
            var n,
                r,
                o,
                a,
                s = t.data,
                h = e.data,
                l = t.width,
                c = t.height,
                d = i.polarCenterX || l / 2,
                u = i.polarCenterY || c / 2,
                p = 0,
                f = 0,
                g = 0,
                v = 0,
                y = Math.sqrt(d * d + u * u);
            r = l - d, o = c - u, y = (a = Math.sqrt(r * r + o * o)) > y ? a : y;

            var m,
                _,
                b,
                x,
                S = c,
                w = l,
                C = 360 / w * Math.PI / 180;

            for (_ = 0; _ < w; _ += 1) {
              for (b = Math.sin(_ * C), x = Math.cos(_ * C), m = 0; m < S; m += 1) {
                r = Math.floor(d + y * m / S * x), p = s[(n = 4 * ((o = Math.floor(u + y * m / S * b)) * l + r)) + 0], f = s[n + 1], g = s[n + 2], v = s[n + 3], h[(n = 4 * (_ + m * l)) + 0] = p, h[n + 1] = f, h[n + 2] = g, h[n + 3] = v;
              }
            }
          }(t, y, {
            polarCenterX: c / 2,
            polarCenterY: d / 2
          });

          for (var m = c / Math.pow(2, u); m <= 8;) {
            m *= 2, u -= 1;
          }

          var _ = m = Math.ceil(m),
              b = 0,
              x = _,
              S = 1;

          for (g + m > c && (b = _, x = 0, S = -1), i = 0; i < d; i += 1) {
            for (e = b; e !== x; e += S) {
              h = 4 * (c * i + Math.round(e + g) % c), r = y.data[h + 0], o = y.data[h + 1], a = y.data[h + 2], s = y.data[h + 3], l = 4 * (c * i + e), y.data[l + 0] = r, y.data[l + 1] = o, y.data[l + 2] = a, y.data[l + 3] = s;
            }
          }

          for (i = 0; i < d; i += 1) {
            for (_ = Math.floor(m), n = 0; n < u; n += 1) {
              for (e = 0; e < _ + 1; e += 1) {
                h = 4 * (c * i + e), r = y.data[h + 0], o = y.data[h + 1], a = y.data[h + 2], s = y.data[h + 3], l = 4 * (c * i + 2 * _ - e - 1), y.data[l + 0] = r, y.data[l + 1] = o, y.data[l + 2] = a, y.data[l + 3] = s;
              }

              _ *= 2;
            }
          }

          !function (t, e, i) {
            var n,
                r,
                o,
                a,
                s,
                h,
                l = t.data,
                c = e.data,
                d = t.width,
                u = t.height,
                p = i.polarCenterX || d / 2,
                f = i.polarCenterY || u / 2,
                g = 0,
                v = 0,
                y = 0,
                m = 0,
                _ = Math.sqrt(p * p + f * f);

            r = d - p, o = u - f, _ = (h = Math.sqrt(r * r + o * o)) > _ ? h : _;
            var b,
                x,
                S,
                w = u,
                C = d,
                P = i.polarRotation || 0;

            for (r = 0; r < d; r += 1) {
              for (o = 0; o < u; o += 1) {
                a = r - p, s = o - f, b = Math.sqrt(a * a + s * s) * w / _, x = (x = (180 * Math.atan2(s, a) / Math.PI + 360 + P) % 360) * C / 360, S = Math.floor(x), g = l[(n = 4 * (Math.floor(b) * d + S)) + 0], v = l[n + 1], y = l[n + 2], m = l[n + 3], c[(n = 4 * (o * d + r)) + 0] = g, c[n + 1] = v, c[n + 2] = y, c[n + 3] = m;
              }
            }
          }(y, t, {
            polarRotation: 0
          });
        }
      },
      Mask: function Mask(t) {
        var e = function (t, e) {
          var i = le(t, 0, 0),
              n = le(t, t.width - 1, 0),
              r = le(t, 0, t.height - 1),
              o = le(t, t.width - 1, t.height - 1),
              a = e || 10;

          if (ce(i, n) < a && ce(n, o) < a && ce(o, r) < a && ce(r, i) < a) {
            for (var s = function (t) {
              for (var e = [0, 0, 0], i = 0; i < t.length; i++) {
                e[0] += t[i][0], e[1] += t[i][1], e[2] += t[i][2];
              }

              return e[0] /= t.length, e[1] /= t.length, e[2] /= t.length, e;
            }([n, i, o, r]), h = [], l = 0; l < t.width * t.height; l++) {
              var c = ce(s, [t.data[4 * l], t.data[4 * l + 1], t.data[4 * l + 2]]);
              h[l] = c < a ? 0 : 255;
            }

            return h;
          }
        }(t, this.threshold());

        return e && function (t, e) {
          for (var i = 0; i < t.width * t.height; i++) {
            t.data[4 * i + 3] = e[i];
          }
        }(t, e = function (t, e, i) {
          for (var n = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9], r = Math.round(Math.sqrt(n.length)), o = Math.floor(r / 2), a = [], s = 0; s < i; s++) {
            for (var h = 0; h < e; h++) {
              for (var l = s * e + h, c = 0, d = 0; d < r; d++) {
                for (var u = 0; u < r; u++) {
                  var p = s + d - o,
                      f = h + u - o;

                  if (p >= 0 && p < i && f >= 0 && f < e) {
                    var g = n[d * r + u];
                    c += t[p * e + f] * g;
                  }
                }
              }

              a[l] = c;
            }
          }

          return a;
        }(e = function (t, e, i) {
          for (var n = [1, 1, 1, 1, 1, 1, 1, 1, 1], r = Math.round(Math.sqrt(n.length)), o = Math.floor(r / 2), a = [], s = 0; s < i; s++) {
            for (var h = 0; h < e; h++) {
              for (var l = s * e + h, c = 0, d = 0; d < r; d++) {
                for (var u = 0; u < r; u++) {
                  var p = s + d - o,
                      f = h + u - o;

                  if (p >= 0 && p < i && f >= 0 && f < e) {
                    var g = n[d * r + u];
                    c += t[p * e + f] * g;
                  }
                }
              }

              a[l] = c >= 1020 ? 255 : 0;
            }
          }

          return a;
        }(e = function (t, e, i) {
          for (var n = [1, 1, 1, 1, 0, 1, 1, 1, 1], r = Math.round(Math.sqrt(n.length)), o = Math.floor(r / 2), a = [], s = 0; s < i; s++) {
            for (var h = 0; h < e; h++) {
              for (var l = s * e + h, c = 0, d = 0; d < r; d++) {
                for (var u = 0; u < r; u++) {
                  var p = s + d - o,
                      f = h + u - o;

                  if (p >= 0 && p < i && f >= 0 && f < e) {
                    var g = n[d * r + u];
                    c += t[p * e + f] * g;
                  }
                }
              }

              a[l] = 2040 === c ? 255 : 0;
            }
          }

          return a;
        }(e, t.width, t.height), t.width, t.height), t.width, t.height)), t;
      },
      Noise: function Noise(t) {
        var e,
            i = 255 * this.noise(),
            n = t.data,
            r = n.length,
            o = i / 2;

        for (e = 0; e < r; e += 4) {
          n[e + 0] += o - 2 * o * Math.random(), n[e + 1] += o - 2 * o * Math.random(), n[e + 2] += o - 2 * o * Math.random();
        }
      },
      Pixelate: function Pixelate(t) {
        var e,
            i,
            n,
            r,
            o,
            a,
            s,
            h,
            l,
            c,
            d,
            u,
            p,
            g,
            v = Math.ceil(this.pixelSize()),
            y = t.width,
            m = t.height,
            _ = Math.ceil(y / v),
            b = Math.ceil(m / v),
            x = t.data;

        if (v <= 0) f.error("pixelSize value can not be <= 0");else for (u = 0; u < _; u += 1) {
          for (p = 0; p < b; p += 1) {
            for (r = 0, o = 0, a = 0, s = 0, l = (h = u * v) + v, d = (c = p * v) + v, g = 0, e = h; e < l; e += 1) {
              if (!(e >= y)) for (i = c; i < d; i += 1) {
                i >= m || (r += x[(n = 4 * (y * i + e)) + 0], o += x[n + 1], a += x[n + 2], s += x[n + 3], g += 1);
              }
            }

            for (r /= g, o /= g, a /= g, s /= g, e = h; e < l; e += 1) {
              if (!(e >= y)) for (i = c; i < d; i += 1) {
                i >= m || (x[(n = 4 * (y * i + e)) + 0] = r, x[n + 1] = o, x[n + 2] = a, x[n + 3] = s);
              }
            }
          }
        }
      },
      Posterize: function Posterize(t) {
        var e,
            i = Math.round(254 * this.levels()) + 1,
            n = t.data,
            r = n.length,
            o = 255 / i;

        for (e = 0; e < r; e += 1) {
          n[e] = Math.floor(n[e] / o) * o;
        }
      },
      RGB: function RGB(t) {
        var e,
            i,
            n = t.data,
            r = n.length,
            o = this.red(),
            a = this.green(),
            s = this.blue();

        for (e = 0; e < r; e += 4) {
          i = (.34 * n[e] + .5 * n[e + 1] + .16 * n[e + 2]) / 255, n[e] = i * o, n[e + 1] = i * a, n[e + 2] = i * s, n[e + 3] = n[e + 3];
        }
      },
      RGBA: function RGBA(t) {
        var e,
            i,
            n = t.data,
            r = n.length,
            o = this.red(),
            a = this.green(),
            s = this.blue(),
            h = this.alpha();

        for (e = 0; e < r; e += 4) {
          i = 1 - h, n[e] = o * h + n[e] * i, n[e + 1] = a * h + n[e + 1] * i, n[e + 2] = s * h + n[e + 2] * i;
        }
      },
      Sepia: function Sepia(t) {
        var e,
            i,
            n,
            r,
            o = t.data,
            a = o.length;

        for (e = 0; e < a; e += 4) {
          i = o[e + 0], n = o[e + 1], r = o[e + 2], o[e + 0] = Math.min(255, .393 * i + .769 * n + .189 * r), o[e + 1] = Math.min(255, .349 * i + .686 * n + .168 * r), o[e + 2] = Math.min(255, .272 * i + .534 * n + .131 * r);
        }
      },
      Solarize: function Solarize(t) {
        var e = t.data,
            i = t.width,
            n = 4 * i,
            r = t.height;

        do {
          var o = (r - 1) * n,
              a = i;

          do {
            var s = o + 4 * (a - 1),
                h = e[s],
                l = e[s + 1],
                c = e[s + 2];
            h > 127 && (h = 255 - h), l > 127 && (l = 255 - l), c > 127 && (c = 255 - c), e[s] = h, e[s + 1] = l, e[s + 2] = c;
          } while (--a);
        } while (--r);
      },
      Threshold: function Threshold(t) {
        var e,
            i = 255 * this.threshold(),
            n = t.data,
            r = n.length;

        for (e = 0; e < r; e += 1) {
          n[e] = n[e] < i ? 0 : 255;
        }
      }
    }
  });
});
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard', ['ui.router', 'ngSanitize', 'templates', 'core.ui', 'ngMaterial', 'rx', 'ngPromiseExtras', 'ngAria']).config(function ($compileProvider, $ariaProvider) {
    // https://code.angularjs.org/1.5.11/docs/api/ng/provider/$compileProvider
    $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|filesystem|file):/);
    $ariaProvider.config({
      bindKeypress: false
    });
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').config(function ($stateProvider, $urlRouterProvider, ROUTES) {
    $urlRouterProvider.otherwise('/');
    $stateProvider.state({
      name: 'schedule',
      url: ROUTES.SCHEDULE,
      templateUrl: 'schedule/schedule.html'
    }).state({
      name: 'authentication',
      url: ROUTES.AUTHENTICATION,
      templateUrl: 'setup/authentication.html'
    }).state({
      name: 'pickroom',
      url: ROUTES.PICK_ROOM,
      templateUrl: 'setup/pickRoom.html'
    }).state('/', {
      name: 'default',
      url: '/',
      templateUrl: 'setup/init.html'
    });
  });
})(window.angular);
"use strict";

(function ($angular) {
  var app = $angular.module('scheduleBoard');
  app.controller('mainController', ["$q", "$scope", "interactivityManager", "cardApiManager", "backgroundDataManager", "displayConfigurationManager", "mediaUtil", "textUtil", "displayUtil", function ($q, $scope, interactivityManager, cardApiManager, backgroundDataManager, displayConfigurationManager, mediaUtil, textUtil, displayUtil) {
    $scope.backgroundMedia = undefined;
    $scope.backgroundColor = 'white';
    $scope.showDialog = false;
    var dialogApiPromise = $q.defer();
    var dialogApi;
    var subscribers = [];
    cardApiManager.init();
    subscribers.push(displayConfigurationManager.subscribeToCustomFontChanged(onFontUpdate));

    $scope.onDialogApiReady = function (api) {
      dialogApi = api;
      dialogApiPromise.resolve();
    };

    $scope.$on('triggerDialogEvent', function (event, data) {
      dialogApiPromise.promise.then(function () {
        if (!data.showDialog) {
          dialogApi.close();
          return;
        }

        $scope.showDialog = true;
        dialogApi.open(data.dialogModel);
      });
    });

    $scope.onDialogClose = function () {
      $scope.showDialog = false;
    };

    function onBackgroundColorChanged(color) {
      $scope.backgroundColor = color;
    }

    function onBackgroundMediaChanged(media) {
      $scope.backgroundMedia = media;
    }

    function onBackgroundMaskColorChanged(color) {
      $scope.maskColor = color;
    }

    function onFontUpdate(font) {
      font = font || {};
      var fontFormat = mediaUtil.getMediaExtension(font.file);
      var fontName = mediaUtil.removeMediaExtension(font.originalName);
      displayUtil.appendCssClassOverwrite('customFontFace', font.path, textUtil.formatText('{0} {font-family:{1}; src:url("{2}") format({3})}', ['@font-face', fontName, font.path, fontFormat]));
      displayUtil.appendCssClassOverwrite('customFont', fontName, textUtil.formatText('{0} {font-family:{1}}', ['.main-controller, input, button, .schedule-board .header .header-components', fontName]));
    }

    backgroundDataManager.getBackgroundColor().subscribe(onBackgroundColorChanged);
    backgroundDataManager.getBackgroundMedia().subscribe(onBackgroundMediaChanged);
    backgroundDataManager.getBackgroundMaskColor().subscribe(onBackgroundMaskColorChanged);
    interactivityManager.start();
  }]);
})(window.angular);
"use strict";

angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('components/ctDialog.html', '<div class="overlay dialog-holder" ng-click="$ctrl.overlayClicked($event)">\n' + '    <div ng-show="$ctrl.isOpened" ng-class="$ctrl.dialogModel.styling.windowClass">\n' + '        <div ng-show="$ctrl.dialogModel.headerTitle!=undefined" ng-class="$ctrl.dialogModel.styling.headerClass" class="dialog-header">\n' + '            {{$ctrl.dialogModel.headerTitle}}\n' + '        </div>\n' + '        <ct-checkpoint class="dialog-content" checkpoint="$ctrl.dialogModel.checkpoint" ng-if="$ctrl.dialogModel.checkpoint" on-accept-clicked="$ctrl.onAcceptClicked" on-cancel-clicked="$ctrl.onCancelClicked">\n' + '        </ct-checkpoint>\n' + '        <div ng-class="$ctrl.dialogModel.styling.inputClass" class="input-holder" ng-show="$ctrl.state==$ctrl.DIALOG_STATE.INPUT">\n' + '            <div class="title" ng-if="$ctrl.dialogModel.inputTitle">{{$ctrl.dialogModel.inputTitle}}</div>\n' + '            <div class="description" ng-bind-html="$ctrl.dialogModel.description"></div>\n' + '            <div class="form" ng-show="$ctrl.dialogModel.showInput">\n' + '                <input type="textbox" id="ctDialogInputBox" placeholder="{{$ctrl.dialogModel.inputPlaceholder}}" ng-model="$ctrl.dialogModel.inputText" ng-keypress="$ctrl.onInputKeyPress($event)" ng-keyup="$ctrl.onInputKeyUp($event)" ng-click="$ctrl.inputTextClicked($event)">\n' + '            </div>\n' + '            <div class="dialog-options-holder" ng-if="$ctrl.dialogModel.showOptions">\n' + '                <div ng-repeat="option in $ctrl.dialogModel.selectOptions">\n' + '                    <button class="main-btn option-btn" ng-class="option.cssClass" ng-style="$ctrl.dialogModel.selectOptionsStyle" ng-click="$ctrl.onOptionClicked(option)">{{option.text}}</button>\n' + '                </div>\n' + '            </div>\n' + '            <div ng-class="$ctrl.dialogModel.styling.buttonsClass">\n' + '                <button id="buttonOther" ng-class="$ctrl.dialogModel.styling.buttonOtherClass" ng-style="$ctrl.dialogModel.otherStyle" ng-show="$ctrl.dialogModel.showOther" ng-click="$ctrl.onOtherClicked()">{{$ctrl.dialogModel.otherText}}</button>\n' + '                <button id="buttonAccept" ng-disabled="$ctrl.dialogModel.acceptDisabled" ng-class="$ctrl.dialogModel.styling.buttonAcceptClass" ng-style="$ctrl.dialogModel.acceptStyle" ng-show="$ctrl.dialogModel.showAccept" ng-click="$ctrl.onAcceptClicked()">{{$ctrl.dialogModel.acceptText}}</button>\n' + '                <button ng-class="$ctrl.dialogModel.styling.buttonCancelClass" ng-hide="$ctrl.dialogModel.hideCancel" ng-click="$ctrl.onCancelClicked()">{{$ctrl.dialogModel.cancelText}}</button>\n' + '            </div>\n' + '        </div>\n' + '        <div class="phase-processing" ng-show="$ctrl.state==$ctrl.DIALOG_STATE.PROCESSING">\n' + '            <div class="title">{{$ctrl.dialogModel.processingTitle}}</div>\n' + '            <div class="asui loading-mask-holder">\n' + '                <asui-loading-mask show="true"></asui-loading-mask>\n' + '            </div>\n' + '        </div>\n' + '        <div class="phase-success" ng-show="$ctrl.state==$ctrl.DIALOG_STATE.SUCCESS">\n' + '            <div class="icon" ng-class="$ctrl.dialogModel.icon" ng-if="$ctrl.dialogModel.icon"></div>\n' + '            <div class="title">{{$ctrl.dialogModel.successTitle}}</div>\n' + '            <div class="success"><i class="icon icon-success"></i></div>\n' + '        </div>\n' + '        <div class="phase-retry" ng-show="$ctrl.state==$ctrl.DIALOG_STATE.RETRY">\n' + '            <div class="title">{{$ctrl.dialogModel.retryTitle}}</div>\n' + '            <div class="buttons">\n' + '                <button class="main-btn accept-btn outline-btn" ng-click="$ctrl.onRetryClicked()" ng-class="$ctrl.dialogModel.styling.buttonRetryClass">{{$ctrl.dialogModel.tryAgainText}}</button>\n' + '                <button class="main-btn" ng-hide="$ctrl.dialogModel.hideCancel" ng-click="$ctrl.onCancelClicked()">{{$ctrl.dialogModel.cancelText}}</button>\n' + '            </div>\n' + '        </div>\n' + '        <div class="phase-failure" ng-show="$ctrl.state==$ctrl.DIALOG_STATE.FAILURE">\n' + '            <div class="icon" ng-class="$ctrl.dialogModel.failureIcon" ng-if="$ctrl.dialogModel.failureIcon"></div>\n' + '            <div class="title">{{$ctrl.dialogModel.failureTitle}}</div>\n' + '            <div class="buttons">\n' + '                <button class="main-btn" ng-hide="$ctrl.dialogModel.hideCancel" ng-click="$ctrl.onCancelClicked()" ng-class="$ctrl.dialogModel.styling.buttonCancelClass">{{$ctrl.dialogModel.cancelText}}</button>\n' + '            </div>\n' + '        </div>\n' + '        <div class="confirmation-dialog" ng-show="$ctrl.dialogModel.showConfirmation">\n' + '            <div class="dialog-window centered-dialog-window">\n' + '                <div class="icon" ng-class="$ctrl.dialogModel.icon" ng-if="$ctrl.dialogModel.icon"></div>\n' + '                <div class="title">{{$ctrl.dialogModel.confirmationTitle}}</div>\n' + '                <div class="buttons">\n' + '                    <button class="main-btn outline-btn" ng-click="$ctrl.onConfirmClicked()">{{$ctrl.dialogModel.confirmationText}}</button>\n' + '                    <button class="main-btn" ng-click="$ctrl.onCancelConfirmationClicked()">{{$ctrl.dialogModel.cancelConfirmationText}}</button>\n' + '                </div>\n' + '            </div>\n' + '        </div>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('components/ctProvidersCustom.html', '<div class="box custom-box">\n' + '    <div class="title">{{title}}</div>\n' + '    <div class="form">\n' + '        <span>Provider URL</span>\n' + '        <input type="textbox" placeholder="Enter provider URL here" ng-model="providerUrlInput" ng-change="onInputChanged(\'providerUrlInput\')">\n' + '        <span ng-show="warningMessage" class="warning-message">{{warningMessage}}</span>\n' + '        <span ng-show="errorMessage" class="error-message">{{errorMessage}}</span>\n' + '        <span>API Key</span>\n' + '        <input type="textbox" placeholder="Enter API key here" ng-model="apiKeyInput" ng-change="onInputChanged(\'apiKeyInput\')">\n' + '        <span ng-show="apiKeyErrorMessage" class="error-message">{{apiKeyErrorMessage}}</span>\n' + '        <div class="headers">\n' + '            <div id="header-inputs" class="header-inputs" ng-show="headers.length > 0">\n' + '                <div class="header" ng-repeat="header in headers">\n' + '                    <input type="textbox" class="header-key" placeholder="Enter header here" ng-model="header.key" ng-change="onHeaderKeyChanged()">\n' + '                    <input type="textbox" class="header-value" placeholder="Enter value here" ng-model="header.value" ng-change="onHeaderValueChanged()">\n' + '                    <div class="header-button" ng-click="deleteHeader($index)"></div>\n' + '                </div>\n' + '            </div>\n' + '            <div class="link" ng-click="onAddHeaderClicked()">Add HTTP(S) header</div>\n' + '        </div>\n' + '        <button type="button" ng-click="onConfigureButtonClicked()" ng-disabled="isButtonDisabled" ng-class="{\'input-disabled\': isButtonDisabled}">Configure</button>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('components/ctRoomPicker.html', '<div class="error" ng-show="$ctrl.errorMessage != undefined">{{$ctrl.errorMessage}}</div>\n' + '<div class="modal-content room-picker-dialog">\n' + '    <div class="modal-header">{{$ctrl.header}}\n' + '        <div class="modal-sub-header" ng-if="$ctrl.subHeader">{{$ctrl.subHeader}}</div>\n' + '    </div>\n' + '    <div class="room-picker-dialog-loading asui" ng-if="$ctrl.roomsProcessing">\n' + '        <asui-loading-mask show="$ctrl.roomsProcessing"></asui-loading-mask>\n' + '    </div>\n' + '    <div class="modal-holder" ng-if="$ctrl.shouldShowView($ctrl.VIEWS.MANAGE) && !$ctrl.roomsProcessing">\n' + '        <div class="modal-body asui">\n' + '            <div class="title" ng-if="$ctrl.title">{{$ctrl.title}}</div>\n' + '            <form class="rooms-input">\n' + '                <div class="rooms-input-block">\n' + '                    <asui-tags-input model="$ctrl.selectedRoomsModel" placeholder="{{$ctrl.roomIdInput.placeholder}}" display-property="{{$ctrl.roomIdInput.options.displayProperty}}" validation-in-progress="$ctrl.roomIdInput.validationInProgress" on-tag-removed="$ctrl.onRoomRemoved(tag)" on-invalid-tag="$ctrl.onInvalidRoom(tag)" options="$ctrl.roomIdInput.options">\n' + '                    </asui-tags-input>\n' + '                </div>\n' + '            </form>\n' + '            <div class="link" ng-click="$ctrl.setView($ctrl.VIEWS.FIND)">Find rooms</div>\n' + '        </div>\n' + '    </div>\n' + '    <div class="modal-holder" ng-if="$ctrl.shouldShowView($ctrl.VIEWS.FIND) && !$ctrl.roomsLoading">\n' + '        <div class="modal-body asui">\n' + '            <div class="title" ng-if="$ctrl.title">{{$ctrl.title}}</div>\n' + '            <md-content>\n' + '                <div class="search-bar" ng-if="!$ctrl.roomsVerified" ng-hide="!$ctrl.roomsLoading && !$ctrl.roomList.length">\n' + '                    <asui-search ng-model="$ctrl.searchedRoom" placeholder="{{$ctrl.searchPlaceholder}}" on-clear="$ctrl.onSearchClear()">\n' + '                    </asui-search>\n' + '                </div>\n' + '            </md-content>\n' + '            <md-content class="room-list">\n' + '                <div class="loading s-center" ng-show="$ctrl.roomsLoading">\n' + '                    <asui-loading-mask show="true"></asui-loading-mask>\n' + '                </div>\n' + '                <div class="no-rooms-placeholder s-center" ng-show="!$ctrl.roomsLoading && !$ctrl.roomList.length">\n' + '                    No resources available based on your card configuration\n' + '                </div>\n' + '                <div class="room-list-holder" ng-repeat="room in $ctrl.roomList | filter:$ctrl.searchedRoom | orderBy: [\'-checked\',\'label\']">\n' + '                    <label ng-style="room.display">\n' + '                        <input type="checkbox" ng-model="room.checked" ng-true-value="true" ng-false-value="false" ng-change="$ctrl.onCheckboxChecked()" ng-if="!$ctrl.roomsVerified">\n' + '                        {{room.label}}\n' + '                    </label>\n' + '                </div>\n' + '            </md-content>\n' + '        </div>\n' + '        <div class="room-list-selected" ng-if="$ctrl.getSelectedRooms().length > 0 && !$ctrl.roomsVerified">\n' + '            {{$ctrl.getSelectedRooms().length}} selected\n' + '        </div>\n' + '    </div>\n' + '    <div class="modal-footer">\n' + '        <button class="asui-btn btn btn-default" ng-click="$ctrl.cancel()">\n' + '            {{$ctrl.cancelText}}\n' + '        </button>\n' + '        <button class="asui-btn btn btn-primary" ng-click="$ctrl.onSave()" ng-if="$ctrl.shouldShowView($ctrl.VIEWS.MANAGE)" ng-disabled="$ctrl.getValidRooms().length === 0 || $ctrl.roomsProcessing || $ctrl.roomsLoading">\n' + '            {{$ctrl.saveMessage}}\n' + '        </button>\n' + '        <button class="asui-btn btn btn-primary" ng-click="$ctrl.onAdd()" ng-if="$ctrl.shouldShowView($ctrl.VIEWS.FIND)" ng-disabled="$ctrl.getSelectedRooms().length === 0">\n' + '            {{$ctrl.addMessage}}\n' + '        </button>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('components/ctScheduleTable.html', '<div class="asui">\n' + '    <asui-schedule-table on-api-ready="$ctrl.onScheduleApiReady(api)" options="$ctrl.options" on-schedule-click="$ctrl.onOccupiedSlotClicked(item, schedule)" on-free-slot-click="$ctrl.onFreeSlotClicked(item, slot)" on-end-click="$ctrl.onEndClicked(item, schedule)" on-extend-click="$ctrl.onExtendClicked(item, schedule)" on-check-in-click="$ctrl.onCheckInClicked(item, schedule)" on-filter-click="$ctrl.onFilterClicked()" on-items-retrieved="$ctrl.onItemsRetrieved()" on-status-changed="$ctrl.onStatusChanged(item, status, schedule)" on-map-toggle-click="$ctrl.onMapToggleClick()" set-show-footer="$ctrl.setShowFooter" on-item-info-show-changed="$ctrl.onItemInfoShowChanged(show)">\n' + '    </asui-schedule-table>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('directives/asuiScheduleMap.html', '<div class="loading s-center" ng-show="isFloorPlanProcessing">\n' + '    <asui-loading-mask show="isFloorPlanProcessing"></asui-loading-mask>\n' + '</div>\n' + '<div ng-show="!isFloorPlanProcessing" class="asui floorplan-wrapper" ng-class="{\'invisible\': showMapPlaceholder || isMapLoading || !filteredFloors.length}" ng-if="!isScreenshot">\n' + '    <asui-floorplan-editor-poi-layer on-api-ready="onPoiLayerApiReady(api)" floorplan="{{activeFloorPlan}}" on-item-click="onPoiClicked(item, event)" on-floorplan-load="onPoiFloorplanLoad(size)" on-zoom-update="onLayerZoomUpdate(zoom)" items="activePois" options="poiLayerOptions" ng-class="getTransitionStyle()">\n' + '    </asui-floorplan-editor-poi-layer>\n' + '</div>\n' + '<div class="floor-buttons-wrapper">\n' + '    <div class="floor-buttons" ng-if="!showMapPlaceholder && filteredFloors.length">\n' + '        <button ng-repeat="floor in filteredFloors | orderBy:\'-floorNumber\'" ng-click="onFloorSelected(floor.id)" ng-style="getButtonStyle(floor.id)">{{floor.name || floor.floorNumber}}\n' + '        </button>\n' + '    </div>\n' + '</div>\n' + '<div ng-switch="isScreenshot" class="placeholder-wrapper" ng-class="{\'full-width\' : showMapPlaceholder || !filteredFloors.length}">\n' + '    <div ng-switch-when="true" class="placeholder-image">\n' + '        <img src="assets/img/map-placeholder.png">\n' + '    </div>\n' + '    <div ng-switch-default class="placeholder-text" ng-if="!isMapLoading && showMapPlaceholder || !filteredFloors.length" ng-style="textStyle">\n' + '        {{placeholderText}}\n' + '        <div class="placeholder-subtext" ng-style="textStyle">\n' + '            {{placeholderSubtext}}\n' + '        </div>\n' + '        <button ng-if="showTryAgainButton" ng-click="restartMapService()" ng-style="buttonStyle">Try again</button>\n' + '    </div>\n' + '</div>\n' + '<div class="floorplan-footer-wrapper">\n' + '    <div class="floorplan-footer" ng-if="getFooterText()">\n' + '        <span ng-style="textStyle">\n' + '            {{getFooterText()}}\n' + '        </span>\n' + '        <button ng-if="filter && !readonly && !isRoomInfoPanelOpen" ng-click="resetFilter()" ng-style="buttonStyle">\n' + '            View All Rooms\n' + '        </button>\n' + '        <button ng-if="showResetButton" ng-click="loadDefaultFloor()" ng-style="buttonStyle">\n' + '            Reset\n' + '        </button>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('directives/ctBackground.html', '<div class="element-background" ng-style="backgroundColorStyling">\n' + '    <ng-transclude>\n' + '        <div class="mask" ng-style="maskStyling" ng-if="showMask"></div>\n' + '    </ng-transclude>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('directives/ctCheckpoint.html', '<div ng-if="checkpointHtml" ng-bind-html="checkpointHtml" class="checkpoint-content"></div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('schedule/schedule.html', '<div class="schedule-board" ng-controller="scheduleController">\n' + '    <div class="header" ng-show="showHeader" ng-class="!isHeaderEnabled ? \'hide-header\' : \'\'">\n' + '        <ct-background class="header-background" color="headerBackground.color" media="headerBackground.media" mask-color="headerBackground.mask" ng-style="headerBackground.style"></ct-background>\n' + '        <div class="header-components" ng-class="(hideTable) ? \'hide-padding\' : \'\'">\n' + '            <div ng-if="shouldShowLogo(POSITIONS.TOP_LEFT)" class="logo-top-left logo">\n' + '                <ct-image source="logoImage"></ct-image>\n' + '            </div>\n' + '            <div class="title" ng-attr-style="{{titleStyle}}">{{title}}</div>\n' + '            <ct-clock class="clock-directive" is-24-hour-clock="is24HourClock" ng-if="isHeaderEnabled && isClockEnabled" ng-style="headerTextColor"></ct-clock>\n' + '            <div ng-if="shouldShowLogo(POSITIONS.TOP_RIGHT)" class="logo-top-right logo">\n' + '                <ct-image source="logoImage"></ct-image>\n' + '            </div>\n' + '        </div>\n' + '    </div>\n' + '    <div class="content" ng-class="(hideTable) ? \'hide-margin\' : \'\'">\n' + '        <div class="error-message" ng-if="hideTable">\n' + '            <div>{{error.message}}</div>\n' + '            <div>{{error.subMessage}}</div>\n' + '        </div>\n' + '        <ct-schedule-table ng-class="{\'map-enabled-portrait\' : isMapEnabled, \'map-only-portrait\': isMapLayout}" ng-if="!hideTable" is-current-map-view="isCurrentMapView" on-api-ready="onScheduleTableApiReady(api)" on-event-info-only-clicked="onEventInfoOnlyClicked(room, event)" on-check-in-event-clicked="onCheckInEventClicked(room, event)" on-end-event-clicked="onEndEventClicked(room, event)" on-extend-event-clicked="onExtendEventClicked(room, event)" on-event-action-clicked="onEventActionClicked(room, event, events)" on-book-event-clicked="onBookEventClicked(room, slot, events)" on-filter-clicked="onFilterClicked()" on-map-toggle-click="onMapToggleClick()" on-info-panel-open-changed="onInfoPanelOpenChanged(isOpen)">\n' + '        </ct-schedule-table>\n' + '    </div>\n' + '    <div class="footer" ng-if="shouldShowFooter()">\n' + '        <div ng-if="shouldShowLogo(POSITIONS.BOTTOM_LEFT)" class="logo-bottom-left logo">\n' + '            <ct-image source="logoImage"></ct-image>\n' + '        </div>\n' + '        <div ng-if="shouldShowLogo(POSITIONS.BOTTOM_RIGHT)" class="logo-bottom-right logo">\n' + '            <ct-image source="logoImage"></ct-image>\n' + '        </div>\n' + '    </div>\n' + '    <div class="settings" ng-if="isEditing">\n' + '        <img src="assets/img/icon-cog.svg">\n' + '        <div class="settings-bar asui">\n' + '            <asui-context-menu options="settingsMenu.options" ng-model="settingsMenu.model" menu-groups="settingsMenu.menuGroups" on-item-click="onSettingsClicked(value)">\n' + '                <div class="iconPreview"></div>\n' + '                <i class="icon icon-caret-down"></i>\n' + '            </asui-context-menu>\n' + '        </div>\n' + '    </div>\n' + '    <div class="room-picker-holder s-center" ng-if="isRoomPickerVisible">\n' + '        <ct-room-picker class="room-picker" on-api-ready="onRoomPickerApiReady(api)" on-close="onRoomPickerClose(selectedRooms)" on-cancel="onRoomPickerCancel()"></ct-room-picker>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('setup/authentication.html', '<div class="settings s-center" ng-controller="authenticationController">\n' + '    <div class="s-holder">\n' + '        <div class="error" ng-show="showError">{{error}}</div>\n' + '        <div>\n' + '            <div class="box" ng-show="showLoading">\n' + '                <div class="title">{{authenticateBoxTitle}}</div>\n' + '                <div class="asui loading s-center" ng-show="showLoading">\n' + '                    <asui-loading-mask show="showLoading"></asui-loading-mask>\n' + '                </div>\n' + '                <div class="popup-message" ng-show="showLoading && popupBlockedMessage">\n' + '                    {{popupBlockedMessage}}\n' + '                </div>\n' + '                <div class="return-button" ng-show="showLoading && returnButtonText">\n' + '                    <button class="asui-btn btn btn-default" ng-click="onReturnClicked()">{{returnButtonText}}</button>\n' + '                </div>\n' + '            </div>\n' + '\n' + '            <div class="box" ng-show="showProvidersBox && !showLoading">\n' + '                <div class="title">{{userBoxTitle}}</div>\n' + '                <div class="provider asui s-center" ng-repeat="provider in providerList">\n' + '                    <div class="holder">\n' + '                        <div class="left s-center">\n' + '                            <img ng-if="provider.logo" ng-src="{{provider.logo}}">\n' + '                            <div class="custom-provider" ng-if="!provider.logo">\n' + '                                <i class="icon" ng-if="!provider.logo" ng-class="provider.icon"></i>\n' + '                                <span>{{provider.name}}</span>\n' + '                            </div>\n' + '                        </div>\n' + '                        <div class="right s-center">\n' + '                            <button type="button" ng-click="onClick(provider)" class="asui-btn btn btn-primary">Connect</button>\n' + '                        </div>\n' + '                    </div>\n' + '                </div>\n' + '            </div>\n' + '\n' + '            <div class="box admin-box" ng-show="showAdminBox && !showLoading">\n' + '                <div class="title">{{adminBoxTitle}}</div>\n' + '                <div class="holder">\n' + '                    <div class="logo">\n' + '                        <img ng-src="{{userProvider.logo}}">\n' + '                    </div>\n' + '                    <div class="text">\n' + '                        {{userSubtitle}}\n' + '                    </div>\n' + '                    <div class="s-center">\n' + '                        <button type="button" ng-click="onClick(userProvider)" class="asui-btn btn btn-primary">{{userButton}}</button>\n' + '                    </div>\n' + '                </div>\n' + '                <div class="text split"><span> or </span></div>\n' + '                <div class="holder">\n' + '                    <div class="logo">\n' + '                        <img ng-src="{{adminProvider.logo}}">\n' + '                    </div>\n' + '                    <div class="text">\n' + '                            {{adminSubtitle}}\n' + '                        </div>\n' + '                    <div class="s-center">\n' + '                        <button type="button" ng-click="onClick(adminProvider)" class="asui-btn btn btn-primary button-white-out">{{adminButton}}</button>\n' + '                    </div>\n' + '                </div>\n' + '            </div>\n' + '            \n' + '            <ct-providers-custom ng-if="showCustomBox && !showLoading" on-click="onClick(provider)" custom-provider="customProvider"></ct-providers-custom>\n' + '\n' + '            <div class="text previous-provider" ng-if="!showAdminBox && !showCustomBox && showProvidersBox && !showLoading" ng-click="onDemoModeClick()">\n' + '                Preview card in demo mode</div>\n' + '\n' + '            <div class="text previous-provider" ng-if="(showAdminBox || showCustomBox) && !showLoading" ng-click="onGoBackClick()">\n' + '                Authentication with a different provider\n' + '            </div>\n' + '\n' + '        </div>\n' + '    </div>\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('setup/init.html', '<div ng-controller="initController">\n' + '    Hello\n' + '</div>');
}]);
angular.module('scheduleBoard').run(['$templateCache', function ($templateCache) {
  $templateCache.put('setup/pickRoom.html', '<div class="settings s-center" ng-controller="pickRoomController">\n' + '    <div class="room-picker-holder">\n' + '        <ct-room-picker class="room-picker" on-api-ready="onRoomPickerApiReady(api)" on-close="onRoomPickerClose(selectedRooms)" on-cancel="onRoomPickerCancel()"></ct-room-picker>\n' + '    </div>\n' + '</div>');
}]);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.component('ctClock', {
    template: '<div class="clock">' + '<div ng-hide="$ctrl.disableTime" class="clock-time">{{ $ctrl.time }}</div>' + '<div ng-hide="$ctrl.disableDate" class="clock-date">{{ $ctrl.date }}</div>' + '</div>',
    bindings: {
      disableDate: '<',
      disableTime: '<',
      is24HourClock: '<'
    },
    controller: ["timeManager", "timeUtil", function (timeManager, timeUtil) {
      var $ctrl = this;
      var timerId = new Date().getTime() + '-ctClock';
      $ctrl.is24hr = false;

      $ctrl.$onChanges = function (changes) {
        if (changes.disableDate) {
          $ctrl.disableDate = changes.disableDate.currentValue || false;
        }

        if (changes.disableTime) {
          $ctrl.disableTime = changes.disableTime.currentValue || false;
        }

        if (changes.is24HourClock) {
          $ctrl.is24hr = changes.is24HourClock.currentValue || false;
          updateTime();
        }
      };

      function updateDate(date) {
        $ctrl.date = timeUtil.getDateText(date);
      }

      function updateTime(date) {
        date = date || new Date();
        $ctrl.time = timeUtil.getTimeText(date, $ctrl.is24hr);
      }

      function init() {
        var now = new Date();
        onTimeUpdated(now);
      }

      function onTimeUpdated(date) {
        updateTime(date);
        updateDate(date);
        date.setMinutes(date.getMinutes() + 1);
        timeManager.register(timerId, onTimeUpdated, date);
      }

      init();
    }]
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.component('ctDialog', {
    bindings: {
      onClose: '<',
      onApiReady: '&',
      onSuccess: '<'
    },
    templateUrl: 'components/ctDialog.html',
    controller: ["$timeout", "$document", "$element", "AlertDialog", "textResourceManager", "TEXT_RESOURCE", "DIALOG_STATE", "SYSTEM_DATA", function ($timeout, $document, $element, AlertDialog, textResourceManager, TEXT_RESOURCE, DIALOG_STATE, SYSTEM_DATA) {
      var $ctrl = this;
      var closeTimeout;
      var isTextboxClicked = false;
      var INPUT_CONFIRMED_KEYCODE = 13;
      var CLOSE_SUCCESS_TIMEOUT = 2000;
      var CLOSE_TRYAGAIN_TIMEOUT = 30000;
      $ctrl.isOpened = false;
      $ctrl.dialogModel;
      $ctrl.state = DIALOG_STATE.NONE;
      $ctrl.DIALOG_STATE = DIALOG_STATE;

      $ctrl.onOptionClicked = function (option) {
        if (!$ctrl.dialogModel || !$ctrl.dialogModel.onOptionClicked) {
          return;
        }

        $ctrl.dialogModel.onOptionClicked(option);
      };

      $ctrl.onAcceptClicked = function () {
        if (!$ctrl.dialogModel || !$ctrl.dialogModel.onAcceptClicked) {
          return;
        }

        $ctrl.dialogModel.onAcceptClicked();
      };

      $ctrl.onOtherClicked = function () {
        if (!$ctrl.dialogModel || !$ctrl.dialogModel.onOtherClicked) {
          return;
        }

        $ctrl.dialogModel.onOtherClicked();
      };

      $ctrl.onCancelClicked = function () {
        if ($ctrl.dialogModel.onCancelClicked && $ctrl.dialogModel.checkpoint) {
          $ctrl.dialogModel.onCancelClicked();
          return;
        }

        close();
      };

      $ctrl.onConfirmClicked = function () {
        if (!$ctrl.dialogModel.onConfirmClicked) {
          return;
        }

        $ctrl.dialogModel.onConfirmClicked();
      };

      $ctrl.onCancelConfirmationClicked = function () {
        if (!$ctrl.dialogModel.onCancelConfirmationClicked) {
          return;
        }

        $ctrl.dialogModel.onCancelConfirmationClicked();
      };

      $ctrl.onInputKeyPress = function (e) {
        if (!e || !e.preventDefault || (e.which || e.charCode) != INPUT_CONFIRMED_KEYCODE) {
          return;
        }

        if ($ctrl.dialogModel && $ctrl.dialogModel.onInputConfirmed) {
          $ctrl.dialogModel.onInputConfirmed();
          e.preventDefault();
          return;
        }

        if (!e.target) {
          return;
        }

        e.target.blur();
        e.preventDefault();
      };

      $ctrl.onInputKeyUp = function (e) {
        if (!$ctrl.dialogModel || !$ctrl.dialogModel.onInputKeyUp) {
          return;
        }

        $ctrl.dialogModel.onInputKeyUp(e);
      };

      $ctrl.onRetryClicked = function () {
        if ($ctrl.dialogModel && $ctrl.dialogModel.onRetry) {
          cancelCloseTimeout();
          $ctrl.dialogModel.onRetry();
          return;
        }

        process();
      };

      $ctrl.inputTextClicked = function ($event) {
        isTextboxClicked = true;

        if (!$event || !$event.stopPropagation) {
          return;
        }

        $event.stopPropagation();
      };

      $ctrl.overlayClicked = function ($event) {
        // ignore if
        // textbox was never clicked, OR
        // the event is fired but it is still targeting the text box (aria accessibility feature - treat space as click)
        if (!isTextboxClicked || $event.target == getElements().textBox) {
          return;
        }

        isTextboxClicked = false;
        getElements().buttonAccept.focus();
      };

      function success() {
        if ($ctrl.dialogModel && $ctrl.dialogModel.onSuccess) {
          $ctrl.dialogModel.onSuccess();
        } else {
          $ctrl.state = DIALOG_STATE.SUCCESS;
          closeTimeout = $timeout(close, CLOSE_SUCCESS_TIMEOUT);
        }

        if ($ctrl.onSuccess) {
          $ctrl.onSuccess();
        }
      }

      function failed(err) {
        if (err && err.errorCode === SYSTEM_DATA.CONSTRAINED_ERROR) {
          $ctrl.dialogModel.failureTitle = err.errorMessage;

          if ($ctrl.dialogModel.styling) {
            $ctrl.dialogModel.styling.windowClass = 'dialog-window centered-dialog-window';
          }

          $ctrl.state = DIALOG_STATE.FAILURE;
        } else {
          $ctrl.state = DIALOG_STATE.RETRY;
        }

        closeTimeout = $timeout(close, CLOSE_TRYAGAIN_TIMEOUT);
      }

      function process(cancelled) {
        cancelCloseTimeout();

        if (!$ctrl.dialogModel || !$ctrl.dialogModel.onProcess) {
          return;
        }

        $ctrl.state = DIALOG_STATE.PROCESSING;
        $ctrl.dialogModel.onProcess(cancelled).then(success, failed);
      }

      function open(dialogModel) {
        $ctrl.isOpened = false;
        $ctrl.state = DIALOG_STATE.NONE;

        if (!dialogModel) {
          dialogModel = new AlertDialog(textResourceManager.getText(TEXT_RESOURCE.DIALOG_PREVIEW_MODE));
        }

        dialogModel.onApiReady(api);
        $ctrl.dialogModel = dialogModel;

        if (dialogModel.onOpen) {
          dialogModel.onOpen();
        } else {
          $ctrl.state = DIALOG_STATE.INPUT;
        }

        $document.ready(function () {
          // Need to timeout to show the dialog box via a
          // force the digest cycle.
          $timeout(function () {
            $ctrl.isOpened = true;
          });
        });
      }

      function close() {
        $ctrl.isOpened = false;
        cancelCloseTimeout();

        if ($ctrl.dialogModel && $ctrl.dialogModel.onClose) {
          $ctrl.dialogModel.onClose($ctrl.state);
        }

        $ctrl.dialogModel = null;

        if ($ctrl.onClose) {
          $ctrl.onClose($ctrl.state);
        }

        $ctrl.state = DIALOG_STATE.CLOSE;
      }

      function setState(state) {
        $ctrl.state = state;
      }

      function cancelCloseTimeout() {
        if (closeTimeout) {
          $timeout.cancel(closeTimeout);
          closeTimeout = null;
        }
      }

      function getElements() {
        return {
          buttonAccept: $element.find('#buttonAccept'),
          textBox: $element.find('#ctDialogInputBox')
        };
      }

      var api = {
        open: open,
        close: close,
        process: process,
        setState: setState,
        getElements: getElements
      };
      $ctrl.onApiReady({
        api: api
      });
    }]
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.component('ctProvidersCustom', {
    bindings: {
      onBack: '&',
      onClick: '&',
      customProvider: '<'
    },
    templateUrl: 'components/ctProvidersCustom.html',
    controller: ["$scope", "$timeout", "dataUtil", "textUtil", "SYSTEM_DATA", "MODEL_INPUT_KEYS", "TEXT_RESOURCE", "textResourceManager", "configurationManager", function ($scope, $timeout, dataUtil, textUtil, SYSTEM_DATA, MODEL_INPUT_KEYS, TEXT_RESOURCE, textResourceManager, configurationManager) {
      var $ctrl = this;
      var headerInputsElement = document.getElementById('header-inputs');
      $scope.isButtonDisabled = true;
      $scope.providerUrlInput = '';
      $scope.apiKeyInput = '';
      $scope.warningMessage = '';
      $scope.errorMessage = '';
      $scope.title = '';
      $scope.headers = [];
      var provider;
      var MIN_API_KEY_LENGTH = 32;
      var validationCallback = {
        apiKeyInput: validateApiKey,
        providerUrlInput: validateUrl
      };
      $scope.title = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_TITLE);

      function scrollToBottom() {
        headerInputsElement.scrollTop = headerInputsElement.scrollHeight;
      }

      function generateHeaders() {
        var headersObject = {
          'Api-Key': $scope.apiKeyInput
        };
        var headers = $scope.headers;

        if (!headers.length) {
          return headersObject;
        }

        for (var i = 0; i < headers.length; i++) {
          var header = headers[i];
          var headerKey = header.key;
          var headerValue = header.value;

          if (!header || !headerKey || dataUtil.isNullOrUndefined(headerValue)) {
            continue;
          }

          headersObject[headerKey] = headerValue;
        }

        return headersObject;
      }

      function showButton() {
        $scope.isButtonDisabled = !$scope.providerUrlInput || !$scope.apiKeyInput || $scope.errorMessage || $scope.apiKeyErrorMessage;
      }

      function validateApiKey(apiKey) {
        $scope.apiKeyErrorMessage = '';

        if (apiKey && apiKey.length >= MIN_API_KEY_LENGTH) {
          return;
        }

        $scope.apiKeyErrorMessage = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_API_KEY_ERROR, MIN_API_KEY_LENGTH);
      }

      function validateUrl(url) {
        $scope.warningMessage = '';
        $scope.errorMessage = '';

        if (!url) {
          return;
        }

        var isHttp = textUtil.contains(url, 'http://');
        var isHttps = textUtil.contains(url, 'https://');

        if (!isHttp && !isHttps) {
          $scope.errorMessage = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_INVALID_URL_FORMAT_ERROR);
          return;
        }

        var isHttpsEnforced = $ctrl.customProvider.enforcehttps;

        if (isHttpsEnforced && !isHttps) {
          $scope.errorMessage = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_HTTP_URL_ERROR);
        }

        if (!isHttpsEnforced && isHttp) {
          $scope.warningMessage = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_HTTP_URL_WARNING);
        }
      }

      $scope.onInputChanged = function (key) {
        $scope[key] = textUtil.trim($scope[key]);
        validationCallback[key]($scope[key]);
        showButton();
      };

      $scope.onConfigureButtonClicked = function () {
        if ($scope.errorMessage) {
          return;
        }

        provider = $angular.copy($ctrl.customProvider);
        provider.providerUrl = $scope.providerUrlInput.replace(SYSTEM_DATA.END_SLASH_REGEX, '').toLowerCase();
        provider.headers = generateHeaders();
        $ctrl.onClick({
          provider: provider
        });
      };

      $scope.onAddHeaderClicked = function () {
        $scope.headers.push({}); // Only scroll if there are more than 2 headers added

        if ($scope.headers.length < 3) {
          return;
        }

        $timeout(scrollToBottom, 0);
      };

      $scope.deleteHeader = function (index) {
        $scope.headers.splice(index, 1);
      };
    }]
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').component('ctRoomPicker', {
    bindings: {
      onClose: '&',
      onCancel: '&',
      onApiReady: '&'
    },
    templateUrl: 'components/ctRoomPicker.html',
    controller: function controller($filter, $q, $scope, textResourceManager, roomManager, configurationManager, LoginUserDialog, TEXT_RESOURCE, CUSTOM_DATA_KEY) {
      var $ctrl = this;
      var api = {
        start: start
      };
      var selectedRoomIds = [];
      var VIEWS = {
        FIND: 'find',
        MANAGE: 'manage'
      };
      var currentView = VIEWS.MANAGE;
      var selectedView;
      var viewConfig = {
        manage: {
          header: TEXT_RESOURCE.ROOMPICKER_HEADER_MANAGE,
          subHeader: TEXT_RESOURCE.ROOMPICKER_SUBHEADER_MANAGE
        },
        find: {
          header: TEXT_RESOURCE.ROOMPICKER_HEADER_FIND
        }
      };
      var initialized = false;
      var allRooms = [];
      var authenticationData = {};
      var processingLoginUserData = false;
      configurationManager.subscribeToCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA, function (data) {
        authenticationData = $angular.copy(data); // ignore if we're not processing login user data

        if (!processingLoginUserData) {
          return;
        } // if we're processing login user data, call verify rooms and reset the flag


        processingLoginUserData = false;
        changeView();
        verifyRooms();
      });
      $ctrl.VIEWS = VIEWS;
      $ctrl.setView = setView;
      $ctrl.roomList = [];
      $ctrl.selectedRoomsModel = [];
      $ctrl.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL);
      $ctrl.saveMessage = textResourceManager.getText(TEXT_RESOURCE.BUTTON_SAVE);
      $ctrl.addMessage = textResourceManager.getText(TEXT_RESOURCE.BUTTON_ADD);
      $ctrl.errorMessage;
      $ctrl.searchPlaceholder = 'Search';
      $ctrl.searchText = '';
      $ctrl.searchedRoom = '';
      $ctrl.disabledSelectButton = true;
      $ctrl.roomIdInput = {
        id: 'roomIdInput',
        placeholder: 'Enter room id here',
        options: {
          invalidTagMessage: '',
          pasteSplitPattern: '[,; ]',
          addOnPaste: true,
          addOnSpace: true,
          validateTag: getAndVerifyRoom,
          showProgress: true,
          checkInvalidTag: true,
          validationInProgress: true,
          displayProperty: 'name'
        }
      };
      $ctrl.onApiReady({
        api: api
      });

      $ctrl.$onDestroy = function () {
        stop();
      };

      $ctrl.cancel = function () {
        if (currentView === VIEWS.FIND) {
          setView(VIEWS.MANAGE);
          return;
        }

        $ctrl.onCancel();
      };

      $ctrl.onAdd = function () {
        var selectedRooms = $filter('filter')($ctrl.getSelectedRooms()).map(function (item) {
          return item.value;
        });
        selectedRoomIds = selectedRoomIds.concat(selectedRooms);
        setView(VIEWS.MANAGE);
      };

      $ctrl.onSave = function () {
        $scope.$emit('triggerDialogEvent', {
          showDialog: false
        });
        $ctrl.onClose({
          selectedRooms: getMappedValidRooms()
        });
      };

      $ctrl.onRoomRemoved = function (room) {
        if (!room) {
          return;
        }

        var roomIndex = selectedRoomIds.indexOf(room.id);

        if (roomIndex < 0) {
          return;
        }

        selectedRoomIds.splice(roomIndex, 1);
      };

      $ctrl.onSearchClear = function () {
        $ctrl.searchedRoom = '';
      };

      function getInvalidRoomMessage(room) {
        if (!room) {
          return;
        }

        room.tooltip = textResourceManager.getText(room.undelegated ? TEXT_RESOURCE.ROOMPICKER_UNDELEGATED_ROOM_ERROR_MESSAGE : TEXT_RESOURCE.ROOMPICKER_INVALID_ROOM_ERROR_MESSAGE);
        return room;
      }

      $ctrl.onInvalidRoom = getInvalidRoomMessage;

      function setView(view) {
        selectedView = view;

        if (!isLoginUserDialogNeeded()) {
          changeView();
          verifyRooms();
          return;
        }

        processingLoginUserData = true;
        $scope.$emit('triggerDialogEvent', {
          showDialog: true,
          dialogModel: new LoginUserDialog(updateProviderLoginUser)
        });
      }

      function changeView() {
        currentView = selectedView;
        $ctrl.header = textResourceManager.getText(viewConfig[currentView].header) || '';
        $ctrl.subHeader = textResourceManager.getText(viewConfig[currentView].subHeader) || '';
        $ctrl.searchText = '';
        $ctrl.searchedRoom = '';
      }

      function isLoginUserDialogNeeded() {
        // if we don't have login user & we're using office365admin
        // and we need to open find rooms page, user need to provide login user email
        return selectedView === VIEWS.FIND && authenticationData && authenticationData.provider && authenticationData.provider.type === 'office365admin' && !authenticationData.provider.loginUser;
      }

      function updateRoomList() {
        configurationManager.isReady().then(function () {
          $ctrl.roomList = [];
          allRooms = allRooms || [];

          for (var i = 0; i < allRooms.length; i++) {
            var id = allRooms[i].id;

            if (selectedRoomIds.indexOf(id) > -1) {
              // to ensure selected room is excluded from the list
              continue;
            }

            $ctrl.roomList.push({
              value: id,
              label: allRooms[i].displayName,
              checked: false
            });
          }

          $ctrl.roomsLoading = false;
        });
      }

      $ctrl.shouldShowView = function (view) {
        return currentView === view;
      };

      $ctrl.getSelectedRooms = function () {
        return $filter('filter')($ctrl.roomList, {
          checked: true
        });
      };

      $ctrl.getValidRooms = function () {
        return $filter('filter')($ctrl.selectedRoomsModel, {
          valid: true
        });
      };

      function getMappedValidRooms() {
        return $ctrl.getValidRooms().map(function (item) {
          return item.id;
        });
      }

      function updateProviderLoginUser(data) {
        authenticationData.provider = authenticationData.provider || {};
        authenticationData.provider.loginUser = (data || {}).loginUser;
        configurationManager.updateCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA, authenticationData);
      }

      function verifyRooms() {
        $ctrl.roomsProcessing = true;

        if (currentView === VIEWS.FIND) {
          $ctrl.roomsLoading = true;

          if (allRooms.length > 0) {
            // to make sure we only initialise allRooms (by calling getAllRooms) once
            updateRoomList();
            $ctrl.roomsProcessing = false;
            return;
          }

          roomManager.getAllRooms().then(function (rooms) {
            allRooms = rooms;
            updateRoomList();
            $ctrl.roomsProcessing = false;
          }, function () {
            // invalid userLogin authenticationData
            updateProviderLoginUser();
          });
          return;
        }

        if (!selectedRoomIds.length) {
          $ctrl.roomsProcessing = false;
          $ctrl.selectedRoomsModel = [];
          return;
        }

        var rooms = [];
        var promises = [];

        var findRoomFromVerifiedList = function findRoomFromVerifiedList(roomId) {
          var matchedRooms = $filter('filter')($ctrl.selectedRoomsModel).map(function (item) {
            return item.id === roomId;
          });
          return $ctrl.selectedRoomsModel[matchedRooms.indexOf(true)];
        };

        for (var i = 0; i < selectedRoomIds.length; i++) {
          var selectedRoom = selectedRoomIds[i];
          var verifiedRoom = findRoomFromVerifiedList(selectedRoom);

          if (verifiedRoom && verifiedRoom.verified) {
            // to ensure we call getAndVerifyRoom only if a room had not been verified before
            rooms.push(verifiedRoom);
            promises.push($q.resolve());
            continue;
          }

          var room = {
            name: selectedRoom,
            id: selectedRoom,
            valid: false,
            verified: false
          };
          var promise = getAndVerifyRoom(room).then(function (roomData) {
            roomData.verified = true;
            rooms.push(roomData);
          });
          promises.push(promise);
        }

        $q.allSettled(promises)["finally"](function () {
          $ctrl.selectedRoomsModel = rooms;
          $ctrl.roomsProcessing = false;
          $ctrl.roomsLoading = false;
        });
      }

      function start() {
        var initializeRoomIds = function initializeRoomIds() {
          $ctrl.roomsProcessing = true;

          if (initialized) {
            // to ensure we only get room ids from model once
            return $q.resolve();
          }

          var promise = $q.defer();
          configurationManager.isReady().then(function () {
            var modelRoomIds = configurationManager.getCustomData(CUSTOM_DATA_KEY.ROOM_IDS) || [];
            selectedRoomIds = selectedRoomIds.concat(modelRoomIds);
            initialized = true;
            promise.resolve();
          });
          return promise.promise;
        };

        initializeRoomIds().then(verifyRooms);
      }

      function addRoom(room) {
        if (selectedRoomIds.indexOf(room.id) > -1) {
          return;
        }

        selectedRoomIds.push(room.id);
      }

      function getAndVerifyRoom(room) {
        var promise = $q.defer();

        var onSuccess = function onSuccess(data) {
          room.valid = true;
          room.name = (data || {}).displayName;
          room.tooltip = room.id;
          promise.resolve(room);
        };

        var onFailure = function onFailure(error) {
          // room is invalid or undelegated
          room.valid = false;
          room.invalid = true; // this is required to show invalid message tooltip in asui's tags input

          room.undelegated = error === TEXT_RESOURCE.ROOMPICKER_UNDELEGATED_ROOM_ERROR.value;
          promise.resolve(getInvalidRoomMessage(room));
        };

        roomManager.getRoom(room.name).then(onSuccess, onFailure)["finally"](function () {
          addRoom(room);
        });
        return promise.promise;
      }

      setView(currentView);
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.component('ctScheduleTable', {
    templateUrl: 'components/ctScheduleTable.html',
    bindings: {
      isCurrentMapView: '<',
      onApiReady: '&',
      onEventInfoOnlyClicked: '&',
      onCheckInEventClicked: '&',
      onEndEventClicked: '&',
      onExtendEventClicked: '&',
      onEventActionClicked: '&',
      onBookEventClicked: '&',
      onFilterClicked: '&',
      onStatusChanged: '&',
      onMapToggleClick: '&',
      setShowFooter: '&',
      onInfoPanelOpenChanged: '&'
    },
    controller: ["$q", "$filter", "timeUtil", "scheduleUtil", "MODEL_INPUT_VALUES", "displayConfigurationManager", "eventManager", "interactivityManager", "calendarDataManager", "IDLE_EVENT", "$scope", function ($q, $filter, timeUtil, scheduleUtil, MODEL_INPUT_VALUES, displayConfigurationManager, eventManager, interactivityManager, calendarDataManager, IDLE_EVENT, $scope) {
      var scheduleApi;
      var scheduleApiReadyPromise = $q.defer();
      var itemsRetrievedPromise = $q.defer();
      var $ctrl = this;
      var currentConfiguration = {};
      var roomsDataReady = $q.defer();
      var AUTO_SCROLL_DURATION = 15000;
      var isMapEnabled = false;
      var api = {
        setConfiguration: setConfiguration,
        setClockFormat: setClockFormat,
        setInteractivity: setInteractivity,
        setLayout: setLayout,
        setTemporaryLayout: setTemporaryLayout,
        setEnableMap: setEnableMap,
        setRoomsAndEvents: setRoomsAndEvents,
        reset: reset,
        updateRooms: updateRooms,
        updateEvents: updateEvents,
        setFilter: setFilter,
        setSwitchButtonStyle: setSwitchButtonStyle,
        setShowFooter: setShowFooter
      };
      $ctrl.options = {
        retrieveItemsAsync: getData,
        retrieveItemsAsyncOnload: true,
        // default is true, if false it will not retieve items until reloadData called
        readonly: true,
        timeformat: timeUtil.getTimeFormat(false),
        theme: {},
        timeline: {
          sync: true,
          // syncs timeline to current time
          start: new Date(),
          end: new Date(),
          interval: 0 // in seconds

        },
        defaultShowMap: true
      };

      $ctrl.$onChanges = function (changes) {
        if (changes.isCurrentMapView) {
          $ctrl.options.isCurrentMapView = changes.isCurrentMapView.currentValue;
        }
      };

      var subscribers = [];
      subscribers.push(displayConfigurationManager.subscribeToTableStylingChanged(onTableStylingChanged));
      interactivityManager.isReady().then(function () {
        subscribers.push(interactivityManager.subscribeToIdleEvent(IDLE_EVENT.AUTO_RESET, onAutoReset));
      });
      subscribers.push(eventManager.subscribeToSelectedRoomId(onSelectedRoomIdChanged));

      function onSelectedRoomIdChanged(roomId) {
        isScheduleApiReady().then(function () {
          if (roomId) {
            scheduleApi.selectItem({
              id: roomId
            });
            return;
          }

          scheduleApi.closeItemInfo(true);
        });
      }

      function onAutoReset(timestamp) {
        if (!timestamp) {
          return;
        }

        isScheduleApiReady().then(function () {
          scheduleApi.resetDay();
        });
      }

      function onTableStylingChanged(style) {
        $ctrl.options.theme = style;
      }

      function setConfiguration(configuration) {
        if (!configuration) {
          return;
        }

        currentConfiguration = configuration;
        refreshScheduleTable();
      }

      function reset() {
        // if reset is called while data is still processing, reject the promise and wait for a new promise resolve
        if (roomsDataReady) {
          roomsDataReady.reject('Rejected due to room IDs changes during processing');
        } // reset promise to wait for new set of rooms info


        roomsDataReady = $q.defer(); // refresh the schedule table to prepare for new set of rooms info

        refreshScheduleTable();
      }

      function updateRooms(displayItems) {
        itemsRetrievedPromise = $q.defer();
        roomsDataReady.resolve(displayItems);
        refreshScheduleTable();
      }

      function setRoomsAndEvents(displayItems) {
        if (!displayItems) {
          return;
        }

        roomsDataReady.resolve(displayItems);
        refreshScheduleTable();
      }

      function getData() {
        return roomsDataReady.promise;
      }

      function setFilter(filter) {
        isScheduleApiReady().then(function () {
          scheduleApi.setFilter(filter);
        });
      }

      function setSwitchButtonStyle(styleClasses) {
        isScheduleApiReady().then(function () {
          $ctrl.options.mapToggleStyle = styleClasses;
          scheduleApi.refresh(true);
        });
      }

      function setShowFooter(show) {
        isScheduleApiReady().then(function () {
          scheduleApi.setShowFooter(show);
        });
      }

      function refreshScheduleTable() {
        isScheduleApiReady().then(function () {
          $ctrl.options.timeline = {
            start: currentConfiguration.start,
            end: currentConfiguration.end,
            interval: currentConfiguration.interval // in seconds

          };
          scheduleApi.refresh(true);
        });
      }

      function updateEvents(displayItem) {
        isScheduleApiReady().then(function () {
          isItemsRetrieved().then(function () {
            scheduleApi.updateItem(displayItem);
          });
        });
      }

      function isItemsRetrieved() {
        return itemsRetrievedPromise.promise;
      }

      function isScheduleApiReady() {
        return scheduleApiReadyPromise.promise;
      }

      function setInteractivity(value) {
        var readOnly = false;
        var autoPaging; // ready only mode

        if (!value) {
          readOnly = true;
          autoPaging = AUTO_SCROLL_DURATION;
        }

        $ctrl.options.readonly = readOnly;
        $ctrl.options.pagingInterval = autoPaging;
      }

      function setShowMapToggle() {
        // Don't show map toggle if it's in map layout
        $ctrl.options.showMapToggle = $ctrl.options.defaultShowMap ? false : isMapEnabled;
      }

      function setEnableMap(value) {
        isMapEnabled = value;
        setShowMapToggle();
      }

      function setScheduleTableView(value) {
        if (value === MODEL_INPUT_VALUES.MAP) {
          return true;
        } // Set layout only if it's not "Map"


        $ctrl.options.view = value;
        return false;
      }

      function setLayout(value) {
        $ctrl.options.defaultShowMap = setScheduleTableView(value);
        setShowMapToggle();
      }

      function setTemporaryLayout(value) {
        isScheduleApiReady().then(function () {
          scheduleApi.showMap(setScheduleTableView(value));
        });
      }

      function setClockFormat(clockFormat) {
        if (!clockFormat) {
          return;
        }

        $ctrl.options.timeformat = clockFormat.format;
      }

      function isReadOnly() {
        return $ctrl.options.readonly;
      }

      $scope.$on('$destroy', function () {
        for (var i = 0; i < subscribers.length; i++) {
          var subscriber = subscribers[i];

          if (!subscriber || !subscriber.dispose) {
            continue;
          }

          subscriber.dispose();
        }
      });

      $ctrl.onScheduleApiReady = function (api) {
        if (!api) {
          return;
        }

        scheduleApi = api;
        scheduleApiReadyPromise.resolve();
      };

      $ctrl.onEndClicked = function (item, schedule) {
        if (!item || !schedule || !$ctrl.onEndEventClicked) {
          return;
        }

        $ctrl.onEndEventClicked({
          room: item,
          event: schedule
        });
      };

      $ctrl.onExtendClicked = function (item, schedule) {
        if (!item || !schedule || !$ctrl.onExtendEventClicked) {
          return;
        }

        $ctrl.onExtendEventClicked({
          room: item,
          event: schedule
        });
      };

      $ctrl.onCheckInClicked = function (item, schedule) {
        if (!item || !schedule || !$ctrl.onCheckInEventClicked) {
          return;
        }

        $ctrl.onCheckInEventClicked({
          room: item,
          event: schedule
        });
      };

      $ctrl.onOccupiedSlotClicked = function (item, schedule) {
        if (!item || !schedule) {
          return;
        }

        var room = item.room;
        var event = schedule.event; // for future event or component is in read-only mode

        if (isReadOnly() || isEventShowInfoOnly(schedule)) {
          $ctrl.onEventInfoOnlyClicked({
            room: room,
            event: event
          });
          return;
        } // for current event or event that is starting in 10 minutes that hasn't been checked-in


        if (!schedule.confirmed) {
          $ctrl.onCheckInEventClicked({
            room: room,
            event: event
          });
          return;
        } // for current event that has been checked-in


        $ctrl.onEventActionClicked({
          room: room,
          event: event,
          events: item.schedules
        });
      };

      $ctrl.onFreeSlotClicked = function (displayItem, slot) {
        if (isReadOnly() || !displayItem || !slot) {
          return;
        }

        var sortedSchedules = $filter('orderBy')(displayItem.schedules, 'start'); // find end time of last meeting in the current slot

        var findLastEventEndTime = function findLastEventEndTime() {
          for (var i = sortedSchedules.length - 1; i >= 0; i--) {
            var event = sortedSchedules[i];

            if (event.end < slot.start || event.start >= slot.end) {
              // ignore meetings that are not in the current slot
              continue;
            }

            return event.end;
          }

          return;
        };

        var lastEventEndTime = findLastEventEndTime();
        var now = new Date().getTime(); // get either current time or slot start, whichever is bigger

        var startBookTime = Math.max(slot.start, now); // if there's meeting(s) in the current slot and the last meeting ends after the slot start time,
        // use the last meeting's end time as the start book time

        if (lastEventEndTime && lastEventEndTime > startBookTime) {
          startBookTime = lastEventEndTime;
        }

        if (startBookTime >= slot.end) {
          return;
        }

        slot.start = startBookTime;
        $ctrl.onBookEventClicked({
          room: displayItem.room,
          slot: slot,
          events: displayItem.schedules
        });
      };

      $ctrl.onItemsRetrieved = function () {
        itemsRetrievedPromise.resolve();
      };

      $ctrl.onItemInfoShowChanged = function (show) {
        if (!$ctrl.onInfoPanelOpenChanged) {
          return;
        }

        $ctrl.onInfoPanelOpenChanged({
          isOpen: show
        });
      };

      $ctrl.onStatusChanged = eventManager.onScheduleStatusChanged;

      function isEventShowInfoOnly(event) {
        // if the event is not current & doesn't require check-in
        return !scheduleUtil.isScheduleCurrent(event) && !calendarDataManager.isEventRequiresCheckIn(event);
      }

      $ctrl.onApiReady({
        api: api
      });
    }]
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('BOOKING_ACTION', {
    BOOK: 'book',
    CHECK_IN: 'check-in',
    EXTEND: 'extend',
    END: 'end',
    AUTO_CANCEL: 'auto-cancel',
    RENAME: 'rename'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('CHECKPOINT', {
    ATRESERVATION: 'booking',
    ATCHECKIN: 'checkin'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('CHECKPOINT_REQUIREMENT', {
    CONSENT: 'consent',
    NOTICE: 'notice',
    FORM: 'form'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('CHECKPOINT_STATUS', {
    PASS: 'PASS',
    FAIL: 'FAIL'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('COMMANDS', {
    BOOK: 'book',
    END: 'end',
    EXTEND: 'extend',
    GET_CURRENT_MEETING: 'get-current-meeting',
    GET_CURRENT_ROOM: 'get-current-room',
    RENAME: 'rename-current-meeting',
    CHECK_IN: 'check-in',
    GET_TODAY_SCHEDULE: 'get-today-schedule',
    GET_CURRENT_STATUS: 'get-status',
    SELECT_ROOM: 'select-room',
    UNSELECT_ROOM: 'unselect-room'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('CUSTOM_DATA_KEY', {
    AUTHENTICATION_SERVICE: 'authenticationservice',
    PROVIDERS: 'providers',
    AUTHENTICATION_DATA: 'authenticationdata',
    CUSTOM_ROOM_ID: 'customroomid',
    ROOM_IDS: 'roomids',
    MOCK_DATA: 'mockdata'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('DIALOG_STATE', {
    NONE: 'NONE',
    CLOSE: 'CLOSE',
    PROCESSING: 'PROCESSING',
    INPUT: 'INPUT',
    RETRY: 'RETRY',
    SUCCESS: 'SUCCESS',
    FAILURE: 'FAILURE'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('HTTP_STATUS_CODE', {
    UNAUTHORIZED: 401,
    NOT_FOUND: 404,
    FORBIDDEN: 403,
    CONFLICT: 409
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('IDLE_EVENT', {
    VIEW: 'VIEW',
    AUTO_RESET: 'AUTO_RESET'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('MAP_SERVICE_STATE', {
    NONE: 'NONE',
    CONNECTED: 'CONNECTED',
    FAILURE: 'FAILURE',
    NO_CONNECTION: 'NO_CONNECTION'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('MEDIA_TYPE', {
    VIDEO: 'video',
    IMAGE: 'image',
    IFRAME: 'iframe'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('MOCK_STATE', {
    NONE: 'mock-none',
    AVAILABLE: 'mock-available',
    OCCUPIED: 'mock-occupied',
    OFFLINE: 'mock-offline'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('MODEL_INPUT_KEYS', {
    CUSTOM_FONT: 'customfont',
    BACKGROUND_COLOR: 'backgroundcolor',
    BACKGROUND_MEDIA: 'backgroundmedia',
    BACKGROUND_MASK_COLOR: 'backgroundmaskcolor',
    HEADER_TITLE: 'headertitle',
    HEADER_BACKGROUND_COLOR: 'headerbackgroundcolor',
    HEADER_BACKGROUND_IMAGE: 'headerbackgroundimage',
    HEADER_MASK_COLOR: 'headermaskcolor',
    LOGO_IMAGE: 'logoimage',
    LOGO_POSITION: 'logoposition',
    TABLE_TEXT_COLOR: 'tabletextcolor',
    TABLE_BACKGROUND_COLOR: 'tablebackgroundcolor',
    TABLE_BORDER_COLOR: 'tablebordercolor',
    LEVEL_COLOR: 'levelcolor',
    LEVEL_TEXT_COLOR: 'leveltextcolor',
    DISPLAY_OPTIONS: 'displayoptions',
    ENABLE_CHECK_IN: 'enablecheckin',
    ROOMS_LOCATION: 'roomslocation',
    FUTURE_DAYS_BOOKING: 'futuredaysbooking',
    PRIVATE_MEETING_NAME: 'privatemeetingname',
    LAYOUT: 'layout',
    AVAILABLE_COLOR: 'availablecolor',
    OCCUPIED_COLOR: 'occupiedcolor',
    CHECK_IN_COLOR: 'checkincolor',
    IDLE_TIMEOUT: 'idletimeout',
    BOOK_LIMIT: 'booklimitinhours',
    AUTO_RESET_TIMEOUT: 'autoresettimeout',
    FACILITIES_MAPPING: 'facilitiesmapping',
    ROOM_CATEGORIES: 'roomcategories',
    IS_CHECK_IN_CONFIGURATION_SUPPORTED: 'ischeckinconfigurationsupported'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('MODEL_INPUT_VALUES', {
    IS_24_HOUR_CLOCK: '24hourclock',
    CURRENT_EVENTS: 'current',
    SCHEDULE: 'timeline',
    MAP: 'map',
    IS_MAP_ENABLED: 'map',
    IS_INTERACTIVITY_ENABLED: 'interactivity',
    IS_LOGO_ENABLED: 'logo',
    IS_HEADER_ENABLED: 'header',
    IS_MEETING_NAME_ENABLED: 'meetingname',
    IS_ORGANIZER_NAME_ENABLED: 'organizername',
    IS_CLOCK_ENABLED: 'clock',
    IS_15_MINUTES_TIME_BLOCK: '15minutestimeblock'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('PLAYER_PROPERTY_KEYS', {
    PLAYER_GUID: 'player.guid',
    ACCOUNT_GUID: 'player.account.guid',
    SERVICES_API: 'player.services.api',
    LOCATION: 'card.schedule.location',
    MAP_LOCATION: 'card.schedule.map.location',
    MAP_LOCATION_ID: 'card.schedule.map.locationid'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('POSITIONS', {
    TOP_LEFT: 'top-left',
    TOP_RIGHT: 'top-right',
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_RIGHT: 'bottom-right'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('POST_MESSAGES', {
    MESSAGE: 'appspace-card',
    CARD_NAME: 'schedule',
    COMMAND_RECEIVED: 'command-received',
    COMMAND_EXECUTED: 'command-executed',
    COMMAND_RESULT_FAILURE: 'failure',
    COMMAND_RESULT_SUCCESS: 'success',
    CURRENT_MEETING: 'current-meeting',
    CURRENT_ROOM: 'current-room',
    TODAY_SCHEDULE: 'today-schedule',
    CURRENT_STATUS: 'current-status',
    BOOKING_EXECUTED: 'booking-executed',
    MEETING_DATA_RETRIEVED: 'meeting-data-retrieved',
    MEETING_DATA_REFRESHED: 'meeting-data-refreshed',
    VIEW_CHANGED: 'view-changed',
    ROOM_CHANGED: 'room-changed',
    STATUS_CHANGED: 'status-changed',
    MEETING_EVENT: 'meeting-event'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('PROVIDER_STATE', {
    NONE: 'NONE',
    UNCONFIGURED: 'UNCONFIGURED',
    UNAUTHORIZED: 'UNAUTHORIZED',
    INVALID_ROOM: 'INVALID_ROOM',
    OFFLINE: 'OFFLINE',
    READY: 'READY',
    CONNECTED: 'CONNECTED',
    EXPIRED: 'EXPIRED',
    NO_CONNECTION: 'NO_CONNECTION'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('ROOM_EVENT', {
    ROOMS_DATA_CHANGED: 'ROOMS_DATA_CHANGED',
    PROVIDER_STATE_CHANGED: 'PROVIDER_STATE_CHANGED'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('ROOM_FACILITIES', {
    ETHERNET: 'ethernet',
    PHONE: 'phone',
    PROJECTOR: 'projector',
    VIDEOCONFERENCE: 'videoConference',
    WHITEBOARD: 'whiteBoard',
    SMARTBOARD: 'smartBoard',
    WIFI: 'wifi',
    SCREENSHARE: 'screenShare',
    CAPACITY: 'capacity'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('ROOM_STATUS', {
    OCCUPIED: 'occupied',
    AVAILABLE: 'available',
    CHECK_IN: 'checkin'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('ROUTES', {
    AUTHENTICATION: '/authentication',
    PICK_ROOM: '/pickroom',
    SCHEDULE: '/schedule',
    DEFAULT: '/'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('SCHEDULE_ERROR', {
    TIMEOUT: 'TIMEOUT'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('SETTINGS_OPTIONS', {
    MANAGE_ROOMS: 'managerooms',
    LOG_OUT: 'logout',
    AUTHENTICATE_ACCOUNT: 'authenticateaccount'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('STATE', {
    INITIALIZING: 'initializing',
    UNAUTHENTICATED: 'unauthenticated',
    UNCONFIGURED: 'unconfigured'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.constant('SYSTEM_DATA', {
    URL_QUERY_STRING_FORMAT: '{0}?{1}',
    POPUP_WINDOW_FORMAT: 'toolbar=yes,scrollbars=yes,resizable=yes,top={0},left={1},width={2},height={3}',
    POPUP_WINDOW_HEIGHT: 550,
    POPUP_WINDOW_WIDTH: 600,
    PIXEL_ORBITER_BORDER_WIDTH: '{0}px {1}px 0px 0px',
    PIXEL_ORBITER_OFFSET: 3,
    PIXEL_ORBITER_DEFAULT_TIMER: 900000,
    // 15 minutes
    PIXEL_ORBITER_MIN_TIMER: 60000,
    // 60 seconds
    CSS_STRIPE_LIGHT_VALUE: 1.4,
    SELECTED_BLOCK_BACKGROUND: 'repeating-linear-gradient(45deg,{0},{0} 5px,{1} 6px,{1} 8px)',
    BACKGROUND_IMAGE_TEMPLATE: '<img/>',
    BACKGROUND_VIDEO_TEMPLATE: '<video></video>',
    IFRAME_TEMPLATE: '<iframe/>',
    IMAGE_DIRECTIVE: '<ct-image on-api-ready="onMediaApiReady(api)" on-media-loaded="onMediaLoaded()" on-media-error="onMediaError(error)" class="element-background-item element-background-item-hidden"></ct-image>',
    VIDEO_DIRECTIVE: '<ct-video on-api-ready="onMediaApiReady(api)" on-media-loaded="onMediaLoaded()" on-media-error="onMediaError(error)" on-media-ended="onMediaEnded()" class="element-background-item element-background-item-hidden"></ct-video>',
    IFRAME_DIRECTIVE: '<ct-iframe on-api-ready="onMediaApiReady(api)" on-media-loaded="onMediaLoaded()" on-media-error="onMediaError(error)" on-media-ended="onMediaEnded()" class="element-background-item element-background-item-hidden"></ct-iframe>',
    BACKGROUND_CSS_ANIMATE_VISIBLE: 'animated fadeIn',
    BACKGROUND_CSS_ANIMATE_HIDE: 'animated fadeOut',
    BACKGROUND_CSS_VISIBLE: 'element-background-item-visible',
    BACKGROUND_CSS_HIDE: 'element-background-item-hidden',
    RENDERING_DELAY: 500,
    BACKGROUND_ROTATION_DURATION: 12000,
    DATE_FORMAT: 'dddd, MMM D',
    YEAR_FORMAT: 'YYYY',
    MAXIMUM_BLOCK_MINUTES: 30,
    DAYS_IN_MILLISECONDS: 86400000,
    // 1 day
    UPDATE_FREQUENCY: 21600000,
    // 6 hours
    TIME_BLOCK: 1800,
    CSS_AVAILABLE_CLASS: 'room-status-available',
    CSS_OCCUPIED_CLASS: 'room-status-occupied',
    CSS_CHECK_IN_CLASS: 'room-status-checkin',
    DEFAULT_HTTP_TIMEOUT: 30000,
    CHECK_IN_LIMIT: 600000,
    END_SLASH_REGEX: /\/+$/g,
    ROOM_DIRECTIONS: ['left', 'right', 'forward', 'escalator-up', 'escalator-down', 'stairs-up', 'stairs-down', 'forward-left', 'forward-right', 'backward', 'backward-left', 'backward-right'],
    ROOM_ID_MAPPING_HEADER: '$roomid',
    ROOM_NAME_MAPPING_HEADER: '$roomname',
    CONSTRAINED_ERROR: 'CONSTRAINED_ERROR',
    INPUT_ENABLED: 'enable'
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').constant('TEXT_RESOURCE', {
    BUTTON_ACCEPT: {
      key: 'BUTTON_ACCEPT',
      value: 'Accept'
    },
    BUTTON_DECLINE: {
      key: 'BUTTON_DECLINE',
      value: 'Decline'
    },
    BUTTON_DONE: {
      key: 'BUTTON_DONE',
      value: 'Done'
    },
    BUTTON_CANCEL: {
      key: 'BUTTON_CANCEL',
      value: 'Cancel'
    },
    BUTTON_CLOSE: {
      key: 'BUTTON_CLOSE',
      value: 'Close'
    },
    BUTTON_OK: {
      key: 'BUTTON_OK',
      value: 'OK'
    },
    BUTTON_OTHER: {
      key: 'BUTTON_OTHER',
      value: 'Other'
    },
    BUTTON_TRYAGAIN: {
      key: 'BUTTON_TRYAGAIN',
      value: 'Try again'
    },
    BUTTON_BOOK: {
      key: 'BUTTON_BOOK',
      value: 'Book'
    },
    BUTTON_CHECK_IN: {
      key: 'BUTTON_CHECK_IN',
      value: 'Check-in'
    },
    BUTTON_EXTEND: {
      key: 'BUTTON_EXTEND',
      value: 'Extend'
    },
    BUTTON_END: {
      key: 'BUTTON_END',
      value: 'End'
    },
    BUTTON_YES: {
      key: 'BUTTON_YES',
      value: 'Yes'
    },
    BUTTON_NO: {
      key: 'BUTTON_NO',
      value: 'No'
    },
    BUTTON_RESET: {
      key: 'BUTTON_RESET',
      value: 'Reset'
    },
    BUTTON_SAVE: {
      key: 'BUTTON_SAVE',
      value: 'Save'
    },
    BUTTON_ADD: {
      key: 'BUTTON_ADD',
      value: 'Add'
    },
    PROVIDER_POPUP_BLOCKED: {
      key: 'PROVIDER_POPUP_BLOCKED',
      value: 'We\'ve detected that your browser is blocking our authentication popup window. Please update your browser settings to allow popup windows from Appspace and try again.'
    },
    PROVIDER_SELECT: {
      key: 'PROVIDER_SELECT',
      value: 'Select a calendar provider'
    },
    PROVIDER_ADMIN_SELECT: {
      key: 'PROVIDER_ADMIN_SELECT',
      value: 'Select your authentication method'
    },
    PROVIDER_ADMIN_SUBTITLE: {
      key: 'PROVIDER_ADMIN_SUBTITLE',
      value: 'Login as an admin to authenticate with {0}'
    },
    PROVIDER_USER_SUBTITLE: {
      key: 'PROVIDER_USER_SUBTITLE',
      value: 'Login as a user to authenticate with {0}'
    },
    PROVIDER_ADMIN_BUTTON: {
      key: 'PROIVDER_ADMIN_BUTTON',
      value: 'Login as an Admin'
    },
    PROVIDER_USER_BUTTON: {
      key: 'PROIVDER_USER_BUTTON',
      value: 'Login as a User'
    },
    PROVIDER_CUSTOM_TITLE: {
      key: 'PROVIDER_CUSTOM_TITLE',
      value: 'Configure custom provider'
    },
    PROVIDER_CUSTOM_ERROR: {
      key: 'PROVIDER_CUSTOM_ERROR',
      value: 'An error has occured when attempting to add a custom provider. Please check your provider source and try again.'
    },
    PROVIDER_CUSTOM_API_KEY_ERROR: {
      key: 'PROVIDER_CUSTOM_API_KEY_ERROR',
      value: 'API key must be at least {0} characters long.'
    },
    PROVIDER_CUSTOM_INVALID_URL_FORMAT_ERROR: {
      key: 'PROVIDER_CUSTOM_INVALID_URL_FORMAT_ERROR',
      value: 'Invalid URL format. Please try again.'
    },
    PROVIDER_CUSTOM_HTTP_URL_ERROR: {
      key: 'PROVIDER_CUSTOM_HTTP_URL_ERROR',
      value: 'You have entered a HTTP URL for your provider. Please try again with a HTTPS URL.'
    },
    PROVIDER_CUSTOM_HTTP_URL_WARNING: {
      key: 'PROVIDER_CUSTOM_HTTP_URL_WARNING',
      value: 'You have entered a HTTP URL for your provider. The connection will not be secure. Please proceed with caution.'
    },
    PROVIDER_ERROR: {
      key: 'PROVIDER_ERROR',
      value: 'Opps! We couldn\'t connect to your provider. Please try again'
    },
    PROVIDER_AUTHENTICATING: {
      key: 'PROVIDER_AUTHENTICATING',
      value: 'Authenticating with your account'
    },
    PROVIDER_APPSPACE_CONNECTING: {
      key: 'PROVIDER_APPSPACE_CONNECTING',
      value: 'Connecting to Appspace provider'
    },
    ROOMPICKER_HEADER_MANAGE: {
      key: 'ROOMPICKER_HEADER_MANAGE',
      value: 'Manage rooms'
    },
    ROOMPICKER_HEADER_FIND: {
      key: 'ROOMPICKER_HEADER_FIND',
      value: 'Find rooms'
    },
    ROOMPICKER_HEADER_VERIFY: {
      key: 'ROOMPICKER_HEADER_VERIFY',
      value: 'Verify rooms'
    },
    ROOMPICKER_SUBHEADER_MANAGE: {
      key: 'ROOMPICKER_SUBHEADER_MANAGE',
      value: 'Enter room ids below to add to this schedule board or select the "Find rooms" link to search for rooms.'
    },
    ROOMPICKER_UNDELEGATED_ROOM_ERROR: {
      key: 'ROOMPICKER_UNDELEGATED_ROOM_ERROR',
      value: 'Unable to get events for undelegated room'
    },
    ROOMPICKER_UNDELEGATED_ROOM_ERROR_MESSAGE: {
      key: 'ROOMPICKER_UNDELEGATED_ROOM_ERROR_MESSAGE',
      value: 'Room is not delegated to the current user'
    },
    ROOMPICKER_INVALID_ROOM_ERROR_MESSAGE: {
      key: 'ROOMPICKER_INVALID_ROOM_ERROR_MESSAGE',
      value: 'Room is invalid'
    },
    STATE_UNAUTHENTICATED_MESSAGE: {
      key: 'STATE_UNAUTHENTICATED_MESSAGE',
      value: 'This schedule board is not authenticated to a calendar exchange.'
    },
    STATE_UNAUTHENTICATED_SUBMESSAGE: {
      key: 'STATE_UNAUTHENTICATED_SUBMESSAGE',
      value: 'Please authenticate your schedule board in the Appspace console.'
    },
    STATE_UNCONFIGURED_MESSAGE: {
      key: 'STATE_UNCONFIGURED_MESSAGE',
      value: 'This schedule board is not configured to show rooms.'
    },
    STATE_UNCONFIGURED_SUBMESSAGE: {
      key: 'STATE_UNCONFIGURED_SUBMESSAGE',
      value: 'Please configure your schedule board in the Appspace console.'
    },
    DIALOG_PREVIEW_MODE: {
      key: 'DIALOG_PREVIEW_MODE',
      value: 'This preview is for demo purposes only and no actions can be performed. Configure this card to view live room information.'
    },
    DIALOG_NOTSUPPORTED: {
      key: 'DIALOG_NOTSUPPORTED',
      value: 'This feature is not supported in edit mode'
    },
    DIALOG_BOOKNOW_TITLE: {
      key: 'DIALOG_BOOKNOW_TITLE',
      value: 'Book {0} from {1} until'
    },
    DIALOG_BOOK_TITLE: {
      key: 'DIALOG_BOOK_TITLE',
      value: 'Name your meeting'
    },
    DIALOG_EVENT_DISPLAY_TITLE: {
      key: 'DIALOG_EVENT_DISPLAY_TITLE',
      value: 'Meeting information'
    },
    DIALOG_EVENT_ACTION_TITLE: {
      key: 'DIALOG_EVENT_ACTION_TITLE',
      value: 'Current meeting'
    },
    DIALOG_BOOK_RETRY: {
      key: 'DIALOG_BOOK_RETRY',
      value: 'We\'re having trouble booking your meeting. Please try again.'
    },
    DIALOG_BOOK_SUCCESS: {
      key: 'DIALOG_BOOK_SUCCESS',
      value: 'Room successfully booked'
    },
    DIALOG_BOOK_PLACEHOLDER: {
      key: 'DIALOG_BOOK_PLACEHOLDER',
      value: 'Instant Booking'
    },
    DIALOG_BOOK_PROCESSING: {
      key: 'DIALOG_BOOK_PROCESSING',
      value: 'We\'re booking your meeting...'
    },
    DIALOG_CHECKPOINT_REQUIRED: {
      key: 'DIALOG_CHECKPOINT_REQUIRED',
      value: 'Required {0:capitalize}'
    },
    DIALOG_CHECKPOINT_BOOK_CONFIRMATION: {
      key: 'DIALOG_CHECKPOINT_BOOK_CONFIRMATION',
      value: 'By declining this consent form, your meeting will not be booked.'
    },
    DIALOG_CHECKPOINT_BOOK_FAILURE: {
      key: 'DIALOG_CHECKPOINT_BOOK_FAILURE',
      value: 'We were unable to book your meeting due to a conflict with the reservation rules for this resource.'
    },
    DIALOG_CHECKPOINT_CHECK_IN_CONFIRMATION: {
      key: 'DIALOG_CHECKPOINT_CHECK_IN_CONFIRMATION',
      value: 'By declining this consent form, your meeting will not be checked in.'
    },
    DIALOG_CHECKPOINT_CHECK_IN_FAILURE: {
      key: 'DIALOG_CHECKPOINT_CHECK_IN_FAILURE',
      value: 'We were unable to check-in to your meeting due to a conflict with the reservation rules for this resource.'
    },
    DIALOG_END_PROCESSING: {
      key: 'DIALOG_END_PROCESSING',
      value: 'We\'re ending your meeting...'
    },
    DIALOG_END_RETRY: {
      key: 'DIALOG_END_RETRY',
      value: 'We\'re having trouble ending your meeting. Please try again.'
    },
    DIALOG_END_SUCCESS: {
      key: 'DIALOG_END_SUCCESS',
      value: 'Meeting successfully ended'
    },
    DIALOG_END_TITLE: {
      key: 'DIALOG_END_TITLE',
      value: 'End the following meeting'
    },
    DIALOG_EXTEND_PROCESSING: {
      key: 'DIALOG_EXTEND_PROCESSING',
      value: 'We\'re extending your meeting...'
    },
    DIALOG_EXTEND_RETRY: {
      key: 'DIALOG_EXTEND_RETRY',
      value: 'We\'re having trouble extending your meeting. Please try again.'
    },
    DIALOG_EXTEND_SUCCESS: {
      key: 'DIALOG_EXTEND_SUCCESS',
      value: 'Meeting successfully extended'
    },
    DIALOG_EXTEND_TITLE: {
      key: 'DIALOG_EXTEND_TITLE',
      value: 'Extend the following meeting'
    },
    DIALOG_CHECK_IN_PROCESSING: {
      key: 'DIALOG_CHECK_IN_PROCESSING',
      value: 'We\'re checking you in...'
    },
    DIALOG_CHECK_IN_RETRY: {
      key: 'DIALOG_CHECK_IN_RETRY',
      value: 'We\'re having trouble checking you in. Please try again.'
    },
    DIALOG_CHECK_IN_SUCCESS: {
      key: 'DIALOG_CHECK_IN_SUCCESS',
      value: 'Meeting successfully checked in'
    },
    DIALOG_CHECK_IN_TITLE: {
      key: 'DIALOG_CHECK_IN_TITLE',
      value: 'Check in to your meeting'
    },
    DIALOG_FILTER_ROOMS_TITLE: {
      key: 'DIALOG_FILTER_ROOMS_TITLE',
      value: 'Filter by'
    },
    DIALOG_FILTER_AVAILABLE_TITLE: {
      key: 'DIALOG_FILTER_AVAILABLE_TITLE',
      value: 'Available rooms'
    },
    DIALOG_FILTER_OCCUPIED_TITLE: {
      key: 'DIALOG_FILTER_OCCUPIED_TITLE',
      value: 'Occupied rooms'
    },
    DIALOG_FILTER_CHECK_IN_TITLE: {
      key: 'DIALOG_FILTER_CHECK_IN_TITLE',
      value: 'Check-in rooms'
    },
    DIALOG_EVENT_INFO_DESCRIPTION: {
      key: 'DIALOG_EVENT_INFO_DESCRIPTION',
      value: '<i class="icon icon-calendar">{0}</i><i class="icon icon-pin">{1}</i><i class="icon icon-clock">{2}</i>'
    },
    DIALOG_EVENT_INFO_UNTIL: {
      key: 'DIALOG_EVENT_INFO_UNTIL',
      value: '{0} until'
    },
    DIALOG_EVENT_INFO_ORGANIZER: {
      key: 'DIALOG_EVENT_INFO_ORGANIZER',
      value: '<span class="organizer-field"><span class="organizer-icon"></span><span class="organizer-name">{0}</span></span>'
    },
    SETTINGS_MANAGE_ROOMS_LABEL: {
      key: 'SETTINGS_MANAGE_ROOMS_LABEL',
      value: 'Manage Rooms'
    },
    SETTINGS_LOG_OUT_LABEL: {
      key: 'SETTINGS_LOG_OUT_LABEL',
      value: 'Log Out'
    },
    SETTINGS_AUTHENTICATE_ACCOUNT_LABEL: {
      key: 'SETTINGS_AUTHENTICATE_ACCOUNT_LABEL',
      value: 'Authenticate Account'
    },
    DIALOG_SETTINGS_TITLE: {
      key: 'DIALOG_SETTINGS_TITLE',
      value: 'Settings'
    },
    DIALOG_LOGOUT_HEADER: {
      key: 'DIALOG_LOGOUT_HEADER',
      value: 'Log out'
    },
    DIALOG_LOGOUT_TITLE: {
      key: 'DIALOG_LOGOUT_TITLE',
      value: 'You are about to log out and un-authenticate your card. Do you wish to proceed?'
    },
    DIALOG_LOGOUT_PROCESSING: {
      key: 'DIALOG_LOGOUT_PROCESSING',
      value: 'Logging out...'
    },
    DIALOG_LOGIN_USER: {
      key: 'DIALOG_LOGIN_USER',
      value: 'Please provide an email address to authenticate with the provider'
    },
    DIALOG_LOGIN_PLACEHOLDER: {
      key: 'DIALOG_LOGIN_PLACEHOLDER',
      value: 'Enter email here'
    },
    DIALOG_HIDDEN_MEETING_NAME: {
      key: 'DIALOG_HIDDEN_MEETING_NAME',
      value: 'Room Occupied'
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('AlertDialog', ["textResourceManager", "BaseDialog", "TEXT_RESOURCE", function (textResourceManager, BaseDialog, TEXT_RESOURCE) {
    function AlertDialog(message) {
      BaseDialog.extend(this, new BaseDialog());
      this.inputTitle = message || textResourceManager.getText(TEXT_RESOURCE.DIALOG_NOTSUPPORTED);
      this.showOther = true;
      this.otherText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_OK);
      this.hideCancel = true;
      this.enableOnEditing = true;
      this.styling.buttonOtherClass = 'main-btn outline-btn';

      this.onOtherClicked = function () {
        this.api.close();
      };
    } // Return the constructor for the class


    return AlertDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('BaseDialog', ["textResourceManager", "TEXT_RESOURCE", function (textResourceManager, TEXT_RESOURCE) {
    function BaseDialog() {
      this.inputTitle = '';
      this.showInput = false;
      this.showOptions = false;
      this.inputPlaceholder = '';
      this.inputText = '';
      this.selectOptions = [];
      this.showOther = false;
      this.showAccept = false;
      this.acceptDisabled = false;
      this.acceptText = '';
      this.enableOnEditing = false;
      this.hideCancel = false;
      this.otherText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_OTHER);
      this.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL);
      this.tryAgainText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_TRYAGAIN);
      this.processingTitle = '';
      this.successTitle = '';
      this.retryTitle = '';
      this.selectOptionsStyle = {};
      this.acceptStyle = {};
      this.otherStyle = {};
      this.styling = {
        windowClass: 'dialog-window',
        headerClass: '',
        inputClass: 'phase-input',
        buttonsClass: 'buttons',
        buttonOtherClass: 'main-btn accept-btn',
        buttonAcceptClass: 'main-btn accept-btn',
        buttonCancelClass: 'main-btn'
      };
      this.refresh = $angular.noop;

      this.onApiReady = function (api) {
        this.api = api;
      };

      this.onAcceptClicked = function () {
        this.api.process();
      };
    }

    BaseDialog.extend = function (derived, base) {
      for (var key in base) {
        derived[key] = base[key];

        if (typeof derived[key] != 'function') {
          continue;
        } // Purpose is to bind the "this" reference to the "derived" dialog inside the extending function.


        derived[key].bind(derived);
      }
    }; // Return the constructor for the class


    return BaseDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('BookAdvanceDialog', ["calendarDataManager", "checkpointManager", "textResourceManager", "BaseDialog", "CheckpointDialog", "textUtil", "TEXT_RESOURCE", "SYSTEM_DATA", "CHECKPOINT", function (calendarDataManager, checkpointManager, textResourceManager, BaseDialog, CheckpointDialog, textUtil, TEXT_RESOURCE, SYSTEM_DATA, CHECKPOINT) {
    function BookAdvanceDialog(bookingInfo, end, base) {
      BaseDialog.extend(this, new BaseDialog());
      bookingInfo = bookingInfo || {};
      var checkpoints = checkpointManager.getCheckpoints(bookingInfo.room, CHECKPOINT.ATRESERVATION);
      this.styling.buttonOtherClass = 'main-btn accept-btn';
      this.start = bookingInfo.start;
      this.end = end;
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOK_TITLE);
      this.retryTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOK_RETRY);
      this.successTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOK_SUCCESS);
      this.processingTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOK_PROCESSING);
      this.confirmationTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECKPOINT_BOOK_CONFIRMATION);
      this.confirmationErrorText = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECKPOINT_BOOK_FAILURE);
      this.inputText = '';
      this.showOptions = false;
      this.showOther = true;
      this.otherText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_BOOK);
      this.showInput = true;
      this.styling.buttonOtherClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_AVAILABLE_CLASS);
      this.styling.buttonRetryClass = textUtil.formatText('{0}', SYSTEM_DATA.CSS_AVAILABLE_CLASS);
      this.onOpen = undefined;
      this.inputPlaceholder = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOK_PLACEHOLDER);

      this.onInputConfirmed = function () {
        this.api.getElements().buttonOther.focus();
      };

      this.onOtherClicked = function () {
        // Checkpoint is not required, process book event directly
        if (!checkpoints.length) {
          this.onAcceptClicked();
          return;
        } // Checkpoint is required, open checkpoint dialog


        BaseDialog.extend(this, new CheckpointDialog(checkpoints, bookEvent, this));
      };

      var bookEvent = function () {
        return calendarDataManager.createEvent(bookingInfo.room, this.inputText || this.inputPlaceholder, this.start, this.end);
      }.bind(base);

      this.onProcess = function () {
        return bookEvent();
      };
    } // Return the constructor for the class


    return BookAdvanceDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('BookDialog', ["BaseDialog", "TimePickerDialog", "textResourceManager", "TEXT_RESOURCE", "timeUtil", "SYSTEM_DATA", "BookAdvanceDialog", function (BaseDialog, TimePickerDialog, textResourceManager, TEXT_RESOURCE, timeUtil, SYSTEM_DATA, BookAdvanceDialog) {
    function BookDialog(bookingInfo) {
      bookingInfo = bookingInfo || {};
      bookingInfo.room = bookingInfo.room || {};
      this.base = new TimePickerDialog(bookingInfo.start, bookingInfo.end, SYSTEM_DATA.CSS_AVAILABLE_CLASS, bookingInfo.endOfDay);
      BaseDialog.extend(this, this.base);
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_BOOKNOW_TITLE, [bookingInfo.room.name, timeUtil.getTimeText(bookingInfo.start)]);
      this.successTitle = 'success';

      this.onOptionClicked = function (option) {
        if (!option) {
          return;
        }

        BaseDialog.extend(this, new BookAdvanceDialog(bookingInfo, option.date, this));

        if (this.onOpen) {
          this.onOpen();
        }
      };
    }

    return BookDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('CheckInDialog', ["textResourceManager", "BaseDialog", "TEXT_RESOURCE", "EventInfoDialog", "SYSTEM_DATA", "textUtil", "calendarDataManager", function (textResourceManager, BaseDialog, TEXT_RESOURCE, EventInfoDialog, SYSTEM_DATA, textUtil, calendarDataManager) {
    function CheckInDialog(room, event) {
      BaseDialog.extend(this, new EventInfoDialog(room, event));
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECK_IN_TITLE);
      this.retryTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECK_IN_RETRY);
      this.processingTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECK_IN_PROCESSING);
      this.successTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_CHECK_IN_SUCCESS);
      this.showAccept = true;
      this.acceptText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CHECK_IN);
      this.styling.buttonAcceptClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_CHECK_IN_CLASS);
      this.onOpen = undefined;

      this.onInputConfirmed = function () {
        this.api.getElements().buttonAccept.focus();
      };

      this.onProcess = function () {
        // check in the current/next meeting
        return calendarDataManager.checkIn(room, event);
      };
    } // Return the constructor for the class


    return CheckInDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('CheckpointDialog', ["$q", "textUtil", "SYSTEM_DATA", "BaseDialog", "textResourceManager", "TEXT_RESOURCE", "CHECKPOINT_REQUIREMENT", function ($q, textUtil, SYSTEM_DATA, BaseDialog, textResourceManager, TEXT_RESOURCE, CHECKPOINT_REQUIREMENT) {
    function CheckpointDialog(checkpoints, onProcess, base) {
      BaseDialog.extend(this, new BaseDialog());
      this.showAccept = true;
      this.description = undefined;
      this.acceptStyle = base.otherStyle;
      this.retryTitle = base.retryTitle;
      this.successTitle = base.successTitle;
      this.successTitleLabelKey = base.successTitleLabelKey;
      this.processingTitle = base.processingTitle;
      this.processingTitleLabelKey = base.processingTitleLabelKey;
      this.inputText = base.inputText;
      this.inputPlaceholder = base.inputPlaceholder;
      this.styling.windowClass = 'dialog-window white-dialog-window';
      this.styling.buttonCancelClass = 'main-btn black-btn';
      this.confirmationErrorText = base.confirmationErrorText;
      this.confirmationTitle = base.confirmationTitle;
      this.confirmationText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_OK);
      this.cancelConfirmationText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL);
      this.icon = 'icon icon-alert';
      this.failureIcon = this.icon;
      var checkpointCount = checkpoints.length;
      var currentCount = 0;
      var closeDialog = false;
      var isDeclined = false;
      var ACCEPT_BUTTON_CLASS = 'main-btn accept-btn';
      var CANCELLATION_CONFIG = {
        BUTTON_CANCEL_CLASS: 'main-btn outline-btn',
        WINDOW_CLASS: 'dialog-window centered-dialog-window',
        CANCEL_TEXT: textResourceManager.getText(TEXT_RESOURCE.BUTTON_OK),
        HEADER_TITLE: ''
      };
      var PROCESSING_CONFIG = {
        BUTTON_CANCEL_CLASS: 'main-btn',
        WINDOW_CLASS: 'dialog-window',
        ICON: '',
        CANCEL_TEXT: base.cancelText,
        BUTTON_RETRY_CLASS: SYSTEM_DATA.CSS_AVAILABLE_CLASS,
        HIDE_CANCEL: false
      };
      var BUTTONS_CONFIG = {};
      BUTTONS_CONFIG[CHECKPOINT_REQUIREMENT.CONSENT] = {
        showAccept: true,
        styling: {
          buttonAcceptClass: textUtil.formatText('{0} {1}', [ACCEPT_BUTTON_CLASS, SYSTEM_DATA.CSS_AVAILABLE_CLASS])
        },
        acceptText: textResourceManager.getText(TEXT_RESOURCE.BUTTON_ACCEPT),
        hideCancel: false,
        cancelText: textResourceManager.getText(TEXT_RESOURCE.BUTTON_DECLINE)
      };
      BUTTONS_CONFIG[CHECKPOINT_REQUIREMENT.NOTICE] = {
        showAccept: true,
        styling: {
          buttonAcceptClass: textUtil.formatText('{0} {1}', [ACCEPT_BUTTON_CLASS, SYSTEM_DATA.CSS_AVAILABLE_CLASS])
        },
        acceptText: textResourceManager.getText(TEXT_RESOURCE.BUTTON_DONE),
        hideCancel: true,
        cancelText: ''
      };
      BUTTONS_CONFIG[CHECKPOINT_REQUIREMENT.FORM] = {
        showAccept: false,
        acceptText: '',
        hideCancel: false,
        cancelText: textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL)
      };
      var title = TEXT_RESOURCE.DIALOG_CHECKPOINT_REQUIRED.value;

      if (checkpointCount > 1) {
        title += ' {1}/' + checkpointCount;
      }

      var items = [];
      var currentItem;

      for (var i = 0; i < checkpointCount; i++) {
        var requirement = checkpoints[i];

        if (!requirement || !requirement.value) {
          continue;
        }

        var item = {
          type: requirement.type,
          title: textUtil.formatText(title, [requirement.type, i + 1]),
          value: requirement.value,
          buttonsConfig: BUTTONS_CONFIG[requirement.type]
        };
        items.push(item);
      }

      this.finalize = function () {
        items = undefined;
        this.checkpoint = undefined;
      };

      this.onCancelClicked = function () {
        if (closeDialog) {
          this.api.close();
          return;
        }

        if (isDeclined) {
          this.styling.buttonCancelClass = CANCELLATION_CONFIG.BUTTON_CANCEL_CLASS;
          this.styling.windowClass = CANCELLATION_CONFIG.WINDOW_CLASS;
          this.cancelText = CANCELLATION_CONFIG.CANCEL_TEXT;
          this.hideCancel = false;
          this.headerTitle = '';
          this.finalize();
          this.api.process(true);
          closeDialog = true;
          return;
        }

        this.showConfirmation = true;
        isDeclined = true;
      };

      this.onConfirmClicked = function () {
        this.showConfirmation = false;
        this.onCancelClicked(true);
      };

      this.onCancelConfirmationClicked = function () {
        this.showConfirmation = false;
        isDeclined = false;
        closeDialog = false;
      };

      this.onAcceptClicked = function () {
        currentCount++;
        this.processCheckpoint();
      };

      this.onProcess = function (cancelled) {
        if (!cancelled) {
          this.icon = PROCESSING_CONFIG.ICON;
          this.styling.buttonCancelClass = PROCESSING_CONFIG.BUTTON_CANCEL_CLASS;
          this.styling.windowClass = PROCESSING_CONFIG.WINDOW_CLASS;
          this.cancelText = PROCESSING_CONFIG.CANCEL_TEXT;
          this.styling.buttonRetryClass = PROCESSING_CONFIG.BUTTON_RETRY_CLASS;
          this.hideCancel = PROCESSING_CONFIG.HIDE_CANCEL;
          return onProcess();
        }

        return $q.reject({
          errorCode: SYSTEM_DATA.CONSTRAINED_ERROR,
          errorMessage: this.confirmationErrorText
        });
      };

      this.processCheckpoint = function () {
        this.headerTitle = '';
        this.checkpoint = ''; // We have passed the last checkpoint

        if (currentCount >= checkpointCount) {
          this.finalize();
          this.api.process();
          return;
        }

        currentItem = items[currentCount];
        var buttonsConfig = currentItem.buttonsConfig;
        this.showAccept = buttonsConfig.showAccept;

        if (this.styling && buttonsConfig.styling) {
          this.styling.buttonAcceptClass = buttonsConfig.styling.buttonAcceptClass;
        }

        this.acceptText = buttonsConfig.acceptText;
        this.hideCancel = buttonsConfig.hideCancel;
        this.cancelText = buttonsConfig.cancelText;
        this.headerTitle = currentItem.title;
        this.checkpoint = currentItem.value;
      };

      this.processCheckpoint();
    } // Return the constructor for the class


    return CheckpointDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('EndDialog', ["textResourceManager", "BaseDialog", "TEXT_RESOURCE", "EventInfoDialog", "calendarDataManager", "textUtil", "SYSTEM_DATA", function (textResourceManager, BaseDialog, TEXT_RESOURCE, EventInfoDialog, calendarDataManager, textUtil, SYSTEM_DATA) {
    function EndDialog(room, event) {
      BaseDialog.extend(this, new EventInfoDialog(room, event));
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_END_TITLE);
      this.retryTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_END_RETRY);
      this.processingTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_END_PROCESSING);
      this.successTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_END_SUCCESS);
      this.showAccept = true;
      this.acceptText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_END);
      this.styling.buttonAcceptClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_OCCUPIED_CLASS);
      this.onOpen = undefined;

      this.onInputConfirmed = function () {
        this.api.getElements().buttonAccept.focus();
      };

      this.onProcess = function () {
        // end the current meeting
        return calendarDataManager.end(room, event);
      };
    } // Return the constructor for the class


    return EndDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('EventActionDialog', ["textResourceManager", "BaseDialog", "EventInfoDialog", "EndDialog", "ExtendDialog", "bookingUtil", "textUtil", "SYSTEM_DATA", "TEXT_RESOURCE", function (textResourceManager, BaseDialog, EventInfoDialog, EndDialog, ExtendDialog, bookingUtil, textUtil, SYSTEM_DATA, TEXT_RESOURCE) {
    function EventActionDialog(room, event, extendableTimeRange) {
      extendableTimeRange = extendableTimeRange || {};
      BaseDialog.extend(this, new EventInfoDialog(room, event));
      var availableTimeSlots = bookingUtil.generateTimeBlocks(extendableTimeRange.start, extendableTimeRange.end);

      if (availableTimeSlots.length > 0) {
        // there's no back-to-back meeting; meeting is extendable
        this.showOther = true;
        this.otherText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_EXTEND);
        this.otherStyle = {
          'background-color': '#308ced'
        };

        this.onOtherClicked = function () {
          BaseDialog.extend(this, new ExtendDialog(room, event, extendableTimeRange));

          if (this.onOpen) {
            this.onOpen();
          }
        };
      }

      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EVENT_ACTION_TITLE);
      this.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL);
      this.showAccept = true;
      this.acceptText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_END);
      this.styling.buttonOtherClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_AVAILABLE_CLASS);
      this.styling.buttonAcceptClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_OCCUPIED_CLASS);

      this.onAcceptClicked = function () {
        BaseDialog.extend(this, new EndDialog(room, event));

        if (this.onOpen) {
          this.onOpen();
        }
      };
    }

    return EventActionDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('EventInfoDialog', ["textResourceManager", "dataUtil", "textUtil", "timeUtil", "eventUtil", "BaseDialog", "TEXT_RESOURCE", function (textResourceManager, dataUtil, textUtil, timeUtil, eventUtil, BaseDialog, TEXT_RESOURCE) {
    function EventInfoDialog(room, event, useUntilText) {
      event = event || {};
      room = room || {};
      BaseDialog.extend(this, new BaseDialog());

      this.generateInfo = function () {
        var untilText = useUntilText ? textResourceManager.getText(TEXT_RESOURCE.DIALOG_EVENT_INFO_UNTIL, timeUtil.getTimeText(new Date(event.start))) : timeUtil.getTimeRangeText(event.start, event.end);
        this.description = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EVENT_INFO_DESCRIPTION, [textUtil.encodeHtml(event.title), room.name, untilText]);
        var organizerLabel = eventUtil.generateOrganizerName(room, event.organizerUsername, event.organizerUsername);

        if (dataUtil.isNullOrUndefined(organizerLabel)) {
          return;
        }

        this.description += textResourceManager.getText(TEXT_RESOURCE.DIALOG_EVENT_INFO_ORGANIZER, [textUtil.encodeHtml(organizerLabel)]);
      };

      this.generateInfo();
      this.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CLOSE);

      this.refresh = function () {
        this.generateInfo();
      };
    } // Return the constructor for the class


    return EventInfoDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('ExtendDialog', ["textResourceManager", "BaseDialog", "TEXT_RESOURCE", "EventInfoDialog", "calendarDataManager", "SYSTEM_DATA", "TimePickerDialog", function (textResourceManager, BaseDialog, TEXT_RESOURCE, EventInfoDialog, calendarDataManager, SYSTEM_DATA, TimePickerDialog) {
    function ExtendDialog(room, event, timeRange) {
      timeRange = timeRange || {};
      var extendedEndTime;
      var eventInfoDialog = new EventInfoDialog(room, event, true);
      BaseDialog.extend(this, eventInfoDialog);
      BaseDialog.extend(this, new TimePickerDialog(timeRange.start, timeRange.end, SYSTEM_DATA.CSS_AVAILABLE_CLASS, timeRange.endOfDay));
      this.selectOptionsStyle = {
        'background-color': '#308ced'
      };
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EXTEND_TITLE);
      this.retryTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EXTEND_RETRY);
      this.processingTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EXTEND_PROCESSING);
      this.successTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_EXTEND_SUCCESS);
      this.onOpen = undefined;

      this.onOptionClicked = function (option) {
        if (!option) {
          return;
        }

        extendedEndTime = option.date;
        this.api.process();
      };

      this.onProcess = function () {
        // extend the current meeting
        return calendarDataManager.extend(room, event, extendedEndTime);
      };

      this.refresh = eventInfoDialog.refresh;
    } // Return the constructor for the class


    return ExtendDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('FilterDialog', ["textResourceManager", "BaseDialog", "SYSTEM_DATA", "TEXT_RESOURCE", "ROOM_STATUS", function (textResourceManager, BaseDialog, SYSTEM_DATA, TEXT_RESOURCE, ROOM_STATUS) {
    function FilterDialog(callback) {
      BaseDialog.extend(this, new BaseDialog());
      var filters = {};
      filters[ROOM_STATUS.AVAILABLE] = {
        key: ROOM_STATUS.AVAILABLE,
        text: textResourceManager.getText(TEXT_RESOURCE.DIALOG_FILTER_AVAILABLE_TITLE),
        cssClass: SYSTEM_DATA.CSS_AVAILABLE_CLASS
      };
      filters[ROOM_STATUS.OCCUPIED] = {
        key: ROOM_STATUS.OCCUPIED,
        text: textResourceManager.getText(TEXT_RESOURCE.DIALOG_FILTER_OCCUPIED_TITLE),
        cssClass: SYSTEM_DATA.CSS_OCCUPIED_CLASS
      };
      filters[ROOM_STATUS.CHECK_IN] = {
        key: ROOM_STATUS.CHECK_IN,
        text: textResourceManager.getText(TEXT_RESOURCE.DIALOG_FILTER_CHECK_IN_TITLE),
        cssClass: SYSTEM_DATA.CSS_CHECK_IN_CLASS
      };
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_FILTER_ROOMS_TITLE);
      this.showAccept = true;
      this.acceptText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_RESET);
      this.acceptStyle = {
        'background-color': 'transparent',
        'border': '1px solid white',
        'margin': '1em 0 0.7em 0'
      };
      this.showCancel = true;
      this.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_CANCEL);
      this.onOpen = undefined;
      this.showOptions = true;
      this.selectOptions = filters;

      this.onAcceptClicked = function () {
        callback('');
        this.api.close();
      };

      this.onOptionClicked = function (option) {
        if (!option) {
          return;
        }

        callback(option.key);
        this.api.close();
      };
    } // Return the constructor for the class


    return FilterDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('LogOutDialog', function ($location, $q, BaseDialog, textResourceManager, calendarDataManager, eventManager, configurationManager, calendarProviderFactory, SYSTEM_DATA, TEXT_RESOURCE, ROUTES, CUSTOM_DATA_KEY, textUtil, dataUtil, authenticationManager) {
    function LogOutDialog() {
      BaseDialog.extend(this, new BaseDialog());
      this.showOther = true;
      this.hideCancel = false;
      this.headerTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_LOGOUT_HEADER);
      this.otherText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_YES);
      this.cancelText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_NO);
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_LOGOUT_TITLE);
      this.processingTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_LOGOUT_PROCESSING);
      this.styling.headerClass = 'settings-header';
      this.styling.buttonOtherClass += textUtil.formatText(' {0}', SYSTEM_DATA.CSS_AVAILABLE_CLASS);

      this.onOtherClicked = function () {
        this.api.process();
      };

      this.onProcess = function () {
        this.headerTitle = '';
        return authenticationManager.logOut();
      };

      this.onSuccess = function () {
        $location.path(ROUTES.DEFAULT);
        this.api.close();
      };
    }

    return LogOutDialog;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('LoginUserDialog', ["BaseDialog", "textResourceManager", "TEXT_RESOURCE", function (BaseDialog, textResourceManager, TEXT_RESOURCE) {
    function LoginUserDialog(callback) {
      var disabledColor = '#999';
      var enabledColor = '#58b090';
      BaseDialog.extend(this, new BaseDialog());

      this.disableAcceptButton = function (disable) {
        this.acceptDisabled = disable;
        this.acceptStyle['background-color'] = this.acceptDisabled ? disabledColor : enabledColor;
      };

      this.showInput = true;
      this.inputTitle = textResourceManager.getText(TEXT_RESOURCE.DIALOG_LOGIN_USER); // Button

      this.showAccept = true;
      this.acceptDisabled = true;
      this.acceptText = textResourceManager.getText(TEXT_RESOURCE.BUTTON_OK);
      this.acceptStyle = {};
      this.disableAcceptButton(true); // Input

      this.inputPlaceholder = textResourceManager.getText(TEXT_RESOURCE.DIALOG_LOGIN_PLACEHOLDER);

      this.onInputConfirmed = function () {
        this.api.getElements().buttonAccept.focus();
      };

      this.onOpen = undefined;

      this.onAcceptClicked = function () {
        callback({
          loginUser: this.inputText
        });
        this.api.close();
      };

      this.onInputKeyUp = function (event) {
        if (!event || !event.currentTarget) {
          return;
        }

        if (!event.currentTarget.value) {
          this.disableAcceptButton(true);
          return;
        }

        this.disableAcceptButton(false);
      };
    }

    return LoginUserDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('TimePickerDialog', ["timeUtil", "bookingUtil", "BaseDialog", "calendarDataManager", function (timeUtil, bookingUtil, BaseDialog, calendarDataManager) {
    function TimePickerDialog(start, end, optionCssClass, endOfDay) {
      BaseDialog.extend(this, new BaseDialog());
      endOfDay = calendarDataManager.supportBookingUntilEndOfDay() ? endOfDay : undefined;
      var dateRange = timeUtil.getCurrentDateRange();
      this.start = start || dateRange.start;
      this.end = end || dateRange.end;
      this.showOptions = true;
      this.selectOptions = bookingUtil.generateTimeBlocks(this.start, this.end, optionCssClass, endOfDay);
    } // Return the constructor for the class


    return TimePickerDialog;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('asuiScheduleMap', ["$q", "$timeout", "domUtil", "dataUtil", "textUtil", "timeUtil", "displayUtil", "mapManager", "eventManager", "calendarDataManager", "configurationManager", "displayConfigurationManager", "MAP_SERVICE_STATE", function ($q, $timeout, domUtil, dataUtil, textUtil, timeUtil, displayUtil, mapManager, eventManager, calendarDataManager, configurationManager, displayConfigurationManager, MAP_SERVICE_STATE) {
    return {
      restrict: 'E',
      templateUrl: 'directives/asuiScheduleMap.html',
      scope: {
        items: '=',
        selectedItem: '=',
        readonly: '=',
        onApiReady: '&',
        onActionClick: '&',
        showMap: '<',
        showMapToggle: '<',
        isMapView: '<',
        isCurrentMapView: '<',
        showFooter: '<',
        filter: '<',
        resetFilter: '&',
        filteredCount: '<',
        totalCount: '<'
      },
      link: function link(scope) {
        scope.$watch('selectedItem', function (newValue) {
          scope.onRoomSelected(newValue);
        });
        scope.$watch('showMapToggle', function (newValue) {
          scope.showMapToggle = newValue;
        });
        scope.$watch('showMap', function (newValue) {
          if (newValue) {
            scope.init();
          } else {
            scope.resetMap();
          }

          if (scope.isMapView || !newValue || scope.isRoomInfoPanelOpen) {
            return;
          } // Reset map only if it's been changed to temporary map view


          scope.resetMapToInitialState();
        });
        scope.$watch('isMapView', function (newValue) {
          scope.isMapView = newValue;
          scope.resetMapToInitialState();
        });
        scope.$watch('showFooter', function (newValue, previousValue) {
          if (newValue == previousValue) {
            return;
          } // Resize map upon showing / hiding footer


          scope.resizeMap();
        });
        scope.$watch('isCurrentMapView', function (newValue) {
          if (!newValue) {
            scope.closeMap();
          }
        });
        scope.$watch('items', function (newValue, previousValue) {
          var newItems = newValue || [];
          var previousItems = previousValue || [];

          if ((newItems[0] || {}).id == (previousItems[0] || {}).id) {
            return;
          }

          scope.loadDefaultFloor();
        });
        scope.$watch('filter', function (newValue, previousValue) {
          if (newValue == previousValue) {
            return;
          }

          scope.onFilterUpdated();
        });
      },
      controller: ["$scope", "$filter", "$element", function ($scope, $filter, $element) {
        var api = {
          loadRoom: onRoomSelected,
          loadFloor: onFloorSelected,
          init: init,
          onItemAction: onItemAction
        };
        var subscribers = [];
        var floorStyle = {};
        var STATUS_COLOR_MAPPING = {
          'available': {
            status: 'available',
            color: ''
          },
          'occupied': {
            status: 'occupied',
            color: ''
          },
          'checkin': {
            status: 'checkin',
            color: ''
          }
        };
        var ACTIONS = {
          INFO_CLOSE: 'info-close',
          BOOK: 'book',
          EXTEND: 'extend',
          END: 'end',
          CHECK_IN: 'checkin'
        };
        var CURRENT_LOCATION_KEY = 'CurrentLocation';
        var CURRENT_LOCATION_POI = {
          id: CURRENT_LOCATION_KEY,
          geoJSON: {
            geometry: {
              type: 'Point'
            }
          },
          style: {
            fill: '#1D7BE3',
            strokeWidth: 3
          },
          isCurrentLocation: true
        };
        var ANIMATION_SLIDE_UP = 'slide-up';
        var ANIMATION_SLIDE_DOWN = 'slide-down';
        var MAP_WRAPPER_CLASS = 'floorplan-wrapper';
        var ARTIFICIAL_DELAY = 10;
        var RENDERING_BUFFER = 300;
        var INFO_PANEL_ANIMATION_DURATION = 500;
        var DEFAULT_ZOOM = 0.8;
        var DEFAULT_SCALE = 1;
        var DEFAULT_POSITION_POINTS = {
          x: 0,
          y: 0
        };
        var NO_MAPS_PLACEHOLDER_TEXT = 'There are no maps available for this location.';
        var NO_MAPS_PLACEHOLDER_SUBTEXT = 'Go to the Maps section on the Appspace console to configure your maps';
        var MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_TEXT = 'Unable to connect to Map Service.';
        var MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_SUBTEXT = 'The service or network is temporarily down. ';
        var isInitialized = false;
        var isTemporaryMapView = false;
        var isCurrentLocationValid = false;
        var previousLocation;
        var mapTransition = '';
        var activePois = [];
        var activeFloorPlan;
        var activeFloorId;
        var activeFloor;
        var previousFloorId;
        var currentLocation = {};
        var renderingResizeTimeout;
        var floors = [];
        var rooms = {};
        var roomStateSubscriptions = [];
        var floorPlanInfo = {
          imageWidth: 1,
          imageHeight: 1,
          imageRatio: 1,
          elementWidth: 1,
          elementHeight: 1
        };
        var resizeInterval = null;
        var poiLayerApi = null;
        var previousSelectedRoomId;
        $scope.onFloorSelected = onFloorSelected;
        $scope.onRoomSelected = onRoomSelected;
        $scope.resizeMap = startRenderingResize;
        $scope.loadDefaultFloor = loadDefaultFloor;
        $scope.restartMapService = restartMapService;
        $scope.onFilterUpdated = applyFilter;
        $scope.resetMap = resetMap;
        $scope.closeMap = closeMap;
        $scope.init = init;
        $scope.showMapPlaceholder = false;
        $scope.isRoomInfoPanelOpen = false;
        $scope.isMapLoading = true;
        $scope.showResetButton = false;
        $scope.isScreenshot = false;
        $scope.isFloorPlanProcessing = false;
        $scope.filteredFloors = [];
        $scope.textStyle = {};
        $scope.poiLayerOptions = {
          zoom: {
            scale: DEFAULT_ZOOM
          },
          floorplanScale: DEFAULT_SCALE
        };
        $scope.placeholderText = '';
        var $parentCtrl = $scope.$parent.$ctrl;
        $parentCtrl.onMapApiReady(api);

        $scope.resetMapToInitialState = function () {
          activeFloorId = undefined;
          closeItemInfo();
          resetMap();
          loadDefaultFloor();
          startResize();
        };

        $scope.onPoiClicked = function (poi) {
          // Skip if there is no POI room ID or
          // a POI is clicked when room info panel is open
          if (!poi || !poi.roomId || $scope.isRoomInfoPanelOpen) {
            return;
          }

          selectRoom(poi.roomId);
        };

        $scope.onPoiFloorplanLoad = function (size) {
          floorPlanInfo.imageWidth = size.width;
          floorPlanInfo.imageHeight = size.height;
          floorPlanInfo.imageRatio = size.width / size.height;
          floorPlanInfo.elementWidth = 0;
          floorPlanInfo.elementHeight = 0;
          startResize();
          $scope.showMapPlaceholder = false; // Add rendering buffer to prevent intermittent flicker when map transition occurs

          $timeout(function () {
            $scope.isMapLoading = false;
          }, RENDERING_BUFFER);
        };

        $scope.onLayerZoomUpdate = function (zoom) {
          $scope.zoom = zoom.scale;
        };

        $scope.onPoiLayerApiReady = function (api) {
          poiLayerApi = api;
        };

        $scope.getFloorStyle = function (floorId) {
          return activeFloorId == floorId ? floorStyle.selectedButton : floorStyle.button;
        };

        $scope.getButtonStyle = function (floorId) {
          return activeFloorId == floorId ? floorStyle.selectedButton : floorStyle.button;
        };

        $scope.getFooterText = function () {
          $scope.showResetButton = false; // Don't show any text if
          // no floorplans are available and filter is not applied or room info panel is open

          if (!$scope.filteredFloors.length && !$scope.filter || $scope.isRoomInfoPanelOpen) {
            return '';
          } // If filter is not applied


          if (!$scope.filter) {
            // If there's no active floor / valid current location or
            // current location and active floor are the same floor
            if (!activeFloor || !isCurrentLocationValid || dataUtil.isNullOrUndefined(currentLocation.floorNumber) || isCurrentLocationFloor(activeFloor.floorNumber)) {
              return 'Select a room for more information';
            }

            $scope.showResetButton = true;
            return textUtil.formatText('You are on Level {0}', activeFloor.name);
          }

          return !$scope.filteredFloors.length && !$scope.filteredCount ? textUtil.formatText('There are no {0} rooms', $scope.filter) : textUtil.formatText('Viewing {0} out of {1} rooms', [$scope.filteredCount, $scope.totalCount]);
        };

        $scope.getTransitionStyle = function () {
          if ($scope.showMapPlaceholder || $scope.isRoomInfoPanelOpen) {
            return '';
          }

          return $scope.isMapLoading ? mapTransition : 'floorplan-show';
        };

        function isCurrentLocationFloor(floorNumber) {
          return currentLocation.floorNumber == floorNumber;
        }

        function init() {
          $scope.isScreenshot = configurationManager.isScreenshot(); // Init only if it hasn't been done before and it's not in screenshot / preview mode

          if (isInitialized || $scope.isScreenshot || calendarDataManager.isPreview()) {
            return;
          }

          isInitialized = true;
          $scope.isEditing = configurationManager.isEditing();
          mapManager.start().then(function () {
            subscribers.push(displayConfigurationManager.subscribeToLevelStylingChanged(onFloorStyleChanged));
            subscribers.push(displayConfigurationManager.subscribeToTableTextColorChanged(onTableTextColorChanged));
            subscribers.push(displayConfigurationManager.subscribeToCheckInColorChanged(onCheckInColorChanged));
            subscribers.push(displayConfigurationManager.subscribeToOccupiedColorChanged(onOccupiedColorChanged));
            subscribers.push(displayConfigurationManager.subscribeToAvailableColorChanged(onAvailableColorChanged));
            subscribers.push(mapManager.subscribeToMapChanged(onFloorsChanged));
            subscribers.push(calendarDataManager.subscribeToProviderRoomIdsChanged(onRoomIdsChanged));
            subscribers.push(mapManager.subscribeToCurrentLocationChanged(onCurrentLocationChanged));
            subscribers.push(mapManager.subscribeToMapServiceStateChanged(onMapServiceStateChanged));
          });
        }

        function startRenderingResize() {
          if (renderingResizeTimeout) {
            $timeout.cancel(renderingResizeTimeout);
            renderingResizeTimeout = undefined;
          } // Give buffer for rendering before starting to resize map


          renderingResizeTimeout = $timeout(startResize, ARTIFICIAL_DELAY);
        }

        function resetMap() {
          $scope.isRoomInfoPanelOpen = false;
          setZoom();
          previousSelectedRoomId = undefined;
          $scope.selectedItem = undefined;
        }

        function selectFloorByRoom(room) {
          // Map is unavailable, return true to mimic that a floor has been selected
          // so that the consumer stops trying with another room
          if (!$scope.filteredFloors || !$scope.filteredFloors.length) {
            return true;
          } // The room isn't defined or is invalid


          if (!room || !room.id) {
            return false;
          } // The room isn't mapped with a floor POI


          var locationInfo = mapManager.getLocationInfoByRoomId(room.id, $scope.filteredFloors);

          if (!locationInfo) {
            return false;
          }

          setActiveFloor(locationInfo.floor); // Floor has been selected

          return true;
        }

        function loadDefaultFloorWithMap(rooms) {
          mapTransition = ''; // Default floor is where the first room with location info is located at

          for (var i = 0; i < rooms.length; i++) {
            // Default floor has been set or map is unavailable,
            // stop attempts to select floor by the remaining rooms
            if (selectFloorByRoom(rooms[i])) {
              break;
            }
          }
        }

        function loadDefaultFloor() {
          if (!$scope.items) {
            return;
          } // Set current location as default floor


          if (!dataUtil.isNullOrUndefined(currentLocation.floorId)) {
            onFloorSelected(currentLocation.floorId);
            return;
          } // Default floor is where the first room with location info is located at


          loadDefaultFloorWithMap($scope.items);
        }

        function getFilteredPois(pois) {
          return pois.filter(function (poi) {
            return poi.status == $scope.filter;
          });
        }

        function loadDefaultFilteredFloor() {
          if (!$scope.filteredFloors.length) {
            return;
          } // Default floor is where the first filtered room with location info is located at


          var filteredRooms = $filter('filter')($scope.items, function (room) {
            return room.status === $scope.filter;
          });
          loadDefaultFloorWithMap(filteredRooms);
        }

        function applyFilter() {
          if (!$scope.filter) {
            $scope.filteredFloors = floors;
            activeFloorId = undefined;
            loadDefaultFloor();
            return;
          }

          var currentFloors = [];
          var originalFloors = $angular.copy(floors);

          for (var i = 0; i < originalFloors.length; i++) {
            var floor = originalFloors[i];

            if (!floor || !floor.pointOfInterests) {
              continue;
            }

            var filteredPois = getFilteredPois(floor.pointOfInterests);

            if (!filteredPois.length) {
              continue;
            }

            floor.pointOfInterests = filteredPois; // Add floor to display only if there are filtered POIs

            currentFloors.push(floor);
          }

          $scope.filteredFloors = currentFloors;
          loadDefaultFilteredFloor();
        }

        function bookEvent(item, slot) {
          if (!$parentCtrl.api || !$parentCtrl.api.bookEvent) {
            return;
          }

          $parentCtrl.api.bookEvent(item, slot);
        }

        function extendEvent(item, event) {
          if (!$parentCtrl.api || !$parentCtrl.api.extendEvent) {
            return;
          } // Send room object only to match room object structure when patching an event


          $parentCtrl.api.extendEvent(item.room, event);
        }

        function endEvent(item, event) {
          if (!$parentCtrl.api || !$parentCtrl.api.endEvent) {
            return;
          } // Send room object only to match room object structure when patching an event


          $parentCtrl.api.endEvent(item.room, event);
        }

        function checkInEvent(item, event) {
          if (!$parentCtrl.api || !$parentCtrl.api.checkInEvent) {
            return;
          } // Send room object only to match room object structure when patching an event


          $parentCtrl.api.checkInEvent(item.room, event);
        }

        function onItemAction(action) {
          if (!action) {
            return;
          }

          switch (action.type) {
            case ACTIONS.INFO_CLOSE:
              resetMap();

              if (!isTemporaryMapView && $scope.showMapToggle || !$scope.isCurrentMapView && $scope.showMapToggle && isTemporaryMapView && !displayUtil.isPortraitOrientation()) {
                closeMap();
                return;
              }

              onInfoPanelAnimated().then(function () {
                selectFloor(previousFloorId);

                if (!$scope.showMapToggle || !displayUtil.isPortraitOrientation()) {
                  return;
                }

                closeMap();
              });
              break;

            case ACTIONS.BOOK:
              var now = new Date().getTime(); // End time will be either the upcoming meeting's (if any) start time
              // or current date range's end time

              var end = action.upcomingMeetings.length ? action.upcomingMeetings[0].start : timeUtil.getCurrentDateRange().end;
              bookEvent(action.item, {
                start: now,
                time: now,
                end: end
              });
              break;

            case ACTIONS.EXTEND:
              extendEvent(action.item, action.currentMeeting);
              break;

            case ACTIONS.END:
              endEvent(action.item, action.currentMeeting);
              break;

            case ACTIONS.CHECK_IN:
              // Use current meeting for check-in state
              // or the first upcoming meeting for pre check-in state
              checkInEvent(action.item, action.currentMeeting || action.upcomingMeetings[0]);
          }
        }

        function closeMap() {
          if (!$parentCtrl.api || !$parentCtrl.api.showMap) {
            return;
          }

          $parentCtrl.api.showMap(false);
        }

        function closeItemInfo() {
          if (!$parentCtrl.api || !$parentCtrl.api.closeItemInfo) {
            return;
          }

          $scope.isRoomInfoPanelOpen = false;
          previousSelectedRoomId = undefined;
          $parentCtrl.api.closeItemInfo($scope.isRoomInfoPanelOpen);
        }

        function openItemInfo(roomId, showMap) {
          if (!$parentCtrl.api || !$parentCtrl.api.openItemInfo || !roomId) {
            return;
          }

          $parentCtrl.api.openItemInfo(roomId, showMap);
        }

        function selectFloor(floorId, isFromMap) {
          // Skip if the same floor is selected through map
          if (isFromMap && floorId == activeFloorId) {
            return;
          }

          if (isFromMap && $scope.isRoomInfoPanelOpen) {
            closeItemInfo();

            if (!$scope.isCurrentMapView) {
              // Simulate view switching to reflect map view correctly
              $parentCtrl.api.switchView();
            }
          }

          var floor = mapManager.getFloorByFloorId(floorId, $scope.filteredFloors);
          var previousFloor = mapManager.getFloorByFloorId(activeFloorId, $scope.filteredFloors);
          mapTransition = ''; // Show map transition only if floor is clicked from map and
          // previous floor exists

          if (isFromMap && previousFloor) {
            mapTransition = previousFloor.floorNumber > floor.floorNumber ? ANIMATION_SLIDE_DOWN : ANIMATION_SLIDE_UP;
          }

          if (!floor) {
            loadDefaultFloor();
            return;
          }

          setActiveFloor(floor);
        }

        function onFloorSelected(floorId) {
          selectFloor(floorId, true);
        }

        function selectRoom(roomId, notFromMap) {
          $scope.isRoomInfoPanelOpen = true;
          openItemInfo(roomId, $scope.isRoomInfoPanelOpen);
          onInfoPanelAnimated().then(function () {
            setActiveRoom(roomId, !notFromMap);
          });
        }

        function onRoomSelected(room) {
          if (!$scope.isMapView) {
            isTemporaryMapView = $scope.showMap;
          } // If map is not enabled or room is empty, skip


          if (!$scope.showMapToggle && !$scope.isMapView || !room || !room.id) {
            return;
          }

          if (previousSelectedRoomId == room.id) {
            return;
          }

          previousSelectedRoomId = room.id;
          selectRoom(room.id, true);
        }

        function onFloorStyleChanged(style) {
          style = style || {};
          floorStyle = {
            selectedButton: {
              color: style.color,
              background: style.backgroundColor
            },
            button: {
              color: style.backgroundColor,
              background: style.color
            }
          };
        }

        function onTableTextColorChanged(color) {
          $scope.textStyle = {
            'color': color
          };
          $scope.buttonStyle = {
            'color': color,
            'border-color': color
          };
        }

        function updateFloors() {
          $scope.filteredFloors = floors;

          if (!$scope.filter) {
            return;
          }

          applyFilter();
        }

        function updateRoomsStatusColor() {
          for (var i = 0; i < floors.length; i++) {
            // Go through each floor's POIs
            var pois = floors[i].pointOfInterests;

            if (!pois) {
              continue;
            }

            for (var j = 0; j < pois.length; j++) {
              // Go through each POI to update status color
              var poi = pois[j];

              if (!poi || !poi.status) {
                continue;
              }

              poi.style = {
                fill: STATUS_COLOR_MAPPING[poi.status].color
              };
            }
          }

          updateFloors();
          buildScene();
        }

        function onStatusColorChanged(status, color) {
          STATUS_COLOR_MAPPING[status].color = color;
          updateRoomsStatusColor();
        }

        function onCheckInColorChanged(color) {
          onStatusColorChanged('checkin', color);
        }

        function onOccupiedColorChanged(color) {
          onStatusColorChanged('occupied', color);
        }

        function onAvailableColorChanged(color) {
          onStatusColorChanged('available', color);
        }

        function setActiveFloor(floor) {
          if (!floor) {
            return;
          }

          previousFloorId = activeFloorId;
          activeFloorId = floor.id;
          activeFloor = floor; // Clear active floor plan and POIs before rebuilding

          $scope.activeFloorPlan = undefined;
          $scope.activePois = [];
          $scope.isMapLoading = true;
          activeFloorPlan = floor.floorPlanUrl;
          activePois = floor.pointOfInterests;
          $timeout(buildScene, ARTIFICIAL_DELAY);
          startRenderingResize();
        }

        function setActiveRoom(roomId, isClickedFromMap) {
          var originalFloor = mapManager.getLocationInfoByRoomId(roomId); // Up-to-date floor with status-mapped POIs

          var updatedFloor = mapManager.getLocationInfoByRoomId(roomId, floors);

          if (!updatedFloor || !originalFloor) {
            // Show default floor plan only if room is clicked from room list
            $scope.isMapLoading = false;
            $scope.showMapPlaceholder = !isClickedFromMap;
            return;
          }

          var floor = $angular.copy(originalFloor.floor); // Show active room as the only POI on the floor

          floor.pointOfInterests = [updatedFloor.floor.pointOfInterests[updatedFloor.poiIndex]]; // Show current location if it's applicable to the floor

          if (isCurrentLocationValid && isCurrentLocationFloor(floor.floorNumber)) {
            floor.pointOfInterests.push(currentLocation.poi);
          }

          setActiveFloor(floor);
        }

        function startResize() {
          stopResize(); // Since the map drawing canvas requires exact size values,
          // we will resize it until it matches the map container size

          resizeInterval = setInterval(checkResize, ARTIFICIAL_DELAY);
          checkResize();
        }

        function stopResize() {
          if (!resizeInterval) {
            return;
          }

          clearInterval(resizeInterval);
          resizeInterval = 0;
        }

        function getMapSize() {
          var mapElement = domUtil.getFirstElementByClassName(MAP_WRAPPER_CLASS);
          return !mapElement ? undefined : {
            width: mapElement.offsetWidth,
            height: mapElement.offsetHeight
          };
        }

        function checkResize() {
          // No need to check size until we have POI layer api
          if (!poiLayerApi) {
            return;
          }

          var mapSize = getMapSize();

          if (!mapSize) {
            return;
          }

          var elementWidth = Math.floor($element.innerWidth());
          var elementHeight = Math.floor($element.innerHeight());
          var resizeRequired = false;
          var mapWidth = mapSize.width;
          var mapHeight = mapSize.height;

          if (floorPlanInfo.elementWidth != mapWidth) {
            elementWidth = mapWidth;
            floorPlanInfo.elementWidth = elementWidth;
            resizeRequired = true;
          }

          if (floorPlanInfo.elementHeight != mapHeight) {
            elementHeight = mapHeight;
            floorPlanInfo.elementHeight = elementHeight;
            resizeRequired = true;
          }

          if (!resizeRequired) {
            stopResize();
            setZoom();
            $scope.showMapPlaceholder = !floors.length;
            return;
          }

          poiLayerApi.setStageSize(mapWidth, mapHeight);
        }

        function buildScene() {
          if (!poiLayerApi || !poiLayerApi.buildScene) {
            return;
          }

          $scope.activeFloorPlan = activeFloorPlan;
          $scope.$evalAsync(poiLayerApi.buildScene);
          $scope.activePois = activePois;
        }

        function getCenter(length) {
          return (length - length * DEFAULT_ZOOM) / 2;
        }

        function setZoom() {
          if (!poiLayerApi || !poiLayerApi.setZoom) {
            return;
          }

          var mapSize = getMapSize();
          var position = DEFAULT_POSITION_POINTS;

          if (mapSize) {
            var width = mapSize.width;
            var height = mapSize.height;
            position = {
              x: getCenter(width),
              y: getCenter(height)
            };
          }

          poiLayerApi.setZoom({
            amount: DEFAULT_ZOOM,
            position: position
          });
          $scope.poiLayerOptions.zoom.scale = DEFAULT_ZOOM;
        }

        function updatePoiRoomStatus(room) {
          if (dataUtil.isObjectEmpty(room)) {
            return;
          }

          rooms[room.roomId].status = room.status;

          if (!room.status) {
            return;
          }

          var roomLocation = rooms[room.roomId].locationInfo;

          if (!roomLocation) {
            return;
          }

          var floor = floors[roomLocation.floorIndex];

          if (!floor) {
            return;
          }

          floor.pointOfInterests[roomLocation.poiIndex].status = room.status;
          floor.pointOfInterests[roomLocation.poiIndex].style = {
            fill: STATUS_COLOR_MAPPING[room.status].color
          };
          floors[roomLocation.floorIndex] = floor;
        }

        function onRoomStatusChanged(room) {
          updatePoiRoomStatus(room);
          updateFloors();
          buildScene();
        }

        function clearRooms() {
          for (var i = 0; i < roomStateSubscriptions.length; i++) {
            roomStateSubscriptions[i].dispose();
          }

          roomStateSubscriptions = [];
          rooms = {};
        }

        function onRoomIdsChanged(roomIds) {
          clearRooms();
          roomIds = roomIds || [];

          for (var i = 0; i < roomIds.length; i++) {
            var roomId = roomIds[i];
            rooms[roomId] = {
              id: roomId,
              locationInfo: mapManager.getLocationInfoByRoomId(roomId)
            };
            roomStateSubscriptions.push(eventManager.getRoomStatusObservable(roomId).subscribe(onRoomStatusChanged));
          }

          refreshActiveFloor();
        }

        function removePinnedLocation() {
          isCurrentLocationValid = false;

          if (!previousLocation) {
            return;
          }

          for (var i = 0; i < floors.length; i++) {
            var floor = floors[i] || {};
            var pois = floor.pointOfInterests;

            if (floor.id != previousLocation.floorId || !pois) {
              continue;
            }

            for (var j = 0; j < pois.length; j++) {
              // Go through each POI to find previously pinned location and remove it
              var poi = pois[j];

              if (!poi || poi.id != previousLocation.poi.id) {
                continue;
              }

              pois.splice(j, 1);
              previousLocation = undefined;
              return;
            }
          }
        }

        function addPinnedLocation() {
          for (var i = 0; i < floors.length; i++) {
            var floor = floors[i] || {};

            if (floor.id != currentLocation.floorId) {
              continue;
            }

            currentLocation.poi = $angular.copy(CURRENT_LOCATION_POI);
            currentLocation.poi.geoJSON.geometry.coordinates = currentLocation.coordinates; // Add current pinned location

            floor.pointOfInterests.push(currentLocation.poi);
            isCurrentLocationValid = true;
            previousLocation = $angular.copy(currentLocation);
            break;
          }
        }

        function updateCurrentLocation() {
          removePinnedLocation();
          addPinnedLocation();
        }

        function onCurrentLocationChanged(location) {
          currentLocation = $angular.copy(location) || {};
          updateCurrentLocation();
          updateFloors();
          refreshActiveFloor();
        }

        function onMapServiceStateChanged(status) {
          switch (status) {
            case MAP_SERVICE_STATE.CONNECTED:
              // connected state; map service is able to get floors
              $scope.placeholderText = NO_MAPS_PLACEHOLDER_TEXT;
              $scope.placeholderSubtext = $scope.isEditing ? NO_MAPS_PLACEHOLDER_SUBTEXT : '';
              break;

            case MAP_SERVICE_STATE.FAILURE:
              // failure state (will retry up to 5 times in the background)
              $scope.placeholderText = MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_TEXT;
              $scope.placeholderSubtext = MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_SUBTEXT + 'Please wait while we try to reconnect';
              break;

            case MAP_SERVICE_STATE.NO_CONNECTION:
              // no connection after 5 failed attempts (show the try again button)
              $scope.showTryAgainButton = true;
              $scope.placeholderText = MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_TEXT;
              $scope.placeholderSubtext = MAP_SERVICE_UNAVAILABLE_PLACEHOLDER_SUBTEXT;
              break;
          }
        }

        function updateRoomsInfo() {
          for (var roomId in rooms) {
            var room = rooms[roomId];

            if (!room) {
              continue;
            } // Update location info


            room.locationInfo = mapManager.getLocationInfoByRoomId(roomId);
            updatePoiRoomStatus({
              roomId: roomId,
              status: room.status
            });
          }
        }

        function restartMapService() {
          $scope.showTryAgainButton = false;
          mapManager.restartMapService();
        }

        function refreshActiveFloor() {
          // No active floor on initial load
          if (!activeFloorId) {
            loadDefaultFloor();
            return;
          }

          var activeFloor = mapManager.getFloorByFloorId(activeFloorId, floors);

          if (activeFloor) {
            mapTransition = ''; // Refresh active floor

            setActiveFloor(activeFloor);
            return;
          } // Load default floor if selected floor is no longer valid


          activeFloorId = undefined;
          loadDefaultFloor();
        }

        function onFloorsChanged(updatedFloors) {
          floors = $angular.copy(updatedFloors) || [];
          updateCurrentLocation();
          updateRoomsInfo();
          updateRoomsStatusColor();
          refreshActiveFloor();
        }

        function onInfoPanelAnimated() {
          $scope.isFloorPlanProcessing = true;
          var promise = $q.defer(); // timeout to smooth transition

          $timeout(function () {
            $scope.isFloorPlanProcessing = false;
            promise.resolve();
          }, INFO_PANEL_ANIMATION_DURATION);
          return promise.promise;
        }
      }]
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctBackground', function () {
    return {
      restrict: 'E',
      templateUrl: 'directives/ctBackground.html',
      transclude: true,
      scope: {
        color: '=',
        media: '=',
        maskColor: '='
      },
      link: function link(scope) {
        scope.$watch('color', function (newValue) {
          scope.updateBackgroundColor(newValue);
        });
        scope.$watch('media', function (newValue) {
          scope.updateBackgroundMedia(newValue);
        });
        scope.$watch('maskColor', function (newValue) {
          scope.updateMask(newValue);
        });
      },
      controller: ["$q", "$scope", "$timeout", "$element", "SYSTEM_DATA", "Playlist", "mediaUtil", "colorUtil", "interactivityManager", "logManager", "domUtil", function ($q, $scope, $timeout, $element, SYSTEM_DATA, Playlist, mediaUtil, colorUtil, interactivityManager, logManager, domUtil) {
        var currentMediaList;
        var rotationPromise;
        var currentPlaylist;
        var loadingMedia;
        var currentMedia;
        var supportMultiVideo = false;
        var supportTransition = false;
        var shouldMuteOnLoad = true;
        $scope.backgroundColorStyling = {};
        $scope.showMask = false;

        $scope.updateBackgroundMedia = function (backgroundMedia) {
          currentMediaList = backgroundMedia || [];
          currentPlaylist = new Playlist(currentMediaList, true);

          if (currentPlaylist.getItems().length == 0) {
            removeBackgroundMedia();
          } else {
            setBackground();
          }
        };

        $scope.updateBackgroundColor = function (backgroundColor) {
          $scope.backgroundColorStyling['background-color'] = backgroundColor;
        };

        $scope.updateMask = function (maskColor) {
          $scope.showMask = colorUtil.isColorVisible(maskColor);

          if (!$scope.showMask) {
            return;
          }

          $scope.maskStyling = {
            'background-color': maskColor
          };
        };

        $scope.onMediaApiReady = function (api) {
          loadingMedia.api = api;
          loadingMedia.element = loadingMedia.api.getElement();
          setMedia(loadingMedia, loadingMedia.url);
        };

        $scope.onMediaLoaded = function () {
          logManager.debug('Media ready: {0}', loadingMedia.url);
          mediaUtil.showMedia(loadingMedia.element, shouldAnimate(loadingMedia)).then(onLoadingMediaVisible);
        };

        $scope.onMediaEnded = function () {
          logManager.debug('Media ended: {0}', currentMedia.url);
          setBackground();
        };

        $scope.onMediaError = function (error) {
          var errorMedia = loadingMedia;
          var message = 'loading';

          if (!errorMedia) {
            errorMedia = currentMedia;
            message = 'playing';
          }

          logManager.error('Error {0} content {1}; {2}', [message, errorMedia.url, JSON.stringify(error)]);
          removeMediaItem(errorMedia).then(function () {
            loadingMedia = undefined;
            currentMedia = undefined;
            setBackground();
          });
        };

        $scope.$on('$destroy', function () {
          interactivityManager.unsubscribe(onPageInteracted);
          removeBackgroundMedia();
        });

        function onLoadingMediaVisible() {
          var swapMedia = function swapMedia() {
            currentMedia = $angular.copy(loadingMedia);
            loadingMedia = undefined;
            startBackgroundRotation(currentMedia.duration);
            playMedia(currentMedia);
          }; // if we're reusing the same playback directive, don't remove it


          if (currentMedia && loadingMedia && currentMedia.api.id === loadingMedia.api.id) {
            swapMedia();
            return;
          }

          removeMediaItem(currentMedia).then(swapMedia);
        }

        function playMedia(media) {
          if (!media || !media.api.play) {
            return;
          }

          media.api.play();
        }

        function startBackgroundRotation(duration) {
          cancelBackgroundRotation();

          if (duration == 0) {
            logManager.debug('Waiting for media to complete');
            return;
          }

          duration = duration || SYSTEM_DATA.BACKGROUND_ROTATION_DURATION;
          logManager.debug('Load next media in {0}ms', duration);
          rotationPromise = $timeout(setBackground, duration);
        }

        function cancelBackgroundRotation() {
          if (rotationPromise) {
            $timeout.cancel(rotationPromise);
            rotationPromise = undefined;
          }
        }

        function removeBackgroundMedia() {
          cancelBackgroundRotation();

          if (currentMedia) {
            removeMediaItem(currentMedia).then(function () {
              currentMedia = undefined;
            });
          }

          if (loadingMedia) {
            removeMediaItem(loadingMedia).then(function () {
              loadingMedia = undefined;
            });
          }
        }

        function removeMediaItem(mediaItem) {
          if (!mediaItem) {
            return $q.resolve();
          }

          var promise = $q.defer();
          mediaUtil.hideMedia(mediaItem.element, shouldAnimate(mediaItem)).then(function () {
            mediaItem.api.dispose();
            promise.resolve();
          });
          return promise.promise;
        }

        function loadBackground(url) {
          var lastElement = domUtil.getLastElement($element);
          var mediaConfig = mediaUtil.getMediaConfigFromUri(url);

          if (!mediaConfig) {
            logManager.error('Unable to retrieve media configuration for {0}', [url]);
            setBackground();
            return;
          }

          loadingMedia = {
            url: url,
            duration: mediaConfig.duration,
            config: mediaConfig
          };

          if (shouldReuseMediaDirective()) {
            loadingMedia.element = currentMedia.element;
            loadingMedia.api = currentMedia.api;
            setMedia(currentMedia, loadingMedia.url);
            return;
          }

          lastElement.before(domUtil.compileDirective(loadingMedia.config.directive, $scope.$new()));
        }

        function setMedia(mediaItem, url) {
          mediaItem.api.setMedia(url, {
            mute: !useAudio()
          });
        }

        function setBackground() {
          var item = currentPlaylist.nextItem(); // if we have current media & it's the same media, just replay

          if (currentMedia && currentMedia.url == item) {
            logManager.debug('Replaying media: {0}', item);
            startBackgroundRotation(currentMedia.duration);
            playMedia(currentMedia);
            return;
          } // if we already have loading media, remove it first


          if (loadingMedia) {
            logManager.debug('Setting bakground while there\'s an existing loading item. Removing loading item first.');
            removeMediaItem(loadingMedia).then(function () {
              loadingMedia = undefined;
              loadBackground(item);
            });
            return;
          }

          loadBackground(item);
        }

        function shouldReuseMediaDirective() {
          // if directive supports reuse and platform doesn't support multi video
          // we should reuse the directive
          return !supportMultiVideo && loadingMedia && loadingMedia.config.reuseDirective && currentMedia && currentMedia.config.directive == loadingMedia.config.directive;
        }

        function shouldAnimate(media) {
          return media.config.alwaysAnimate || supportTransition;
        }

        function onPageInteracted() {
          muteAudio(!useAudio());
        }

        function muteAudio(mute) {
          if (!currentMedia || !currentMedia.api.mute) {
            return;
          }

          currentMedia.api.mute(mute);
        }

        function useAudio() {
          // enable audio if page is interacted with or
          // platform support audio on load
          return interactivityManager.isInteracted() || !shouldMuteOnLoad;
        }

        interactivityManager.subscribe(onPageInteracted);
      }]
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctCheckpoint', function () {
    return {
      restrict: 'E',
      templateUrl: 'directives/ctCheckpoint.html',
      transclude: true,
      scope: {
        checkpoint: '=',
        onCancelClicked: '<',
        onAcceptClicked: '<'
      },
      link: function link(scope) {
        scope.$watch('checkpoint', function (newValue) {
          scope.updateCheckpoint(newValue);
        });
      },
      controller: ["$q", "$sce", "$scope", "$element", "domUtil", "mediaUtil", "MEDIA_TYPE", "CHECKPOINT_STATUS", "checkpointManager", "configurationManager", function ($q, $sce, $scope, $element, domUtil, mediaUtil, MEDIA_TYPE, CHECKPOINT_STATUS, checkpointManager, configurationManager) {
        var checkpoint;
        var loadingMedia;
        var currentMedia;
        var mediaElement;
        var subscribers = [];

        function onCheckpointResultUpdate(status) {
          switch (status) {
            case CHECKPOINT_STATUS.PASS:
              pauseMedia();
              $scope.onAcceptClicked();
              break;

            case CHECKPOINT_STATUS.FAIL:
              pauseMedia();
              $scope.onCancelClicked();
              break;
          }
        }

        var getContentType = function getContentType(type) {
          return type === MEDIA_TYPE.IMAGE || type === MEDIA_TYPE.VIDEO ? type : MEDIA_TYPE.IFRAME;
        };

        function getContentUrl(content) {
          if (content.url) {
            return $q.resolve(content.url);
          }

          var promise = $q.defer();
          configurationManager.getConstellationBaseUrl().then(function (url) {
            configurationManager.getConstellationAccountId().then(function (id) {
              promise.resolve(url + '/contents/' + id + '/' + content.contentId + '/');
            });
          });
          return promise.promise;
        }

        function setCheckpointHtml(html) {
          $scope.checkpointHtml = $sce.trustAsHtml(html);
        }

        function removeMediaItem(mediaItem) {
          if (!mediaItem) {
            return $q.resolve();
          }

          var promise = $q.defer();
          mediaUtil.hideMedia(mediaItem.element).then(function () {
            mediaItem.api.dispose();
            promise.resolve();
          });
          return promise.promise;
        }

        function loadMedia(content, config) {
          loadingMedia = {
            url: content.url,
            duration: config.duration,
            config: config,
            type: content.type
          };
          removeMediaItem(currentMedia).then(function () {
            mediaElement = $element;
            mediaElement.append(domUtil.compileDirective(loadingMedia.config.directive, $scope.$new()));
          });
        }

        function setMedia(mediaItem, url) {
          mediaItem.api.setMedia(url, {
            controls: true
          });
        }

        function pauseMedia() {
          if (!currentMedia || !currentMedia.api.pause) {
            return;
          }

          currentMedia.api.pause();
        }

        function playMedia() {
          if (!currentMedia || !currentMedia.api.play) {
            return;
          }

          currentMedia.api.play();
        }

        $scope.onMediaApiReady = function (api) {
          loadingMedia.api = api;
          loadingMedia.element = loadingMedia.api.getElement();
          setMedia(loadingMedia, loadingMedia.url);
        };

        $scope.onMediaLoaded = function () {
          mediaUtil.showMedia(loadingMedia.element).then(function (media) {
            currentMedia = $angular.copy(loadingMedia);
            loadingMedia = undefined;
            playMedia();
          });
        };

        $scope.updateCheckpoint = function (newCheckpoint) {
          clearCheckpoint().then(function () {
            checkpoint = newCheckpoint;
            $scope.checkpointHtml = '';

            if (!checkpoint) {
              return;
            }

            if (checkpoint.html) {
              setCheckpointHtml(checkpoint.html);
              return;
            }

            var content = checkpoint.content ? checkpoint.content : checkpoint;
            content.type = getContentType(content.type);
            getContentUrl(content).then(function (url) {
              content.url = url;
              var mediaConfig = mediaUtil.getMediaConfig(content);

              if (!mediaConfig) {
                return;
              }

              loadMedia(content, mediaConfig);
            });
          });
        };

        function clearCheckpoint() {
          var promise = $q.defer();
          $scope.checkpointHtml = '';
          pauseMedia();
          removeMediaItem(currentMedia).then(function () {
            checkpoint = undefined;
            currentMedia = undefined;
            loadingMedia = undefined;
            mediaElement = undefined;
            promise.resolve();
          });
          return promise.promise;
        }

        $scope.$on('$destroy', function () {
          clearCheckpoint().then(function () {
            for (var i = 0; i < subscribers.length; i++) {
              subscribers[i].dispose();
            }

            subscribers = [];
            checkpointManager.reset();
          });
        });
        checkpointManager.initialize();
        subscribers.push(checkpointManager.subscribeToCheckpointResult(onCheckpointResultUpdate));
      }]
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctIframe', ["SYSTEM_DATA", "domUtil", function (SYSTEM_DATA, domUtil) {
    return {
      restrict: 'E',
      template: SYSTEM_DATA.IFRAME_TEMPLATE,
      scope: {
        onApiReady: '&',
        onMediaLoaded: '&',
        onMediaError: '&'
      },
      controller: ["$scope", "$element", function ($scope, $element) {
        var ID_PREFIX = 'ctIframe-';
        var EVENT = {
          ERROR: 'error',
          LOAD: 'load'
        };
        var iframeElement = domUtil.getElement($element, 'iframe');
        iframeElement.on(EVENT.LOAD, onLoaded);
        iframeElement.on(EVENT.ERROR, onError);
        $scope.$on('$destroy', dispose);
        $scope.onApiReady({
          api: {
            id: ID_PREFIX + new Date().getTime(),
            setMedia: setMedia,
            dispose: dispose,
            getElement: getElement
          }
        });

        function getElement() {
          return $element;
        }

        function dispose() {
          if (iframeElement) {
            iframeElement.off(EVENT.LOAD, onLoaded);
            iframeElement.off(EVENT.ERROR, onError);
            iframeElement.remove();
            iframeElement = undefined;
          }

          $element.remove();
        }

        function setMedia(media) {
          iframeElement.attr('src', media);
        }

        function onLoaded() {
          $scope.onMediaLoaded();
        }

        function onError(err) {
          $scope.onMediaError({
            error: err
          });
        }
      }]
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctImage', ["SYSTEM_DATA", "domUtil", function (SYSTEM_DATA, domUtil) {
    return {
      restrict: 'E',
      template: SYSTEM_DATA.BACKGROUND_IMAGE_TEMPLATE,
      scope: {
        onApiReady: '&',
        onMediaLoaded: '&',
        onMediaError: '&',
        source: '='
      },
      link: function link(scope) {
        scope.$watch('source', function (newValue) {
          scope.updateSource(newValue);
        });
      },
      controller: ["$scope", "$element", function ($scope, $element) {
        var imgElement = domUtil.getElement($element, 'img');
        imgElement.on('load', onLoaded);
        imgElement.on('error', onError);
        $scope.$on('$destroy', dispose);
        $scope.onApiReady({
          api: {
            id: 'ctImage-' + new Date().getTime(),
            setMedia: setMedia,
            dispose: dispose,
            getElement: getElement
          }
        });
        $scope.updateSource = setMedia;

        function getElement() {
          return $element;
        }

        function dispose() {
          if (imgElement) {
            imgElement.off('load', onLoaded);
            imgElement.off('error', onError);
            imgElement.remove();
            imgElement = undefined;
          }

          $element.remove();
        }

        function setMedia(media) {
          imgElement.attr('src', media);
        }

        function onLoaded() {
          $scope.onMediaLoaded();
        }

        function onError(err) {
          $scope.onMediaError({
            error: err
          });
        }
      }]
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctPixelOrbiter', function () {
    return {
      restrict: 'A',
      scope: {
        timer: '<',
        shiftOffset: '<'
      },
      transclude: true,
      template: '<div class="pixel-orbiter" ng-style="pixelOrbitStyle"><ng-transclude class="pixel-orbiter-transclude"></ng-transclude></div>',
      controller: ["$scope", "$timeout", "textUtil", "Playlist", "configurationManager", "logManager", "SYSTEM_DATA", function ($scope, $timeout, textUtil, Playlist, configurationManager, logManager, SYSTEM_DATA) {
        var doOrbitTimerPromise;
        var maxOffset;
        var currentShift;
        $scope.pixelOrbitStyle = {};
        $scope.$watch('timer', function (newvalue, oldvalue) {
          if (newvalue != oldvalue) {
            doOrbit();
          }
        });
        $scope.$watch('shiftOffset', function (newvalue, oldvalue) {
          if (newvalue != oldvalue) {
            maxOffset = newvalue;
            generatePixelShiftRule();
            doOrbit();
          }
        });

        function init() {
          maxOffset = SYSTEM_DATA.PIXEL_ORBITER_OFFSET;
          generatePixelShiftRule();
          doOrbit();
        }

        function startTimer() {
          cancelTimer();
          var timeout = Math.max($scope.timer || SYSTEM_DATA.PIXEL_ORBITER_DEFAULT_TIMER, SYSTEM_DATA.PIXEL_ORBITER_MIN_TIMER);
          doOrbitTimerPromise = $timeout(doOrbit, timeout);
        }

        function cancelTimer() {
          if (doOrbitTimerPromise) {
            $timeout.cancel(doOrbitTimerPromise);
            doOrbitTimerPromise = undefined;
          }
        }

        function generatePixelShiftRule() {
          var shiftRule = [];

          var addRule = function addRule(index, offset) {
            shiftRule.splice(index, 0, textUtil.formatText(SYSTEM_DATA.PIXEL_ORBITER_BORDER_WIDTH, offset));
          };

          for (var i = 0; i < maxOffset; i++) {
            addRule(i, [i, 0]);
            addRule(2 * i + 1, [maxOffset - i, 0]);
            addRule(3 * i + 2, [0, i]);
            addRule(4 * i + 3, [0, maxOffset - i]);
          }

          currentShift = new Playlist(shiftRule, true);
        }

        function doOrbit() {
          cancelTimer();
          $scope.pixelOrbitStyle['border-width'] = currentShift.nextItem();

          if (configurationManager.isEditing()) {
            logManager.debug('Pixel Orbiter turned off due to editing mode');
            return;
          }

          startTimer();
        }

        init();
      }]
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.directive('ctVideo', ["$q", "SYSTEM_DATA", "dataUtil", "domUtil", function ($q, SYSTEM_DATA, dataUtil, domUtil) {
    return {
      restrict: 'E',
      template: SYSTEM_DATA.BACKGROUND_VIDEO_TEMPLATE,
      scope: {
        onApiReady: '&',
        onMediaLoaded: '&',
        onMediaError: '&',
        onMediaEnded: '&'
      },
      controller: ["$scope", "$element", function ($scope, $element) {
        var id = 'ctVideo-' + new Date().getTime();
        var videoElement = domUtil.getElement($element, 'video');
        videoElement.attr('id', id);
        videoElement.on('loadeddata', onLoadedData);
        videoElement.on('error', onError);
        videoElement.on('ended', onEnded);
        $scope.$on('$destroy', dispose);
        $scope.onApiReady({
          api: {
            id: id,
            setMedia: setMedia,
            dispose: dispose,
            getElement: getElement,
            play: play,
            pause: pause,
            mute: muteAudio
          }
        });

        function getElement() {
          return $element;
        }

        function setMedia(media, options) {
          options = options || {};
          var mute = options.mute;

          if (dataUtil.isNullOrUndefined(mute)) {
            mute = true;
          }

          muteAudio(mute);

          if (options.controls) {
            videoElement.attr('controls', '');
          }

          videoElement.attr('src', media);
          videoElement[0].load();
        }

        function onLoadedData() {
          $scope.onMediaLoaded();
        }

        function onError() {
          $scope.onMediaError({
            error: videoElement[0].error
          });
        }

        function onEnded() {
          $scope.onMediaEnded();
        }

        function play() {
          videoElement[0].play();
        }

        function pause() {
          videoElement[0].pause();
        }

        function dispose() {
          if (videoElement) {
            videoElement.off('loadeddata', onLoadedData);
            videoElement.off('error', onError);
            videoElement.off('ended', onEnded);
            videoElement.remove();
            videoElement = undefined;
          }

          $element.remove();
        }

        function muteAudio(mute) {
          videoElement[0].muted = mute;
        }
      }]
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('appCoreFactory', ["$window", function ($window) {
    var core;

    function getCore() {
      core = core || getCoreFrameworkService();
      return core;
    }

    function getCoreFrameworkService() {
      var core;

      try {
        core = $window.top.$asCoreFrameworkService;
      } catch (err) {
        $window.console.log('Unable to retrieve app\'s core framework service', err);
      }

      return core;
    }

    return {
      getCore: getCore
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('calendarProviderFactory', function (logManager, MockProvider, AppspaceProvider, GoogleProvider, Office365Provider, Office365AdminProvider, UserBasedProvider, CustomProvider, DemoProvider) {
    var providers = {};
    var configProviders = {
      'appspace': AppspaceProvider,
      'google': GoogleProvider,
      'office365': Office365Provider,
      'office365admin': Office365AdminProvider,
      'base': UserBasedProvider,
      'custom': CustomProvider,
      'demo': DemoProvider
    };

    function getProvider(config, useMock) {
      var type = (config || {}).type;

      if (!type) {
        if (!useMock) {
          logManager.info('Provider NOT found.');
          return;
        }

        type = 'base';
      }

      type = type.toLowerCase();
      var providerType = configProviders[type];

      if (!providerType) {
        logManager.info('Provider type [{0}] NOT found.', type);
        return;
      }

      var provider = findProvider(type, providerType, useMock, config);
      logManager.info('Provider type [{0}] retrieved.', provider.type);
      return provider;
    }

    function findProvider(type, Provider, useMock, config) {
      var provider = retrieveProvider(type, Provider, undefined, config);

      if (!useMock) {
        return provider;
      }

      return retrieveProvider('mock.' + type, MockProvider, provider, config);
    }

    function retrieveProvider(type, Provider, base, config) {
      if (providers[type]) {
        return providers[type];
      }

      var provider = new Provider(base, config);
      provider.type = type;
      providers[type] = provider;
      logManager.info('Provider type [{0}] created.', provider.type);
      return providers[type];
    }

    function clearProviders() {
      for (var key in providers) {
        providers[key].dispose();
      }

      providers = {};
    }

    return {
      getProvider: getProvider,
      clearProviders: clearProviders
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('cardApiFactory', ["$window", function ($window) {
    var cardApi;

    function getApi() {
      cardApi = cardApi || $window.$cardApi;
      return cardApi;
    }

    return {
      getApi: getApi
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('loggerFactory', ["AppLogger", "ConsoleLogger", function (AppLogger, ConsoleLogger) {
    // sequence is important
    var loggers = [AppLogger, ConsoleLogger];
    var logger;

    function getLogger() {
      if (logger) {
        return logger;
      }

      for (var i = 0; i < loggers.length; i++) {
        var Logger = loggers[i];

        if (Logger.isAvailable()) {
          logger = new Logger();
          break;
        }
      }

      return logger;
    }

    return {
      getLogger: getLogger
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('storageFactory', ["logManager", "AppStorage", "LocalStorage", "MemoryStorage", function (logManager, AppStorage, LocalStorage, MemoryStorage) {
    // sequence is important
    var storages = [AppStorage, LocalStorage, MemoryStorage];
    var storage;

    function getStorage() {
      if (storage) {
        return storage;
      }

      for (var i = 0; i < storages.length; i++) {
        var Storage = storages[i];

        if (!Storage.isAvailable()) {
          continue;
        }

        storage = new Storage();
        logManager.info('Setting the storage to use [{0}]', storage.type);
        break;
      }

      return storage;
    }

    return {
      getStorage: getStorage
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('storageHelperFactory', ["$window", function ($window) {
    var storageHelper;

    function get() {
      storageHelper = storageHelper || getStorageHelper();
      return storageHelper;
    }

    function getStorageHelper() {
      return $window.appspace ? $window.appspace.StorageHelper : undefined;
    }

    return {
      get: get
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('AppLogger', ["$window", "appCoreFactory", function ($window, appCoreFactory) {
    var loggerName = 'appspace.content.cards';
    var logger;

    function AppLogger() {
      var services = appCoreFactory.getCore().getServices();
      logger = services.core.logService;

      this.debug = function (message) {
        logger.debug(loggerName, message);
      };

      this.warn = function (message) {
        logger.warn(loggerName, message);
      };

      this.error = function (message) {
        logger.error(loggerName, message);
      };

      this.info = function (message) {
        logger.info(loggerName, message);
      };
    } // static methods


    AppLogger.isAvailable = function () {
      var core = appCoreFactory.getCore();

      if (!core || !core.getServices) {
        return false;
      }

      var services = core.getServices();

      if (services && services.core && services.core.logService) {
        return true;
      }

      return false;
    }; // Return the constructor for the class


    return AppLogger;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('ConsoleLogger', ["$window", "timeUtil", "textUtil", function ($window, timeUtil, textUtil) {
    var loggerFormat = '[{0} appspace.scheduleboard {1}] {2}';
    var logger;

    function ConsoleLogger() {
      logger = $window.console;

      function log(type, message) {
        var text = textUtil.formatText(loggerFormat, [timeUtil.getDateTimeText(new Date()), type, message]);
        logger[type](text);
      }

      this.debug = function (message) {
        log('debug', message);
      };

      this.warn = function (message) {
        log('warn', message);
      };

      this.error = function (message) {
        log('error', message);
      };

      this.info = function (message) {
        log('info', message);
      };
    } // static methods


    ConsoleLogger.isAvailable = function () {
      if ($window.console) {
        return true;
      }

      return false;
    }; // Return the constructor for the class


    return ConsoleLogger;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('backgroundDataManager', function (configurationManager, DataBehavior, MODEL_INPUT_KEYS, SYSTEM_DATA) {
    var DEFAULT_BACKGROUND_COLOR = '#ffffff';
    var backgroundMediaObservable = new DataBehavior([]);

    this.getBackgroundColor = function () {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.BACKGROUND_COLOR, DEFAULT_BACKGROUND_COLOR);
    };

    this.getBackgroundMedia = function () {
      return backgroundMediaObservable.subject;
    };

    this.getBackgroundMaskColor = function () {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.BACKGROUND_MASK_COLOR, SYSTEM_DATA.DEFAULT_MASK_COLOR);
    };

    function onBackgroundMediaChanges(media) {
      media = media || [];
      var result = [];

      for (var i = 0; i < media.length; i++) {
        var mediaItem = media[i];
        result.push(mediaItem.path);
      }

      backgroundMediaObservable.onChange(result);
    }

    configurationManager.getInputObservable(MODEL_INPUT_KEYS.BACKGROUND_MEDIA, []).subscribe(onBackgroundMediaChanges);
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('calendarDataManager', function ($q, $filter, $timeout, $injector, DataBehavior, ScheduleError, calendarProviderFactory, logManager, configurationManager, roomDataSetManager, dataConfigurationManager, displayConfigurationManager, roomUtil, textUtil, dataUtil, timeUtil, eventUtil, scheduleUtil, STATE, SYSTEM_DATA, SCHEDULE_ERROR, CUSTOM_DATA_KEY, MODEL_INPUT_KEYS, BOOKING_ACTION) {
    var formatText = textUtil.formatText;
    var calendarProvider;
    var currentRoomIds;
    var currentRoomsMapping = [];
    var currentAuthenticationData;
    var subscribers = [];
    var rooms = [];
    var providerBuildings = [];
    var roomsLocation = [];
    var roomsName = [];
    var roomsNumber = [];
    var roomsFacilities = [];
    var roomsFloorName = [];
    var refreshEventTimeoutPromise;
    var retryRefreshRoomsPromise;
    var isReadyPromise = $q.defer();
    var isRoomsMappingReadyPromise = $q.defer();
    var roomsUpdateTracker = {};
    var refreshRoomsTracker = {
      failCount: 0
    };
    var observables = {
      rooms: new DataBehavior(),
      roomIds: new DataBehavior(),
      providerRoomIds: new DataBehavior(),
      configuration: new DataBehavior(),
      action: new DataBehavior()
    };
    var roomEventsObservables = {};
    var eventRetrievedCallbacks = {};
    var stateObservable = new DataBehavior(STATE.INITIALIZING);
    var dataRange = {};
    var timeBlockInterval = SYSTEM_DATA.TIME_BLOCK;
    var INSTANT_EVENT_CHECK_IN_FORMAT = '[instant-checkin:{0}Z-{1}]';
    var EVENT_CHECK_IN_FORMAT = '[checkin:{0}Z-{1}]';
    var EVENT_CHECK_IN_DATE_FORMAT = 'YYYY-MM-DDTHH:mm:ss';
    var checkEventMaxTimeout = 20000;
    var retryCheckTimeout = 1000;
    var refreshDataTimeout = 60000;
    var BOOK_LIMIT_IN_MILLISECONDS = 21600000; // 6-hours

    var START_BUFFER_IN_MINUTES = -5; // -5 minutes

    var bookLimit = BOOK_LIMIT_IN_MILLISECONDS;
    var DEFAULT_ROOM_MAPPING_HEADER = [SYSTEM_DATA.ROOM_ID_MAPPING_HEADER, SYSTEM_DATA.ROOM_NAME_MAPPING_HEADER];
    var providerRoomIds = [];
    var areRoomsCached = false;
    var areCachedRoomsRefreshed = false;
    var roomEventsRetrievalCount = 0;
    var areRoomsProcessedPromise = $q.defer();

    this.isReady = function () {
      return isReadyPromise.promise;
    };

    this.subscribeToConfigurationChanged = function (callback) {
      return observables.configuration.subject.subscribe(callback);
    };

    this.resetRoomEventData = function () {
      for (var roomId in roomEventsObservables) {
        roomEventsObservables[roomId].subject.dispose();
      }

      roomEventsObservables = {};
    };

    this.isEventRequiresCheckIn = function (event) {
      return calendarProvider && calendarProvider.isEventInCheckInState ? calendarProvider.isEventInCheckInState(event) : undefined;
    };

    this.reset = function () {
      this.resetRoomEventData(); // Notify that rooms have been cleared

      rooms = [];
      updateBuildings(true);
      providerRoomIds = [];
      observables.roomIds.onChange([]);
      observables.providerRoomIds.onChange(providerRoomIds);
      updateRoomsMapping(true);
      stopRefreshRoomEvents();

      for (var i = 0; i < subscribers.length; i++) {
        var subscriber = subscribers[i];

        if (!subscriber || !subscriber.dispose) {
          continue;
        }

        subscriber.dispose();
      }

      subscribers = [];
      isReadyPromise = $q.defer();
      calendarProvider = undefined;
      updateShowCheckInInput(); // reset all observables

      for (var key in observables) {
        observables[key].subject.dispose();
        observables[key] = new DataBehavior();
      }
    };

    this.initialize = initialize;

    this.createEvent = function (room, title, start, end) {
      if (!start || !end) {
        return;
      }

      logMessage('info', 'Processing BOOK EVENT with title {0}, ending at {1}.', [title, end]);
      var now = new Date().getTime();
      var metadata;
      start = timeUtil.resetDate(start);
      end = timeUtil.resetDate(end); // event already started, check in automatically

      if (now >= start.getTime()) {
        var checkInValue = textUtil.formatText(INSTANT_EVENT_CHECK_IN_FORMAT, [timeUtil.getUtcStringFromDate(start, EVENT_CHECK_IN_DATE_FORMAT), eventUtil.generateInstantEventUniqueKey(start)]);
        metadata = {
          checkininfo: checkInValue
        };
      }

      var defer = $q.defer();
      createEventAndVerify(room, title, start, end, metadata).then(function (res) {
        logMessage('info', 'Success BOOK EVENT with title {0}, ending at {1}.', [title, end]);
        onBookingActionExecuted(BOOKING_ACTION.BOOK, room, res);
        defer.resolve(res);
      }, function (err) {
        logMessage('error', 'Failed BOOK EVENT with error {0}.', JSON.stringify(err));
        defer.reject(err);
      });
      return defer.promise;
    };

    this.getRoomById = function (id) {
      return $filter('filter')(rooms, function (room) {
        return room.id === id;
      })[0];
    };

    this.checkIn = function (room, event) {
      if (!room || !event || !event.start) {
        return;
      }

      logMessage('info', 'Processing CHECK-IN event with title {0} in room {1}.', [event.title, room.id]);
      var checkInValue = textUtil.formatText(EVENT_CHECK_IN_FORMAT, [timeUtil.getUtcStringFromDate(new Date(), EVENT_CHECK_IN_DATE_FORMAT), eventUtil.generateEventUniqueKey(event.id)]);
      var data = {
        metadata: {
          checkininfo: checkInValue
        }
      };
      var currentTime = new Date();

      if (currentTime.getTime() < event.start.getTime()) {
        // modify event start time if it's pre-check in
        data.start = currentTime;
      }

      var defer = $q.defer();
      updateEventAndVerify(room, event, data, BOOKING_ACTION.CHECK_IN).then(function (res) {
        logMessage('info', 'Success CHECK-IN event with title {0} in room {1}.', [event.title, room.id]);
        onBookingActionExecuted(BOOKING_ACTION.CHECK_IN, room, res);
        defer.resolve(res);
      }, function (err) {
        logMessage('error', 'Failed CHECK-IN event with error {0}.', JSON.stringify(err));
        defer.reject(err);
      });
      return defer.promise;
    };

    this.end = function (room, event) {
      if (!event) {
        return;
      }

      logMessage('info', 'Processing END EVENT with title {0} in room {1}.', [event.title, room.id]);
      var defer = $q.defer();
      updateEventAndVerify(room, event, {
        end: timeUtil.resetDate(new Date())
      }, BOOKING_ACTION.END).then(function (res) {
        logMessage('info', 'Success END EVENT with title {0} in room {1}.', [event.title, room.id]);
        onBookingActionExecuted(BOOKING_ACTION.END, room, res);
        defer.resolve(res);
      }, function (err) {
        logMessage('error', 'Failed END EVENT with error {0}.', JSON.stringify(err));
        defer.reject(err);
      });
      return defer.promise;
    };

    this.extend = function (room, event, end) {
      if (!event || !end) {
        return;
      }

      logMessage('info', 'Processing EXTEND EVENT with title {0} in room {1}, ending at {2}.', [event.title, room.id, end]);
      var defer = $q.defer();
      updateEventAndVerify(room, event, {
        end: timeUtil.resetDate(end)
      }, BOOKING_ACTION.EXTEND).then(function (res) {
        logMessage('info', 'Success EXTEND EVENT with title {0} in room {1}, ending at {2}.', [event.title, room.id, end]);
        onBookingActionExecuted(BOOKING_ACTION.EXTEND, room, res);
        defer.resolve(res);
      }, function (err) {
        logMessage('error', 'Failed EXTEND EVENT with error {0}.', JSON.stringify(err));
        defer.reject(err);
      });
      return defer.promise;
    };

    this.rename = function (room, event, title) {
      if (!event || !title) {
        return;
      }

      logMessage('info', 'Processing RENAME EVENT with new title {0} in room {1}.', [title, room.id]);
      var defer = $q.defer();
      updateEventAndVerify(room, event, {
        title: title,
        metadata: event.metadata
      }, BOOKING_ACTION.RENAME).then(function (res) {
        logMessage('info', 'Success RENAME EVENT with new title {0} in room {1}.', [title, room.id]);
        defer.resolve(res);
      }, function (err) {
        logMessage('error', 'Failed RENAME EVENT with error {0}.', JSON.stringify(err));
        defer.reject(err);
      });
      return defer.promise;
    };

    this.getRoomsObservable = function () {
      return observables.rooms.subject;
    };

    this.subscribeToRoomIdsChanged = function (callback) {
      return observables.roomIds.subject.subscribe(callback);
    };

    this.subscribeToProviderRoomIdsChanged = function (callback) {
      return observables.providerRoomIds.subject.subscribe(callback);
    };

    this.subscribeToStateChanged = function (callback) {
      return stateObservable.subject.subscribe(callback);
    };

    this.subscribeToRoomEvent = function (room, eventRefreshedCallback, eventRetrievedCallback) {
      if (!room || dataUtil.isNullOrUndefined(room.id)) {
        return;
      }

      if (!roomEventsObservables[room.id]) {
        roomEventsObservables[room.id] = new DataBehavior();
        updateRoomEvents(room);
        startRefreshRoomEvents();
      }

      if (eventRetrievedCallback) {
        eventRetrievedCallbacks[room.id] = eventRetrievedCallback;
      }

      return roomEventsObservables[room.id].subject.subscribe(eventRefreshedCallback);
    };

    this.subscribeToActionExecuted = function (callback) {
      return observables.action.subject.subscribe(callback);
    };

    this.getRoomsAndEvent = function () {
      var promise = $q.defer();
      var roomsWithEvents = [];

      var updateRoomWithEvents = function updateRoomWithEvents(room) {
        var roomEventPromise = $q.defer();

        var onEventsRetrieved = function (events) {
          roomsWithEvents.push({
            room: this,
            events: events
          });
          roomEventPromise.resolve();
        }.bind(room);

        var onEventsRetrievalFailed = function onEventsRetrievalFailed() {
          onEventsRetrieved([]);
        };

        getCurrentEvents(room, dataRange.start, dataRange.end).then(onEventsRetrieved, onEventsRetrievalFailed);
        return roomEventPromise.promise;
      };

      var onRoomsRetrieved = function onRoomsRetrieved(roomsData) {
        rooms = roomsData || [];
        updateBuildings();
        var promises = [];

        for (var i = 0; i < rooms.length; i++) {
          promises.push(updateRoomWithEvents(rooms[i]));
        }

        $q.allSettled(promises).then(function () {
          promise.resolve(roomsWithEvents);
        });
      };

      calendarProvider.getRooms().then(onRoomsRetrieved);
      return promise.promise;
    };

    this.isPreview = function () {
      return Boolean(calendarProvider && calendarProvider.isPreview);
    };

    this.getMapRoomIdentifier = function () {
      return (calendarProvider || {}).mapRoomIdentifier;
    };

    this.supportBookingUntilEndOfDay = function () {
      return Boolean(calendarProvider && calendarProvider.supportBookingUntilEndOfDay);
    };

    this.getIgnoreCheckInConfiguration = ignoreCheckInConfiguration;

    function ignoreCheckInConfiguration() {
      return Boolean(calendarProvider && calendarProvider.ignoreCheckInConfiguration);
    }

    function updateBuildings(reset) {
      providerBuildings = [];

      if (reset || !rooms.length) {
        return;
      }

      for (var i = 0; i < rooms.length; i++) {
        var providerBuilding = rooms[i].providerBuildingName;

        if (!providerBuilding || dataUtil.includesValue(providerBuildings, providerBuilding)) {
          continue;
        }

        providerBuildings.push(providerBuilding);
      }
    }

    function onBookingActionExecuted(action, room, event) {
      observables.action.onChange({
        action: action,
        room: room,
        event: event
      });
    }

    function logMessage(level, message, params) {
      var formattedMessage = formatText(message, params);
      logManager[level](formattedMessage);
    }

    function getCurrentEvents(room) {
      return calendarProvider.getEvents(room, getStartTime(dataRange.start), dataRange.end);
    }

    function getStartTime(start) {
      return timeUtil.addMinutesAndReset(start, START_BUFFER_IN_MINUTES);
    }

    function updateRoomEvents(room) {
      var roomUpdateTracker = getRoomUpdateTracker(room);
      var delay = scheduleUtil.getUpdateDelayTimeout(roomUpdateTracker.failCount, roomUpdateTracker.lastFailure);

      if (delay.timeout === -1) {
        logManager.warn('Skip update for ' + room.name + ' (id:' + room.id + ')' + ', next request:' + getNextRequest(delay) + ', last failure:' + getLastFailure(roomUpdateTracker) + ', last success:' + roomUpdateTracker.lastSuccess.toString() + ', fail count:' + roomUpdateTracker.failCount);
        return $q.reject();
      }

      var promise = $q.defer();

      var executeGetCurrentEvents = function executeGetCurrentEvents() {
        getCurrentEvents(room).then(function (getEventPromise, events) {
          registerUpdateSuccess(this);
          onEventsRetrieved(this, events);
          getEventPromise.resolve(events);
        }.bind(room, promise), function (getEventPromise, err) {
          onEventsRetrieved(this, []);
          logManager.error('Unable to retrieve events for room' + this.name + ' (id:' + this.id + ')');
          registerUpdateFailure(this);
          getEventPromise.reject(err);
        }.bind(room, promise));
      };

      if (delay.timeout) {
        logManager.debug('Requesting update for ' + room.name + ' in ' + delay.timeout + ' ms');
      }

      $timeout(executeGetCurrentEvents, delay.timeout);
      return promise.promise;
    }

    function getRoomUpdateTracker(room) {
      // create entry if it's not there
      roomsUpdateTracker[room.id] = roomsUpdateTracker[room.id] || {
        failCount: 0,
        lastSuccess: new Date()
      };
      return roomsUpdateTracker[room.id];
    }

    function registerUpdateFailure(room) {
      var updateTracker = getRoomUpdateTracker(room);
      updateTracker.lastFailure = new Date();
      updateTracker.failCount++;
    }

    function registerUpdateSuccess(room) {
      var updateTracker = getRoomUpdateTracker(room);
      updateTracker.lastSuccess = new Date();
      updateTracker.failCount = 0;
    }

    function getCurrentEvent(currentTime, events) {
      return $filter('filter')(events, function (event) {
        return currentTime >= event.start.getTime() && currentTime < event.end.getTime();
      })[0];
    }

    function checkAutoCancelEvent(room, events) {
      if (ignoreCheckInConfiguration() || !dataConfigurationManager.getCheckInEnabled()) {
        return $q.resolve();
      }

      var currentTime = new Date().getTime();
      var currentEvent = getCurrentEvent(currentTime, events); // don't cancel if event has been checked in
      // or difference between current & event start is less than the limit

      if (!currentEvent || currentEvent.isCheckedIn || currentTime - currentEvent.start.getTime() < SYSTEM_DATA.CHECK_IN_LIMIT) {
        return $q.resolve();
      }

      var promise = $q.defer();
      calendarProvider.deleteEvent(currentEvent).then(function (deletedEvent) {
        verifyUpdatedEvent(room, deletedEvent, false).then(function (res) {
          onBookingActionExecuted(BOOKING_ACTION.AUTO_CANCEL, room, res);
          promise.resolve(res);
        }, promise.reject);
      }, promise.reject);
      return promise.promise;
    }

    function refreshRoomEvents() {
      if (rooms.length == 0) {
        return;
      }

      var now = new Date(); // if date changes, regenerate the data range and stop refresh event
      // we're expecting the consumer to restart the process

      if (!timeUtil.isSameDate(now, dataRange.start)) {
        updateDataRange();
      }

      var promises = [];

      for (var i = 0; i < rooms.length; i++) {
        var promise = $q.defer();
        var room = rooms[i]; // the 1st argument of bind is for 'this'. subsequent arguments will be send as parameters
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind
        // events parameter in the resolve method is the resolve object from updateRoomEvents

        updateRoomEvents(room).then(function (roomPromise, events) {
          checkAutoCancelEvent(this, events).then(roomPromise.resolve, roomPromise.resolve);
        }.bind(room, promise), promise.reject);
        promises.push(promise.promise);
      } // continue the cycle regardless of promise status (rejected/resolved)
      // for cases where any of the rooms failed to get events


      $q.allSettled(promises)["finally"](startRefreshRoomEvents);
    }

    function startRefreshRoomEvents() {
      stopRefreshRoomEvents();
      refreshEventTimeoutPromise = $timeout(refreshRoomEvents, refreshDataTimeout);
    }

    function stopRefreshRoomEvents() {
      $timeout.cancel(refreshEventTimeoutPromise);
      refreshEventTimeoutPromise = undefined;
    }

    function getRoomsInfo(rooms) {
      if (!calendarProvider || !calendarProvider.getRoomsInfo) {
        return $q.resolve(rooms);
      }

      var promise = $q.defer();
      calendarProvider.getRoomsInfo(rooms).then(function (data) {
        if (!data || dataUtil.isNotArrayOrEmpty(data)) {
          return;
        }

        rooms = data;
      }, $angular.noop)["finally"](function () {
        promise.resolve(rooms);
      });
      return promise.promise;
    }

    function onEventsRetrieved(room, events) {
      if (!roomEventsObservables[room.id]) {
        return;
      }

      var now = new Date().getTime(); // only get events that have not ended

      events = $filter('filter')(events, function (event) {
        return event.end >= getStartTime(now);
      }); // set all the events of the room to checked-in state in case the room is read-only
      // in order to tell schedule table to not show check-in button

      if (room.isReadOnly) {
        for (var i = 0; i < events.length; i++) {
          events[i].isCheckedIn = true;
        }
      }

      var data = {
        room: room,
        events: events
      };
      roomEventsObservables[room.id].onChange(data);
      var retrievedCallback = eventRetrievedCallbacks[room.id];

      if (retrievedCallback) {
        retrievedCallback(data);
      }

      roomEventsRetrievalCount++; // First round of events retrieval is not done

      if (roomEventsRetrievalCount < rooms.length || !areRoomsCached || areCachedRoomsRefreshed) {
        return;
      }

      areCachedRoomsRefreshed = true;
      refreshRooms(true);
    }

    function processCachedRooms(cachedRooms) {
      rooms = [];
      updateBuildings();

      for (var key in cachedRooms) {
        var room = cachedRooms[key];

        if (!room) {
          continue;
        }

        rooms.push(roomUtil.createRoom(room));
      }

      rooms = $filter('orderBy')(rooms, 'name');
      areRoomsProcessedPromise.resolve();
      bindRoomsToDataSet();
    }

    function updateShowCheckInInput() {
      configurationManager.updateInput(MODEL_INPUT_KEYS.IS_CHECK_IN_CONFIGURATION_SUPPORTED, !ignoreCheckInConfiguration());
    }

    function onCustomModelUpdated(customData) {
      customData = customData || {};
      isReadyPromise.resolve();
      updateDataRange();
      var authenticationData = customData[CUSTOM_DATA_KEY.AUTHENTICATION_DATA];
      var roomIds = customData[CUSTOM_DATA_KEY.ROOM_IDS] || []; // no changes to authentication data & room ids, don't do anything

      if (dataUtil.isObjectEqual(currentAuthenticationData, authenticationData) && dataUtil.isObjectEqual(currentRoomIds, roomIds)) {
        return;
      } // if we already have a provider, dispose first


      if (calendarProvider) {
        calendarProvider.dispose();
      }

      var providerType;
      var useMockAuthenticationData;

      if (authenticationData) {
        currentAuthenticationData = authenticationData;
        var provider = currentAuthenticationData.provider || {};
        providerType = provider.type;
        useMockAuthenticationData = provider.useMockAuthenticationData;
      }

      currentRoomIds = roomIds;
      areRoomsCached = false;
      areCachedRoomsRefreshed = false;
      roomEventsRetrievalCount = 0;
      areRoomsProcessedPromise = $q.defer(); // Reset rooms so that after logging out and then reaunthenticating,
      // schedule board doesn't retain the previous rooms (in editing mode)

      if (configurationManager.isEditing() && !currentRoomIds.length) {
        rooms = [];
        updateBuildings(true);
      }

      calendarProvider = calendarProviderFactory.getProvider({
        type: providerType
      }, configurationManager.isEditing() && !useMockAuthenticationData || configurationManager.isScreenshot());

      if (!calendarProvider) {
        stateObservable.onChange(STATE.UNAUTHENTICATED);
        return;
      }

      calendarProvider.initialize();
      updateShowCheckInInput();
      observables.roomIds.onChange(currentRoomIds);
      updateRoomsMapping();
      stateObservable.onChange(!currentRoomIds.length && !configurationManager.isEditing() && !useMockAuthenticationData ? STATE.UNCONFIGURED : STATE.INITIALIZING);
      var storageManager = $injector.get('storageManager');
      storageManager.isReady().then(function () {
        var cachedRooms = storageManager.getRooms();
        areRoomsCached = Boolean(cachedRooms && !dataUtil.isObjectEmpty(cachedRooms)); // Proceed with refreshing rooms if we don't have any cached rooms

        if (!areRoomsCached) {
          refreshRooms();
          return;
        }

        processCachedRooms(cachedRooms);
      });
    }

    function getRoomMappingById(id) {
      return !currentRoomsMapping.length ? undefined : $filter('filter')(currentRoomsMapping, function (mapping) {
        return mapping[0] === id;
      })[0];
    }

    function updateRoomsMappingInput(value) {
      configurationManager.updateInput(MODEL_INPUT_KEYS.ROOMS_LOCATION, value);
    }

    function isRoomsMappingReady() {
      return isRoomsMappingReadyPromise.promise;
    }

    function updateRoomsMapping(reset) {
      isRoomsMappingReady().then(function () {
        // We need to reset rooms
        if (reset) {
          currentRoomsMapping = [];
          updateRoomsMappingInput(currentRoomsMapping);
          return;
        } // Don't do anything if there are no rooms configured yet


        if (!providerRoomIds || !providerRoomIds.length) {
          return;
        }

        var newMapping = []; // Get current header

        var header = currentRoomsMapping[0]; // Use default header if there's no current header

        newMapping.push(header && header.length ? header : DEFAULT_ROOM_MAPPING_HEADER);

        for (var i = 0; i < providerRoomIds.length; i++) {
          var roomId = providerRoomIds[i];
          var roomMapping = getRoomMappingById(roomId);
          newMapping.push(roomMapping || [roomId]);
        }

        updateRoomsMappingInput(newMapping);
      });
    }

    function getNextRequest(delay) {
      return (delay.nextRequest || '').toString();
    }

    function getLastFailure(tracker) {
      return (tracker.lastFailure || '').toString();
    }

    function sortRoomsByIdentifier(a, b) {
      return dataUtil.compareValues(a.number, b.number);
    }

    var onRoomsDataRetrieved = function onRoomsDataRetrieved(roomsData) {
      rooms = $filter('orderBy')(roomsData, 'name');
      updateBuildings();
      bindRoomsToDataSet();
    };

    function refreshRooms(forceTransparentUpdate) {
      cancelRetryRefreshRooms();
      var delay = scheduleUtil.getUpdateDelayTimeout(refreshRoomsTracker.failCount, refreshRoomsTracker.lastFailure);

      if (delay.timeout === -1) {
        logManager.warn('Skip refresh rooms info. ' + ', next request:' + getNextRequest(delay) + ', last failure:' + getLastFailure(refreshRoomsTracker) + ', fail count:' + refreshRoomsTracker.failCount);
        retryRefreshRooms();
        return;
      }

      var onRoomsInfoRetrieved = function onRoomsInfoRetrieved(roomsInfo) {
        onRoomsDataRetrieved(roomsInfo, forceTransparentUpdate);
      };

      var onRoomsRetrieved = function onRoomsRetrieved(roomsData) {
        refreshRoomsTracker.failCount = 0;
        areRoomsProcessedPromise.resolve(); // Get rooms info after retrieving rooms

        getRoomsInfo(roomsData).then(onRoomsInfoRetrieved);
      };

      var onRoomsFailedToRetrieve = function onRoomsFailedToRetrieve() {
        refreshRoomsTracker.lastFailure = new Date();
        refreshRoomsTracker.failCount++;
        retryRefreshRooms();
      };

      var getRooms = function getRooms() {
        calendarProvider.getRooms(currentRoomIds).then(onRoomsRetrieved, onRoomsFailedToRetrieve);
      };

      if (delay.timeout) {
        logManager.debug('Requesting rooms info in ' + delay.timeout + ' ms');
      }

      $timeout(getRooms, delay.timeout);
    }

    function getFacilities(room) {
      var mapFacilities = getRoomByCollection(room.id, roomsFacilities).roomFacilities || {};
      var providerFacilities = room.providerFacilities || {}; // Merge map facilities and provider facilities and
      // let map facilities take priority

      return dataUtil.mergeObjects([providerFacilities, mapFacilities]);
    }

    function getRoomByCollection(roomId, collection) {
      var mappedRoom = $filter('filter')(collection, function (value) {
        return value.roomId === roomId;
      })[0];
      return mappedRoom || {};
    }

    function getNumber(room) {
      return getRoomByCollection(room.id, roomsNumber).roomNumber || room.providerNumber;
    }

    function getFloorName(room) {
      return getRoomByCollection(room.id, roomsFloorName).floorName || room.providerFloorName;
    }

    function getBuildingName(room) {
      // Show building name only if there's more than 1 building
      return providerBuildings.length < 2 ? undefined : room.providerBuildingName;
    }

    function bindRoomsToDataSet(isTransparentUpdate) {
      providerRoomIds = [];

      for (var i = 0; i < rooms.length; i++) {
        var room = rooms[i];
        var mappedRoom = getRoomByCollection(room.id, roomsName);
        room.setName(mappedRoom.roomName);
        room.setDisplayName(mappedRoom.roomName);
        room.direction = getRoomDirection(room.id) || room.providerDirection;
        room.facilities = getFacilities(room);
        room.number = getNumber(room);
        room.floorName = getFloorName(room);
        room.buildingName = getBuildingName(room);
        providerRoomIds.push(room.id);
      }

      observables.providerRoomIds.onChange(providerRoomIds);
      rooms.sort(sortRoomsByIdentifier);
      observables.rooms.onChange({
        rooms: rooms,
        isTransparentUpdate: isTransparentUpdate
      });
      updateRoomsMapping();
    }

    function getRoomDirection(roomId) {
      for (var i = 0; i < roomsLocation.length; i++) {
        var location = roomsLocation[i];
        var direction = location.direction;

        if (location.roomId.toLowerCase() != roomId.toLowerCase()) {
          continue;
        }

        return direction;
      }

      return;
    }

    function cancelRetryRefreshRooms() {
      if (!retryRefreshRoomsPromise) {
        return;
      }

      $timeout.cancel(retryRefreshRoomsPromise);
      retryRefreshRoomsPromise = undefined;
    }

    function retryRefreshRooms() {
      cancelRetryRefreshRooms();
      retryRefreshRoomsPromise = $timeout(refreshRooms, refreshDataTimeout);
    }

    function areRoomsProcessed() {
      return areRoomsProcessedPromise.promise;
    }

    function onRoomDataSetUpdated(mapping) {
      if (!mapping) {
        return;
      }

      roomsLocation = mapping.locations || [];
      roomsName = mapping.names || [];
      roomsNumber = mapping.numbers || [];
      roomsFacilities = mapping.facilities || [];
      roomsFloorName = mapping.floorNames || []; // Don't do anything if there are no rooms

      if (!rooms.length) {
        return;
      }

      areRoomsProcessed().then(function () {
        bindRoomsToDataSet(mapping.isTransparentUpdate);
      });
    }

    function onRoomsMappingUpdated(mapping) {
      currentRoomsMapping = mapping || [];
      isRoomsMappingReadyPromise.resolve();
    }

    function initialize() {
      subscribers.push(configurationManager.getCustomModelObservable().subscribe(onCustomModelUpdated));
      subscribers.push(roomDataSetManager.subscribeToRoomDataSet(onRoomDataSetUpdated));
      subscribers.push(displayConfigurationManager.subscribeToTimeBlockIntervalChanged(onTimeBlockIntervalChanged));
      subscribers.push(configurationManager.getInputObservable(MODEL_INPUT_KEYS.ROOMS_LOCATION, []).subscribe(onRoomsMappingUpdated));
    }

    function updateDataRange() {
      var dateRange = timeUtil.getEventsDateRange();
      dataRange = {
        start: dateRange.start,
        end: dateRange.end
      }; // get book limit (in hours) from model.json

      var configuredBookLimit = configurationManager.getInputModel(MODEL_INPUT_KEYS.BOOK_LIMIT);

      if (configuredBookLimit) {
        // convert book limit in hours to milliseconds
        bookLimit = configuredBookLimit * 60 * 60 * 1000;
      }

      onConfigurationChanged();
    }

    function onTimeBlockIntervalChanged(interval) {
      if (dataUtil.isNullOrUndefined(interval)) {
        return;
      }

      timeBlockInterval = interval;
      onConfigurationChanged();
    }

    function onConfigurationChanged() {
      observables.configuration.onChange({
        start: dataRange.start,
        end: dataRange.end,
        interval: timeBlockInterval,
        bookLimit: bookLimit
      });
    }

    function createEventAndVerify(room, title, start, end, metadata) {
      var promise = $q.defer();

      var onEventCreated = function onEventCreated(newEvent) {
        verifyUpdatedEvent(room, newEvent, true).then(promise.resolve, promise.reject);
      };

      calendarProvider.createEvent(room, title, start, end, metadata).then(onEventCreated, promise.reject);
      return promise.promise;
    }

    function updateEventAndVerify(room, event, dataToUpdate, bookingAction) {
      var promise = $q.defer();
      dataToUpdate.room = room;
      dataToUpdate.id = event.id;
      dataToUpdate.originalEvent = event;

      var onEventUpdated = function onEventUpdated(newEvent) {
        verifyUpdatedEvent(room, newEvent, true).then(promise.resolve, promise.reject);
      };

      calendarProvider.updateEvent(dataToUpdate, bookingAction).then(onEventUpdated, promise.reject);
      return promise.promise;
    }

    function verifyUpdatedEvent(room, newEvent, exists) {
      var promise = $q.defer();
      var isFinalized = false; // if the event is not there within x seconds, consider failed

      var checkEventTimeoutPromise = $timeout(function () {
        finalize();
        promise.reject(new ScheduleError(room.id, SCHEDULE_ERROR.TIMEOUT, 'Operation timed out.'));
      }, checkEventMaxTimeout);
      var retryTimeoutPromise;

      var finalize = function finalize() {
        isFinalized = true;
        $timeout.cancel(checkEventTimeoutPromise);
        $timeout.cancel(retryTimeoutPromise);
      };

      var onRetrieveEventsFailed = function onRetrieveEventsFailed(err) {
        finalize();
        promise.reject(err);
      };

      var checkEvent = function checkEvent(events) {
        // if the result is not as intended and we haven't stopped trying, try again
        if (eventUtil.hasEvent(newEvent, events) != exists && !isFinalized) {
          retryTimeoutPromise = $timeout(startCheckEvent, retryCheckTimeout);
          return;
        }

        finalize();
        promise.resolve(newEvent);
        onEventsRetrieved(room, events);
      };

      var startCheckEvent = function startCheckEvent() {
        getCurrentEvents(room).then(checkEvent, onRetrieveEventsFailed);
      };

      startCheckEvent();
      return promise.promise;
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('dataConfigurationManager', function (configurationManager, MODEL_INPUT_KEYS, SYSTEM_DATA, DataBehavior, dataUtil) {
    var DEFAULT_ENABLE_CHECK_IN = [SYSTEM_DATA.INPUT_ENABLED];
    var DEFAULT_SUPPORTS_CHECK_IN_CONFIGURATION = true;
    var checkInEnabledObservable = new DataBehavior();
    var enableCheckIn = DEFAULT_ENABLE_CHECK_IN;
    var supportsCheckInConfiguration = DEFAULT_SUPPORTS_CHECK_IN_CONFIGURATION;
    var checkInEnabled;

    this.subscribeToCheckIn = function (callback) {
      return checkInEnabledObservable.subject.subscribe(callback);
    };

    this.getCheckInEnabled = function () {
      if (!dataUtil.isNullOrUndefined(checkInEnabled)) {
        return checkInEnabled;
      }

      updateIsCheckInEnabled();
      return checkInEnabled;
    };

    function isEnabled(input) {
      return dataUtil.isInputEnabled(input);
    }

    function getValueBasedOnFlag(flag, value) {
      return flag ? value : [SYSTEM_DATA.INPUT_DISABLED];
    }

    function isCheckInEnabled() {
      return isEnabled(getValueBasedOnFlag(supportsCheckInConfiguration, enableCheckIn));
    }

    function updateIsCheckInEnabled() {
      checkInEnabled = isCheckInEnabled();
      checkInEnabledObservable.onChange(checkInEnabled);
    }

    function onEnableCheckInChanged(value) {
      enableCheckIn = value;
      updateIsCheckInEnabled();
    }

    function onSupportsCheckInConfigurationChanged(value) {
      supportsCheckInConfiguration = value;
      updateIsCheckInEnabled();
    }

    configurationManager.getInputObservable(MODEL_INPUT_KEYS.ENABLE_CHECK_IN, DEFAULT_ENABLE_CHECK_IN).subscribe(onEnableCheckInChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.IS_CHECK_IN_CONFIGURATION_SUPPORTED, DEFAULT_SUPPORTS_CHECK_IN_CONFIGURATION).subscribe(onSupportsCheckInConfigurationChanged);
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('displayConfigurationManager', function (configurationManager, DataBehavior, displayUtil, timeUtil, colorUtil, dataUtil, MODEL_INPUT_KEYS, MODEL_INPUT_VALUES, POSITIONS, SYSTEM_DATA, textUtil) {
    var DEFAULT_HEADER_COLOR = '#183B65';
    var DEFAULT_TABLE_TEXT_COLOR = '#114';
    var tableStyling = {
      status: {
        occupied: '',
        checkin: '',
        available: ''
      },
      timelineHeader: {
        color: ''
      },
      itemsHeader: {
        color: '',
        backgroundColor: ''
      },
      items: {
        color: '',
        backgroundColor: ''
      },
      timeline: {
        color: '',
        backgroundColor: ''
      },
      table: {
        borderColor: ''
      }
    };
    var levelStyling = {
      color: '',
      backgroundColor: ''
    };
    var tableBackgroundColorObservable = new DataBehavior('');
    var tableTextColorObservable = new DataBehavior('');
    var headerEnabledObservable = new DataBehavior();
    var meetingNameEnabledObservable = new DataBehavior();
    var organizerNameEnabledObservable = new DataBehavior();
    var headerBackgroundColorObservable = new DataBehavior(DEFAULT_HEADER_COLOR);
    var headerBackgroundImageObservable = new DataBehavior([]);
    var headerTitleObservable = new DataBehavior({});
    var headerTextColorObservable = new DataBehavior('');
    var availableStatusColorObservable = new DataBehavior('');
    var occupiedStatusColorObservable = new DataBehavior('');
    var checkInStatusColorObservable = new DataBehavior('');
    var mapEnabledObservable = new DataBehavior();
    var interactivityObservable = new DataBehavior();
    var logoEnabledObservable = new DataBehavior();
    var clockFormatObservable = new DataBehavior();
    var tableStylingObservable = new DataBehavior();
    var levelStylingObservable = new DataBehavior();
    var clockEnabledObservable = new DataBehavior(true);
    var timeBlockIntervalChangedObservable = new DataBehavior();
    var customFontChangedObservable = new DataBehavior({});
    var cssOverwrite = {
      // for available, schedule-item-status doesn't have important as other status (checkIn and occupied) will inherit this css as well with additional class (schedule-item-status-occupied/checkIn)
      availableStatusColor: '.{0} {background-color:{1} !important}',
      occupiedStatusColor: '.{0} {background-color:{1} !important}',
      checkInStatusColor: '.{0} {background-color:{1} !important}'
    };

    this.subscribeToEnableLogo = function (callback) {
      return logoEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToLogoImage = function (callback) {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.LOGO_IMAGE, []).subscribe(callback);
    };

    this.subscribeToLogoPosition = function (callback) {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.LOGO_POSITION, POSITIONS.TOP_LEFT).subscribe(callback);
    };

    this.subscribeToEnableHeader = function (callback) {
      return headerEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToEnableMeetingName = function (callback) {
      return meetingNameEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToEnableOrganizerName = function (callback) {
      return organizerNameEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToHeaderBackgroundImage = function (callback) {
      return headerBackgroundImageObservable.subject.subscribe(callback);
    };

    this.subscribeToHeaderBackgroundColor = function (callback) {
      return headerBackgroundColorObservable.subject.subscribe(callback);
    };

    this.subscribeToHeaderMaskColor = function (callback) {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.HEADER_MASK_COLOR, SYSTEM_DATA.DEFAULT_MASK_COLOR).subscribe(callback);
    };

    this.subscribeToHeaderTitle = function (callback) {
      return headerTitleObservable.subject.subscribe(callback);
    };

    this.subscribeToHeaderTextColor = function (callback) {
      return headerTextColorObservable.subject.subscribe(callback);
    };

    this.subscribeToClockFormat = function (callback) {
      return clockFormatObservable.subject.subscribe(callback);
    };

    this.subscribeToEnableMap = function (callback) {
      return mapEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToInteractivity = function (callback) {
      return interactivityObservable.subject.subscribe(callback);
    };

    this.subscribeToTableTextColorChanged = function (callback) {
      return tableTextColorObservable.subject.subscribe(callback);
    };

    this.subscribeToAvailableColorChanged = function (callback) {
      return availableStatusColorObservable.subject.subscribe(callback);
    };

    this.subscribeToCheckInColorChanged = function (callback) {
      return checkInStatusColorObservable.subject.subscribe(callback);
    };

    this.subscribeToOccupiedColorChanged = function (callback) {
      return occupiedStatusColorObservable.subject.subscribe(callback);
    };

    this.subscribeToTableStylingChanged = function (callback) {
      return tableStylingObservable.subject.subscribe(callback);
    };

    this.subscribeToLevelStylingChanged = function (callback) {
      return levelStylingObservable.subject.subscribe(callback);
    };

    this.subscribeToLayout = function (callback) {
      return configurationManager.getInputObservable(MODEL_INPUT_KEYS.LAYOUT).subscribe(callback);
    };

    this.subscribeToEnableClock = function (callback) {
      return clockEnabledObservable.subject.subscribe(callback);
    };

    this.subscribeToTimeBlockIntervalChanged = function (callback) {
      return timeBlockIntervalChangedObservable.subject.subscribe(callback);
    };

    this.subscribeToCustomFontChanged = function (callback) {
      return customFontChangedObservable.subject.subscribe(callback);
    };

    function onAvailableColorChanged(color) {
      onStatusColorChanged('availableStatusColor', color, SYSTEM_DATA.CSS_AVAILABLE_CLASS);
      availableStatusColorObservable.onChange(color);
    }

    function onOccupiedColorChanged(color) {
      onStatusColorChanged('occupiedStatusColor', color, SYSTEM_DATA.CSS_OCCUPIED_CLASS);
      occupiedStatusColorObservable.onChange(color);
    }

    function onCheckInColorChanged(color) {
      onStatusColorChanged('checkInStatusColor', color, SYSTEM_DATA.CSS_CHECK_IN_CLASS);
      checkInStatusColorObservable.onChange(color);
    }

    function onStatusColorChanged(id, color, className) {
      displayUtil.appendCssClassOverwrite(id, color, textUtil.formatText(cssOverwrite[id], [className, color]));
    }

    function onHeaderBackgroundImageChanged(media) {
      media = media || [];
      var result = [];

      for (var i = 0; i < media.length; i++) {
        var mediaItem = media[i];
        result.push(mediaItem.path);
      }

      headerBackgroundImageObservable.onChange(result);
    }

    function onDisplayOptionsChanged(displayOptions) {
      var is24Hour = dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_24_HOUR_CLOCK);
      var res = {
        is24Hour: is24Hour,
        format: timeUtil.getTimeFormat(is24Hour)
      };
      clockFormatObservable.onChange(res);
      interactivityObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_INTERACTIVITY_ENABLED));
      mapEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_MAP_ENABLED));
      logoEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_LOGO_ENABLED));
      headerEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_HEADER_ENABLED));
      meetingNameEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_MEETING_NAME_ENABLED));
      organizerNameEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_ORGANIZER_NAME_ENABLED));
      clockEnabledObservable.onChange(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_CLOCK_ENABLED));
      timeBlockIntervalChangedObservable.onChange(timeUtil.getTableInterval(dataUtil.isOptionEnabled(displayOptions, MODEL_INPUT_VALUES.IS_15_MINUTES_TIME_BLOCK)));
    }

    function setStyling(input) {
      if (!input || !input.name) {
        return;
      }

      var inputValue = input.value;

      switch (input.name) {
        case MODEL_INPUT_KEYS.HEADER_TITLE:
          headerTitleObservable.onChange(input);

          if (!input.style || !input.style.color) {
            break;
          }

          var headerTextColor = input.style.color;
          tableStyling.timelineHeader.color = headerTextColor;
          tableStyling.itemsHeader.color = headerTextColor;
          headerTextColorObservable.onChange(headerTextColor);
          break;

        case MODEL_INPUT_KEYS.HEADER_BACKGROUND_COLOR:
          tableStyling.itemsHeader.backgroundColor = inputValue;
          headerBackgroundColorObservable.onChange(inputValue);
          break;

        case MODEL_INPUT_KEYS.AVAILABLE_COLOR:
          tableStyling.status.available = inputValue;
          onAvailableColorChanged(inputValue);
          break;

        case MODEL_INPUT_KEYS.OCCUPIED_COLOR:
          tableStyling.status.occupied = inputValue;
          onOccupiedColorChanged(inputValue);
          break;

        case MODEL_INPUT_KEYS.CHECK_IN_COLOR:
          tableStyling.status.checkin = inputValue;
          onCheckInColorChanged(inputValue);
          break;

        case MODEL_INPUT_KEYS.TABLE_BACKGROUND_COLOR:
          tableStyling.items.backgroundColor = inputValue;
          tableStyling.timeline.backgroundColor = inputValue;
          tableBackgroundColorObservable.onChange(inputValue);
          break;

        case MODEL_INPUT_KEYS.TABLE_TEXT_COLOR:
          var tableTextColor = inputValue || DEFAULT_TABLE_TEXT_COLOR;
          tableStyling.items.color = tableTextColor;
          tableStyling.timeline.color = tableTextColor;
          tableTextColorObservable.onChange(tableTextColor);
          break;

        case MODEL_INPUT_KEYS.TABLE_BORDER_COLOR:
          tableStyling.table.borderColor = inputValue;
          break;

        case MODEL_INPUT_KEYS.LEVEL_COLOR:
          levelStyling.backgroundColor = inputValue;
          break;

        case MODEL_INPUT_KEYS.LEVEL_TEXT_COLOR:
          levelStyling.color = inputValue;
          break;
      }
    }

    function onInputModelsChanged(inputs) {
      if (!inputs || !inputs.length) {
        return;
      }

      for (var i = 0; i < inputs.length; i++) {
        setStyling(inputs[i]);
      }

      tableStylingObservable.onChange($angular.copy(tableStyling));
      levelStylingObservable.onChange($angular.copy(levelStyling));
    }

    function onCustomFontChanged(font) {
      font = font ? font[font.length - 1] || {} : {};
      customFontChangedObservable.onChange(font);
    }

    configurationManager.getInputModelObservable().subscribe(onInputModelsChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.HEADER_BACKGROUND_IMAGE, []).subscribe(onHeaderBackgroundImageChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.DISPLAY_OPTIONS, []).subscribe(onDisplayOptionsChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.AVAILABLE_COLOR).subscribe(onAvailableColorChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.OCCUPIED_COLOR).subscribe(onOccupiedColorChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.CHECK_IN_COLOR).subscribe(onCheckInColorChanged);
    configurationManager.getInputObservable(MODEL_INPUT_KEYS.CUSTOM_FONT).subscribe(onCustomFontChanged);
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('mapDataManager', function ($timeout, DataBehavior, networkUtil, logManager, configurationManager, PLAYER_PROPERTY_KEYS, MAP_SERVICE_STATE) {
    var MAP_POLLING_INTERVAL = 60000;
    var MAX_FAILURE_COUNT = 5;
    var mapObservables = new DataBehavior();
    var locationObservables = new DataBehavior();
    var serviceStatusObservables = new DataBehavior();
    var currentLocation = {};
    var floors;
    var mapRequestConfig;
    var mapPollingPromise;
    var failureCount = 0;
    var serviceStatus = MAP_SERVICE_STATE.NONE;
    configurationManager.getPlayerPropertyObservable(PLAYER_PROPERTY_KEYS.MAP_LOCATION, '').subscribe(onLocationChanged);
    configurationManager.getPlayerPropertyObservable(PLAYER_PROPERTY_KEYS.MAP_LOCATION_ID, '').subscribe(onLocationIdChanged);

    function createMapRequestConfig(roomIds) {
      var data = {
        calendarResourceIds: roomIds,
        start: 0,
        limit: 1000,
        includePointOfInterests: true
      };
      return {
        method: 'POST',
        relativeUrl: '/api/v3/maps/floors/manifests/search',
        headers: {
          Accept: 'application/json'
        },
        data: JSON.stringify(data),
        contentType: 'application/json'
      };
    }

    function updateServiceStatus(state) {
      serviceStatus = state;
      serviceStatusObservables.onChange(serviceStatus);
    }

    function startMapPolingTimer() {
      if (failureCount >= MAX_FAILURE_COUNT) {
        updateServiceStatus(MAP_SERVICE_STATE.NO_CONNECTION);
        return;
      }

      mapPollingPromise = $timeout(getMap, MAP_POLLING_INTERVAL);
    }

    function getMap() {
      var onFailedToGetMap = function onFailedToGetMap(error) {
        var errorMessage = (error || {}).message;
        logManager.error('Failed to retrieve maps: {0}', errorMessage || JSON.stringify(error));
        failureCount++;
        updateServiceStatus(MAP_SERVICE_STATE.FAILURE);
        startMapPolingTimer();
      };

      var parsedData = JSON.parse(mapRequestConfig.data);
      logManager.debug('Retrieving maps for: {0}', JSON.stringify(parsedData.calendarResourceIds));
      networkUtil.requestConstellationService(mapRequestConfig).then(function (result) {
        result = result || {};
        floors = result.items;
        failureCount = 0;
        mapObservables.onChange(floors);
        updateServiceStatus(MAP_SERVICE_STATE.CONNECTED);
        startMapPolingTimer();
      }, onFailedToGetMap);
    }

    function startMapPolling(roomIds) {
      mapRequestConfig = createMapRequestConfig(roomIds);
      getMap();
    }

    function stopMapPolling() {
      if (!mapPollingPromise) {
        return;
      }

      $timeout.cancel(mapPollingPromise);
      mapPollingPromise = undefined;
      failureCount = 0;
    }

    this.subscribeToMap = function (roomIds, callback) {
      if (!callback) {
        return;
      }

      stopMapPolling();

      if (!roomIds || !roomIds.length) {
        floors = [];
      } else {
        startMapPolling(roomIds);
      }

      mapObservables.onChange(floors);
      return mapObservables.subject.subscribe(callback);
    };

    function onCurrentLocationChanged() {
      locationObservables.onChange(currentLocation);
    }

    function onLocationChanged(location) {
      currentLocation.location = location ? JSON.parse(location) : location;
      onCurrentLocationChanged();
    }

    function onLocationIdChanged(locationId) {
      currentLocation.locationId = locationId;
      onCurrentLocationChanged();
    }

    this.subscribeToCurrentLocation = function (callback) {
      if (!callback) {
        return;
      }

      locationObservables.onChange(currentLocation);
      return locationObservables.subject.subscribe(callback);
    };

    this.subscribeToMapServiceState = function (callback) {
      if (!callback) {
        return;
      }

      serviceStatusObservables.onChange(serviceStatus);
      return serviceStatusObservables.subject.subscribe(callback);
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('authenticationManager', function ($q, $timeout, displayUtil, networkUtil, textUtil, dataUtil, calendarProviderFactory, configurationManager, SYSTEM_DATA, HTTP_STATUS_CODE, CUSTOM_DATA_KEY, eventManager, calendarDataManager) {
    var authenticationTimeoutValue = '300000';
    var authenticationPollingValue = '1000';
    var URL_GET_TOKEN_FORMAT = '{0}/token?pairingkey={1}';
    var isAuthenticating = false;
    var authenticationWindow;
    var authenticationTimeout;
    var authenticationPollingTimeout;
    var currentCancel;
    var authenticationServiceUrl;
    var getCustomDataObservable = configurationManager.getCustomDataObservable;

    this.initialize = function () {
      authenticationServiceUrl = (configurationManager.getCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_SERVICE) || {}).url;
    };

    this.authenticate = function (config) {
      if (!config || !config.provider || !config.provider.type) {
        return $q.reject('incompleteconfig');
      }

      var defer = $q.defer();
      getPairingKey(config).then(function (settings) {
        dataUtil.appendObject(config.provider, settings.info);
        dataUtil.mergeObject(config.provider, settings.config);
        config.provider.serviceUrl = authenticationServiceUrl;
        getAuthenticationData(settings.pairingKey, config).then(defer.resolve, defer.reject);
      }, defer.reject);
      return defer.promise;
    };

    this.cancel = cancel;

    this.getProviderList = function (callback) {
      return getCustomDataObservable(CUSTOM_DATA_KEY.PROVIDERS).subscribe(callback);
    };

    this.getAuthenticationData = function (callback) {
      return getCustomDataObservable(CUSTOM_DATA_KEY.AUTHENTICATION_DATA).subscribe(callback);
    };

    this.updateAuthenticationData = function (authenticationData) {
      configurationManager.updateCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA, authenticationData);
    };

    this.validateProvider = function (config) {
      if (!config) {
        return $q.reject('noconfig');
      }

      if (config.provider && config.provider.useMockAuthenticationData) {
        var providerConfig = config.provider;
        return $q.resolve({
          provider: {
            type: providerConfig.provider.type,
            isPickRoomSkipped: providerConfig.isPickRoomSkipped,
            useMockAuthenticationData: providerConfig.useMockAuthenticationData
          },
          data: {
            lastUpdated: new Date().toISOString()
          }
        });
      }

      if (!config.providerUrl || !config.requestMethod || !networkUtil[config.requestMethod]) {
        return $q.reject('incompleteconfig');
      }

      var promise = $q.defer();
      var requestConfig = config.requestConfig;
      networkUtil[config.requestMethod](requestConfig).then(function (res) {
        var provider = {
          type: config.provider.type,
          baseUrl: config.providerUrl,
          healthCheckPath: config.healthCheckPath
        };

        if (!config.skipHeaders) {
          provider.headers = requestConfig.headers;
        }

        promise.resolve({
          provider: provider,
          data: {
            lastUpdated: new Date().toISOString()
          }
        });
      }, promise.reject);
      return promise.promise;
    };

    this.logOut = function () {
      var processPromise = $q.defer();
      eventManager.reset();
      calendarDataManager.reset();
      calendarProviderFactory.clearProviders();
      var authenticationKey = CUSTOM_DATA_KEY.AUTHENTICATION_DATA;
      var roomIdsKey = CUSTOM_DATA_KEY.ROOM_IDS;
      configurationManager.getCustomModelObservable().subscribe(function (data) {
        if (!dataUtil.isObjectEqual({}, data[authenticationKey]) || !dataUtil.isObjectEqual([], data[roomIdsKey])) {
          return;
        }

        processPromise.resolve();
      });
      configurationManager.updateCustomData(authenticationKey, {});
      configurationManager.updateCustomData(roomIdsKey, []);
      return processPromise.promise;
    };

    function reset() {
      isAuthenticating = false;

      if (authenticationTimeout) {
        $timeout.cancel(authenticationTimeout);
        authenticationTimeout = null;
      }

      clearAuthenticationPollingTimeout();

      if (authenticationWindow) {
        if (!authenticationWindow.closed && authenticationWindow.close) {
          authenticationWindow.close();
        }

        authenticationWindow = undefined;
      }

      if (currentCancel) {
        currentCancel = null;
      }
    }

    function clearAuthenticationPollingTimeout() {
      if (!authenticationPollingTimeout) {
        return;
      }

      $timeout.cancel(authenticationPollingTimeout);
      authenticationPollingTimeout = null;
    }

    function getAuthenticationData(pairingKey, config) {
      cancel();
      var calendarProvider = calendarProviderFactory.getProvider({
        type: config.provider.type
      });

      if (!calendarProvider) {
        return $q.reject('noprovider');
      }

      calendarProvider.initialize();
      var authenticationInfo = calendarProvider.getAuthenticationInfo(pairingKey, config.provider);

      if (!authenticationInfo || !authenticationInfo.url || !authenticationInfo.key) {
        return $q.reject('invalidauthenticationinfo');
      }

      var tokenUrl = textUtil.formatText(URL_GET_TOKEN_FORMAT, [authenticationServiceUrl, pairingKey]);
      isAuthenticating = true;
      var defer = $q.defer();

      var onError = function onError(reason) {
        calendarProvider.dispose();
        defer.reject(reason);
        reset();
      };

      var onRetrieveToken = function onRetrieveToken() {
        getToken(tokenUrl).then(function (result) {
          if (result.isWaiting) {
            onPolling();
            return;
          }

          calendarProvider.dispose();
          defer.resolve({
            provider: config.provider,
            data: result.data
          });
        }, onError);
      };

      var onPolling = function onPolling() {
        if (!isAuthenticating) {
          reset();
          return;
        }

        if (authenticationWindow && authenticationWindow.closed) {
          onError('windowclosed');
          return;
        }

        clearAuthenticationPollingTimeout();
        authenticationPollingTimeout = $timeout(onRetrieveToken, authenticationPollingValue);
      };

      openAuthenticationWindow(authenticationInfo.url, config);
      setAuthenticationHandler(onError);
      onPolling();
      return defer.promise;
    }

    function openAuthenticationWindow(url, config) {
      authenticationWindow = displayUtil.openPopupWindow(url, config.provider.popUpWindowSize);

      if (!authenticationWindow && config.onPopupBlocked) {
        config.onPopupBlocked();
        return;
      }

      if (!config.showCancelButton) {
        return;
      }

      config.showCancelButton();
    }

    function setAuthenticationHandler(callback) {
      currentCancel = function currentCancel() {
        callback('cancel');
      };

      authenticationTimeout = $timeout(function () {
        callback('timeout');
      }, authenticationTimeoutValue);
    }

    function getToken(tokenUrl) {
      var defer = $q.defer();
      var token = {
        isWaiting: true
      };
      networkUtil.http({
        method: 'GET',
        url: tokenUrl
      }).then(function (result) {
        if (!result || !result.data) {
          defer.resolve(token);
          return;
        }

        if (!result.data.oauthId) {
          defer.reject(result.data.error || 'cannotauthenticate');
          return;
        }

        token.isWaiting = false;
        token.data = result.data;
        defer.resolve(token);
      }, function (error) {
        // only with specific error from the service do we reject the promise.
        if (error && error.status === HTTP_STATUS_CODE.FORBIDDEN) {
          defer.reject('forbidden');
          return;
        }

        defer.resolve(token);
      });
      return defer.promise;
    }

    function cancel() {
      if (currentCancel) {
        currentCancel();
      }

      reset();
    }

    function getPairingKey(config) {
      var url = textUtil.formatText('{0}/{1}/info', [authenticationServiceUrl, config.provider.applicationPath || config.provider.type]); // need to pass sessionInfo somewhere

      var pairingKeySettings = {
        method: 'GET',
        timeout: SYSTEM_DATA.NETWORK_PROXY_TIMEOUT,
        url: url
      };
      var defer = $q.defer();
      networkUtil.http(pairingKeySettings).then(function (result) {
        // change provider config here
        if (!result || !result.data || !result.data.pairingKey) {
          defer.reject('noproviderinfo');
          return;
        }

        defer.resolve(result.data);
      }, defer.reject);
      return defer.promise;
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('cardApiManager', function (cardApiFactory, DataBehavior, DataSubject, dataUtil) {
    var cardApi;
    var hasNotified = false;
    var messagesObservable = new DataBehavior();
    var postMessagesObservable = new DataSubject();

    function isPlaybackContext(contexts) {
      return cardApi && cardApi.getPlaybackContext && dataUtil.includesValue(contexts, cardApi.getPlaybackContext());
    }

    this.isScreenshot = function () {
      return isPlaybackContext([cardApi.PLAYBACKCONTEXT.SCREENSHOT, cardApi.PLAYBACKCONTEXT.THEMESCREENSHOT]);
    };

    this.isEditing = function () {
      return isPlaybackContext([cardApi.PLAYBACKCONTEXT.EDIT, cardApi.PLAYBACKCONTEXT.THEME]);
    };

    this.isPreview = function () {
      return cardApi && cardApi.isPreview && cardApi.isPreview();
    };

    this.isDevicePlayback = function () {
      return isPlaybackContext([cardApi.PLAYBACKCONTEXT.DEVICE]);
    };

    this.isPlaybackContextNone = function () {
      return isPlaybackContext([cardApi.PLAYBACKCONTEXT.NONE]);
    };

    this.notifyOnLoad = function () {
      if (hasNotified) {
        return;
      }

      hasNotified = true;
      cardApi.notifyOnLoad();
    };

    this.subscribeOnModelUpdate = function (callback) {
      cardApi.subscribeModelUpdate(callback);
    };

    this.xhr = function (url, config) {
      return cardApi.api.xhr(url, config);
    };

    this.init = function () {
      cardApi.init();
      cardApi.subscribeToMessages(onParentMessage);
      cardApi.subscribeToPostMessages(onPostMessage);
    };

    this.updateModelCustomData = function (data) {
      cardApi.api.updateModelCustomData(data);
    };

    this.updateModelInput = function (input) {
      cardApi.api.updateModelInput(input);
    };

    this.getConstellationAccountId = function () {
      return cardApi && cardApi.api && cardApi.api.getAccountId ? cardApi.api.getAccountId() : undefined;
    };

    this.getConstellationBaseUrl = function () {
      return cardApi && cardApi.api && cardApi.api.getConstellationBaseUrl ? cardApi.api.getConstellationBaseUrl() : undefined;
    };

    function onParentMessage(event) {
      if (!event || !event.message) {
        return;
      }

      messagesObservable.onChange(event);
    }

    function onPostMessage(event) {
      postMessagesObservable.onChange(event);
    }

    this.subscribeToMessages = function (callback) {
      return messagesObservable.subject.subscribe(callback);
    };

    this.subscribeToPostMessages = function (callback) {
      return postMessagesObservable.subject.subscribe(callback);
    };

    this.requestConstellationService = function (relativeUrl, configuration) {
      return cardApi.api.requestConstellationService(relativeUrl, configuration);
    };

    function start() {
      cardApi = cardApiFactory.getApi();
    }

    start();
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('checkpointManager', function (postMessageManager, dataUtil, DataSubject, CHECKPOINT_STATUS) {
    var subscribers = [];
    var observable = new DataSubject();

    this.initialize = function () {
      subscribers.push(postMessageManager.subscribeToPostMessages(onPostMessageReceived));
    };

    this.reset = function () {
      for (var i = 0; i < subscribers.length; i++) {
        subscribers[i].dispose();
      }

      subscribers = [];
    };

    this.subscribeToCheckpointResult = function (callback) {
      return observable.subject.subscribe(callback);
    };

    this.getCheckpoints = function (room, type) {
      if (!room) {
        return;
      }

      var checkpoints = room.checkpoints || {};
      return !type ? checkpoints : checkpoints[type] || [];
    };

    function isMessageValid(event) {
      if (!event) {
        return false;
      }

      var keys = Object.keys(event);
      var status = event.status;
      return keys.length === 1 && keys[0] === 'status' && dataUtil.isString(status) && dataUtil.objectHasValue(CHECKPOINT_STATUS, status.toUpperCase());
    }

    function onPostMessageReceived(event) {
      if (!isMessageValid(event)) {
        return;
      }

      observable.onChange(event.status.toUpperCase());
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('configurationManager', function ($q, $filter, DataBehavior, cardApiManager, dataUtil) {
    var DEFAULT_FEATURES = {};
    var inputsObservable = {};
    var customsObservable = {};
    var playerPropertiesObservable = {};
    var inputDataObservable = new DataBehavior([]);
    var customDataObservable = new DataBehavior({});
    var messagesObservable = new DataBehavior({});
    var currentCustomData = {};
    var currentInputData = {};
    var playerProperties = {};
    var features = DEFAULT_FEATURES;
    var cardApiReadyPromise = $q.defer();
    var isReadyPromise = $q.defer();
    var modelPromise = $q.defer();
    var readyPromises = [modelPromise.promise, cardApiReadyPromise.promise];

    this.isReady = function () {
      return isReadyPromise.promise;
    };

    this.getInputModelObservable = function () {
      return inputDataObservable.subject;
    };

    this.getCustomModelObservable = function () {
      return customDataObservable.subject;
    };

    this.getInputObservable = function (key, defaultValue) {
      return getObservable(inputsObservable, key, defaultValue);
    };

    this.getCustomDataObservable = function (key, defaultValue) {
      return getObservable(customsObservable, key, defaultValue);
    };

    this.getPlayerPropertyObservable = function (key, defaultValue) {
      return getObservable(playerPropertiesObservable, key, defaultValue);
    };

    this.getCustomData = function (key) {
      return getObservableValue(customsObservable, key);
    };

    this.subscribeToCustomData = function (key, callback) {
      return this.getCustomDataObservable(key).subscribe(callback);
    };

    this.subscribeToMessages = function (callback) {
      return messagesObservable.subject.subscribe(callback);
    };

    this.subscribeToPostMessages = function (callback) {
      return cardApiManager.subscribeToPostMessages(callback);
    };

    this.getInputModel = function (key) {
      return getObservableValue(inputsObservable, key);
    };

    this.getPlayerProperty = function (key) {
      return playerProperties[key];
    };

    this.getFeatures = function () {
      return features || DEFAULT_FEATURES;
    };

    this.isEditing = cardApiManager.isEditing;
    this.isScreenshot = cardApiManager.isScreenshot;

    this.updateCustomData = function (key, data) {
      if (!key || !data) {
        return;
      }

      currentCustomData[key] = data;
      cardApiManager.updateModelCustomData(currentCustomData);
    };

    this.getConstellationAccountId = cardApiManager.getConstellationAccountId;
    this.getConstellationBaseUrl = cardApiManager.getConstellationBaseUrl;

    this.updateInput = function (key, data) {
      var input = getModelInput(key);

      if (!input) {
        return;
      }

      input.value = data;
      cardApiManager.updateModelInput(input);
    };

    function getModelInput(key) {
      return !key || dataUtil.isNotArrayOrEmpty(currentInputData) ? undefined : $filter('filter')(currentInputData, function (input) {
        return input.name === key;
      })[0];
    }

    function getObservableValue(observables, key) {
      var dataBehavior = observables[key];
      return dataBehavior ? dataBehavior.value : undefined;
    }

    function init() {
      $q.allSettled(readyPromises).then(isReadyPromise.resolve);
      cardApiManager.subscribeOnModelUpdate(onModelUpdated); // We don't want to wait for card API init if the
      // card is in screnshot mode or running isolatedly

      if (cardApiManager.isScreenshot() || cardApiManager.isPlaybackContextNone()) {
        cardApiReadyPromise.resolve();
        return;
      }

      cardApiManager.subscribeToMessages(onCardApiMessage);
    }

    function notifyPropertyObservable(key, value) {
      playerPropertiesObservable[key].onChange(value);
    }

    function processRemovedPlayerProperties() {
      for (var key in playerPropertiesObservable) {
        var value = playerProperties[key];

        if (!dataUtil.isNullOrUndefined(value)) {
          continue;
        } // Notify existing subscribers of removed player property


        notifyPropertyObservable(key, value);
      }
    }

    function onPlayerPropertiesUpdated(properties) {
      playerProperties = properties || {}; // To update or create observables

      for (var key in playerProperties) {
        var value = playerProperties[key];

        if (!playerPropertiesObservable[key]) {
          playerPropertiesObservable[key] = new DataBehavior(value);
        }

        notifyPropertyObservable(key, value);
      }

      processRemovedPlayerProperties();
    }

    function onCardApiMessage(event) {
      if (!event) {
        return;
      }

      switch (event.message) {
        case 'api.init':
          var config = event.config || {};
          features = config.features;
          onPlayerPropertiesUpdated(config.properties);
          break;

        case 'updatedeviceproperties':
          onPlayerPropertiesUpdated(event.parameters);
          break;

        default:
          // To ensure that Post Message API able to receive the same message
          event.receivedAt = Date.now();
          messagesObservable.onChange(event);
          return;
      }

      cardApiReadyPromise.resolve();
    }

    function onModelUpdated(model) {
      model = model || {};
      configureInputs(model.inputs);
      configureCustomData(model.customData || []);
      modelPromise.resolve();
    }

    function configureInputs(inputs) {
      currentInputData = inputs;
      inputDataObservable.onChange(currentInputData);

      if (!currentInputData || !currentInputData.length) {
        return;
      }

      for (var i = 0; i < currentInputData.length; i++) {
        var currentInput = currentInputData[i];
        var key = currentInput.name;
        var value = currentInput.value;

        if (currentInput.style) {
          value = {
            value: value,
            style: currentInput.style
          };
        }

        if (!inputsObservable[key]) {
          inputsObservable[key] = new DataBehavior(value);
          continue;
        }

        inputsObservable[key].onChange(value);
      }
    }

    function configureCustomData(customData) {
      currentCustomData = customData;
      customDataObservable.onChange(currentCustomData);
      Object.keys(customData).forEach(function (key) {
        var value = customData[key];

        if (!customsObservable[key]) {
          customsObservable[key] = new DataBehavior(value);
          return;
        }

        customsObservable[key].onChange(value);
      });
    }

    function getObservable(observableData, key, defaultValue) {
      if (!observableData[key]) {
        observableData[key] = new DataBehavior(defaultValue);
      }

      return observableData[key].subject;
    }

    init();
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('eventManager', function ($q, $filter, calendarDataManager, postMessageManager, DataBehavior, logManager, commandUtil, textUtil, dataUtil, timeUtil, TEXT_RESOURCE, COMMANDS, POST_MESSAGES, ROOM_STATUS) {
    var subscribers = [];
    var formatText = textUtil.formatText;
    var roomEventSubscribers = {};
    var currentRoomsInfo = {};
    var roomsInfo = {};
    var EXTERNAL_ROOM_STATUS = {
      AVAILABLE: 'available',
      OCCUPIED: 'occupied',
      CHECK_IN: 'check-in'
    };
    var EXTERNAL_MEETING_TYPE = {
      STARTED: 'started',
      ENDED: 'ended'
    };
    var READ_ONLY_ENABLED_COMMANDS = [COMMANDS.GET_CURRENT_MEETING, COMMANDS.GET_CURRENT_ROOM, COMMANDS.GET_TODAY_SCHEDULE, COMMANDS.GET_CURRENT_STATUS];
    var RAISE_EVENT_STATUSES = [ROOM_STATUS.AVAILABLE, ROOM_STATUS.CHECK_IN, ROOM_STATUS.OCCUPIED];
    var CHECK_IN_PERIOD = 600000; // 10 minutes

    var BOOKING_COMMAND_ACTION = {};
    var sourceView = 'init';
    var previousRoomsInfo = {};
    var roomStatusObservables = {};
    var selectedRoomIdObservable = new DataBehavior();
    var roomsInfoObservable = new DataBehavior({});
    BOOKING_COMMAND_ACTION[COMMANDS.BOOK] = createEvent;
    BOOKING_COMMAND_ACTION[COMMANDS.END] = endEvent;
    BOOKING_COMMAND_ACTION[COMMANDS.EXTEND] = extendEvent;
    BOOKING_COMMAND_ACTION[COMMANDS.GET_CURRENT_MEETING] = raiseCurrentEvent;
    BOOKING_COMMAND_ACTION[COMMANDS.GET_CURRENT_ROOM] = raiseCurrentRoom;
    BOOKING_COMMAND_ACTION[COMMANDS.RENAME] = renameEvent;
    BOOKING_COMMAND_ACTION[COMMANDS.CHECK_IN] = checkIn;
    BOOKING_COMMAND_ACTION[COMMANDS.GET_TODAY_SCHEDULE] = raiseTodaySchedule;
    BOOKING_COMMAND_ACTION[COMMANDS.GET_CURRENT_STATUS] = raiseCurrentStatus;
    BOOKING_COMMAND_ACTION[COMMANDS.SELECT_ROOM] = selectRoom;
    BOOKING_COMMAND_ACTION[COMMANDS.UNSELECT_ROOM] = unselectRoom;

    this.initialize = function () {
      subscribers.push(postMessageManager.subscribeToMessages(onCommandMessageReceived));
      subscribers.push(calendarDataManager.subscribeToActionExecuted(onBookingActionExecuted));
      subscribers.push(calendarDataManager.getRoomsObservable().subscribe(onRoomsDataChanged));
    };

    this.subscribeToRoomsEvent = function (rooms) {
      for (var j = 0; j < rooms.length; j++) {
        var room = rooms[j];
        roomEventSubscribers[room.id] = calendarDataManager.subscribeToRoomEvent(room, onEventRefreshed, onEventRetrieved);
      }
    };

    this.subscribeToRoomsInfo = function (callback) {
      roomsInfoObservable.subject.subscribe(callback);
    };

    this.subscribeToSelectedRoomId = function (callback) {
      return selectedRoomIdObservable.subject.subscribe(callback);
    };

    this.getRoomStatusObservable = function (roomId) {
      if (!roomStatusObservables[roomId]) {
        roomStatusObservables[roomId] = new DataBehavior({});
      }

      return roomStatusObservables[roomId].subject;
    };

    this.resetRoomInfo = function () {
      currentRoomsInfo = {};
      updateRoomsInfo();
    };

    this.reset = function () {
      this.resetRoomInfo();

      for (var i = 0; i < subscribers.length; i++) {
        subscribers[i].dispose();
      }

      subscribers = [];
    };

    this.raiseViewChanged = function (view) {
      if (view == sourceView) {
        return;
      }

      raisePostMessage(POST_MESSAGES.VIEW_CHANGED, {
        source: sourceView,
        target: view
      });
      sourceView = view;
    };

    this.onScheduleStatusChanged = function (item, status, schedule) {
      if (!item || !item.room || !item.room.id || !status) {
        return;
      }

      var roomId = item.room.id;
      var previousInfo = previousRoomsInfo[roomId] || {};
      var event = (schedule || {}).event || {};
      var previousEvent = previousInfo.event || {};
      var previousStatus = previousInfo.status;
      previousRoomsInfo[roomId] = previousInfo;
      notifyRoomStatusSubscribers(roomId, status);

      if ((previousStatus !== status || previousEvent.id !== event.id) && dataUtil.includesValue(RAISE_EVENT_STATUSES, status)) {
        raiseRoomStatusChanged(item.room, status);

        if (previousStatus === ROOM_STATUS.OCCUPIED) {
          raiseMeetingEvent(item.room, EXTERNAL_MEETING_TYPE.ENDED, getEvent(item.room, previousEvent));
        }

        if (status === ROOM_STATUS.OCCUPIED) {
          raiseMeetingEvent(item.room, EXTERNAL_MEETING_TYPE.STARTED, event);
        }
      }

      previousInfo.event = event;
      previousInfo.status = status;
    };

    function getEvent(room, event) {
      var currentRoom = currentRoomsInfo[room.id];

      if (!currentRoom || !currentRoom.events) {
        return;
      }

      return $filter('filter')(currentRoom.events, function (obj) {
        return obj.id === event.id;
      })[0];
    }

    function notifyRoomStatusSubscribers(roomId, status) {
      if (!roomStatusObservables[roomId]) {
        roomStatusObservables[roomId] = new DataBehavior({});
      }

      roomStatusObservables[roomId].onChange({
        status: status,
        roomId: roomId
      });
    }

    function raiseRoomStatusChanged(room, status) {
      raisePostMessage(POST_MESSAGES.STATUS_CHANGED, {
        roomId: room.id,
        status: status
      });
    }

    function raiseMeetingEvent(room, type, event) {
      raisePostMessage(POST_MESSAGES.MEETING_EVENT, {
        roomId: room.id,
        type: type,
        meeting: toExternalEvent(room, event)
      });
    }

    function onRoomsDataChanged(data) {
      if (!data) {
        return;
      }

      var rooms = data.rooms;

      if (!dataUtil.isArray(rooms)) {
        return;
      }

      for (var i = 0; i < rooms.length; i++) {
        var room = rooms[i];

        if (!room || !room.id) {
          continue;
        }

        var currentRoom = currentRoomsInfo[room.id];

        if (!currentRoom || !dataUtil.isObjectEqual(room, currentRoom.room)) {
          raisePostMessage(POST_MESSAGES.ROOM_CHANGED, toExternalRoom(room));
        }

        currentRoomsInfo[room.id] = currentRoomsInfo[room.id] || {};
        currentRoomsInfo[room.id].room = $angular.copy(room);
      }

      updateRoomsInfo();
    }

    function updateRoomsInfo() {
      roomsInfo = {};

      for (var id in currentRoomsInfo) {
        roomsInfo[id] = $angular.copy(currentRoomsInfo[id].room);
      }

      roomsInfoObservable.onChange(roomsInfo);
    }

    function setRoomInfo(data, message) {
      if (!data || !data.room || !dataUtil.isArray(data.events)) {
        return;
      }

      currentRoomsInfo[data.room.id] = {
        room: data.room,
        events: data.events
      };
      raisePostMessage(message, toExternalDataRetrieved(data.room, data.events));
    }

    function onEventRefreshed(data) {
      setRoomInfo(data, POST_MESSAGES.MEETING_DATA_REFRESHED);
    }

    function onEventRetrieved(data) {
      setRoomInfo(data, POST_MESSAGES.MEETING_DATA_RETRIEVED);
    }

    function onBookingActionExecuted(data) {
      if (!data || !data.action || !data.room || !data.event) {
        return;
      }

      raisePostMessage(POST_MESSAGES.BOOKING_EXECUTED, toExternalAction(data.action, data.room, data.event));
    }

    function getTodayEvents(events) {
      var today = new Date();
      return $filter('filter')(events, function (event) {
        return timeUtil.isSameDate(today, event.start);
      });
    }

    function getCurrentEvent(events, startBufferTime) {
      var currentTime = new Date().getTime();
      return $filter('filter')(events, function (event) {
        var eventStart = event.start.getTime() - (startBufferTime || 0);
        return currentTime >= eventStart && currentTime < event.end.getTime();
      })[0];
    }

    function toExternalDataRetrieved(room, events) {
      return {
        roomId: room.id,
        meetings: toExternalEvents(room, events)
      };
    }

    function toExternalEvent(room, event) {
      if (!event) {
        return {};
      }

      return {
        id: event.id,
        title: event.title,
        start: timeUtil.getStringFromDate(event.start),
        end: timeUtil.getStringFromDate(event.end),
        startInUtc: timeUtil.getUtcStringFromDate(event.start),
        endInUtc: timeUtil.getUtcStringFromDate(event.end),
        organizer: event.organizerUsername || room.email,
        isCheckedIn: event.isCheckedIn,
        isEditable: event.isEditable || !room.isReadOnly,
        isAllDay: event.isAllDay
      };
    }

    function toExternalEvents(room, events) {
      var externalEvents = [];

      for (var i = 0; i < events.length; i++) {
        externalEvents.push(toExternalEvent(room, events[i]));
      }

      return externalEvents;
    }

    function toExternalTodayEvents(room, events) {
      return {
        room: {
          id: room.id,
          meetings: toExternalEvents(room, getTodayEvents(events))
        }
      };
    }

    function toExternalAction(action, room, event) {
      return {
        action: action,
        roomId: room.id,
        meeting: toExternalEvent(room, event)
      };
    }

    function toExternalRoomEvent(room, events) {
      return {
        room: {
          id: room.id,
          meeting: toExternalEvent(room, getCurrentEvent(events))
        }
      };
    }

    function toExternalRoom(room) {
      return {
        room: {
          id: room.id,
          name: room.name,
          displayName: room.displayName,
          email: room.email,
          providerFacilities: room.providerFacilities,
          isReadOnly: room.isReadOnly,
          direction: room.direction
        }
      };
    }

    function raiseEventPostMessage(event, data) {
      postMessageManager.raiseMessage({
        event: event,
        data: data
      });
    }

    function getAllRoomsInfo(transformCallback) {
      var allRoomsInfo = [];

      for (var key in currentRoomsInfo) {
        var currentRoom = currentRoomsInfo[key];
        allRoomsInfo.push(transformCallback(currentRoom.room, currentRoom.events));
      }

      return allRoomsInfo;
    }

    function raiseRoomsInfo(command, data, event, errorMessage, transformCallback) {
      var roomIds = $angular.copy(data || {}).roomId; // Retrieve all rooms if roomId is undefined or an empty array

      if (!roomIds || roomIds.length === 0) {
        raiseEventPostMessage(event, getAllRoomsInfo(transformCallback));
        return $q.resolve();
      }

      var roomsInfo = [];
      var isRoomIdsArray = dataUtil.isArray(roomIds); // Convert roomIds to array if it's a single room id

      if (!isRoomIdsArray) {
        roomIds = [roomIds];
      }

      for (var i = 0; i < roomIds.length; i++) {
        var roomId = roomIds[i];

        if (dataUtil.isNullOrUndefined(roomId)) {
          logFailedAction(errorMessage, ['', 'undefined room id']);
          continue;
        }

        var commandInfo = getCommandInfo(roomId, command);

        if (commandInfo.error) {
          logFailedAction(errorMessage, [roomId, commandInfo.error]);
          continue;
        }

        roomsInfo.push(transformCallback(commandInfo.room, commandInfo.events));
      } // All room id(s) are invalid


      if (!roomsInfo.length) {
        return $q.reject('No valid rooms');
      }

      raiseEventPostMessage(event, !isRoomIdsArray ? roomsInfo[0] : roomsInfo);
      return $q.resolve();
    }

    function raiseTodaySchedule(data) {
      return raiseRoomsInfo(COMMANDS.GET_TODAY_SCHEDULE, data, POST_MESSAGES.TODAY_SCHEDULE, 'Unable to get today\'s schedule in room {0}: {1}', toExternalTodayEvents);
    }

    function raiseCurrentRoom(data) {
      return raiseRoomsInfo(COMMANDS.GET_CURRENT_ROOM, data, POST_MESSAGES.CURRENT_ROOM, 'Unable to get room {0}: {1}', toExternalRoom);
    }

    function raiseCurrentEvent(data) {
      return raiseRoomsInfo(COMMANDS.GET_CURRENT_MEETING, data, POST_MESSAGES.CURRENT_MEETING, 'Unable to get current event in room {0}: {1}', toExternalRoomEvent);
    }

    function toExternalRoomStatus(room, events) {
      var currentEvent = getCurrentEvent(events, CHECK_IN_PERIOD);
      var status = EXTERNAL_ROOM_STATUS.AVAILABLE;

      if (currentEvent) {
        status = currentEvent.isCheckedIn ? EXTERNAL_ROOM_STATUS.OCCUPIED : EXTERNAL_ROOM_STATUS.CHECK_IN;
      }

      return {
        room: {
          id: room.id,
          status: status
        }
      };
    }

    function raiseCurrentStatus(data) {
      return raiseRoomsInfo(COMMANDS.GET_CURRENT_STATUS, data, POST_MESSAGES.CURRENT_STATUS, 'Unable to get current status in room {0}: {1}', toExternalRoomStatus);
    }

    function logFailedRoomSelecting(message) {
      return logFailedAction('Unable to select room: {0}.', message);
    }

    function selectRoom(data) {
      if (!data) {
        return $q.reject(logFailedRoomSelecting('data is not specified'));
      } // Don't attempt to select room if room doesn't exist in current rooms collection


      if (!currentRoomsInfo[data.roomId]) {
        return $q.reject(logFailedRoomSelecting('invalid room id'));
      }

      selectedRoomIdObservable.onChange(data.roomId);
      return $q.resolve();
    }

    function unselectRoom() {
      selectedRoomIdObservable.onChange();
      return $q.resolve();
    }

    function createEvent(data) {
      if (!data) {
        return $q.reject(logFailedEventBooking('data is not specified'));
      }

      var durationInMiliseconds = data.durationInMiliseconds;
      var roomId = data.roomId; // Don't attempt to book event if there's no duration or room id specified

      if (!durationInMiliseconds || dataUtil.isNullOrUndefined(roomId)) {
        return $q.reject(logFailedEventBooking('duration or room id is not specified'));
      } // Assume start time to be current time if it's not defined


      var eventStart = data.start || new Date().getTime();
      eventStart = new Date(eventStart); // Don't book advanced event if start time is invalid

      if (!timeUtil.isDate(eventStart)) {
        return $q.reject(logFailedEventBooking('start time is invalid'));
      }

      var commandInfo = getCommandInfo(roomId, COMMANDS.BOOK);

      if (!commandInfo.isValid) {
        return $q.reject(logFailedEventBooking(commandInfo.error));
      }

      var eventTitle = data.title || TEXT_RESOURCE.DIALOG_BOOK_PLACEHOLDER.value;
      var eventEnd = new Date(eventStart.getTime() + durationInMiliseconds);
      return calendarDataManager.createEvent(commandInfo.room, eventTitle, eventStart, eventEnd);
    }

    function logFailedEventBooking(message) {
      return logFailedAction('Unable to book event: {0}.', message);
    }

    function checkIn(data) {
      if (!data) {
        return $q.reject(logFailedCheckIn('data is not specified'));
      }

      var roomId = data.roomId; // Don't attempt to end event if there's no room id specified

      if (dataUtil.isNullOrUndefined(roomId)) {
        return $q.reject(logFailedCheckIn('room id is not specified'));
      }

      var commandInfo = getCommandInfo(roomId, COMMANDS.END);

      if (!commandInfo.isValid) {
        return $q.reject(logFailedCheckIn(commandInfo.error));
      } // Check if there is current ongoing event for that particular room


      var event = getCurrentEvent(commandInfo.events, CHECK_IN_PERIOD);

      if (!event) {
        return $q.reject(logFailedCheckIn('no ongoing event'));
      }

      return calendarDataManager.checkIn(commandInfo.room, event);
    }

    function logFailedCheckIn(message) {
      return logFailedAction('Unable to check-in event: {0}.', message);
    }

    function endEvent(data) {
      if (!data) {
        return $q.reject(logFailedEventEnding('data is not specified'));
      }

      var roomId = data.roomId; // Don't attempt to end event if there's no room id specified

      if (dataUtil.isNullOrUndefined(roomId)) {
        return $q.reject(logFailedEventEnding('room id is not specified'));
      }

      var commandInfo = getCommandInfo(roomId, COMMANDS.END);

      if (!commandInfo.isValid) {
        return $q.reject(logFailedEventEnding(commandInfo.error));
      } // Check if there is current ongoing event for that particular room


      var event = getCurrentEvent(commandInfo.events);

      if (!event) {
        return $q.reject(logFailedEventEnding('no ongoing event'));
      }

      return calendarDataManager.end(commandInfo.room, event);
    }

    function logFailedEventEnding(message) {
      return logFailedAction('Unable to end event: {0}.', message);
    }

    function extendEvent(data) {
      if (!data) {
        return $q.reject(logFailedEventExtension('data is not specified'));
      }

      var durationInMiliseconds = data.durationInMiliseconds;
      var roomId = data.roomId; // Don't attempt to extend event if there's no duration or room id specified

      if (!durationInMiliseconds || dataUtil.isNullOrUndefined(roomId)) {
        return $q.reject(logFailedEventExtension('duration or room id is not specified'));
      }

      var commandInfo = getCommandInfo(roomId, COMMANDS.EXTEND);

      if (!commandInfo.isValid) {
        return $q.reject(logFailedEventExtension(commandInfo.error));
      } // Check if there is current ongoing event for that particular room


      var event = getCurrentEvent(commandInfo.events);

      if (!event) {
        return $q.reject(logFailedEventExtension('no ongoing event'));
      }

      var eventEnd = new Date(event.end.getTime() + durationInMiliseconds);
      return calendarDataManager.extend(commandInfo.room, event, eventEnd);
    }

    function logFailedEventExtension(message) {
      return logFailedAction('Unable to extend event: {0}.', message);
    }

    function renameEvent(data) {
      if (!data) {
        return $q.reject(logFailedEventRenaming('data is not specified'));
      }

      var title = data.title;
      var roomId = data.roomId; // Don't attempt to rename event if there's no title or room id specified

      if (textUtil.isNullOrWhiteSpace(title) || dataUtil.isNullOrUndefined(roomId)) {
        return $q.reject(logFailedEventRenaming('title or room id is not specified'));
      }

      var commandInfo = getCommandInfo(roomId, COMMANDS.RENAME);

      if (!commandInfo.isValid) {
        return $q.reject(logFailedEventRenaming(commandInfo.error));
      } // Check if there is current ongoing event for that particular room


      var event = getCurrentEvent(commandInfo.events);

      if (!event) {
        return $q.reject(logFailedEventRenaming('no ongoing event'));
      }

      if (event.title === title) {
        return $q.reject(logFailedEventRenaming('new title is the same as the current title'));
      }

      return calendarDataManager.rename(commandInfo.room, event, textUtil.trim(title));
    }

    function logFailedEventRenaming(message) {
      return logFailedAction('Unable to rename event: {0}.', message);
    }

    function logFailedAction(message, params) {
      var errorMessage = formatText(message, params);
      logManager.debug(errorMessage);
      return errorMessage;
    }

    function getCommandInfo(roomId, command) {
      var result = {
        isValid: false
      };
      var roomInfo = currentRoomsInfo[roomId]; // Check if room exists in current list of rooms

      if (!roomInfo || !roomInfo.room) {
        result.error = 'invalid room id';
        return result;
      } // Check if command is supported for read-only room


      if (roomInfo.room.isReadOnly && READ_ONLY_ENABLED_COMMANDS.indexOf(command) === -1) {
        result.error = formatText('Command [{0}] is not supported for read-only room', command);
        return result;
      }

      result.isValid = true;
      result.room = roomInfo.room;
      result.events = roomInfo.events;
      return result;
    }

    function raisePostMessage(event, data) {
      postMessageManager.raiseMessage({
        event: event,
        data: data
      });
    }

    function onCommandSuccess(data, command) {
      raisePostMessage(POST_MESSAGES.COMMAND_EXECUTED, {
        data: data,
        command: command,
        result: POST_MESSAGES.COMMAND_RESULT_SUCCESS
      });
    }

    function onCommandFailure(data, command, error) {
      raisePostMessage(POST_MESSAGES.COMMAND_EXECUTED, {
        data: data,
        command: command,
        result: POST_MESSAGES.COMMAND_RESULT_FAILURE,
        error: JSON.stringify(error)
      });
    }

    function onCommandMessageReceived(event) {
      if (!commandUtil.isCommandEventValid(event)) {
        return;
      }

      var command = event.command.toLowerCase();
      var executeCommand = BOOKING_COMMAND_ACTION[command];
      var rawData = event.data;
      var eventData = $angular.copy(rawData);

      if (eventData) {
        if (eventData.durationInMinutes) {
          eventData.durationInMiliseconds = timeUtil.getMilisecondsFromMinutes(eventData.durationInMinutes);
        }
      }

      raisePostMessage(POST_MESSAGES.COMMAND_RECEIVED, {
        data: rawData,
        command: command
      });
      executeCommand(eventData).then(function () {
        onCommandSuccess(rawData, command);
      }, function (error) {
        onCommandFailure(rawData, command, error);
      });
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('interactivityManager', ["$window", "$timeout", "$q", "MODEL_INPUT_KEYS", "IDLE_EVENT", "configurationManager", "DataBehavior", function ($window, $timeout, $q, MODEL_INPUT_KEYS, IDLE_EVENT, configurationManager, DataBehavior) {
    var isReadyPromise = $q.defer();
    var isInteractedFlag = false;
    var isStartedFlag = false;
    var idleMappings = {};
    idleMappings[IDLE_EVENT.VIEW] = MODEL_INPUT_KEYS.IDLE_TIMEOUT;
    idleMappings[IDLE_EVENT.AUTO_RESET] = MODEL_INPUT_KEYS.AUTO_RESET_TIMEOUT;
    var idleTimeoutPromises = {};
    var idleTimeoutDuration = {};
    var subscribers = [];
    var onIdleEventObservable = {};

    function isReady() {
      return isReadyPromise.promise;
    }

    function start() {
      if (isStartedFlag) {
        return;
      }

      isStartedFlag = true;
      configurationManager.isReady().then(function () {
        for (var key in idleMappings) {
          var value = configurationManager.getInputModel(idleMappings[key]);

          if (!value) {
            continue;
          }

          idleTimeoutDuration[key] = value;
          onIdleEventObservable[key] = new DataBehavior();
        }

        if ('ontouchstart' in $window) {
          $window.addEventListener('touchstart', onTouch);
        }

        $window.addEventListener('mousedown', onTouch);

        if ('onscroll' in $window) {
          $window.addEventListener('scroll', onTouch, true);
        }

        isReadyPromise.resolve();
      });
    }

    function stop() {
      if (!isStartedFlag) {
        return;
      }

      isStartedFlag = false;

      if ('ontouchstart' in $window) {
        $window.removeEventListener('touchstart', onTouch);
      }

      $window.removeEventListener('mousedown', onTouch);

      if ('onscroll' in $window) {
        $window.removeEventListener('scroll', onTouch, true);
      }
    }

    function isStarted() {
      return isStartedFlag;
    }

    function isInteracted() {
      return isInteractedFlag;
    }

    function onTouch() {
      isInteractedFlag = true;
      notifySubscribers();
      resetIdleTimeout();
    }

    function cancelIdleTimeout() {
      for (var key in idleTimeoutPromises) {
        if (!idleTimeoutPromises[key]) {
          continue;
        }

        $timeout.cancel(idleTimeoutPromises[key]);
        delete idleTimeoutPromises[key];
      }
    }

    function resetIdleTimeout() {
      cancelIdleTimeout();

      for (var key in idleTimeoutDuration) {
        createTimeout(key, idleTimeoutDuration[key]);
      }
    }

    function createTimeout(key, duration) {
      idleTimeoutPromises[key] = $timeout(function () {
        onIdleEventObservable[key].onChange(new Date().getTime());
      }, duration);
    }

    function subscribe(callback) {
      if (!callback || subscribers.indexOf(callback) > -1) {
        return false;
      }

      subscribers.push(callback);
      return true;
    }

    function unsubscribe(callback) {
      var index = subscribers.indexOf(callback);

      if (index === -1) {
        return false;
      }

      subscribers.splice(index, 1);
      return true;
    }

    function notifySubscribers() {
      for (var i = 0; i < subscribers.length; i++) {
        subscribers[i]();
      }
    }

    function subscribeToIdleEvent(key, callback) {
      var observable = onIdleEventObservable[key];

      if (!observable) {
        return;
      }

      return observable.subject.subscribe(callback);
    }

    return {
      isReady: isReady,
      start: start,
      stop: stop,
      isStarted: isStarted,
      isInteracted: isInteracted,
      subscribeToIdleEvent: subscribeToIdleEvent,
      subscribe: subscribe,
      unsubscribe: unsubscribe
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('logManager', ["textUtil", "loggerFactory", function (textUtil, loggerFactory) {
    var logger = loggerFactory.getLogger();

    function log(type, message, params) {
      if (!logger || !logger[type]) {
        return;
      }

      logger[type](textUtil.formatText(message, params));
    }

    function debug(message, params) {
      log('debug', message, params);
    }

    function info(message, params) {
      log('info', message, params);
    }

    function warn(message, params) {
      log('warn', message, params);
    }

    function error(message, params) {
      log('error', message, params);
    }

    return {
      debug: debug,
      info: info,
      warn: warn,
      error: error
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('mapManager', function ($q, $filter, ROOM_FACILITIES, DataBehavior, dataUtil, mapDataManager, calendarDataManager) {
    var mapObservables = new DataBehavior([]);
    var locationObservables = new DataBehavior({});
    var roomsInfoObservables = new DataBehavior({});
    var mapServiceStateObservables = new DataBehavior();
    var map;
    var currentRoomIds = [];
    var mapSubscription;
    var currentRooms = {};
    var currentLocation = {};
    var hasStartedPromise;
    var POINT_COORDINATES_SIZE = 2;
    var poiIdentifierKey;
    var PASSPORT_CONFIGURED_KEY = 'providerRoomId';
    var MANUAL_CONFIGURED_KEY = 'email';
    var RESERVATION_CONFIGURED_KEY = 'id';
    var DEFAULT_POI_COLOR = '#a8bccd';

    function onMapChanged(newMap) {
      map = newMap;
      processRoomsMap();
    }

    function processFacilities(poi) {
      var facilities = {};

      if (poi.metadata) {
        var capacityKey = ROOM_FACILITIES.CAPACITY;

        if (poi.metadata[capacityKey]) {
          facilities[capacityKey] = parseInt(poi.metadata[capacityKey]);
        }
      }

      var poiFacilities = poi.facilities || [];

      for (var j = 0; j < poiFacilities.length; j++) {
        var facility = poiFacilities[j].type;

        if (!facility) {
          continue;
        }

        var mappedFacility = ROOM_FACILITIES[facility.toUpperCase()];

        if (!mappedFacility) {
          continue;
        }

        facilities[mappedFacility] = true;
      }

      return facilities;
    }

    function fillPointsOfInterest(pointsOfInterest) {
      if (!pointsOfInterest || !pointsOfInterest.length) {
        return;
      }

      for (var j = 0; j < pointsOfInterest.length; j++) {
        // Fill POI with default POI color
        var pointOfInterest = pointsOfInterest[j];

        if (!pointOfInterest) {
          continue;
        }

        pointOfInterest.style = {
          fill: DEFAULT_POI_COLOR
        };
      }
    }

    function processPointsOfInterest() {
      if (!map) {
        return;
      }

      for (var i = 0; i < map.length; i++) {
        if (!map[i]) {
          continue;
        }

        fillPointsOfInterest(map[i].pointOfInterests);
      }
    }

    function processRoomsMap() {
      processPointsOfInterest();
      currentRooms = {};

      for (var i = 0; i < currentRoomIds.length; i++) {
        var roomId = currentRoomIds[i];

        if (!roomId) {
          continue;
        }

        currentRooms[roomId] = {};
        var locationInfo = searchFloorByPoi(roomId, undefined, mapPoiByRoomId);
        currentRooms[roomId].locationInfo = locationInfo;

        if (!locationInfo) {
          continue;
        }

        var roomPoi = locationInfo.floor.pointOfInterests[locationInfo.poiIndex];
        currentRooms[roomId].facilities = processFacilities(roomPoi);
        currentRooms[roomId].identifier = roomPoi.identifier;
        currentRooms[roomId].floorName = locationInfo.floor.name;
      }

      mapObservables.onChange($angular.copy(map));
      roomsInfoObservables.onChange(currentRooms);
      processCurrentLocation();
    }

    function onRoomIdsChanged(roomIds) {
      if (mapSubscription) {
        mapSubscription.dispose();
        mapSubscription = undefined;
      }

      currentRoomIds = roomIds || [];
      mapSubscription = mapDataManager.subscribeToMap(roomIds, onMapChanged);
    }

    function processCurrentLocation() {
      // Maps haven't been processed yet
      if (dataUtil.isObjectEmpty(currentRooms)) {
        locationObservables.onChange();
        return;
      } // Check if location POI exists


      var location = searchFloorByPoiId(currentLocation.locationId);

      if (location) {
        // If POI is not a "point", convert it to a point by getting the center coordinates
        if (location.coordinates.length != POINT_COORDINATES_SIZE) {
          location.coordinates = dataUtil.getCenterCoordinates(location.coordinates[0]);
        }

        if (location.coordinates) {
          locationObservables.onChange(location);
          return;
        }
      } // Location POI is invalid and location info is unavailable


      if (!currentLocation.location) {
        locationObservables.onChange();
        return;
      } // Check if floor number exists


      var locationInfo = currentLocation.location;
      var floor = getFloorByFloorNumber(locationInfo.floorNumber);

      if (!floor) {
        locationObservables.onChange();
        return;
      }

      var coordinates = locationInfo.coordinates; // Coordinates are invalid if they're not made up of
      // 2 numbers in an array

      if (dataUtil.isNotArrayOrEmpty(coordinates) || coordinates.length != POINT_COORDINATES_SIZE || isNaN(coordinates[0]) || isNaN(coordinates[1])) {
        locationObservables.onChange();
        return;
      }

      locationObservables.onChange({
        coordinates: coordinates,
        floorNumber: floor.floorNumber,
        floorId: floor.id
      });
    }

    function onCurrentLocationChanged(location) {
      currentLocation = location;
      processCurrentLocation();
    }

    function onMapServiceStateChanged(connection) {
      mapServiceStateObservables.onChange(connection);
    }

    function start() {
      if (hasStartedPromise) {
        return hasStartedPromise.promise;
      }

      hasStartedPromise = $q.defer();
      calendarDataManager.isReady().then(function () {
        calendarDataManager.subscribeToProviderRoomIdsChanged(onRoomIdsChanged);
        mapDataManager.subscribeToCurrentLocation(onCurrentLocationChanged);
        poiIdentifierKey = calendarDataManager.getMapRoomIdentifier();
        mapDataManager.subscribeToMapServiceState(onMapServiceStateChanged);
        hasStartedPromise.resolve();
      });
      return hasStartedPromise.promise;
    }

    function getFloorByRoomId(roomId, floorsToSearch) {
      if (!roomId) {
        return;
      } // If floors to search are not specified, look up floor info through current rooms collection


      return !floorsToSearch ? (currentRooms[roomId] || {}).locationInfo : searchFloorByPoi(roomId, floorsToSearch, mapPoiByRoomId);
    }

    function mapPoiByRoomId(poiIndex, floorIndex, poi, floor, roomId) {
      if (!poi || !poi.calendarResource) {
        return;
      } // if POI is passport-configured but poiIdentifierKey does not match room id or 
      // POI is manual-configured but email does not match roomId


      if (!poi.calendarResource[PASSPORT_CONFIGURED_KEY] && poi.calendarResource[MANUAL_CONFIGURED_KEY] != roomId && poi.calendarResource[RESERVATION_CONFIGURED_KEY] != roomId || poi.calendarResource[PASSPORT_CONFIGURED_KEY] && (!poiIdentifierKey || poi.calendarResource[poiIdentifierKey] != roomId)) {
        return;
      }

      poi.roomId = roomId; // Use identifier to label POI if name is not defined

      poi.name = poi.name || poi.identifier;
      return {
        floor: floor,
        poiIndex: poiIndex,
        floorIndex: floorIndex
      };
    }

    function mapPoiByPoiId(poiIndex, floorIndex, poi, floor, poiId) {
      if (!poi || poi.id != poiId) {
        return;
      }

      return {
        floorNumber: floor.floorNumber,
        floorId: floor.id,
        coordinates: poi.geoJSON.geometry.coordinates
      };
    }

    function searchFloorByPoi(value, floorsToSearch, mapPoiCallback) {
      if (!value) {
        return;
      } // Use current map data if floors to search are not specified


      floorsToSearch = floorsToSearch || map;

      if (!floorsToSearch || !floorsToSearch.length) {
        return;
      }

      for (var i = 0; i < floorsToSearch.length; i++) {
        // Go through each floor's POIs
        var floor = floorsToSearch[i];
        var pois = floor.pointOfInterests;

        if (!pois) {
          continue;
        }

        for (var j = 0; j < pois.length; j++) {
          // Go through each POI to match calendar resource room id with room id
          var poi = pois[j];
          var mappedPoi = mapPoiCallback(j, i, poi, floor, value);

          if (!mappedPoi) {
            continue;
          }

          return mappedPoi;
        }
      }
    }

    function getFloorByProperty(floorsToSearch, property, value) {
      floorsToSearch = floorsToSearch || map;

      if (!floorsToSearch || !floorsToSearch.length) {
        return;
      }

      return $filter('filter')(floorsToSearch, function (floor) {
        return floor[property] === value;
      })[0];
    }

    function searchFloorByPoiId(poiId, floorsToSearch) {
      return searchFloorByPoi(poiId, floorsToSearch, mapPoiByPoiId);
    }

    function getFloorByFloorNumber(floorNumber, floorsToSearch) {
      return getFloorByProperty(floorsToSearch, 'floorNumber', floorNumber);
    }

    this.start = start;
    this.getLocationInfoByRoomId = getFloorByRoomId;

    this.subscribeToMapChanged = function (callback) {
      return mapObservables.subject.subscribe(callback);
    };

    this.subscribeToCurrentLocationChanged = function (callback) {
      return locationObservables.subject.subscribe(callback);
    };

    this.subscribeToRoomsInfoChanged = function (callback) {
      return roomsInfoObservables.subject.subscribe(callback);
    };

    this.subscribeToMapServiceStateChanged = function (callback) {
      return mapServiceStateObservables.subject.subscribe(callback);
    };

    this.getFloorByFloorId = function (floorId, floorsToSearch) {
      return getFloorByProperty(floorsToSearch, 'id', floorId);
    };

    this.restartMapService = function () {
      onRoomIdsChanged(currentRoomIds);
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').service('postMessageManager', function (cardApiFactory, logManager, POST_MESSAGES, configurationManager) {
    var cardApi = cardApiFactory.getApi();

    function subscribeToMessages(callback) {
      if (!callback) {
        return;
      }

      return configurationManager.subscribeToMessages(callback);
    }

    function subscribeToPostMessages(callback) {
      if (!callback) {
        return;
      }

      return configurationManager.subscribeToPostMessages(callback);
    }

    function raiseMessage(message) {
      raisePostMessage(message, function (data, event) {
        return {
          message: POST_MESSAGES.MESSAGE,
          card: POST_MESSAGES.CARD_NAME,
          event: event,
          data: data
        };
      });
    }

    function raisePostMessage(message, callback) {
      if (!message || !message.event || !message.data) {
        return;
      }

      var postMessage = callback(message.data, message.event);
      cardApi.postMessage(postMessage);
      logManager.debug('Posting post message: ' + JSON.stringify(postMessage));
    }

    return {
      subscribeToMessages: subscribeToMessages,
      subscribeToPostMessages: subscribeToPostMessages,
      raiseMessage: raiseMessage
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('roomDataSetManager', ["$injector", "configurationManager", "DataBehavior", "dataUtil", "MODEL_INPUT_KEYS", "PLAYER_PROPERTY_KEYS", "SYSTEM_DATA", function ($injector, configurationManager, DataBehavior, dataUtil, MODEL_INPUT_KEYS, PLAYER_PROPERTY_KEYS, SYSTEM_DATA) {
    var ROOM_ID_DEFAULT_INDEX = 0;
    var roomIdIndex = ROOM_ID_DEFAULT_INDEX;
    var currentLocation = '';
    var roomInfoMappings = [];
    var roomsMapMappings = {};
    var subscribers = [];
    var roomsInfoMappingObservable = new DataBehavior({
      locations: [],
      names: []
    });
    var dataSetHeader = [];

    function getMappingByField(field, sourceField) {
      var mapping = [];

      for (var key in roomsMapMappings) {
        var room = roomsMapMappings[key];

        if (!room) {
          continue;
        }

        var mappedRoom = {
          roomId: key
        };
        mappedRoom[field] = room[sourceField];
        mapping.push(mappedRoom);
      }

      return mapping;
    }

    function updateRoomsFacilities() {
      return getMappingByField('roomFacilities', 'facilities');
    }

    function updateRoomsNumber() {
      return getMappingByField('roomNumber', 'identifier');
    }

    function updateRoomsFloorName() {
      return getMappingByField('floorName', 'floorName');
    }

    function onRoomsMapInfoChanged(rooms) {
      roomsMapMappings = rooms || {};
      onRoomsInfoMappingUpdated(false, true);
    }

    function onLocationChanged(location) {
      currentLocation = location;
      onRoomsInfoMappingUpdated();
    }

    function onRoomsDataSetChanged(dataSet) {
      if (!dataUtil.isArray(dataSet)) {
        return;
      }

      roomInfoMappings = dataSet; // Just reset rooms name if rooms location directory is empty

      if (dataSet.length == 0) {
        onRoomsInfoMappingUpdated(true);
        return;
      } // Use angular copy to avoid modifying the original data due to referencing


      dataSetHeader = $angular.copy(dataSet[0]);
      roomIdIndex = getRoomIdIndex();

      for (var i = 0; i < dataSetHeader.length; i++) {
        // Lowercase the room locations for case insensitive comparison
        dataSetHeader[i] = (dataSetHeader[i] || '').toLowerCase();
      }

      roomInfoMappings = dataSet;
      onRoomsInfoMappingUpdated();
    }

    function getRoomIdIndex() {
      // To determine which column of data we should refer to based on the reserved word
      var idIndex = dataSetHeader.indexOf(SYSTEM_DATA.ROOM_ID_MAPPING_HEADER); // The reserved word does exist in the header of the rooms info mapping

      return idIndex !== -1 ? idIndex : ROOM_ID_DEFAULT_INDEX;
    }

    function updateRoomsName() {
      var mapping = []; // There's no defined rooms mapping info

      if (!roomInfoMappings || !roomInfoMappings.length) {
        return mapping;
      } // To determine which column of data we should refer to based on the reserved word


      var nameIndex = dataSetHeader.indexOf(SYSTEM_DATA.ROOM_NAME_MAPPING_HEADER); // The reserved word does not exist in the header of the rooms info mapping

      if (nameIndex === -1) {
        return mapping;
      }

      for (var i = 1; i < roomInfoMappings.length; i++) {
        var roomInfo = roomInfoMappings[i];
        var roomId = roomInfo[roomIdIndex];
        var roomName = roomInfo[nameIndex] || '';

        if (!roomId || !roomName) {
          continue;
        }

        mapping.push({
          roomId: roomId,
          roomName: roomName
        });
      }

      return mapping;
    } // To produce a set of rooms location mapping based on the current location


    function updateRoomsLocation() {
      var mapping = []; // There's no current location or defined rooms location directory

      if (!currentLocation || !roomInfoMappings || !roomInfoMappings.length) {
        return mapping;
      } // To determine which column of data we should refer to based on the current location


      var currentLocationIndex = dataSetHeader.indexOf(currentLocation.toLowerCase()); // The current location is not in the rooms location directory

      if (currentLocationIndex == -1) {
        return mapping;
      }

      for (var i = 1; i < roomInfoMappings.length; i++) {
        var roomLocation = roomInfoMappings[i];
        var roomId = roomLocation[roomIdIndex];
        var direction = (roomLocation[currentLocationIndex] || '').toLowerCase(); // Skip adding to mapping if there's no room id or supported direction

        if (!roomId || SYSTEM_DATA.ROOM_DIRECTIONS.indexOf(direction) == -1) {
          continue;
        }

        mapping.push({
          roomId: roomId,
          direction: direction
        });
      }

      return mapping;
    }

    function onRoomsInfoMappingUpdated(reset, isTransparentUpdate) {
      var mappings = {
        names: [],
        locations: [],
        numbers: [],
        facilities: [],
        isTransparentUpdate: isTransparentUpdate
      };

      if (!reset) {
        mappings.names = updateRoomsName();
        mappings.locations = updateRoomsLocation();
        mappings.numbers = updateRoomsNumber();
        mappings.facilities = updateRoomsFacilities();
        mappings.floorNames = updateRoomsFloorName();
      }

      roomsInfoMappingObservable.onChange(mappings);
    }

    function subscribeToRoomDataSet(callback) {
      return roomsInfoMappingObservable.subject.subscribe(callback);
    }

    function getMapManager() {
      // To avoid circular dependency error
      return $injector.get('mapManager');
    }

    configurationManager.isReady().then(function () {
      var mapManager = getMapManager();
      subscribers.push(configurationManager.getPlayerPropertyObservable(PLAYER_PROPERTY_KEYS.LOCATION, '').subscribe(onLocationChanged));
      subscribers.push(configurationManager.getInputObservable(MODEL_INPUT_KEYS.ROOMS_LOCATION, []).subscribe(onRoomsDataSetChanged));
      subscribers.push(mapManager.subscribeToRoomsInfoChanged(onRoomsMapInfoChanged));
    });
    return {
      subscribeToRoomDataSet: subscribeToRoomDataSet
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').service('roomManager', function ($q, configurationManager, CUSTOM_DATA_KEY, TEXT_RESOURCE, dataUtil, timeUtil, calendarProviderFactory) {
    var calendarProvider;
    var currentAuthenticationData;
    var isReadyPromise = $q.defer();
    configurationManager.isReady().then(function () {
      configurationManager.subscribeToCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA, onReceivedAuthenticationData);
    });

    this.getAllRooms = function () {
      var promise = $q.defer();
      this.isReady().then(function () {
        if (!calendarProvider.getAllRooms) {
          return;
        }

        calendarProvider.getAllRooms().then(promise.resolve, promise.reject);
      });
      return promise.promise;
    };

    this.getRoom = function (roomId) {
      if (!roomId) {
        return $q.reject();
      }

      var promise = $q.defer();
      this.isReady().then(function () {
        if (!calendarProvider.getRoom || !calendarProvider.getEvents) {
          promise.reject();
          return;
        }

        var onRoomRetrieved = function onRoomRetrieved(room) {
          var dateRange = timeUtil.getEventsDateRange();

          if (calendarProvider.skipDelegationCheck) {
            promise.resolve(room);
            return;
          } // call getEvents to check whether the room is delegated or not


          calendarProvider.getEvents(room, dateRange.start, dateRange.end).then(function () {
            promise.resolve(room);
          }, function () {
            promise.reject(TEXT_RESOURCE.ROOMPICKER_UNDELEGATED_ROOM_ERROR.value);
          });
        };

        calendarProvider.getRoom(roomId).then(onRoomRetrieved, promise.reject);
      });
      return promise.promise;
    };

    this.saveSelectedRooms = function (selectedRooms) {
      var promise = $q.defer();
      configurationManager.updateCustomData(CUSTOM_DATA_KEY.ROOM_IDS, selectedRooms);
      configurationManager.subscribeToCustomData(CUSTOM_DATA_KEY.ROOM_IDS, function (roomIds) {
        if (!dataUtil.isObjectEqual(selectedRooms, roomIds)) {
          return;
        }

        promise.resolve();
      });
      return promise.promise;
    };

    this.isReady = function () {
      return isReadyPromise.promise;
    };

    function onReceivedAuthenticationData(data) {
      if (!data || dataUtil.isObjectEmpty(data) || dataUtil.isObjectEqual(currentAuthenticationData, data)) {
        isReadyPromise = $q.defer();
        return;
      }

      if (calendarProvider) {
        calendarProvider.dispose();
      }

      calendarProvider = calendarProviderFactory.getProvider(data.provider);

      if (!calendarProvider) {
        return;
      }

      currentAuthenticationData = data;
      calendarProvider.initialize();
      isReadyPromise.resolve();
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('storageManager', ["$q", "dataUtil", "storageFactory", "eventManager", "configurationManager", "calendarDataManager", function ($q, dataUtil, storageFactory, eventManager, configurationManager, calendarDataManager) {
    var storage;
    var cachedRoomIdsHash;
    var rooms;
    var isReadyPromise = $q.defer();
    var ROOM_IDS_STORAGE_KEY = 'ROOM_IDS_HASH';

    function init() {
      storage = storageFactory.getStorage();
      calendarDataManager.subscribeToRoomIdsChanged(onRoomIdsUpdated);
      eventManager.subscribeToRoomsInfo(onRoomsInfoUpdated);
      isReadyPromise.resolve();
    }

    function canProcess() {
      return Boolean(storage && cachedRoomIdsHash);
    }

    function purgeRoomsInfo() {
      var keys = storage.getKeys();

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (!key || key === ROOM_IDS_STORAGE_KEY) {
          continue;
        }

        storage.remove(key);
      }
    }

    function updateRoomsInfo() {
      if (!cachedRoomIdsHash) {
        return;
      }

      purgeRoomsInfo();

      for (var key in rooms) {
        var room = rooms[key];

        if (!room || !room.id) {
          continue;
        }

        storage.set(room.id, JSON.stringify(room));
      }
    }

    function onRoomsInfoUpdated(updatedRooms) {
      if (!updatedRooms || dataUtil.isObjectEmpty(updatedRooms)) {
        return;
      }

      rooms = updatedRooms;
      updateRoomsInfo();
    }

    function onRoomIdsUpdated(ids) {
      if (!ids) {
        return;
      }

      ids.sort();
      cachedRoomIdsHash = storage.get(ROOM_IDS_STORAGE_KEY);
      var idsHash = dataUtil.toHash(ids);

      if (idsHash === cachedRoomIdsHash || !storage) {
        return;
      }

      var keys = storage.getKeys(); // Clear storage if room IDs have changed

      for (var i = 0; i < keys.length; i++) {
        storage.remove(keys[i]);
      }

      storage.set(ROOM_IDS_STORAGE_KEY, idsHash);
      cachedRoomIdsHash = idsHash;
    }

    function getRooms() {
      var cachedRooms = {};

      if (!canProcess()) {
        return cachedRooms;
      }

      var keys = storage.getKeys();

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (!key || key === ROOM_IDS_STORAGE_KEY) {
          continue;
        }

        cachedRooms[key] = JSON.parse(storage.get(key));
      }

      return cachedRooms;
    }

    function isReady() {
      return isReadyPromise.promise;
    }

    configurationManager.isReady().then(init);
    return {
      isReady: isReady,
      getRooms: getRooms
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('textResourceManager', ["textUtil", "TEXT_RESOURCE", function (textUtil, TEXT_RESOURCE) {
    function getTextResource(key) {
      return TEXT_RESOURCE[key] ? TEXT_RESOURCE[key].value : undefined;
    }

    function getFormat(textResource, defaultValue) {
      textResource = textResource || {};
      return getTextResource(textResource.key) || textResource.key || defaultValue || '';
    }

    function getText(key, params) {
      var format = getFormat(key, '');
      return textUtil.formatText(format, params);
    }

    return {
      getText: getText
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.service('timeManager', ["$filter", "$interval", "timeUtil", function ($filter, $interval, timeUtil) {
    var subscribers = [];

    function init() {
      $interval(executeMainTimer, 1000);
    }

    function executeMainTimer() {
      var currentdate = new Date();
      var subs = findSubsribers(currentdate);

      for (var i = 0; i < subs.length; i++) {
        var sub = subs[i];
        sub.isCalled = true;
        removeSubscriber(sub.id);
        sub.callback(new Date(currentdate.getTime()));
      }
    }

    function register(callbackId, callback, callInDate) {
      removeSubscriber(callbackId);
      var newDate = timeUtil.resetDate(callInDate);
      subscribers.push({
        id: callbackId,
        callback: callback,
        callInDate: newDate,
        isCalled: false
      });
    }

    function unregister(callbackId) {
      removeSubscriber(callbackId);
    }

    function removeSubscriber(subscriberId) {
      for (var i = 0; i < subscribers.length; i++) {
        var sub = subscribers[i];

        if (sub.id == subscriberId) {
          subscribers.splice(i, 1);
          break;
        }
      }
    }

    function findSubsribers(date) {
      return $filter('filter')(subscribers, function (value, index, array) {
        return !value.isCalled && date.getTime() >= value.callInDate.getTime();
      });
    }

    init();
    return {
      register: register,
      unregister: unregister
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('AppStorage', ["appCoreFactory", "storageHelperFactory", function (appCoreFactory, storageHelperFactory) {
    var storage;

    function AppStorage() {
      var storageUtil = storageHelperFactory.get();
      var services = appCoreFactory.getCore().getServices();
      storage = services.storage.storageLocalStorageService.content;
      var collectionName = storageUtil.getCollectionName();
      this.type = 'AppStorage';

      this.set = function (key, value) {
        storage.set(collectionName, key, value);
      };

      this.get = function (key) {
        return storage.get(collectionName, key);
      };

      this.remove = function (key) {
        storage.removeKey(collectionName, key);
      };

      this.getKeys = function () {
        var collection = storage.getKeys(collectionName);
        var keys = [];

        for (var i = 0; i < collection.length; i++) {
          keys.push(collection[i].key);
        }

        return keys;
      };
    } // static methods


    AppStorage.isAvailable = function () {
      var core = appCoreFactory.getCore();

      if (!core || !core.getServices) {
        return false;
      }

      var services = core.getServices();
      return Boolean(services && services.storage && services.storage.storageLocalStorageService && services.storage.storageLocalStorageService.content);
    }; // Return the constructor for the class


    return AppStorage;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('LocalStorage', ["$window", "appCoreFactory", "cardApiManager", "storageHelperFactory", function ($window, appCoreFactory, cardApiManager, storageHelperFactory) {
    var storage;
    var storageUtil = storageHelperFactory.get();

    function LocalStorage() {
      storage = $window.localStorage;
      var collectionName = storageUtil.getCollectionName();

      var getLocalStorageId = function getLocalStorageId(key) {
        return storageUtil.getLocalStorageId(collectionName, key);
      };

      this.type = 'LocalStorage';

      this.set = function (key, value) {
        storage.setItem(getLocalStorageId(key), value);
      };

      this.get = function (key) {
        return storage.getItem(getLocalStorageId(key));
      };

      this.remove = function (key) {
        storage.removeItem(getLocalStorageId(key));
      };

      this.getKeys = function () {
        var keys = [];

        for (var key in storage) {
          var idInfo = storageUtil.getInfoFromLocalStorageId(key);

          if (!idInfo || idInfo.collection !== collectionName) {
            continue;
          }

          keys.push(idInfo.key);
        }

        return keys;
      };
    } // static methods


    LocalStorage.isAvailable = function () {
      if (cardApiManager.isPreview() || !cardApiManager.isDevicePlayback()) {
        return false;
      }

      return appCoreFactory.getCore() ? false : Boolean($window.localStorage);
    }; // Return the constructor for the class


    return LocalStorage;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('MemoryStorage', function () {
    var storage;

    function MemoryStorage() {
      storage = {};
      this.type = 'MemoryStorage';

      this.set = function (key, value) {
        if (!key) {
          return;
        }

        storage[key] = value;
      };

      this.get = function (key) {
        return storage[key];
      };

      this.remove = function (key) {
        if (!key) {
          return;
        }

        delete storage[key];
      };

      this.getKeys = function () {
        var keys = [];

        for (var key in storage) {
          keys.push(key);
        }

        return keys;
      };
    } // static methods


    MemoryStorage.isAvailable = function () {
      return true;
    }; // Return the constructor for the class


    return MemoryStorage;
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('DataBehavior', function (rx, $timeout, dataUtil) {
    function DataBehavior(value) {
      this.value = value;
      this.subject = new rx.BehaviorSubject(value);
      this.timeoutHandler;
    }

    DataBehavior.prototype.onChange = function (newValue) {
      if (dataUtil.isObjectEqual(newValue, this.value)) {
        return false;
      }

      this.value = $angular.copy(newValue);
      this.subject.onNext(this.value); // since rxjs update the scope out of angularjs context, 
      // need to call rootscope.$apply. Using a simple timeout is
      // the most safest way to do this

      $timeout.cancel(this.timeoutHandler);
      this.timeoutHandler = $timeout();
    };

    return DataBehavior;
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('DataSubject', function (rx, $timeout) {
    function DataSubject(value) {
      this.value = value;
      this.subject = new rx.Subject(value);
      this.timeoutHandler;
    }

    DataSubject.prototype.onChange = function (newValue) {
      this.value = $angular.copy(newValue);
      this.subject.onNext(this.value); // since rxjs update the scope out of angularjs context, 
      // need to call rootscope.$apply. Using a simple timeout is
      // the most safest way to do this

      $timeout.cancel(this.timeoutHandler);
      this.timeoutHandler = $timeout();
    };

    return DataSubject;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('Event', function () {
    function Event(id, organizerUsername, room, title, start, end) {
      var originalTitle = title;
      var originalOrganizerUsername = organizerUsername;
      this.id = id;
      this.organizerUsername = organizerUsername;
      this.room = room;
      this.title = title;
      this.start = start;
      this.end = end;
      this.isAllDay = false;
      this.isCheckedIn = true;
      this.metadata;
      this.isEditable;
      this.isEnded;
      this.isCancelled;
      this.status;

      this.setTitle = function (title) {
        this.title = title || originalTitle;
      };

      this.showOrganizerUsername = function (show) {
        this.organizerUsername = show ? originalOrganizerUsername : undefined;
      };
    } // Return the constructor for the class


    return Event;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('Menu', function () {
    function Menu(menuItems, options) {
      this.model = [];
      this.menuGroups = menuItems;
      this.options = {
        placement: options.placement,
        isOpen: options.isOpen
      };
    } // Return the constructor for the class


    return Menu;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('MenuGroup', function () {
    function MenuGroup(name, groupItems, insertDivider, showHeader) {
      this.name = name;
      this.items = groupItems;
      this.insertDivider = insertDivider;
      this.showHeader = showHeader;
    } // Return the constructor for the class


    return MenuGroup;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('MenuGroupItem', function () {
    function MenuGroupItem(label, value) {
      this.label = label;
      this.value = value;
    } // Return the constructor for the class


    return MenuGroupItem;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('Room', function () {
    function Room(id, name, displayName, email, providerFacilities, isReadOnly, checkpoints, floorName, buildingName) {
      var originalName = name;
      var originalDisplayName = displayName;
      this.id = id;
      this.name = name;
      this.displayName = displayName;
      this.email = email;
      this.providerFacilities = providerFacilities;
      this.isReadOnly = isReadOnly;
      this.checkpoints = checkpoints;
      this.providerFloorName = floorName;
      this.providerBuildingName = buildingName;
      this.number;
      this.direction;
      this.providerDirection;
      this.providerNumber;
      this.floorName;
      this.buildingName;

      this.setName = function (name) {
        this.name = name || originalName;
      };

      this.setDisplayName = function (displayName) {
        this.displayName = displayName || originalDisplayName;
      };
    } // Return the constructor for the class


    return Room;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('RoomError', function () {
    function RoomError(roomId, errorCode, errorMessage, innerError) {
      this.roomId = roomId;
      this.errorCode = errorCode;
      this.errorMessage = errorMessage;
      this.innerError = innerError;
    } // Return the constructor for the class


    return RoomError;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('ScheduleError', function () {
    function ScheduleError(roomId, errorCode, errorMessage, innerError) {
      this.roomId = roomId;
      this.errorCode = errorCode;
      this.errorMessage = errorMessage;
      this.innerError = innerError;
    } // Return the constructor for the class


    return ScheduleError;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('Playlist', function () {
    function Playlist(items, autorotate) {
      this.autoRotate = autorotate || false;
      this.setItems(items);
    }

    Playlist.prototype.setItems = function (items) {
      this.currentItems = items || [];
      this.currentIndex = -1;
    };

    Playlist.prototype.nextItem = function () {
      // if items are empty, just return undefined
      if (this.currentItems.length == 0) {
        return;
      }

      var res = this.currentItems[this.currentIndex + 1]; // if we have item, increase the index

      if (res) {
        this.currentIndex++;
        return res;
      } // if we don't have auto rotate, just return undefined


      if (!this.autoRotate) {
        return;
      } // if auto rotate, grab the first item


      this.currentIndex = 0;
      return this.currentItems[0];
    };

    Playlist.prototype.getItems = function () {
      return this.currentItems;
    };

    Playlist.prototype.getCurrentIndex = function () {
      return this.currentIndex;
    };

    return Playlist;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('AppspaceProvider', ["$q", "$filter", "dataUtil", "BaseCalendarProvider", "configurationManager", "Room", "Event", "textUtil", "timeUtil", "eventUtil", "RoomError", "ROOM_FACILITIES", "MODEL_INPUT_KEYS", "BOOKING_ACTION", "HTTP_STATUS_CODE", "SYSTEM_DATA", "CHECKPOINT", "CHECKPOINT_REQUIREMENT", function ($q, $filter, dataUtil, BaseCalendarProvider, configurationManager, Room, Event, textUtil, timeUtil, eventUtil, RoomError, ROOM_FACILITIES, MODEL_INPUT_KEYS, BOOKING_ACTION, HTTP_STATUS_CODE, SYSTEM_DATA, CHECKPOINT, CHECKPOINT_REQUIREMENT) {
    function AppspaceProvider(baseProvider, config) {
      this.id = 'appspace.provider';
      var base = new BaseCalendarProvider();
      var formatText = textUtil.formatText;
      var privateName;
      var DEFAULT_PRIVATE_MEETING_TITLE = 'Private Meeting';
      var subscriptions = [];
      var serviceUrls = {};
      var ignoreCheckInConfiguration = true;
      var MEETING_STATUSES = {
        CHECK_IN: 'Checkin',
        CHECKED_IN: 'Active',
        ENDED: 'Completed',
        CANCELLED: 'Cancelled'
      };
      var SENSITIVITIES = {
        PUBLIC: 'public',
        PRIVATE: 'private'
      };
      var RESPONSE_ITEMS_START = 0;
      var RESPONSE_ITEMS_LIMIT = 1000;
      var NON_RESERVABLE = 'Inactive';
      var RULE_CHECKPOINT = 'Checkpoint';
      var CHECKPOINT_KEYS = {
        INHERITED: 'inheritedReservationRules',
        CURRENT: 'reservationRules'
      };
      var CHECKPOINT_STATUS = {
        status: 'Pass'
      };

      this.initialize = function () {
        base.initialize();
        var privateNameSubscription = configurationManager.getInputObservable(MODEL_INPUT_KEYS.PRIVATE_MEETING_NAME, DEFAULT_PRIVATE_MEETING_TITLE).subscribe(function (name) {
          privateName = name;
        });
        subscriptions.push(privateNameSubscription);

        if (!config) {
          return;
        }

        var baseUrl = config.baseUrl;

        if (baseUrl) {
          serviceUrls = {
            baseUrl: baseUrl,
            baseRoomsUrl: formatText('{0}/resources', baseUrl),
            baseRoomUrl: formatText('{0}/resources/{1}', [baseUrl, '{0}']),
            baseEventsUrl: formatText('{0}/resources/{1}/events?{2}', [baseUrl, '{0}', '{1}']),
            baseEventUrl: formatText('{0}/events/{1}', [baseUrl, '{0}']),
            batchRoomsUrl: formatText('{0}/resources/search', baseUrl),
            baseReservationUrl: formatText('{0}/reservations', [baseUrl]),
            baseCheckInUrl: formatText('{0}/events/{1}/checkin', [baseUrl, '{0}']),
            baseExtendUrl: formatText('{0}/events/{1}/extend', [baseUrl, '{0}']),
            baseEndUrl: formatText('{0}/events/{1}/end', [baseUrl, '{0}']),
            sendCheckpointStatusUrl: formatText('{0}/reservations/{1}/checkpoints/{2}/status', [baseUrl, '{0}', '{1}']),
            deleteEventUrl: formatText('{0}/reservations/{1}', [baseUrl, '{0}'])
          };
        }
      };

      this.dispose = function () {
        for (var i = 0; i < subscriptions.length; i++) {
          subscriptions[i].dispose();
        }

        base.dispose();
      };

      this.getAllRooms = function () {
        var promise = $q.defer();
        var rooms = [];
        var requestConfig = {
          method: 'GET',
          relativeUrl: serviceUrls.baseRoomsUrl,
          data: {
            sort: 'name',
            types: ['room', 'space'],
            start: RESPONSE_ITEMS_START,
            limit: RESPONSE_ITEMS_LIMIT
          }
        };

        var retrieveRooms = function retrieveRooms() {
          base.getDataFromConstellationService(requestConfig).then(function (data) {
            data = (data || {}).items || [];
            rooms = rooms.concat(processRooms(data));
            var currentSize = data.length;

            if (currentSize === RESPONSE_ITEMS_LIMIT) {
              requestConfig.data.start += currentSize;
              retrieveRooms();
              return;
            }

            promise.resolve(rooms);
          }, promise.reject);
        };

        retrieveRooms();
        return promise.promise;
      };

      this.isEventInCheckInState = function (event) {
        return event.status === MEETING_STATUSES.CHECK_IN;
      };

      this.getAuthenticationInfo = $angular.noop;

      this.getRoom = function (roomId) {
        if (!roomId) {
          return $q.reject();
        }

        var promise = $q.defer();
        var requestConfig = {
          method: 'GET',
          relativeUrl: textUtil.formatText(serviceUrls.baseRoomUrl, roomId)
        };

        var onSuccess = function onSuccess(data) {
          promise.resolve(createRoom(data));
        };

        base.getDataFromConstellationService(requestConfig).then(onSuccess, promise.reject);
        return promise.promise;
      };

      this.getRooms = function (roomIds) {
        if (!roomIds || roomIds.length === 0) {
          return $q.resolve([]);
        }

        var requestConfig = {
          method: 'POST',
          relativeUrl: serviceUrls.batchRoomsUrl,
          data: {
            resourceIds: roomIds,
            start: RESPONSE_ITEMS_START,
            limit: RESPONSE_ITEMS_LIMIT
          }
        };

        var onSuccess = function onSuccess(data) {
          data = (data || {}).items || [];
          return processRooms(data);
        };

        return base.getDataFromConstellationService(requestConfig, onSuccess);
      };

      this.getEvents = function (room, start, end) {
        var params = {
          startAt: timeUtil.getUtcStringFromDate(start),
          endAt: timeUtil.getUtcStringFromDate(end),
          start: RESPONSE_ITEMS_START,
          limit: RESPONSE_ITEMS_LIMIT
        };
        var requestConfig = {
          method: 'GET',
          relativeUrl: textUtil.formatText(serviceUrls.baseEventsUrl, [room.id, textUtil.httpParamSerializer(params)])
        };

        var onDataRetrieved = function onDataRetrieved(data) {
          var events = (data || {}).items || [];
          var result = [];

          for (var i = 0; i < events.length; i++) {
            var event = convertToEvent(room, events[i]);

            if (!event || event.isCancelled) {
              continue;
            }

            result.push(event);
          }

          return result;
        };

        var onDataRetrievalFailed = function onDataRetrievalFailed(error) {
          return createRoomError(room, error);
        };

        return base.getDataFromConstellationService(requestConfig, onDataRetrieved, onDataRetrievalFailed);
      };

      function getEvent(room, event) {
        var requestConfig = {
          method: 'GET',
          relativeUrl: textUtil.formatText(serviceUrls.baseEventUrl, event.id)
        };

        var onDataRetrieved = function onDataRetrieved(data) {
          return convertToEvent(room, data);
        };

        return base.getDataFromConstellationService(requestConfig, onDataRetrieved);
      }

      this.createEvent = function (room, title, start, end, metadata) {
        var promise = $q.defer();

        var onCreateReservationFailure = function onCreateReservationFailure(error) {
          promise.reject(error && error.status === HTTP_STATUS_CODE.CONFLICT ? {
            errorCode: SYSTEM_DATA.CONSTRAINED_ERROR,
            errorMessage: 'We were unable to book your meeting due to a conflict with the reservation rules for this resource.'
          } : error);
        };

        var onCreateReservationSuccess = function onCreateReservationSuccess(result) {
          result = result || {};
          var reservationEvents = (result || {}).events;

          if (!dataUtil.isArray(reservationEvents) || !reservationEvents.length) {
            promise.reject('No reservation events data.');
            return;
          }

          var onProcessCheckpointsSuccess = function onProcessCheckpointsSuccess() {
            var reservationEvent = $filter('filter')(reservationEvents, function (object) {
              return object.resourceId === room.id;
            })[0];

            if (!reservationEvent) {
              promise.reject('No reservation events data.');
              return;
            }

            if (reservationEvent.requiresCheckin && eventUtil.isInstantBooking(reservationEvent.startAt)) {
              reservationEvent.room = room;
              doCheckInEvent(reservationEvent).then(promise.resolve, promise.reject);
              return;
            }

            getEvent(room, reservationEvent).then(promise.resolve, promise.reject);
          };

          processReservationCheckpoints(result.checkpoints || [], result.id).then(onProcessCheckpointsSuccess, onCreateReservationFailure);
        };

        var data = {
          organizer: {
            id: room.id,
            name: room.name,
            type: 'Resource'
          },
          title: title,
          effectiveStartAt: timeUtil.getUtcStringFromDate(start),
          effectiveEndAt: timeUtil.getUtcStringFromDate(end),
          resourceIds: [room.id]
        };
        var requestConfig = {
          method: 'POST',
          relativeUrl: textUtil.formatText(serviceUrls.baseReservationUrl),
          data: data
        };
        base.getDataFromConstellationService(requestConfig, onCreateReservationSuccess, onCreateReservationFailure);
        return promise.promise;
      };

      function deleteReservation(reservationId) {
        var requestConfig = {
          method: 'DELETE',
          relativeUrl: textUtil.formatText(serviceUrls.deleteEventUrl, reservationId)
        };
        return base.getDataFromConstellationService(requestConfig);
      }

      function sendCheckpointStatus(reservationId, checkpointId) {
        var requestConfig = {
          method: 'PATCH',
          relativeUrl: textUtil.formatText(serviceUrls.sendCheckpointStatusUrl, [reservationId, checkpointId]),
          data: CHECKPOINT_STATUS
        };
        return base.getDataFromConstellationService(requestConfig);
      }

      function processReservationCheckpoints(checkpoints, reservationId) {
        if (!checkpoints.length || !reservationId) {
          return $q.resolve();
        }

        var promise = $q.defer();
        var currentIndex = 0;

        var onCheckpointFailed = function onCheckpointFailed() {
          deleteReservation(reservationId);
          promise.reject('Checkpoint update request failed.');
        };

        var processNextCheckpoint = function processNextCheckpoint() {
          currentIndex++;
          sendCurrentCheckpointStatus();
        };

        var sendCurrentCheckpointStatus = function sendCurrentCheckpointStatus() {
          if (currentIndex >= checkpoints.length) {
            // We are done with all checkpionts, resolve promise
            promise.resolve();
            return;
          }

          var checkpoint = checkpoints[currentIndex] || {};
          var checkpointId = checkpoint.id;

          if (!checkpointId) {
            processNextCheckpoint();
            return;
          }

          sendCheckpointStatus(reservationId, checkpointId).then(processNextCheckpoint, onCheckpointFailed);
        };

        sendCurrentCheckpointStatus();
        return promise.promise;
      }

      function doCheckInEvent(event) {
        var onDataRetrieved = function onDataRetrieved(result) {
          return convertToEvent(event.room, result);
        };

        var requestConfig = {
          method: 'POST',
          relativeUrl: textUtil.formatText(serviceUrls.baseCheckInUrl, event.id)
        };
        return base.getDataFromConstellationService(requestConfig, onDataRetrieved);
      }

      function isCheckedIn(metadata) {
        return metadata && !dataUtil.isNullOrUndefined(metadata.checkininfo);
      }

      this.updateEvent = function (event, bookingAction) {
        if (!event) {
          return $q.reject('data not valid');
        }

        switch (bookingAction) {
          case BOOKING_ACTION.CHECK_IN:
            if (isCheckedIn(event.metadata)) {
              return doCheckInEvent(event);
            }

            break;

          case BOOKING_ACTION.EXTEND:
            return doExtendEvent(event);

          case BOOKING_ACTION.END:
            return doEndEvent(event);

          case BOOKING_ACTION.RENAME:
            return doRenameEvent(event);
        }
      };

      function doExtendEvent(event) {
        if (!event.end) {
          return $q.reject('End date is not specified');
        }

        var onDataRetrieved = function onDataRetrieved(result) {
          return convertToEvent(event.room, result);
        };

        var requestConfig = {
          method: 'POST',
          relativeUrl: textUtil.formatText(serviceUrls.baseExtendUrl, event.id),
          data: {
            endAt: event.end
          }
        };
        return base.getDataFromConstellationService(requestConfig, onDataRetrieved);
      }

      function doEndEvent(event) {
        var onDataRetrieved = function onDataRetrieved(result) {
          return convertToEvent(event.room, result);
        };

        var requestConfig = {
          method: 'POST',
          relativeUrl: textUtil.formatText(serviceUrls.baseEndUrl, event.id)
        };
        return base.getDataFromConstellationService(requestConfig, onDataRetrieved);
      }

      function doRenameEvent(event) {
        if (!event.title) {
          return $q.reject('Title is not specified');
        }

        var onDataRetrieved = function onDataRetrieved(result) {
          return convertToEvent(event.room, result);
        };

        var requestConfig = {
          method: 'PATCH',
          relativeUrl: textUtil.formatText(serviceUrls.baseEventUrl, event.id),
          data: {
            title: event.title
          }
        };
        return base.getDataFromConstellationService(requestConfig, onDataRetrieved);
      }

      function convertToEvent(room, data) {
        if (!data) {
          return;
        }

        var dateParser = timeUtil.getDateFromString;
        var startDate = dateParser(data.startAt);
        var endDate = dateParser(data.endAt);
        var event = new Event(data.id + '', undefined, room, generateMeetingTitle(data.sensitivity, data.title), startDate, endDate);
        event.isEditable = data.isEditable;
        event.isAllDay = data.isAllDay;
        event.isCancelled = isMeetingCancelled(data.status);
        event.isEnded = isMeetingEnded(data.status);
        event.isCheckedIn = isMeetingCheckedIn(data.status, startDate, endDate);
        event.status = data.status;
        return event;
      }

      function generateMeetingTitle(sensitivity, title) {
        return sensitivity === SENSITIVITIES.PRIVATE ? privateName : title;
      }

      function isMeetingCheckedIn(status, startDate, endDate) {
        var dateRange = timeUtil.getCurrentDateRange();
        var now = dateRange.now;
        return status === MEETING_STATUSES.CHECKED_IN || now >= startDate && now <= endDate;
      }

      function isMeetingCancelled(status) {
        return status === MEETING_STATUSES.CANCELLED;
      }

      function isMeetingEnded(status) {
        return status === MEETING_STATUSES.ENDED;
      }

      function isRoomReadOnly(room) {
        return !room.isReservable || room.currentStatus === NON_RESERVABLE;
      }

      function createRoomError(room, error) {
        var roomId = (room || {}).id;
        var errorObject = error || {};
        var errorData = (errorObject.data || {}).error || {};
        var innerError = ((error.errors || [])[0] || {}).message;
        return new RoomError(roomId, errorData.code, errorData.message, innerError);
      }

      this.ignoreCheckInConfiguration = ignoreCheckInConfiguration;
      this.skipDelegationCheck = true;
      this.supportBookingUntilEndOfDay = true;
      base.ignoreCheckInConfiguration = ignoreCheckInConfiguration;

      function processRooms(rooms, roomIds) {
        var result = [];

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];

          if (roomIds && roomIds.indexOf(getRoomIdFromRoomData(room)) < 0) {
            continue;
          }

          result.push(createRoom(room));
        }

        return result;
      }

      function getRoomIdFromRoomData(room) {
        return room.id + '';
      }

      function processFacilities(roomData) {
        var result = {};
        var capacityKey = ROOM_FACILITIES.CAPACITY;

        if (roomData[capacityKey]) {
          result.capacity = parseInt(roomData[capacityKey], 10);
        }

        var providerFacilities = roomData.facilities;

        if (!providerFacilities) {
          return result;
        }

        for (var i = 0; i < providerFacilities.length; i++) {
          var facility = providerFacilities[i].type;

          if (!facility) {
            continue;
          }

          var mappedFacility = ROOM_FACILITIES[facility.toUpperCase()];

          if (!mappedFacility) {
            continue;
          }

          result[mappedFacility] = true;
        }

        return result;
      }

      function doProcessCheckpoints(room, checkpoints, key) {
        var rules = room[key] || [];

        if (!rules || !rules.length) {
          return checkpoints;
        }

        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i] || {}; // Rule is not of checkpoint category

          if (rule.category !== RULE_CHECKPOINT) {
            continue;
          }

          var checkpoint = (rule.checkpoint || '').toUpperCase();
          var mappedCheckpoint = CHECKPOINT[checkpoint]; // Checkpoint is not supported

          if (!mappedCheckpoint) {
            continue;
          }

          var checkpointType = CHECKPOINT_REQUIREMENT[(rule.type || '').toUpperCase()]; // Checkpoint requirement type is not supported

          if (!checkpointType) {
            continue;
          }

          checkpoints[mappedCheckpoint].push({
            type: checkpointType,
            description: rule.description,
            value: rule.value
          });
        }

        return checkpoints;
      }

      function processCheckpoints(room) {
        var checkpoints = {};
        checkpoints[CHECKPOINT.ATRESERVATION] = [];
        checkpoints[CHECKPOINT.ATCHECKIN] = [];
        checkpoints = doProcessCheckpoints(room, checkpoints, CHECKPOINT_KEYS.INHERITED);
        return doProcessCheckpoints(room, checkpoints, CHECKPOINT_KEYS.CURRENT);
      }

      function createRoom(room) {
        // To ensure that the room id is a string for consistency
        var roomId = getRoomIdFromRoomData(room);
        return new Room(roomId, room.name, room.name, roomId, processFacilities(room), isRoomReadOnly(room), processCheckpoints(room), room.floorName, room.networkName);
      }
    } // Return the constructor for the class


    return AppspaceProvider;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('BaseCalendarProvider', ["$q", "networkUtil", "ROOM_EVENT", "PROVIDER_STATE", "scheduleUtil", "textUtil", function ($q, networkUtil, ROOM_EVENT, PROVIDER_STATE, scheduleUtil, textUtil) {
    function BaseCalendarProvider() {
      this.id = 'base.provider';
      var subscribers = [];
      var currentState = PROVIDER_STATE.NONE;
      var JSON_CONTENT_TYPE = 'application/json';

      function doProcessData(config) {
        var onSuccess = config.onSuccess;
        var onFailure = config.onFailure;
        var processData = config.processData;
        var requestMethod = config.requestMethod;
        var requestConfig = config.requestConfig;

        if (!requestMethod || !networkUtil[requestMethod]) {
          return $q.reject('Invalid request method');
        }

        var defer = $q.defer();

        var rejectPromise = function rejectPromise(error) {
          var rejectData = error;

          if (onFailure) {
            rejectData = onFailure(error);
          }

          defer.reject(rejectData);
        };

        networkUtil[requestMethod](requestConfig).then(function (result) {
          var data = processData(result);

          if (!data) {
            rejectPromise('No data found');
            return;
          }

          if (data.error) {
            rejectPromise(data.error);
            return;
          }

          if (onSuccess) {
            data = onSuccess(data);
          }

          defer.resolve(data);
        }, rejectPromise);
        return defer.promise;
      }

      var processData = function (method, url, data, onSuccess, onFailure) {
        var defer = $q.defer();
        this.getHeaders().then(function (headers) {
          var config = createHttpConfig(method, url, data, onSuccess, onFailure, headers);
          doProcessData(config).then(defer.resolve, defer.reject);
        }, defer.reject);
        return defer.promise;
      }.bind(this);

      this.getDataFromConstellationService = function (requestConfig, onSuccess, onFailure) {
        return doProcessData(createConstellationConfig(requestConfig, onSuccess, onFailure));
      };

      function createConstellationConfig(requestConfig, onSuccess, onFailure) {
        var method = requestConfig.method;
        return {
          processData: function processData(result) {
            return result;
          },
          requestMethod: 'requestConstellationService',
          requestConfig: {
            method: method,
            relativeUrl: requestConfig.relativeUrl,
            headers: {
              Accept: JSON_CONTENT_TYPE
            },
            data: method === 'GET' ? textUtil.httpParamSerializer(requestConfig.data) : JSON.stringify(requestConfig.data),
            contentType: JSON_CONTENT_TYPE
          },
          onSuccess: onSuccess,
          onFailure: onFailure
        };
      }

      this.setCurrentState = function (state, data) {
        if (!state || state == currentState) {
          return false;
        }

        var result = {
          old: currentState,
          "new": state,
          data: data
        };
        currentState = state;
        this.notifySubscribers(ROOM_EVENT.PROVIDER_STATE_CHANGED, result);
        return true;
      };

      this.getCurrentState = function () {
        return currentState;
      };

      this.subscribe = function (event, callback) {
        if (!event || !callback) {
          return;
        }

        this.unsubscribe(event, callback);
        subscribers.push({
          event: event,
          callback: callback
        });
      };

      this.unsubscribe = function (event, callback) {
        for (var i = 0; i < subscribers.length; i++) {
          var subscriber = subscribers[i];

          if (subscriber.event == event && subscriber.callback == callback) {
            subscribers.splice(i, 1);
            return;
          }
        }
      };

      this.unsubscribeAll = function (callback) {
        var newSubscribers = [];

        for (var i = 0; i < subscribers.length; i++) {
          var subscriber = subscribers[i];

          if (subscriber.callback != callback) {
            newSubscribers.push(subscriber);
          }
        }

        subscribers = newSubscribers;
      };

      this.notifySubscribers = function (event, data) {
        for (var i = 0; i < subscribers.length; i++) {
          var subscriber = subscribers[i];

          if (subscriber.event == event) {
            subscriber.callback(data);
          }
        }
      };

      this.getSubscribers = function () {
        return subscribers;
      };

      this.clearCache = function () {
        // needs to be implemented by consumer
        return;
      };

      this.setConfiguration = function () {
        // needs to be implemented by consumer
        return $q.resolve();
      };

      this.initialize = $angular.noop;
      this.dispose = $angular.noop;

      this.getData = function (url, successCallback, failureCallback) {
        return processData('GET', url, undefined, successCallback, failureCallback);
      };

      this.postData = function (url, data, successCallback) {
        return processData('POST', url, data, successCallback);
      };

      this.deleteData = function (url, successCallback) {
        return processData('DELETE', url, undefined, successCallback);
      };

      this.patchData = function (url, data, successCallback) {
        return processData('PATCH', url, data, successCallback);
      };

      this.getHeaders = function () {
        return $q.resolve({});
      };

      this.isEventInCheckInState = scheduleUtil.isEventRequiresCheckIn;

      function createHttpConfig(method, url, data, onSuccess, onFailure, additionalHeaders) {
        var defaultHeaders = {
          Accept: JSON_CONTENT_TYPE
        };
        var result = {
          processData: function processData(result) {
            return (result || {}).data;
          },
          requestMethod: 'http',
          requestConfig: {
            method: method,
            url: url,
            headers: $angular.extend({}, defaultHeaders, additionalHeaders)
          },
          onSuccess: onSuccess,
          onFailure: onFailure
        };

        if (data) {
          result.requestConfig.data = data;
        }

        return result;
      }
    } // Return the constructor for the class


    return BaseCalendarProvider;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('CustomProvider', ["$q", "dataUtil", "BaseCalendarProvider", "configurationManager", "Room", "Event", "textUtil", "timeUtil", "eventUtil", "RoomError", "MODEL_INPUT_KEYS", function ($q, dataUtil, BaseCalendarProvider, configurationManager, Room, Event, textUtil, timeUtil, eventUtil, RoomError, MODEL_INPUT_KEYS) {
    function CustomProvider(baseProvider, config) {
      this.id = 'custom.provider';
      var base = new BaseCalendarProvider();
      var formatText = textUtil.formatText;
      var privateName;
      var DEFAULT_PRIVATE_MEETING_TITLE = 'Private Meeting';
      var subscriptions = [];
      var baseRoomsUrl;
      var baseRoomUrl;
      var baseEventsUrl;
      var baseEventUrl;
      var baseUserUrl;
      var currentUserUrl;
      var serviceUrls = {};
      var facilitiesMapping = configurationManager.getInputModel(MODEL_INPUT_KEYS.FACILITIES_MAPPING);
      this.isEventInCheckInState = base.isEventInCheckInState;

      this.initialize = function () {
        base.initialize();
        var privateNameSubscription = configurationManager.getInputObservable(MODEL_INPUT_KEYS.PRIVATE_MEETING_NAME, DEFAULT_PRIVATE_MEETING_TITLE).subscribe(function (name) {
          privateName = name;
        });
        subscriptions.push(privateNameSubscription);

        if (!config) {
          return;
        }

        var baseUrl = config.baseUrl;

        if (baseUrl) {
          baseRoomsUrl = formatText('{0}/rooms', baseUrl);
          baseRoomUrl = formatText('{0}/rooms/{1}', [baseUrl, '{0}']);
          baseEventsUrl = formatText('{0}/rooms/{1}/events?{2}', [baseUrl, '{0}', '{1}']);
          baseEventUrl = formatText('{0}/rooms/{1}/events/{2}', [baseUrl, '{0}', '{1}']);
          baseUserUrl = formatText('/{0}/people', baseUrl);
          currentUserUrl = formatText('{0}/me', baseUserUrl);
          serviceUrls = {
            baseUrl: baseUrl,
            baseRoomsUrl: baseRoomsUrl,
            baseRoomUrl: baseRoomUrl,
            baseEventsUrl: baseEventsUrl,
            baseEventUrl: baseEventUrl,
            baseUserUrl: baseUserUrl,
            getCurrentUserUrl: currentUserUrl
          };
        }

        if (!config.headers) {
          return;
        }

        base.getHeaders = function () {
          return $q.resolve(config.headers);
        };
      };

      this.dispose = function () {
        for (var i = 0; i < subscriptions.length; i++) {
          subscriptions[i].dispose();
        }

        base.dispose();
      };

      this.getAllRooms = getRoomsByIds;
      this.getAuthenticationInfo = $angular.noop;

      this.getRoom = function (roomId) {
        if (!roomId) {
          return $q.reject();
        }

        var promise = $q.defer();
        var url = textUtil.formatText(serviceUrls.baseRoomUrl, roomId);

        var onSuccess = function onSuccess(data) {
          promise.resolve(createRoom(data));
        };

        base.getData(url).then(onSuccess, promise.reject);
        return promise.promise;
      };

      this.getRooms = function (roomIds) {
        if (!roomIds || roomIds.length === 0) {
          return $q.resolve([]);
        }

        return getRoomsByIds(roomIds);
      };

      this.getEvents = function (room, start, end) {
        var params = {
          start: timeUtil.getUtcStringFromDate(start),
          end: timeUtil.getUtcStringFromDate(end)
        };
        var url = textUtil.formatText(serviceUrls.baseEventsUrl, [room.id, textUtil.httpParamSerializer(params)]);

        var onDataRetrieved = function onDataRetrieved(data) {
          var events = data || [];
          var result = [];

          for (var i = 0; i < events.length; i++) {
            var event = convertToEvent(room, events[i]);

            if (!event || event.isCancelled) {
              continue;
            }

            result.push(event);
          }

          return result;
        };

        var onDataRetrievalFailed = function onDataRetrievalFailed(error) {
          return createRoomError(room, error);
        };

        return base.getData(url, onDataRetrieved, onDataRetrievalFailed);
      };

      function isCheckedIn(metadata) {
        return metadata && !dataUtil.isNullOrUndefined(metadata.checkininfo);
      }

      this.createEvent = function (room, title, start, end, metadata) {
        var data = {
          organizer: {
            id: room.id
          },
          title: title,
          start: timeUtil.getUtcStringFromDate(start),
          end: timeUtil.getUtcStringFromDate(end),
          isCheckedIn: isCheckedIn(metadata)
        };
        var url = textUtil.formatText(serviceUrls.baseEventsUrl, [room.id, '']);

        var onDataPosted = function onDataPosted(event) {
          return convertToEvent(room, event);
        };

        return base.postData(url, data, onDataPosted);
      };

      this.updateEvent = function (event) {
        if (!event) {
          return $q.reject('data not valid');
        } // only pass applicable data to update.


        var data = {};

        if (event.title) {
          data.title = event.title;
        }

        if (event.start) {
          data.start = timeUtil.getUtcStringFromDate(event.start);
        }

        if (event.end) {
          data.end = timeUtil.getUtcStringFromDate(event.end);
        }

        data.isCheckedIn = isCheckedIn(event.metadata);

        var onDataPatched = function onDataPatched(result) {
          return convertToEvent(event.room, result);
        };

        return base.patchData(getUpdateEventUrl(event), data, onDataPatched);
      };

      function getUpdateEventUrl(event) {
        return textUtil.formatText(serviceUrls.baseEventUrl, [event.room.email, event.id]);
      }

      this.deleteEvent = function (event) {
        var onDataDeleted = function onDataDeleted() {
          return convertToEvent(event.room, event);
        };

        return base.deleteData(getUpdateEventUrl(event), onDataDeleted);
      };

      function getRoomsByIds(roomIds) {
        var promise = $q.defer();
        var rooms = [];
        var url = textUtil.formatText(serviceUrls.baseRoomsUrl);
        base.getData(url).then(function (data) {
          rooms = processRooms(data, roomIds);
          promise.resolve(rooms);
        }, promise.reject);
        return promise.promise;
      }

      function processRooms(rooms, roomIds) {
        var result = [];

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];

          if (roomIds && roomIds.indexOf(getRoomIdFromRoomData(room)) < 0) {
            continue;
          }

          result.push(createRoom(room));
        }

        return result;
      }

      function convertToEvent(room, data) {
        if (!data) {
          return;
        }

        var dateParser = timeUtil.getDateFromString;
        var startData = data.start;
        var endData = data.end;
        var organizer = data.organizer || {};
        var organizerAddress = organizer.id;
        var organizerDisplayName = organizer.name;
        var event = new Event(data.id + '', eventUtil.generateOrganizerName(room, organizerAddress, organizerDisplayName), room, data.isPrivate ? privateName : data.title, dateParser(startData), dateParser(endData));
        event.isCancelled = data.isCancelled;
        event.isAllDay = data.isAllDay;
        event.isCheckedIn = data.isCheckedIn;
        return event;
      }

      function createRoomError(room, error) {
        var roomId = (room || {}).id;
        var errorObject = error || {};
        var errorData = (errorObject.data || {}).error || {};
        var innerError = ((error.errors || [])[0] || {}).message;
        return new RoomError(roomId, errorData.code, errorData.message, innerError);
      }

      function getRoomIdFromRoomData(room) {
        return room.id + '';
      }

      function getKeyFromFacilitiesMap(value) {
        if (!value || !facilitiesMapping) {
          return;
        }

        return Object.keys(facilitiesMapping).filter(function (key) {
          return (facilitiesMapping[key] || '').toLowerCase() === value.toLowerCase();
        })[0];
      }

      function processFacilities(roomData) {
        var result = {};
        result.capacity = roomData.capacity;
        var providerFacilities = roomData.facilities;

        if (!providerFacilities) {
          return result;
        }

        for (var i = 0; i < providerFacilities.length; i++) {
          var facility = providerFacilities[i] || '';
          var key = getKeyFromFacilitiesMap(facility);

          if (!key) {
            continue;
          }

          result[key] = true;
        }

        return result;
      }

      function createRoom(room) {
        // To ensure that the room id is a string for consistency
        var roomId = getRoomIdFromRoomData(room);
        return new Room(roomId, room.name, room.name, roomId, processFacilities(room), room.isReadOnly);
      }
    } // Return the constructor for the class


    return CustomProvider;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('DemoProvider', function ($q, BaseCalendarProvider, MockService, SYSTEM_DATA, dataUtil) {
    function DemoProvider() {
      this.id = 'demo.provider';
      this.isPreview = true;
      var base = new BaseCalendarProvider();
      var currentSchedules = {};
      var mockService = new MockService();
      var MIN_ROOM_NUMBER = 200;
      var UPSTAIR_DIRECTIONS = ['escalator-up', 'stairs-up'];
      var DOWNSTAIR_DIRECTIONS = ['escalator-down', 'stairs-down'];
      var FLOOR_PREFIX = 'Floor ';
      this.dispose = base.dispose;
      this.isEventInCheckInState = base.isEventInCheckInState;

      this.initialize = function () {
        mockService.subscribeToCheckIn(currentSchedules);
        base.initialize();
      };

      this.getRooms = function (roomIds) {
        var directions = $angular.copy(SYSTEM_DATA.ROOM_DIRECTIONS);
        var rooms = mockService.generateRooms();
        var directionsToRemove = UPSTAIR_DIRECTIONS.concat(DOWNSTAIR_DIRECTIONS);
        dataUtil.removeItemsFromArray(directions, directionsToRemove); // The 2 other unprocessed rooms are used to show upper and lower floors

        for (var i = 0; i < rooms.length - 2; i++) {
          setRoomLocation(rooms[i], MIN_ROOM_NUMBER + i, directions);
        } // To generate room number that is in upper floor (3)


        setRoomLocation(rooms[i++], MIN_ROOM_NUMBER + 101, UPSTAIR_DIRECTIONS); // To generate room number that is in lower floor (1)

        setRoomLocation(rooms[i++], MIN_ROOM_NUMBER - 99, DOWNSTAIR_DIRECTIONS);
        return $q.resolve(rooms);
      };

      this.getEvents = function (room, startDate, endDate) {
        return mockService.getEvents(currentSchedules, room, startDate, endDate);
      };

      this.createEvent = function (room, title, start, end, metadata) {
        return mockService.createEvent(currentSchedules, room, title, start, end, metadata);
      };

      this.updateEvent = function (event) {
        return mockService.updateEvent(currentSchedules, event);
      };

      this.deleteEvent = function (eventToDelete) {
        return mockService.deleteEvent(currentSchedules, eventToDelete);
      };

      function setRoomLocation(room, number, directions) {
        room.providerNumber = number;
        room.providerFloorName = FLOOR_PREFIX + Math.floor(number / 100);
        room.providerDirection = directions[dataUtil.getRandomNumber(directions.length - 1)];
      }
    }

    return DemoProvider;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('GoogleProvider', ["$q", "UserBasedProvider", "providerUtil", "textUtil", "timeUtil", "eventUtil", "dataUtil", "Event", "RoomError", "Room", "configurationManager", "MODEL_INPUT_KEYS", function ($q, UserBasedProvider, providerUtil, textUtil, timeUtil, eventUtil, dataUtil, Event, RoomError, Room, configurationManager, MODEL_INPUT_KEYS) {
    function GoogleProvider() {
      this.id = 'google.provider';
      this.mapRoomIdentifier = 'providerRoomId';
      var providerInfo = {
        baseScope: 'https://www.googleapis.com/auth/',
        tokenUrl: 'https://www.googleapis.com/oauth2/v4/token',
        authenticationUrl: 'https://accounts.google.com/o/oauth2/v2/auth?{0}',
        roomsUrl: 'https://www.googleapis.com/admin/directory/v1/customer/my_customer/resources/calendars?{0}',
        baseEventUrl: 'https://www.googleapis.com/calendar/v3/calendars/{0}/events',
        getRoomUrl: 'https://www.googleapis.com/admin/directory/v1/customer/my_customer/resources/calendars/{0}',
        defaultScope: 'calendar admin.directory.resource.calendar.readonly userinfo.profile userinfo.email',
        maxResults: '500',
        field: 'nextPageToken,items(resourceId,resourceName,resourceEmail,resourceCategory)'
      };
      providerInfo.roomInfoUrl = providerInfo.baseEventUrl + '?maxResults=1&fields=accessRole';
      providerInfo.updateEventUrl = providerInfo.baseEventUrl + '/{1}';
      var roomCategories = configurationManager.getInputModel(MODEL_INPUT_KEYS.ROOM_CATEGORIES);
      var READ_ONLY_ACCESS = 'reader';
      var base = new UserBasedProvider();
      this.initialize = base.initialize;
      this.dispose = base.dispose;
      this.isEventInCheckInState = base.isEventInCheckInState;

      this.getAuthenticationInfo = function (pairingKey, config) {
        var providerConfig = providerUtil.getProviderConfig(config, providerInfo);
        var scopes = providerConfig.scope.split(' ');

        for (var i = 0; i < scopes.length; i++) {
          scopes[i] = providerInfo.baseScope + scopes[i];
        }

        var finalScope = scopes.join(' ');
        var state = providerUtil.createAuthInfoState(pairingKey, providerConfig.clientId, providerConfig.redirectUrl, providerConfig.clientSecret, finalScope);
        var endpointParams = textUtil.httpParamSerializer({
          access_type: 'offline',
          client_id: providerConfig.clientId,
          prompt: 'consent',
          redirect_uri: providerConfig.redirectUrl,
          response_type: 'code',
          scope: finalScope,
          state: btoa(state)
        });
        return {
          key: pairingKey,
          url: textUtil.formatText(providerInfo.authenticationUrl, endpointParams)
        };
      };

      this.getRoom = function (roomId) {
        if (!roomId) {
          return $q.reject();
        }

        var promise = $q.defer();
        var url = textUtil.formatText(providerInfo.getRoomUrl, roomId);

        var onSuccess = function onSuccess(data) {
          promise.resolve(createRoom(data));
        };

        base.getData(url).then(onSuccess, promise.reject);
        return promise.promise;
      };

      this.getRooms = function (roomIds) {
        if (!roomIds || roomIds.length === 0) {
          return $q.resolve([]);
        }

        return getRoomsByIds(roomIds);
      };

      this.getAllRooms = function () {
        return getRoomsByIds();
      };

      this.getRoomsInfo = function (rooms) {
        rooms = $angular.copy(rooms || []);
        var promise = $q.defer();
        var promises = [];

        var retrieveRoomInfo = function retrieveRoomInfo(roomId, index) {
          if (!roomId) {
            return;
          }

          var processRoomInfo = function processRoomInfo(data) {
            rooms[index].isReadOnly = isReadOnly(data);
          };

          var url = textUtil.formatText(providerInfo.roomInfoUrl, roomId);
          return base.getData(url).then(processRoomInfo, processRoomInfo);
        };

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];

          if (!room) {
            continue;
          }

          promises.push(retrieveRoomInfo(room.email, i));
        }

        $q.allSettled(promises)["finally"](function () {
          promise.resolve(rooms);
        });
        return promise.promise;
      };

      this.createEvent = function (room, title, start, end, metadata) {
        var data = {
          summary: title,
          start: getDateEventObject(start),
          end: getDateEventObject(end),
          attendees: [{
            email: room.email,
            responseStatus: 'accepted'
          }],
          location: room.name
        };

        if (metadata) {
          data.extendedProperties = {
            "private": metadata
          };
        }

        var url = textUtil.formatText(providerInfo.baseEventUrl, room.email);

        var onDataPosted = function onDataPosted(event) {
          return convertToEvent(room, event);
        };

        return base.postData(url, data, onDataPosted);
      };

      this.getEvents = function (room, start, end) {
        var params = {
          orderBy: 'startTime',
          // Whether to expand recurring events into instances and 
          // only return single one-off events and instances of recurring 
          // events, but not the underlying recurring events themselves. Optional. The default is False.
          singleEvents: true,
          // upper bound.
          timeMax: timeUtil.getUtcStringFromDate(end),
          // lower bound
          timeMin: timeUtil.getUtcStringFromDate(start),
          timeZone: 'UTC'
        };
        var url = textUtil.formatText(providerInfo.baseEventUrl, room.email) + '?' + textUtil.httpParamSerializer(params);

        var onDataRetrieved = function onDataRetrieved(data) {
          var events = data.items || [];
          var result = [];

          for (var i = 0; i < events.length; i++) {
            var event = convertToEvent(room, events[i]);

            if (!event || event.isCancelled) {
              continue;
            }

            result.push(event);
          }

          return result;
        };

        var onDataRetrievalFailed = function onDataRetrievalFailed(error) {
          return createRoomError(room, error);
        };

        return base.getData(url, onDataRetrieved, onDataRetrievalFailed);
      };

      this.updateEvent = function (event) {
        if (!event) {
          return $q.reject('data not valid');
        } // only pass applicable data to update.


        var data = {};

        if (event.start) {
          data.start = getDateEventObject(event.start);
        }

        if (event.end) {
          data.end = getDateEventObject(event.end);
        }

        if (event.metadata) {
          data.extendedProperties = {
            "private": event.metadata
          };
        }

        if (event.title) {
          data.summary = event.title;
        }

        var url = getUpdateEventUrl(event);

        var onDataPatched = function onDataPatched(result) {
          return convertToEvent(event.room, result);
        };

        return base.patchData(url, data, onDataPatched);
      };

      this.deleteEvent = function (event) {
        var url = getUpdateEventUrl(event);

        var onDataDeleted = function onDataDeleted() {
          return convertToEvent(event.room, event);
        };

        return base.deleteData(url, onDataDeleted);
      };

      function createRoomError(room, error) {
        var roomId = (room || {}).id;
        var errorObject = error || {};
        var errorData = (errorObject.data || {}).error || {};
        var innerError = ((error.errors || [])[0] || {}).message;
        return new RoomError(roomId, errorData.code, errorData.message, innerError);
      }

      function getUpdateEventUrl(event) {
        return textUtil.formatText(providerInfo.updateEventUrl, [event.room.email, event.id]);
      }

      function convertToEvent(room, data) {
        if (!data) {
          return;
        }

        var dateParser = timeUtil.getDateFromString;
        var startData = data.start.dateTime;
        var endData = data.end.dateTime;
        var isAllDay = false; // all-day events doesn't have dateTime, only date

        if (!data.start.dateTime && data.start.date) {
          dateParser = timeUtil.getDateFromDateOnlyString;
          startData = data.start.date;
          endData = data.end.date;
          isAllDay = true;
        }

        var organizer = data.organizer || {};
        var organizerAddress = organizer.email;
        var organizerDisplayName = organizer.displayName;
        var event = new Event(data.id, eventUtil.generateOrganizerName(room, organizerAddress, organizerDisplayName), room, base.validateName(data.visibility, data.summary), dateParser(startData), dateParser(endData));
        event.isAllDay = isAllDay; // for provider specific operation

        event.originalStartTime = startData;
        event.originalEndTime = endData;
        event.originalLocation = data.location;
        event.metadata = (data.extendedProperties || {})["private"] || {};
        event.isMeetingCancelled = true;
        var attendees = data.attendees || [];

        for (var i = 0; i < attendees.length; i++) {
          var attendee = attendees[i];

          if (attendee.email == room.email && attendee.responseStatus == 'accepted') {
            event.isMeetingCancelled = false;
            break;
          }
        }

        event.isCheckedIn = base.isEventCheckedIn(event);
        return event;
      }

      function getDateEventObject(date) {
        return {
          dateTime: timeUtil.getUtcStringFromDate(date)
        };
      }

      function isReadOnly(data) {
        return Boolean(data && data.accessRole === READ_ONLY_ACCESS);
      }

      function getRoomsByIds(roomIds) {
        var promise = $q.defer();
        var rooms = [];
        var params = {
          maxResults: providerInfo.maxResults,
          field: providerInfo.field
        };

        var retrieveRooms = function retrieveRooms() {
          var url = textUtil.formatText(providerInfo.roomsUrl, textUtil.httpParamSerializer(params));
          base.getData(url).then(function (data) {
            params.pageToken = data.nextPageToken;
            rooms = rooms.concat(processRooms(data.items || [], roomIds)); // If we have all the specified rooms already

            if (roomIds && roomIds.length && rooms.length === roomIds.length) {
              promise.resolve(rooms);
              return;
            }

            if (data.nextPageToken) {
              retrieveRooms();
              return;
            }

            promise.resolve(rooms);
          }, promise.reject);
        };

        retrieveRooms();
        return promise.promise;
      }

      function processFacilities(roomData) {
        var facilities = {};
        facilities.capacity = roomData.capacity;
        var featureInstances = roomData.featureInstances;

        if (!featureInstances) {
          return facilities;
        }

        for (var i = 0; i < featureInstances.length; i++) {
          var feature = featureInstances[i].feature || {};
          var key = base.getKeyFromFacilitiesMap(feature.name);

          if (!key) {
            continue;
          }

          facilities[key] = true;
        }

        return facilities;
      }

      function createRoom(room) {
        var result = new Room(room.resourceId, room.resourceName, room.resourceName, room.resourceEmail, processFacilities(room), undefined, undefined, room.floorName);
        return result;
      }

      function isCategoryAllowed(category) {
        // Category is allowed if room categories are undefined / empty array
        if (!roomCategories || dataUtil.isArrayEmpty(roomCategories)) {
          return true;
        }

        return dataUtil.includesValue(roomCategories, category);
      }

      function processRooms(rooms, roomIds) {
        var result = [];

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i]; // Only process resource that is of an allowed category

          if (!room || !isCategoryAllowed(room.resourceCategory)) {
            continue;
          }

          if (roomIds && roomIds.indexOf(room.resourceId) < 0) {
            continue;
          }

          result.push(createRoom(room));
        }

        return result;
      }
    } // Return the constructor for the class


    return GoogleProvider;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('MockProvider', function ($q, MockService) {
    function MockProvider(baseProvider) {
      this.id = 'mock.provider';
      var base = baseProvider;
      var currentSchedules = {};
      var mockService = new MockService();
      this.dispose = base.dispose;
      this.mapRoomIdentifier = base.mapRoomIdentifier;
      this.isEventInCheckInState = base.isEventInCheckInState;
      this.ignoreCheckInConfiguration = base.ignoreCheckInConfiguration;

      this.initialize = function () {
        mockService.subscribeToCheckIn(currentSchedules);
        base.initialize();
      };

      this.getRooms = function (roomIds) {
        return roomIds && roomIds.length > 0 ? base.getRooms(roomIds) : $q.resolve(mockService.generateRooms());
      };

      this.getRoomsInfo = function (rooms) {
        return rooms && rooms.length && base.getRoomsInfo ? base.getRoomsInfo(rooms) : $q.resolve();
      };

      this.getEvents = function (room, startDate, endDate) {
        return mockService.getEvents(currentSchedules, room, startDate, endDate);
      };

      this.createEvent = function (room, title, start, end, metadata) {
        return mockService.createEvent(currentSchedules, room, title, start, end, metadata);
      };

      this.updateEvent = function (event) {
        return mockService.updateEvent(currentSchedules, event);
      };

      this.deleteEvent = function (eventToDelete) {
        return mockService.deleteEvent(currentSchedules, eventToDelete);
      };
    }

    return MockProvider;
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('MockService', function ($q, $timeout, dataUtil, eventUtil, timeUtil, configurationManager, dataConfigurationManager, SYSTEM_DATA, CUSTOM_DATA_KEY, Room, Event) {
    function MockService() {
      var mockData = configurationManager.getCustomData(CUSTOM_DATA_KEY.MOCK_DATA);
      var ARTIFICIAL_OPERATION_DELAY = 2000;
      var MAX_TABLE_INITIAL_BLOCK_POSITION = 4;
      var MAX_TABLE_NEXT_BLOCK_POSITION = 7;
      var MIN_TABLE_END_BLOCK_POSITION = 1;
      var MAX_TABLE_END_BLOCK_POSITION = 6;

      this.generateRooms = function () {
        if (!mockData || dataUtil.isObjectEmpty(mockData)) {
          return;
        }

        var mockRooms = [];
        var firstNames = $angular.copy(mockData.roomNames);

        for (var i = 0; i < 10; i++) {
          var firstName = dataUtil.getRandomItem(firstNames);
          var lastNames = $angular.copy(mockData.roomNames);
          lastNames.splice(lastNames.indexOf(firstName), 1);
          mockRooms.push(new Room(i + '-mockroom', firstName + ' ' + dataUtil.getRandomItem(lastNames)));
        }

        return mockRooms;
      };

      this.getEvents = function (currentSchedules, room, startDate, endDate) {
        currentSchedules[room.id] = currentSchedules[room.id] || {};

        if (currentSchedules[room.id].schedules && !currentSchedules[room.id].requireReset) {
          return $q.resolve(currentSchedules[room.id].schedules);
        }

        currentSchedules[room.id].requireReset = false;
        currentSchedules[room.id].schedules = generateSchedules(room, startDate, endDate);
        return delayPromiseResolve(currentSchedules[room.id].schedules);
      };

      this.createEvent = function (currentSchedules, room, title, start, end, metadata) {
        var schedules = currentSchedules[room.id].schedules;

        if (!dataUtil.isArray(schedules)) {
          return;
        }

        var newEvent = createMockEvent(title, start, end, !dataUtil.isNullOrUndefined(metadata), room, true);
        schedules.push(newEvent);
        return delayPromiseResolve(newEvent, ARTIFICIAL_OPERATION_DELAY);
      };

      this.updateEvent = function (currentSchedules, event) {
        var schedules = currentSchedules[event.room.id].schedules;

        if (!dataUtil.isArray(schedules)) {
          return;
        }

        var patchedEvent;
        schedules.map(function (schedule) {
          if (schedule.id !== event.id) {
            return;
          }

          if (event.metadata) {
            schedule.isCheckedIn = true;
          }

          if (event.start) {
            schedule.start = event.start;
          }

          if (event.end) {
            schedule.end = event.end;
          }

          patchedEvent = $angular.copy(schedule);
        });
        return delayPromiseResolve(patchedEvent, ARTIFICIAL_OPERATION_DELAY);
      };

      this.deleteEvent = function (currentSchedules, eventToDelete) {
        var roomId = eventToDelete.room.id;

        if (!currentSchedules[roomId]) {
          return $q.reject();
        }

        var schedules = currentSchedules[eventToDelete.room.id].schedules;
        var deletedEvent;

        for (var i = 0; i < schedules.length; i++) {
          var event = schedules[i];

          if (event.id !== eventToDelete.id) {
            continue;
          }

          deletedEvent = schedules.splice(i, 1)[0];
          break;
        }

        if (!deletedEvent) {
          return $q.reject();
        }

        return delayPromiseResolve(deletedEvent, ARTIFICIAL_OPERATION_DELAY);
      };

      function generateSchedules(room, startDate, endDate) {
        if (!mockData) {
          return;
        }

        var schedules = [];
        var dateRange = timeUtil.getEventsDateRange();
        var startTime = dateRange.start.getTime();
        var endTime = startTime;
        var team = mockData.team;
        var meetingType = mockData.meetingType;

        while (startTime <= endDate.getTime()) {
          if (schedules.length == 0) {
            startTime += SYSTEM_DATA.TIME_BLOCK * dataUtil.getRandomNumber(MAX_TABLE_INITIAL_BLOCK_POSITION) * 1000;
          }

          endTime = startTime + SYSTEM_DATA.TIME_BLOCK * (dataUtil.getRandomNumber(MAX_TABLE_END_BLOCK_POSITION - MIN_TABLE_END_BLOCK_POSITION) + MIN_TABLE_END_BLOCK_POSITION) * 1000;
          var event = createMockEvent(team[dataUtil.getRandomNumber(team.length - 1)] + ' ' + meetingType[dataUtil.getRandomNumber(meetingType.length - 1)], new Date(startTime), new Date(endTime), !dataConfigurationManager.getCheckInEnabled() || Boolean(dataUtil.getRandomNumber(1)), room);
          startTime = endTime + SYSTEM_DATA.TIME_BLOCK * dataUtil.getRandomNumber(MAX_TABLE_NEXT_BLOCK_POSITION) * 1000;

          if (endTime >= endDate) {
            event.end = new Date(endDate);
          }

          schedules.push(event);
        }

        return schedules;
      }

      this.subscribeToCheckIn = function (currentSchedules) {
        dataConfigurationManager.subscribeToCheckIn(function () {
          return onCheckInEnabledChanged(currentSchedules);
        });
      };

      function onCheckInEnabledChanged(currentSchedules) {
        for (var roomId in currentSchedules) {
          currentSchedules[roomId].requireReset = true;
        }
      }

      function createMockEvent(title, start, end, isCheckedIn, room, useRoomOrganizer) {
        if (!mockData) {
          return;
        }

        var mockOrganizer = mockData.organizer;
        var id = Math.random() + '-mock';
        var organizer = useRoomOrganizer ? {
          id: room.email
        } : mockOrganizer[dataUtil.getRandomNumber(mockOrganizer.length - 1)];
        var event = new Event(id, eventUtil.generateOrganizerName(room, organizer.id, organizer.name), room, title, start, end);
        event.isCheckedIn = isCheckedIn;
        return event;
      }

      function delayPromiseResolve(returnValue, delayTime) {
        if (!delayTime) {
          return $q.resolve(returnValue);
        }

        var promise = $q.defer();
        $timeout(function () {
          promise.resolve(returnValue);
        }, delayTime);
        return promise.promise;
      }
    }

    return MockService;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('Office365Provider', function (UserBasedProvider, Room, Event, RoomError, $q, providerUtil, textUtil, timeUtil, eventUtil, dataUtil) {
    function Office365Provider() {
      this.id = 'office365.provider';
      this.mapRoomIdentifier = 'email';
      var base = new UserBasedProvider();
      this.providerInfo = {
        tokenEndpoint: 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
        authenticationEndpoint: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize?{0}',
        baseDataUrl: 'https://graph.microsoft.com',
        baseEventUrl: '{0}/v1.0/users/{1}/events',
        getRoomUrl: '{0}/v1.0/users/{1}',
        getEventUrl: '{0}/v1.0/users/{1}/calendarView/?{2}',
        updateEventUrl: '{0}/v1.0/users/{1}/events/{2}',
        getCurrentRoomUrl: '{0}/v1.0/users/{1}?$select=displayName,userPrincipalName',
        getRoomInfoUrl: '{0}/v1.0/users/{1}/calendar?$select=canEdit',
        getAllRoomsUrl: 'beta/me/findrooms',
        defaultScope: 'offline_access openid profile Calendars.ReadWrite.Shared User.ReadBasic.All',
        urlHierarchicalFormat: '{0}/{1}',
        extendedPropertyExpandFormat: 'singleValueExtendedProperties($filter=id eq \'{0}\')',
        extendedPropertyName: 'String {de66ad5f-6c19-4d33-8cd0-3557275a85aa} Name Metadata'
      };
      this.initialize = base.initialize;
      this.dispose = base.dispose;
      this.updateAuthenticationData = base.updateAuthenticationData;
      this.isEventInCheckInState = base.isEventInCheckInState;

      this.getAuthenticationInfo = function (pairingKey, config) {
        var providerConfig = providerUtil.getProviderConfig(config || {}, this.providerInfo);
        var state = providerUtil.createAuthInfoState(pairingKey, providerConfig.clientId, providerConfig.redirectUrl, providerConfig.clientSecret, providerConfig.scope);
        var endpointParams = textUtil.httpParamSerializer({
          client_id: providerConfig.clientId,
          redirect_uri: providerConfig.redirectUrl,
          response_type: 'code',
          scope: providerConfig.scope,
          state: btoa(state),
          prompt: 'select_account'
        });
        return {
          key: pairingKey,
          url: textUtil.formatText(this.providerInfo.authenticationEndpoint, endpointParams)
        };
      };

      this.getRoom = function (roomId) {
        if (!roomId) {
          return $q.reject();
        }

        var promise = $q.defer();
        var url = textUtil.formatText(this.providerInfo.getRoomUrl, [this.providerInfo.baseDataUrl, roomId]);

        var onSuccess = function onSuccess(data) {
          promise.resolve(new Room(data.mail, data.displayName, data.displayName, data.mail));
        };

        base.getData(url).then(onSuccess, promise.reject);
        return promise.promise;
      };

      this.getRooms = function (roomIds) {
        if (!roomIds || roomIds.length === 0) {
          return $q.resolve([]);
        }

        var promise = $q.defer();
        var promises = [];

        for (var i = 0; i < roomIds.length; i++) {
          promises.push(this.getRoom(roomIds[i]));
        }

        $q.allSettled(promises).then(function (roomPromises) {
          var result = [];

          for (var j = 0; j < roomPromises.length; j++) {
            var roomPromise = roomPromises[j]; // if one of the promise is rejected, reject directly

            if (!roomPromise.value || roomPromise.state === 'rejected') {
              promise.reject('Unable to retrieve one or more rooms');
              return;
            }

            result.push(roomPromise.value);
          }

          promise.resolve(result);
        });
        return promise.promise;
      };

      this.getAllRooms = function () {
        var promise = $q.defer();
        var urlFormat = this.providerInfo.urlHierarchicalFormat;
        var baseUrl = this.providerInfo.baseDataUrl;
        var getAllRoomsUrl = this.providerInfo.getAllRoomsUrl;
        var url = textUtil.formatText(urlFormat, [baseUrl, getAllRoomsUrl]);
        base.getData(url).then(function (data) {
          promise.resolve(processRooms(data.value || []));
        }, promise.reject);
        return promise.promise;
      };

      this.getRoomsInfo = function (rooms) {
        if (!rooms || dataUtil.isNotArrayOrEmpty(rooms)) {
          return $q.resolve(rooms);
        }

        rooms = $angular.copy(rooms);
        var promise = $q.defer();
        var promises = [];

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];

          if (!room) {
            continue;
          }

          promises.push(getRoomInfo(room));
        }

        $q.allSettled(promises)["finally"](function () {
          promise.resolve(rooms);
        });
        return promise.promise;
      };

      this.createEvent = function (room, title, start, end, metadata) {
        var data = {
          subject: title,
          start: toDateWithTimezoneObject(start),
          end: toDateWithTimezoneObject(end),
          location: {
            displayName: room.name,
            uniqueId: room.name
          }
        };

        if (metadata) {
          data = dataUtil.mergeObject(data, toExtendedProperty(metadata));
        }

        var url = textUtil.formatText(this.providerInfo.baseEventUrl, [this.providerInfo.baseDataUrl, room.id]);

        var onDataPosted = function onDataPosted(event) {
          return convertToEvent(room, event, data);
        };

        return base.postData(url, data, onDataPosted);
      };

      this.getEvents = function (room, start, end) {
        var url = getEventUrl(room.id, start, end);

        var onDataRetrieved = function onDataRetrieved(data) {
          var events = data.value || [];
          var result = [];

          for (var i = 0; i < events.length; i++) {
            var event = convertToEvent(room, events[i]);

            if (!event || event.isCancelled) {
              continue;
            }

            result.push(event);
          }

          return result;
        };

        var onDataRetrievalFailed = function onDataRetrievalFailed(error) {
          return createRoomError(room, error);
        };

        return base.getData(url, onDataRetrieved, onDataRetrievalFailed);
      };

      this.updateEvent = function (updateData) {
        if (!updateData) {
          return $q.reject('data not valid');
        } // only pass applicable data to update.


        var data = {};
        var url = getUpdateEventUrl(updateData);

        if (updateData.start) {
          data.start = toDateWithTimezoneObject(updateData.start);
        }

        if (updateData.end) {
          data.end = toDateWithTimezoneObject(updateData.end);
        }

        if (updateData.metadata) {
          data = dataUtil.mergeObject(data, toExtendedProperty(updateData.metadata));
        }

        if (updateData.title) {
          data.subject = updateData.title;
        }

        var onDataPatched = function onDataPatched(result) {
          return convertToEvent(updateData.room, result, data, updateData.originalEvent);
        };

        return base.patchData(url, data, onDataPatched);
      };

      this.deleteEvent = function (event) {
        var url = getUpdateEventUrl(event);

        var onDataDeleted = function onDataDeleted() {
          return convertToEvent(event.room, event);
        };

        return base.deleteData(url, onDataDeleted);
      };

      function createRoomError(room, error) {
        var roomId = (room || {}).id;
        var errorObject = error || {};
        var errorData = (errorObject.data || {}).error || {};
        return new RoomError(roomId, errorObject.status, errorData.message, errorData.code);
      }

      function toDateWithTimezoneObject(time) {
        return {
          datetime: timeUtil.getUtcStringFromDate(time),
          timezone: 'UTC'
        };
      }

      var getUpdateEventUrl = function (event) {
        if (!event) {
          return;
        }

        return textUtil.formatText(this.providerInfo.updateEventUrl, [this.providerInfo.baseDataUrl, event.room.id, event.id]);
      }.bind(this);

      var getRoomInfo = function (room) {
        var promise = $q.defer();
        var url = textUtil.formatText(this.providerInfo.getRoomInfoUrl, [this.providerInfo.baseDataUrl, room.id]);

        var onsuccess = function onsuccess(roomData) {
          room.isReadOnly = !(roomData || {}).canEdit;
        };

        base.getData(url, onsuccess)["finally"](function () {
          promise.resolve(room);
        });
        return promise.promise;
      }.bind(this);

      var toExtendedProperty = function (metadata) {
        return {
          singleValueExtendedProperties: [{
            id: this.providerInfo.extendedPropertyName,
            value: JSON.stringify(metadata)
          }]
        };
      }.bind(this);

      function convertToEvent(room, data, patchData, originalEvent) {
        if (!data) {
          return;
        }

        var dateParser = timeUtil.getDateFromUtcString;
        var startData = data.start.dateTime;
        var endData = data.end.dateTime;
        var isAllDay = false; // all-day events doesn't have dateTime, only date

        if (!data.start.dateTime && data.start.date) {
          dateParser = timeUtil.getDateFromDateOnlyString;
          startData = data.start.date;
          endData = data.end.date;
          isAllDay = true;
        }

        var organizerInfo = data.organizer || {};
        var emailAddress = organizerInfo.emailAddress || {};
        var event = new Event(data.id, eventUtil.generateOrganizerName(room, emailAddress.address, emailAddress.name), room, data.subject, dateParser(startData), dateParser(endData));
        event.isAllDay = isAllDay;
        event.originalStartTime = startData;
        event.originalEndTime = endData;
        event.originalLocation = data.location; // office365 does not return back the singleValueExtendedProperties in the event after a booking action is executed

        var singleValueExtendedProperties = data.singleValueExtendedProperties || (patchData || {}).singleValueExtendedProperties;

        if (singleValueExtendedProperties) {
          event.metadata = JSON.parse(singleValueExtendedProperties[0].value);
        } else if (originalEvent && originalEvent.metadata) {
          // use the original event's metadata to determine that the event has been checked in after patching
          event.metadata = originalEvent.metadata;
        }

        event.isCheckedIn = base.isEventCheckedIn(event);
        return event;
      }

      var getEventUrl = function (id, start, end) {
        if (!id) {
          return;
        }

        var startDate = timeUtil.getUtcStringFromDate(start);
        var endDate = timeUtil.getUtcStringFromDate(end);
        var params = {
          '$orderby': 'start/datetime+asc',
          '$select': 'subject,isAllDay,isCancelled,organizer,start,end,location,sensitivity,responseStatus',
          '$expand': textUtil.formatText(this.providerInfo.extendedPropertyExpandFormat, this.providerInfo.extendedPropertyName),
          '$top': '5000',
          'endDateTime': endDate,
          'startDateTime': startDate
        };
        var url = textUtil.formatText(this.providerInfo.getEventUrl, [this.providerInfo.baseDataUrl, id, textUtil.httpParamSerializer(params)]);
        return url;
      }.bind(this);

      function processRooms(rooms) {
        var result = [];

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];
          result.push(new Room(room.address, room.name, room.name, room.address));
        }

        return result;
      }
    } // Return the constructor for the class


    return Office365Provider;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('Office365AdminProvider', function (Office365Provider, providerUtil, textUtil, dataUtil, configurationManager, CUSTOM_DATA_KEY) {
    function Office365AdminProvider() {
      this.id = 'office365admin.provider';
      var base = new Office365Provider();

      this.initialize = function () {
        base.providerInfo.authenticationEndpoint = 'https://login.microsoftonline.com/common/adminconsent?{0}';
        base.initialize();
      };

      this.dispose = base.dispose;
      this.mapRoomIdentifier = base.mapRoomIdentifier;
      this.updateAuthenticationData = base.updateAuthenticationData;
      this.isEventInCheckInState = base.isEventInCheckInState;
      configurationManager.subscribeToCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA, setAllRoomsUrl);

      this.getAuthenticationInfo = function (pairingKey, config) {
        var providerConfig = providerUtil.getProviderConfig(config || {}, base.providerInfo);
        var state = providerUtil.createAuthInfoState(pairingKey, providerConfig.clientId, providerConfig.redirectUrl, providerConfig.clientSecret, providerConfig.scope);
        var endpointParams = textUtil.httpParamSerializer({
          client_id: providerConfig.clientId,
          redirect_uri: providerConfig.redirectUrl,
          state: btoa(state),
          prompt: 'admin_consent'
        });
        return {
          key: pairingKey,
          url: textUtil.formatText(base.providerInfo.authenticationEndpoint, endpointParams)
        };
      };

      this.getRooms = function (roomIds) {
        return base.getRooms(roomIds);
      };

      this.getRoom = function (roomId) {
        return base.getRoom(roomId);
      };

      this.getAllRooms = function () {
        return base.getAllRooms();
      };

      this.createEvent = function (room, title, start, end, metadata) {
        return base.createEvent(room, title, start, end, metadata);
      };

      this.getEvents = function (room, start, end) {
        return base.getEvents(room, start, end);
      };

      this.updateEvent = function (updateData) {
        return base.updateEvent(updateData);
      };

      this.deleteEvent = function (event) {
        return base.deleteEvent(event);
      };

      function setAllRoomsUrl() {
        var authenticationData = configurationManager.getCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA) || {};

        if (dataUtil.isObjectEmpty(authenticationData) || dataUtil.isObjectEmpty(authenticationData.provider)) {
          return;
        }

        base.providerInfo.getAllRoomsUrl = textUtil.formatText('beta/users/{0}/findrooms', authenticationData.provider.loginUser);
      }
    } // Return the constructor for the class


    return Office365AdminProvider;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('UserBasedProvider', ["$q", "networkUtil", "textUtil", "dataUtil", "eventUtil", "scheduleUtil", "configurationManager", "dataConfigurationManager", "CUSTOM_DATA_KEY", "PLAYER_PROPERTY_KEYS", "MODEL_INPUT_KEYS", function ($q, networkUtil, textUtil, dataUtil, eventUtil, scheduleUtil, configurationManager, dataConfigurationManager, CUSTOM_DATA_KEY, PLAYER_PROPERTY_KEYS, MODEL_INPUT_KEYS) {
    function UserBasedProvider() {
      var tokenTimeoutValue = 10000;
      var accessTokenUrlFormat = '{0}/{1}/accesstoken';
      var accessToken;
      var tokenExpires;
      var providerType;
      var applicationPath;
      var serviceUrl;
      var clientId;
      var oauthId;
      var privateName;
      var DEFAULT_PRIVATE_MEETING_TITLE = 'Private Meeting';
      var EVENT_VISIBILITY_PRIVATE = 'private';
      var isInitialized = false;
      var subscriptions = [];
      var getAccessTokenPromise;
      var facilitiesMapping = configurationManager.getInputModel(MODEL_INPUT_KEYS.FACILITIES_MAPPING);
      this.isEventInCheckInState = scheduleUtil.isEventRequiresCheckIn;

      this.initialize = function () {
        if (isInitialized) {
          return;
        }

        var privateNameSubscription = configurationManager.getInputObservable(MODEL_INPUT_KEYS.PRIVATE_MEETING_NAME, DEFAULT_PRIVATE_MEETING_TITLE).subscribe(function (name) {
          privateName = name;
        });
        subscriptions.push(privateNameSubscription);
        updateAuthenticationData(configurationManager.getCustomData(CUSTOM_DATA_KEY.AUTHENTICATION_DATA));
        isInitialized = true;
      }; // need a way to unsubscribe/dispose.


      this.dispose = function () {
        for (var i = 0; i < subscriptions.length; i++) {
          subscriptions[i].dispose();
        }

        isInitialized = false;
        resetAccessToken();
        providerType = undefined;
        serviceUrl = undefined;
        clientId = undefined;
        oauthId = undefined;
      };

      this.getData = function (url, successCallback, failureCallback) {
        return processData('GET', url, undefined, successCallback, failureCallback);
      };

      this.postData = function (url, data, successCallback) {
        return processData('POST', url, data, successCallback);
      };

      this.deleteData = function (url, successCallback) {
        return processData('DELETE', url, undefined, successCallback);
      };

      this.patchData = function (url, data, successCallback) {
        return processData('PATCH', url, data, successCallback);
      };

      this.validateName = function (value, currentName) {
        return value !== EVENT_VISIBILITY_PRIVATE ? currentName : privateName;
      };

      this.isEventCheckedIn = function (event) {
        return !dataConfigurationManager.getCheckInEnabled() || eventUtil.isCheckedIn(event);
      };

      this.getKeyFromFacilitiesMap = function (value) {
        if (!value || !facilitiesMapping) {
          return;
        }

        return Object.keys(facilitiesMapping).filter(function (key) {
          return (facilitiesMapping[key] || '').toLowerCase() === value.toLowerCase();
        })[0];
      };

      function updateAuthenticationData(authenticationData) {
        if (!authenticationData || dataUtil.isObjectEmpty(authenticationData) || dataUtil.isObjectEmpty(authenticationData.provider)) {
          return;
        }

        applicationPath = authenticationData.provider.applicationPath;
        providerType = authenticationData.provider.type;
        serviceUrl = authenticationData.provider.serviceUrl;
        clientId = authenticationData.provider.clientId;
        oauthId = authenticationData.data.oauthId;
      }

      function processData(method, url, data, onSuccess, onFailure) {
        var defer = $q.defer();

        var rejectPromise = function rejectPromise(error) {
          defer.reject(error);

          if (!onFailure) {
            return;
          }

          onFailure(error);
        };

        getAccessToken().then(function (token) {
          var config = createHttpConfig(method, url, token);

          if (data) {
            config.data = data;
          }

          networkUtil.http(config).then(function (result) {
            // if we have no result
            // or result's data is empty & not 204 (empty response as intended)
            // reject the request
            if (!result || !result.data && result.status != 204) {
              rejectPromise('No data found');
              return;
            }

            if (result.data.error) {
              rejectPromise(result.data.error);
              return;
            }

            var resolveData = result.data;

            if (onSuccess) {
              resolveData = onSuccess(result.data);
            }

            defer.resolve(resolveData);
          }, rejectPromise);
        }, defer.reject);
        return defer.promise;
      }

      function getAccessToken() {
        if (accessToken && tokenExpires && new Date().getTime() < tokenExpires) {
          return $q.resolve(accessToken);
        }

        if (getAccessTokenPromise) {
          return getAccessTokenPromise.promise;
        }

        getAccessTokenPromise = $q.defer();
        resetAccessToken();
        prepareAccessTokenHeader().then(function (requestUrl) {
          networkUtil.http(requestUrl).then(function (result) {
            // Get the number of seconds the token is valid for,
            // Subract 5 minutes (300 sec) to account for differences in clock settings
            // Convert to milliseconds
            var res = result.data;
            var expiresIn = (parseInt(res.expires_in) - 300) * 1000;
            tokenExpires = new Date().getTime() + expiresIn;
            accessToken = res.access_token;
            getAccessTokenPromise.resolve(accessToken);
          }, getAccessTokenPromise.reject)["finally"](function () {
            getAccessTokenPromise = undefined;
          });
        });
        return getAccessTokenPromise.promise;
      }

      function resetAccessToken() {
        accessToken = undefined;
        tokenExpires = undefined;
      }

      function prepareAccessTokenHeader() {
        var promise = $q.defer();
        var config = {
          url: textUtil.formatText(accessTokenUrlFormat, [serviceUrl, applicationPath || providerType]),
          method: 'POST',
          timeout: tokenTimeoutValue,
          headers: {}
        };
        config.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        config.data = {
          client_id: clientId,
          grant_type: 'refresh_token',
          oauth_id: oauthId
        };
        configurationManager.isReady().then(function () {
          var getPlayerProperty = configurationManager.getPlayerProperty;
          config.headers['Appspace-PlayerGuid'] = getPlayerProperty(PLAYER_PROPERTY_KEYS.PLAYER_GUID);
          config.headers['Appspace-AccountGuid'] = getPlayerProperty(PLAYER_PROPERTY_KEYS.ACCOUNT_GUID);
          config.headers['Appspace-ServiceApiUrl'] = getPlayerProperty(PLAYER_PROPERTY_KEYS.SERVICES_API);
          promise.resolve(config);
        });
        return promise.promise;
      }

      function createHttpConfig(method, url, token) {
        return {
          method: method,
          url: url,
          headers: {
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
          }
        };
      }
    }

    return UserBasedProvider;
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  var app = $angular.module('scheduleBoard');
  app.controller('scheduleController', ["$q", "$scope", "$filter", "POSITIONS", "MODEL_INPUT_VALUES", "STATE", "TEXT_RESOURCE", "displayConfigurationManager", "dataConfigurationManager", "configurationManager", "cardApiManager", "cssUtil", "colorUtil", "FilterDialog", "BookDialog", "EventActionDialog", "CheckInDialog", "EndDialog", "ExtendDialog", "EventInfoDialog", "roomManager", "calendarDataManager", "eventManager", "textResourceManager", "scheduleUtil", "settingsUtil", "SETTINGS_OPTIONS", "LogOutDialog", "authenticationManager", "$location", "ROUTES", "dataUtil", function ($q, $scope, $filter, POSITIONS, MODEL_INPUT_VALUES, STATE, TEXT_RESOURCE, displayConfigurationManager, dataConfigurationManager, configurationManager, cardApiManager, cssUtil, colorUtil, FilterDialog, BookDialog, EventActionDialog, CheckInDialog, EndDialog, ExtendDialog, EventInfoDialog, roomManager, calendarDataManager, eventManager, textResourceManager, scheduleUtil, settingsUtil, SETTINGS_OPTIONS, LogOutDialog, authenticationManager, $location, ROUTES, dataUtil) {
    $scope.POSITIONS = POSITIONS;
    $scope.title;
    $scope.logoImage;
    $scope.logoPosition;
    $scope.titleStyle;
    $scope.headerBackground = {};
    $scope.headerTextColor = '';
    $scope.is24HourClock = false;
    $scope.isEditing = configurationManager.isEditing();
    $scope.isRoomPickerVisible = false;
    $scope.hideTable = true;
    $scope.isClockEnabled = true;
    $scope.error = {
      message: '',
      subMessage: ''
    };
    $scope.shouldShowLogo = shouldShowLogo;
    $scope.isMapEnabled = false;
    $scope.isMapLayout = false;
    $scope.isCurrentMapView = false;
    $scope.showHeader = true;
    var isScheduleLayout = false;
    var isInteractivityEnabled = false;
    var isRoomInfoPanelOpen = false;
    var currentConfiguration = {};
    var scheduleTableApi;
    var scheduleTableApiReady = $q.defer();
    var currentRooms;
    var currentRoomsInfo = {};
    var currentLayout = {
      temp: MODEL_INPUT_VALUES.SCHEDULE,
      // temporary
      config: MODEL_INPUT_VALUES.SCHEDULE // from config

    };
    var currentHeaderTitle = '';
    var DEFAULT_HEADER_TITLE = {};
    DEFAULT_HEADER_TITLE[MODEL_INPUT_VALUES.CURRENT_EVENTS] = 'Current Events';
    DEFAULT_HEADER_TITLE[MODEL_INPUT_VALUES.SCHEDULE] = 'Schedule';
    DEFAULT_HEADER_TITLE[MODEL_INPUT_VALUES.MAP] = 'Floor Map';
    var isLogoEnabled = true;
    var showFooter = false;
    var roomEventSubscribers = {};
    var subscribers = [];
    var lastDialogModel = undefined;
    var hiddenMeetingName = textResourceManager.getText(TEXT_RESOURCE.DIALOG_HIDDEN_MEETING_NAME);
    subscribers.push(displayConfigurationManager.subscribeToClockFormat(onClockFormatChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableLogo(onEnableLogoChanged));
    subscribers.push(displayConfigurationManager.subscribeToLogoImage(onLogoImageChanged));
    subscribers.push(displayConfigurationManager.subscribeToLogoPosition(onLogoPositionChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableHeader(onEnableHeaderChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableMeetingName(onEnableMeetingNameChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableOrganizerName(onEnableOrganizerNameChanged));
    subscribers.push(displayConfigurationManager.subscribeToHeaderTitle(onHeaderTitleChanged));
    subscribers.push(displayConfigurationManager.subscribeToHeaderTextColor(onHeaderTextColorChanged));
    subscribers.push(displayConfigurationManager.subscribeToHeaderBackgroundImage(onHeaderBackgroundImageChanged));
    subscribers.push(displayConfigurationManager.subscribeToHeaderBackgroundColor(onHeaderBackgroundColorChanged));
    subscribers.push(displayConfigurationManager.subscribeToHeaderMaskColor(onHeaderMaskColorChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableClock(onEnableClockChanged));
    subscribers.push(calendarDataManager.subscribeToConfigurationChanged(onConfigurationChanged));
    subscribers.push(displayConfigurationManager.subscribeToInteractivity(onInteractivityChanges));
    subscribers.push(displayConfigurationManager.subscribeToLayout(onLayoutChanged));
    subscribers.push(displayConfigurationManager.subscribeToEnableMap(onEnableMapChanged));
    $scope.$on('$destroy', function () {
      currentRooms = [];
      currentRoomsInfo = {};
      updateRoomEventSubscribers();

      for (var i = 0; i < subscribers.length; i++) {
        var subscriber = subscribers[i];

        if (!subscriber || !subscriber.dispose) {
          continue;
        }

        subscriber.dispose();
      }
    });

    $scope.shouldShowFooter = function () {
      var shouldShowFooter = isLogoEnabled && $scope.logoImage && ($scope.logoPosition == POSITIONS.BOTTOM_LEFT || $scope.logoPosition == POSITIONS.BOTTOM_RIGHT);

      if (showFooter != shouldShowFooter) {
        isScheduleTableApiReady().then(function () {
          scheduleTableApi.setShowFooter(shouldShowFooter);
        });
      }

      showFooter = shouldShowFooter;
      return shouldShowFooter;
    };

    function shouldShowLogo(position) {
      return isLogoEnabled && $scope.logoImage && $scope.logoPosition === position;
    }

    function setLayout(layout, isPermanent) {
      currentLayout.temp = layout;
      setHeaderTitle();
      isScheduleTableApiReady().then(function () {
        if (isPermanent) {
          scheduleTableApi.setLayout(currentLayout.config);
        } else {
          scheduleTableApi.setTemporaryLayout(currentLayout.temp);
        }

        eventManager.raiseViewChanged(currentLayout.temp);
      });
    }

    $scope.onRoomPickerApiReady = function (roomPickerApi) {
      if (!roomPickerApi) {
        return;
      }

      roomPickerApi.start();
    };

    $scope.onRoomPickerClose = function (selectedRooms) {
      roomManager.saveSelectedRooms(selectedRooms);
      $scope.isRoomPickerVisible = false;
    };

    $scope.onRoomPickerCancel = function () {
      $scope.isRoomPickerVisible = false;
    };

    $scope.onScheduleTableApiReady = function (api) {
      if (!api) {
        return;
      }

      scheduleTableApi = api;
      scheduleTableApiReady.resolve();
    };

    function getEventFromCurrentRoomsInfo(room, event) {
      return $filter('filter')(currentRoomsInfo[room.id].events, function (obj) {
        return obj.id === event.id;
      })[0];
    }

    $scope.onEventInfoOnlyClicked = function (room, event) {
      var currentEvent = getEventFromCurrentRoomsInfo(room, event);

      if (!currentEvent) {
        return;
      }

      openDialog(new EventInfoDialog(room, currentEvent));
    };

    $scope.onCheckInEventClicked = function (room, event) {
      var currentEvent = getEventFromCurrentRoomsInfo(room, event);

      if (!currentEvent) {
        return;
      }

      openDialog(new CheckInDialog(room, currentEvent));
    };

    $scope.onEndEventClicked = function (room, event) {
      var currentEvent = getEventFromCurrentRoomsInfo(room, event);

      if (!currentEvent) {
        return;
      }

      openDialog(new EndDialog(room, currentEvent));
    };

    $scope.onExtendEventClicked = function (room, event) {
      var currentEvent = getEventFromCurrentRoomsInfo(room, event);

      if (!currentEvent) {
        return;
      }

      openDialog(new ExtendDialog(room, currentEvent, scheduleUtil.getAvailableTimeRange(currentEvent.end, room.schedules, currentConfiguration.bookLimit, currentConfiguration.interval)));
    };

    $scope.onEventActionClicked = function (room, event, events) {
      var currentEvent = getEventFromCurrentRoomsInfo(room, event);

      if (!currentEvent) {
        return;
      }

      openDialog(new EventActionDialog(room, currentEvent, scheduleUtil.getAvailableTimeRange(currentEvent.end, events, currentConfiguration.bookLimit, currentConfiguration.interval)));
    };

    $scope.onBookEventClicked = function (room, slot, events) {
      if (!room || !slot) {
        return;
      }

      var slotRange = scheduleUtil.getAvailableTimeRange(new Date(slot.start), events, currentConfiguration.bookLimit, currentConfiguration.interval);

      if (!slotRange) {
        return;
      }

      openDialog(new BookDialog({
        room: room,
        start: slotRange.start,
        end: slotRange.end,
        endOfDay: slotRange.endOfDay
      }));
    };

    $scope.onFilterClicked = function () {
      openDialog(new FilterDialog(onFilterChanged));
    };

    $scope.onMapToggleClick = function () {
      setLayout(currentLayout.temp === MODEL_INPUT_VALUES.MAP ? currentLayout.config : MODEL_INPUT_VALUES.MAP);
      $scope.isCurrentMapView = currentLayout.temp === MODEL_INPUT_VALUES.MAP;
    };

    $scope.onInfoPanelOpenChanged = function (isOpen) {
      isRoomInfoPanelOpen = isOpen;
      updateShowHeader();
    };

    function setSwitchLayoutButtonClass() {
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setSwitchButtonStyle(shouldShowLogo(POSITIONS.BOTTOM_RIGHT) ? 'left-aligned' : '');
      });
    }

    $scope.onSettingsClicked = function (value) {
      switch (value) {
        case SETTINGS_OPTIONS.MANAGE_ROOMS:
          onChangeRoomsSelected();
          break;

        case SETTINGS_OPTIONS.AUTHENTICATE_ACCOUNT:
          authenticationManager.logOut().then(function () {
            $location.path(ROUTES.DEFAULT);
          });
          break;

        case SETTINGS_OPTIONS.LOG_OUT:
          openDialog(new LogOutDialog());
          break;
      }
    };

    function updateShowHeader() {
      // Don't show header when room info panel is open with header disabled
      if (!$scope.isHeaderEnabled && isRoomInfoPanelOpen) {
        $scope.showHeader = false;
        return;
      } // Header will always be shown in Schedule layout regardless of header and interactivity's availability
      // whereas header will be hidden if both header and interactivity are disabled when it's in other layouts 


      $scope.showHeader = isScheduleLayout || $scope.isHeaderEnabled || isInteractivityEnabled;
    }

    function isScheduleTableApiReady() {
      return scheduleTableApiReady.promise;
    }

    function onCalendarDataManagerInitialized() {
      $scope.settingsMenu = settingsUtil.generateMenu(calendarDataManager.isPreview());
      eventManager.initialize();
      subscribers.push(dataConfigurationManager.subscribeToCheckIn(onCheckInEnabledChanged));

      if (isScreenshotProcessed()) {
        return;
      }

      subscribers.push(calendarDataManager.subscribeToRoomIdsChanged(onRoomIdsChanged));
      subscribers.push(calendarDataManager.getRoomsObservable().subscribe(onRoomsDataChanged));
      subscribers.push(calendarDataManager.subscribeToStateChanged(onStateChanged));
    }

    function onCheckInEnabledChanged() {
      if (isScreenshotProcessed() || !configurationManager.isEditing()) {
        return;
      } // Update rooms list and bind rooms to events in editing mode only


      updateRoomsList();
      bindRoomsToEvents();
    }

    function isScreenshotProcessed() {
      if (!configurationManager.isScreenshot()) {
        return false;
      }

      calendarDataManager.getRoomsAndEvent().then(onRoomsAndEventsReceived);
      return true;
    }

    function onChangeRoomsSelected() {
      $scope.isRoomPickerVisible = true;
    }

    function onEnableLogoChanged(enable) {
      isLogoEnabled = enable;
      setSwitchLayoutButtonClass();
    }

    function onLogoImageChanged(images) {
      $scope.logoImage = (images[0] || {}).path;
      setSwitchLayoutButtonClass();
    }

    function onLogoPositionChanged(position) {
      $scope.logoPosition = position;
      setSwitchLayoutButtonClass();
    }

    function onEnableHeaderChanged(enable) {
      $scope.isHeaderEnabled = enable;
      updateShowHeader();
    }

    function onEnableMeetingNameChanged(enable) {
      $scope.isMeetingNameEnabled = enable;
      refreshUi();
    }

    function onEnableOrganizerNameChanged(enable) {
      $scope.isOrganizerNameEnabled = enable;
      refreshUi();
    }

    function refreshUi() {
      for (var roomId in currentRoomsInfo) {
        refreshScheduleTable(currentRoomsInfo[roomId]);
      }

      updateDialog();
    }

    function updateMeetingInfo(events) {
      var title = $scope.isMeetingNameEnabled ? undefined : hiddenMeetingName;

      for (var i = 0; i < events.length; i++) {
        events[i].setTitle(title);
        events[i].showOrganizerUsername($scope.isOrganizerNameEnabled);
      }
    }

    function updateDialog() {
      if (!lastDialogModel) {
        return;
      }

      lastDialogModel.refresh();
    }

    function setHeaderTitle(title) {
      $scope.title = title || currentHeaderTitle || DEFAULT_HEADER_TITLE[currentLayout.temp];
    }

    function onHeaderTitleChanged(header) {
      header = header || {};
      currentHeaderTitle = header.value;
      setHeaderTitle(header.value);
      var headerStyle = header.style || {};
      $scope.titleStyle = cssUtil.toCssInlineStyle(headerStyle);
    }

    function onHeaderBackgroundImageChanged(media) {
      $scope.headerBackground.media = media;
    }

    function onHeaderBackgroundColorChanged(color) {
      var rgba = colorUtil.toRgbaObject(color);
      $scope.headerBackground.style = {
        opacity: rgba.a
      };
      $scope.headerBackground.color = colorUtil.toCssString({
        r: rgba.r,
        g: rgba.g,
        b: rgba.b
      });
    }

    function onHeaderMaskColorChanged(color) {
      $scope.headerBackground.mask = color;
    }

    function onEnableClockChanged(enabled) {
      $scope.isClockEnabled = enabled;
    }

    function onHeaderTextColorChanged(color) {
      $scope.headerTextColor = {
        color: color
      };
    }

    function onClockFormatChanged(clockFormat) {
      $scope.is24HourClock = clockFormat.is24Hour;
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setClockFormat(clockFormat);
      });
    }

    function onConfigurationChanged(scheduleConfig) {
      currentConfiguration = scheduleConfig;
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setConfiguration(scheduleConfig);
      });
    }

    function onInteractivityChanges(value) {
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setInteractivity(value);
        isInteractivityEnabled = value;
        updateShowHeader();
      });
    }

    function onLayoutChanged(layout) {
      $scope.isMapLayout = layout === MODEL_INPUT_VALUES.MAP;
      $scope.isCurrentMapView = $scope.isMapLayout;
      updateShowHeader();

      if (!layout) {
        return;
      }

      isScheduleLayout = layout === MODEL_INPUT_VALUES.SCHEDULE;
      updateShowHeader();
      currentLayout.config = layout;
      setLayout(layout, true);
    }

    function onEnableMapChanged(enable) {
      $scope.isMapEnabled = enable;
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setEnableMap(enable);
      });

      if (enable) {
        return;
      } // reset temporary layout when map is disabled


      setLayout(currentLayout.config);
    }

    function onRoomsAndEventsReceived(data) {
      if (!data) {
        return;
      }

      showErrorMessage(false);
      var displayItems = [];

      for (var i = 0; i < data.length; i++) {
        var room = data[i];
        displayItems.push(scheduleUtil.toDisplayItem(room.room, room.events, calendarDataManager.getIgnoreCheckInConfiguration()));
      }

      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setRoomsAndEvents(scheduleUtil.toScheduleTableData(displayItems));
      });
      cardApiManager.notifyOnLoad();
    }

    function onRoomIdsChanged(roomIds) {
      // ignore initial value
      if (!roomIds) {
        return;
      } // for cases where rooms are empty


      if (!roomIds.length) {
        cardApiManager.notifyOnLoad();
      }
    }

    function updateCurrentRoomsInfo() {
      var updatedRoomsInfo = {};

      for (var i = 0; i < currentRooms.length; i++) {
        var room = currentRooms[i] || {};
        var roomId = room.id;

        if (!roomId) {
          continue;
        }

        var currentRoomInfo = currentRoomsInfo[roomId];

        if (!currentRoomInfo) {
          continue;
        }

        updatedRoomsInfo[roomId] = $angular.copy(currentRoomInfo);
      }

      currentRoomsInfo = updatedRoomsInfo;
    }

    function onRoomsDataChanged(data) {
      if (!data) {
        return;
      }

      var rooms = data.rooms;

      if (!currentRooms && !rooms || dataUtil.isArrayEqual(currentRooms, rooms)) {
        return;
      }

      currentRooms = $angular.copy(rooms);
      var displayItems = updateRoomsList();
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.reset();
        scheduleTableApi.updateRooms(scheduleUtil.toScheduleTableData(displayItems));
        updateCurrentRoomsInfo();
        $scope.$emit('triggerDialogEvent', {
          showDialog: false
        });
        bindRoomsToEvents(data.isTransparentUpdate);
      });
      cardApiManager.notifyOnLoad();
    }

    function updateRoomsList() {
      var displayItems = [];

      if (!currentRooms) {
        return displayItems;
      }

      updateRoomEventSubscribers();

      for (var i = 0; i < currentRooms.length; i++) {
        var room = currentRooms[i];

        if (!room || !room.id) {
          continue;
        }

        var roomInfo = currentRoomsInfo[room.id] || {}; // convert to schedule table component display item

        displayItems.push(scheduleUtil.toDisplayItem(room, roomInfo.events || []));
      }

      return displayItems;
    }

    function bindRoomsToEvents(isTransparentUpdate) {
      if (isTransparentUpdate) {
        return;
      }

      calendarDataManager.resetRoomEventData();
      eventManager.resetRoomInfo();

      if (!currentRooms) {
        return;
      }

      subscribeToRoomsEvent();
      eventManager.subscribeToRoomsEvent(currentRooms);
    }

    function subscribeToRoomsEvent() {
      for (var j = 0; j < currentRooms.length; j++) {
        var room = currentRooms[j];

        if (!room || !room.id) {
          continue;
        } // subscribe to room's events


        roomEventSubscribers[room.id] = calendarDataManager.subscribeToRoomEvent(room, onEventRefreshed);
      }
    }

    function showErrorMessage(hide, message, subMessage) {
      $scope.hideTable = hide;
      $scope.error.message = message || '';
      $scope.error.subMessage = subMessage || '';
    }

    function onStateChanged(state) {
      if (!state) {
        return;
      }

      showErrorMessage(false);

      switch (state) {
        case STATE.UNAUTHENTICATED:
          showErrorMessage(true, textResourceManager.getText(TEXT_RESOURCE.STATE_UNAUTHENTICATED_MESSAGE), textResourceManager.getText(TEXT_RESOURCE.STATE_UNAUTHENTICATED_SUBMESSAGE));
          break;

        case STATE.UNCONFIGURED:
          showErrorMessage(true, textResourceManager.getText(TEXT_RESOURCE.STATE_UNCONFIGURED_MESSAGE), textResourceManager.getText(TEXT_RESOURCE.STATE_UNCONFIGURED_SUBMESSAGE));
          break;
      }

      cardApiManager.notifyOnLoad();
    }

    function onEventRefreshed(data) {
      if (!data || !data.room) {
        return;
      }

      currentRoomsInfo[data.room.id] = {
        room: data.room,
        events: data.events
      };
      refreshScheduleTable(data);
    }

    function refreshScheduleTable(data) {
      updateMeetingInfo(data.events);
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.updateEvents(scheduleUtil.toDisplayItem(data.room, data.events, calendarDataManager.getIgnoreCheckInConfiguration()));
      });
    }

    function updateRoomEventSubscribers() {
      for (var key in roomEventSubscribers) {
        if (currentRoomsInfo[key]) {
          continue;
        }

        roomEventSubscribers[key].dispose();
      }

      roomEventSubscribers = {};
    }

    function onFilterChanged(filter) {
      isScheduleTableApiReady().then(function () {
        scheduleTableApi.setFilter(filter);
      });
    }

    function openDialog(dialogModel) {
      $scope.$emit('triggerDialogEvent', {
        showDialog: true,
        dialogModel: dialogModel
      });
      lastDialogModel = dialogModel;
    }

    configurationManager.isReady().then(calendarDataManager.initialize);
    calendarDataManager.isReady().then(onCalendarDataManagerInitialized);
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').controller('authenticationController', function ($scope, $location, $timeout, textUtil, dataUtil, authenticationManager, configurationManager, cardApiManager, TEXT_RESOURCE, textResourceManager, ROUTES) {
    var ERROR_TIMEOUT_WAIT_TIME = 5000;
    var DEFAULT_TIMEOUT_DURATION = 5000;
    var errorTimeout;
    var generalError = textUtil.formatText(TEXT_RESOURCE.PROVIDER_ERROR.value);
    var customProviderError = textResourceManager.getText(TEXT_RESOURCE.PROVIDER_CUSTOM_ERROR);
    $scope.showProvidersBox = false;
    $scope.showEror = false;
    $scope.showLoading = false;
    $scope.userBoxTitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_SELECT.value);
    $scope.adminBoxTitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_ADMIN_SELECT.value);
    $scope.authenticateBoxTitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_AUTHENTICATING.value);
    $scope.error = generalError;
    $scope.adminButton = textUtil.formatText(TEXT_RESOURCE.PROVIDER_ADMIN_BUTTON.value);
    $scope.userButton = textUtil.formatText(TEXT_RESOURCE.PROVIDER_USER_BUTTON.value);
    $scope.popupBlockedMessage;
    $scope.returnButtonText;
    $scope.customProvider;
    var authenticationDataSubscription;
    var providerListSubscription;
    var currentProvider;
    var appspaceValidationTimeout;
    var availableFeatures;
    $scope.$on('$destroy', function () {
      if (providerListSubscription) {
        providerListSubscription.dispose();
      }

      if (authenticationDataSubscription) {
        authenticationDataSubscription.dispose();
      }

      authenticationManager.cancel();
      clearError();
    });

    $scope.onClick = function (provider) {
      clearError();

      if (!provider) {
        return;
      }

      currentProvider = $angular.copy(provider);

      if (provider.usecustomvalidation) {
        $scope.customProvider = currentProvider;

        if (!provider.providerUrl) {
          showCustomBox(true);
          return;
        }

        validateProvider();
        return;
      }

      if (provider.requiresconstellationservice) {
        validateAppspaceProvider();
        return;
      }

      if (!provider.admin) {
        doAuthenticate();
        return;
      }

      extractAdminProvider(provider);
    };

    function clearAppspaceValidationTimeout() {
      if (!appspaceValidationTimeout) {
        return;
      }

      $timeout.cancel(appspaceValidationTimeout);
      appspaceValidationTimeout = undefined;
    }

    function validateAppspaceProvider() {
      $scope.authenticateBoxTitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_APPSPACE_CONNECTING.value);
      clearAppspaceValidationTimeout();
      appspaceValidationTimeout = $timeout(function () {
        // Show error message and go back to provider selection page if
        // validation request does not fail or succeed within 5 seconds
        showAdminBox(false);
        $scope.error = generalError;
        $scope.showError = true;
        $scope.showLoading = false;
        clearErrorTimeout();
        errorTimeout = $timeout(clearError, DEFAULT_TIMEOUT_DURATION);
      }, DEFAULT_TIMEOUT_DURATION);
      doValidateProvider({
        provider: currentProvider,
        providerUrl: currentProvider.providerurl,
        requestMethod: 'requestConstellationService',
        requestConfig: {
          method: 'GET',
          headers: {
            Accept: 'application/json'
          },
          relativeUrl: currentProvider.providerurl + currentProvider.healthcheckpath
        }
      });
    }

    function validateProvider() {
      doValidateProvider({
        provider: currentProvider,
        providerUrl: currentProvider.providerUrl,
        requestMethod: 'http',
        requestConfig: {
          method: 'GET',
          url: currentProvider.providerUrl + currentProvider.healthcheckpath,
          headers: currentProvider.headers
        }
      });
    }

    function doValidateProvider(config) {
      $scope.showLoading = true;
      $scope.showError = false;
      config.skipHeaders = currentProvider.skipheaders;
      authenticationManager.validateProvider(config).then(function (data) {
        authenticationManager.updateAuthenticationData(data);
        $location.path(data && data.provider && data.provider.isPickRoomSkipped ? ROUTES.DEFAULT : ROUTES.PICK_ROOM);
      }, function (error) {
        if (error && error.data) {
          try {
            var errorData = JSON.parse(error.data);
            error = errorData.message ? errorData.message : 'Unexpected error occurred.';
          } catch (e) {
            // Stringify error if we are unable to parse error data
            error = JSON.stringify(error);
          }
        }

        $scope.error = $scope.customProvider ? customProviderError : generalError + ': ' + error;
        $scope.showError = true;
        clearErrorTimeout();
        errorTimeout = $timeout(clearError, ERROR_TIMEOUT_WAIT_TIME);
      })["finally"](function () {
        $scope.showLoading = false;
        $scope.customProvider = undefined;
        clearAppspaceValidationTimeout();
      });
    }

    $scope.onReturnClicked = onAuthenticationCancel;

    $scope.onGoBackClick = function () {
      $scope.showLoading = false;
      showAdminBox(false);
      showCustomBox(false);
    };

    $scope.onDemoModeClick = function () {
      currentProvider = {
        useMockAuthenticationData: true,
        isPickRoomSkipped: true,
        provider: {
          type: 'demo'
        }
      };
      validateProvider();
    };

    function extractAdminProvider(provider) {
      var modifiedProvider = $angular.copy(provider);
      $scope.adminProvider = modifiedProvider.admin;
      delete modifiedProvider.admin;
      $scope.userProvider = modifiedProvider;
      $scope.adminSubtitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_ADMIN_SUBTITLE.value, $scope.adminProvider.name);
      $scope.userSubtitle = textUtil.formatText(TEXT_RESOURCE.PROVIDER_USER_SUBTITLE.value, $scope.userProvider.name);
      showAdminBox(true);
    }

    function showAdminBox(show) {
      $scope.showAdminBox = show;
      $scope.showProvidersBox = !$scope.showAdminBox;
    }

    function showCustomBox(show) {
      $scope.showCustomBox = show;
      $scope.showProvidersBox = !$scope.showCustomBox;
    }

    function doAuthenticate() {
      var config = {
        provider: currentProvider,
        onPopupBlocked: function onPopupBlocked() {
          $scope.popupBlockedMessage = textUtil.formatText(TEXT_RESOURCE.PROVIDER_POPUP_BLOCKED.value);
          $scope.returnButtonText = TEXT_RESOURCE.BUTTON_OK.value;
        },
        showCancelButton: function showCancelButton() {
          $scope.returnButtonText = TEXT_RESOURCE.BUTTON_CANCEL.value;
        }
      };

      var finalized = function finalized() {
        $scope.showLoading = false;
      };

      $scope.showLoading = true; // Get the pairing key first

      authenticationManager.authenticate(config).then(function (data) {
        finalized();
        authenticationManager.updateAuthenticationData(data);
        $location.path('/pickroom');
      }, function (err) {
        finalized();
        $scope.showError = true;
        errorTimeout = $timeout(clearError, ERROR_TIMEOUT_WAIT_TIME);
      });
    }

    function initialize() {
      availableFeatures = configurationManager.getFeatures();
      authenticationManager.initialize();
      authenticationDataSubscription = authenticationManager.getAuthenticationData(onAuthenticationData);
      providerListSubscription = authenticationManager.getProviderList(onProviderUpdate);
      cardApiManager.notifyOnLoad();
    }

    function onAuthenticationCancel() {
      authenticationManager.cancel();
      clearError();
    }

    function onAuthenticationData(data) {
      if (dataUtil.isObject(data) && !dataUtil.isObjectEmpty(data)) {
        $location.path(ROUTES.SCHEDULE);
      }
    }

    function processProviders(providers) {
      if (!providers || !providers.length) {
        return providers;
      }

      for (var i = 0; i < providers.length; i++) {
        var provider = providers[i] || {};
        var features = provider.features;

        if (!features || !features.length) {
          continue;
        }

        for (var j = 0; j < features.length; j++) {
          var feature = features[j]; // If feature is undefined or found

          if (!feature || availableFeatures[feature]) {
            continue;
          } // Feature flag not found


          providers.splice(i, 1);
          break;
        }
      }

      return providers;
    }

    function onProviderUpdate(value) {
      $scope.providerList = processProviders(value);
      $scope.showProvidersBox = true;
    }

    function clearError() {
      $scope.showError = false;
      $scope.popupBlockedMessage = undefined;
      $scope.returnButtonText = undefined;
      clearErrorTimeout();
    }

    function clearErrorTimeout() {
      if (!errorTimeout) {
        return;
      }

      $timeout.cancel(errorTimeout);
      errorTimeout = undefined;
    }

    configurationManager.isReady().then(initialize);
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').controller('initController', function ($location, configurationManager, ROUTES) {
    if (configurationManager.isEditing()) {
      $location.path(ROUTES.AUTHENTICATION);
    } else {
      $location.path(ROUTES.SCHEDULE);
    }
  });
})(window.angular);
"use strict";

(function ($angular) {
  var app = $angular.module('scheduleBoard');
  app.controller('pickRoomController', ["$scope", "$location", "roomManager", "ROUTES", function ($scope, $location, roomManager, ROUTES) {
    $scope.onRoomPickerClose = function (selectedRooms) {
      roomManager.saveSelectedRooms(selectedRooms).then(redirectToNextPage);
    };

    $scope.onRoomPickerCancel = redirectToNextPage;

    function redirectToNextPage() {
      $location.path(ROUTES.SCHEDULE);
    }

    $scope.onRoomPickerApiReady = function (roomPickerApi) {
      roomPickerApi.start();
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('bookingUtil', ["timeUtil", "SYSTEM_DATA", function (timeUtil, SYSTEM_DATA) {
    var ALL_DAY_TIMEBLOCK_TEXT = 'All Day';

    function generateTimeBlocks(start, end, cssClass, endOfDay) {
      if (!start) {
        return [];
      }

      var current = new Date(start.getTime()); // if we already past the end time, just return empty blocks

      var endTicks = end.getTime();

      if (current.getTime() >= endTicks) {
        return [];
      }

      var minuteBlock = SYSTEM_DATA.MAXIMUM_BLOCK_MINUTES;
      var blockConfig = {
        type: 'date',
        value: end
      };
      var timeBlocks = timeUtil.generateTimeBlocks(current, minuteBlock, blockConfig);
      var resBlocks = [];

      var addBlock = function addBlock(text, date) {
        resBlocks.push({
          text: text,
          date: date,
          cssClass: cssClass
        });
      };

      if (timeUtil.isDate(endOfDay)) {
        addBlock(ALL_DAY_TIMEBLOCK_TEXT, endOfDay);
      }

      for (var i = 0; i < timeBlocks.length; i++) {
        var timeBlock = timeBlocks[i];
        var endBlockTicks = timeBlock.getTime() > endTicks ? endTicks : timeBlock.getTime();
        var endBlock = new Date(endBlockTicks);
        addBlock(timeUtil.getTimeText(endBlock), endBlock);

        if (endBlockTicks >= endTicks) {
          break;
        }
      }

      return resBlocks;
    }

    return {
      generateTimeBlocks: generateTimeBlocks
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('colorUtil', ["textUtil", "dataUtil", "SYSTEM_DATA", function (textUtil, dataUtil, SYSTEM_DATA) {
    function toRgbaObject(color) {
      if (!color) {
        return {};
      }

      var hex6Regex = new RegExp('^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$', 'i');
      var hex3Regex = new RegExp('^#([0-9a-f]{1})([0-9a-f]{1})([0-9a-f]{1})$', 'i');
      var hexRGBARegex = new RegExp('^rgba?\\((\\d{1,3}),(\\d{1,3}),(\\d{1,3}),?(\\d*\\.?\\d+)?\\)$', 'i');
      color = color.trim().replace(/ /g, '');
      var match = color.match(hex6Regex);

      if (match && match.length == 4) {
        return convertHexToObject(match);
      }

      match = color.match(hex3Regex);

      if (match && match.length == 4) {
        return convertHexToObject(match);
      }

      match = color.match(hexRGBARegex);

      if (match && match.length > 4) {
        return convertRgbaToObject(match);
      }

      return {};
    }

    function convertRgbaToObject(rgba) {
      var red = parseInt(rgba[1], 10);
      var green = parseInt(rgba[2], 10);
      var blue = parseInt(rgba[3], 10);
      var alphaValue = parseFloat(rgba[4], 10);
      var alpha = !isNaN(alphaValue) ? alphaValue : 1;
      return {
        r: red,
        g: green,
        b: blue,
        a: alpha
      };
    }

    function convertHexToObject(hex) {
      var red = convertHexToDecimal(checkSingleHexValue(hex[1]));
      var green = convertHexToDecimal(checkSingleHexValue(hex[2]));
      var blue = convertHexToDecimal(checkSingleHexValue(hex[3]));
      return {
        r: red,
        g: green,
        b: blue,
        a: 1
      };
    }

    function checkSingleHexValue(hexValue) {
      return hexValue.length == 1 ? hexValue + hexValue : hexValue;
    }

    function toCssString(rgba) {
      if (!isRgbValid(rgba)) {
        return;
      }

      var formatText = 'rgb' + (rgba.a ? 'a(' : '(') + '{0},' + '{1},' + '{2}' + (rgba.a ? ',{3})' : ')');
      return textUtil.formatText(formatText, [rgba.r, rgba.g, rgba.b, rgba.a]);
    }

    function convertHexToDecimal(hexVal) {
      return parseInt(hexVal, 16);
    }

    function isRgbValid(color) {
      if (!color || dataUtil.isNullOrUndefined(color.r) || dataUtil.isNullOrUndefined(color.g) || dataUtil.isNullOrUndefined(color.b)) {
        return false;
      }

      return true;
    }

    function isColorVisible(color) {
      if (!color || color === 'transparent') {
        return false;
      }

      var colorObject = toRgbaObject(color);
      return colorObject && colorObject.a !== 0;
    }

    return {
      toRgbaObject: toRgbaObject,
      toCssString: toCssString,
      isColorVisible: isColorVisible
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('commandUtil', function (COMMANDS, POST_MESSAGES, dataUtil) {
    function isCommandEventValid(event) {
      return event && event.card === POST_MESSAGES.CARD_NAME && event.message === POST_MESSAGES.MESSAGE && dataUtil.objectHasValue(COMMANDS, event.command);
    }

    return {
      isCommandEventValid: isCommandEventValid
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('cssUtil', function () {
    var DEFAULT_FONT_SIZE = 5;
    var FONT_SIZE = {
      '200%': 2,
      '150%': 1.5,
      '125%': 1.25,
      '100%': 1,
      '75%': 0.75,
      '50%': 0.5,
      '25%': 0.25
    };
    var TEXT_FORMATTING = {
      bold: 'font-weight',
      underline: 'text-decoration',
      italic: 'font-style'
    };
    var CSS_CONFIG = {
      alignment: {
        property: 'text-align',
        callback: toCssValue
      },
      backgroundcolor: {
        property: 'background',
        callback: toCssValue
      },
      color: {
        property: 'color',
        callback: toCssValue
      },
      size: {
        property: 'font-size',
        callback: getFontSize
      },
      decorations: {
        callback: getTextFormatting
      }
    };

    function toCssInlineStyle(style) {
      var css = '';

      for (var key in style) {
        var matchedCss = CSS_CONFIG[key];

        if (!matchedCss) {
          continue;
        }

        css += matchedCss.callback(matchedCss.property, style[key]);
      }

      return css;
    }

    function toCssInline(style) {
      var css = '';

      for (var key in style) {
        css += toCssValue(key, style[key]);
      }

      return css;
    }

    function toCssValue(property, value) {
      return property + ': ' + value + ';';
    }

    function getTextFormatting(property, value) {
      var style = '';

      for (var i = 0; i < value.length; i++) {
        var textFormat = value[i];
        var formatMatch = TEXT_FORMATTING[textFormat];

        if (!formatMatch) {
          continue;
        }

        style += toCssValue(formatMatch, textFormat);
      }

      return style;
    }

    function getFontSize(property, value) {
      return toCssValue(property, FONT_SIZE[value] * DEFAULT_FONT_SIZE + 'em');
    }

    return {
      toCssInlineStyle: toCssInlineStyle,
      toCssInline: toCssInline
    };
  });
})(window.angular);
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function ($angular) {
  var angular = $angular;
  'use strict';

  var app = angular.module('scheduleBoard');
  app.factory('dataUtil', ["$window", "SYSTEM_DATA", function ($window, SYSTEM_DATA) {
    var COMPARISON = {
      LESSER: -1,
      EQUAL: 0,
      GREATER: 1
    };

    function isNullOrUndefined(value) {
      return value == undefined || value == null;
    }

    function isObject(value) {
      return value !== null && _typeof(value) === 'object';
    }

    function isObjectEmpty(obj) {
      return isObject(obj) && Object.keys(obj).length == 0;
    }

    function isArrayEqual(array1, array2) {
      if (!isArray(array1) || !isArray(array2)) {
        return false;
      }

      var sortedArray1 = $angular.copy(array1);
      sortedArray1.sort();
      var sortedArray2 = $angular.copy(array2);
      sortedArray2.sort();
      return JSON.stringify(sortedArray1) === JSON.stringify(sortedArray2);
    }

    function overwriteObject(targetObject, sourceObject) {
      if (!isObject(targetObject) || !isObject(sourceObject)) {
        return;
      }

      for (var key in sourceObject) {
        if (!targetObject[key]) {
          continue;
        }

        targetObject[key] = sourceObject[key];
      }

      return targetObject;
    }

    function mergeObject(targetObject, sourceObject) {
      if (!isObject(targetObject) || !isObject(sourceObject)) {
        return;
      }

      for (var key in sourceObject) {
        targetObject[key] = sourceObject[key];
      }

      return targetObject;
    }

    function mergeObjects(sourceObjects) {
      var targetObject = {};

      for (var i = 0; i < sourceObjects.length; i++) {
        // Merge object without affecting the original source
        Object.assign(targetObject, $angular.copy(sourceObjects[i]));
      }

      return targetObject;
    }

    function appendObject(targetObject, sourceObject) {
      if (!isObject(targetObject) || !isObject(sourceObject)) {
        return;
      }

      for (var key in sourceObject) {
        if (targetObject[key]) {
          continue;
        }

        targetObject[key] = sourceObject[key];
      }

      return targetObject;
    }

    function objectHasValue(object, value) {
      for (var key in object) {
        if (object[key] === value) {
          return true;
        }
      }

      return false;
    }

    function isObjectEqual(object1, object2) {
      // angular adds a "$$hashKey" kvp in JSON.stringify result to keep track of changes (to update the DOM),
      // which leads to the stringified new value and current value not to be equal.
      // but using $angular.toJson will strip out the internal-use value
      return $angular.toJson(object1) == $angular.toJson(object2);
    }

    function isNotArrayOrEmpty(array) {
      return !Array.isArray(array) || isArrayEmpty(array);
    }

    function isNumber(value) {
      return value !== null && !isNaN(value);
    }

    function isOptionEnabled(options, option) {
      return isNotArrayOrEmpty(options) ? false : options.indexOf(option) != -1;
    }

    function isInputEnabled(input) {
      return isOptionEnabled(input, SYSTEM_DATA.INPUT_ENABLED);
    }

    function getRandomNumber(maxNumber) {
      // Convert max number to integer to avoid generating a number exceeding max number
      // due to string concatenation
      maxNumber = parseInt(maxNumber);
      return isNumber(maxNumber) ? Math.floor(Math.random() * (maxNumber + 1)) : undefined;
    }

    function isArray(array) {
      return Array.isArray(array);
    }

    function isArrayEmpty(array) {
      return isArray(array) && array.length == 0;
    }

    function includesValue(items, value) {
      return Boolean(items && value && Array.isArray(items) && items.indexOf(value) > -1);
    }

    function compareStringValues(a, b) {
      var lengthA = a.length;
      var lengthB = b.length;
      var minCount = Math.min(lengthA, lengthB);

      for (var i = COMPARISON.EQUAL; i < minCount; i++) {
        var charA = a[i];
        var charB = b[i]; // Same character and case

        if (charA === charB) {
          continue;
        }

        var compareResult = charA.localeCompare(charB, 'en', {
          sensitivity: 'base'
        }); // Accented character comes after regular character

        if (compareResult === COMPARISON.EQUAL) {
          return charA > charB ? COMPARISON.GREATER : COMPARISON.LESSER;
        } // Different characters


        return compareResult > COMPARISON.EQUAL ? COMPARISON.GREATER : COMPARISON.LESSER;
      }

      return lengthA > lengthB ? COMPARISON.GREATER : COMPARISON.LESSER;
    }

    function compareValues(a, b) {
      if (a === b) {
        return COMPARISON.EQUAL;
      }

      if (!a) {
        return COMPARISON.GREATER;
      }

      if (!b) {
        return COMPARISON.LESSER;
      }

      var intA = parseInt(a);
      var intB = parseInt(b); // Number comes before string

      if (!isNaN(intA) && isNaN(intB)) {
        return COMPARISON.LESSER;
      } // String comes after number


      if (isNaN(intA) && !isNaN(intB)) {
        return COMPARISON.GREATER;
      } // Both values contain the same number(s) or both values are strings


      if (intA == intB || isNaN(intA) && isNaN(intB)) {
        return compareStringValues(a, b);
      }

      return intA > intB ? COMPARISON.GREATER : COMPARISON.LESSER;
    }

    function getRandomItem(items) {
      return isArray(items) ? items.splice(getRandomNumber(items.length - 1), 1)[0] : undefined;
    }

    function removeItemsFromArray(array, itemsToRemove) {
      if (isNotArrayOrEmpty(array) || isNullOrUndefined(itemsToRemove)) {
        return;
      }

      if (!isArray(itemsToRemove)) {
        itemsToRemove = [itemsToRemove];
      }

      for (var i = 0; i < itemsToRemove.length; i++) {
        array.splice(array.indexOf(itemsToRemove[i]), 1);
      }
    }

    function computeCenter(center, determinant) {
      // Divide by the total mass of the polygon
      return parseInt(center / (3 * determinant));
    }

    function getCenterCoordinates(coordinates) {
      if (!coordinates || !isArray(coordinates) || isArrayEmpty(coordinates)) {
        return;
      }

      var centerX = 0;
      var centerY = 0;
      var determinant = 0;
      var tempDeterminant = 0;
      var j = 0;
      var coordinatesCount = coordinates.length;

      for (var i = 0; i < coordinatesCount; i++) {
        j = i + 1 == coordinatesCount ? 0 : i + 1;
        var x = parseFloat(coordinates[i][0]);
        var y = parseFloat(coordinates[i][1]);
        var nextX = parseFloat(coordinates[j][0]);
        var nextY = parseFloat(coordinates[j][1]);

        if (isNaN(x) || isNaN(y) || isNaN(nextX) || isNaN(nextY)) {
          continue;
        } // Compute the determinant


        tempDeterminant = x * nextY - nextX * y;
        determinant += tempDeterminant;
        centerX += (x + nextX) * tempDeterminant;
        centerY += (y + nextY) * tempDeterminant;
      }

      centerX = computeCenter(centerX, determinant);
      centerY = computeCenter(centerY, determinant);
      return isNaN(centerX) || isNaN(centerY) ? undefined : [centerX, centerY];
    }

    function isString(value) {
      return typeof value === 'string';
    }

    function toHash(value) {
      return isNullOrUndefined(value) ? value : $window.btoa(JSON.stringify(value));
    }

    return {
      isNullOrUndefined: isNullOrUndefined,
      isNumber: isNumber,
      overwriteObject: overwriteObject,
      mergeObject: mergeObject,
      mergeObjects: mergeObjects,
      appendObject: appendObject,
      isObjectEmpty: isObjectEmpty,
      isObject: isObject,
      objectHasValue: objectHasValue,
      isObjectEqual: isObjectEqual,
      isArrayEqual: isArrayEqual,
      isNotArrayOrEmpty: isNotArrayOrEmpty,
      isOptionEnabled: isOptionEnabled,
      isInputEnabled: isInputEnabled,
      getRandomNumber: getRandomNumber,
      isArray: isArray,
      isArrayEmpty: isArrayEmpty,
      includesValue: includesValue,
      compareValues: compareValues,
      getRandomItem: getRandomItem,
      getCenterCoordinates: getCenterCoordinates,
      removeItemsFromArray: removeItemsFromArray,
      isString: isString,
      toHash: toHash
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('displayUtil', function ($window, $document, textUtil, domUtil, SYSTEM_DATA) {
    this.openPopupWindow = function (url, popupWindowSize) {
      // Fixes dual-screen position
      var dualScreenLeft = $window.screenLeft || $window.screen.left || 0;
      var dualScreenTop = $window.screenTop || $window.screen.top || 0;
      var width = $window.outerWidth;
      var height = $window.outerHeight;
      popupWindowSize = popupWindowSize || {};
      var popupWidth = popupWindowSize.width || SYSTEM_DATA.POPUP_WINDOW_WIDTH;
      var popupHeight = popupWindowSize.height || SYSTEM_DATA.POPUP_WINDOW_HEIGHT;
      var left = width / 2 - popupWidth / 2 + dualScreenLeft;
      var top = height / 2 - popupHeight / 2 + dualScreenTop;
      var configuration = textUtil.formatText(SYSTEM_DATA.POPUP_WINDOW_FORMAT, [top, left, popupWidth, popupHeight]);
      return $window.open(url, '_blank', configuration);
    };

    this.appendCssClassOverwrite = function (styleId, value, styleText) {
      removeTableStyle(styleId);

      if (!value) {
        return;
      }

      domUtil.getElement($document, 'head').append(domUtil.createElement(textUtil.formatText('<style id="{0}" type="text/css">{1}</style>', [styleId, styleText])));
    };

    this.isPortraitOrientation = function () {
      return $window.innerHeight > $window.innerWidth;
    };

    function removeTableStyle(id) {
      var styleElement = domUtil.getElementById(id);

      if (!styleElement) {
        return;
      }

      styleElement.remove();
    }

    return this;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('domUtil', ["$compile", "dataUtil", function ($compile, dataUtil) {
    function getElement(element, name, index) {
      if (!element || !name) {
        return;
      }

      if (!dataUtil.isNumber(index)) {
        return element.find(name);
      }

      return element.find(name)[index];
    }

    function getElementById(id) {
      return $angular.element('#' + id);
    }

    function getFirstElementByClassName(className) {
      return $angular.element('.' + className)[0];
    }

    function getFirstElementByTagName(tagName) {
      return $angular.element(tagName)[0];
    }

    function createElement(htmlString) {
      return $angular.element(htmlString);
    }

    function getLastElement(element) {
      return element.children().children().last();
    }

    function compileDirective(directive, scope) {
      return $compile(directive)(scope);
    }

    return {
      getElementById: getElementById,
      getFirstElementByClassName: getFirstElementByClassName,
      getFirstElementByTagName: getFirstElementByTagName,
      createElement: createElement,
      getElement: getElement,
      getLastElement: getLastElement,
      compileDirective: compileDirective
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('eventUtil', ["timeUtil", "textUtil", "SYSTEM_DATA", "$filter", "dataUtil", function (timeUtil, textUtil, SYSTEM_DATA, $filter, dataUtil) {
    var EVENT_CHECKED_IN_REGEX = /\[checkin:(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z)-([A-Z0-9]{6})\]$/;
    var INSTANT_EVENT_CHECKED_IN_REGEX = /\[instant-checkin:(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z)-([A-Z0-9]{6})\]$/;
    var EVENT_CHECKED_IN_SECRET_KEY_REGEX = /[A-Z0-9]/g;
    var EVENT_CHECKED_IN_SECRET_KEY = 'ABDCEF';
    var EVENT_CHECKED_IN_DATE_FORMAT = 'YYYY-MM-DDTHH:mm:SSZ';

    function isEventInfoDifferent(oldEvent, newEvent) {
      if (!oldEvent && newEvent || oldEvent && !newEvent) {
        return true;
      }

      if (!oldEvent && !newEvent) {
        return false;
      }

      oldEvent.room = oldEvent.room || {};
      oldEvent.start = oldEvent.start || new Date();
      oldEvent.end = oldEvent.end || new Date();
      newEvent.room = newEvent.room || {};
      newEvent.start = newEvent.start || new Date();
      newEvent.end = newEvent.end || new Date();

      if (oldEvent.id != newEvent.id || oldEvent.organizerUsername != newEvent.organizerUsername || oldEvent.room.id != newEvent.room.id || oldEvent.start.getTime() != newEvent.start.getTime() || oldEvent.end.getTime() != newEvent.end.getTime() || oldEvent.isAllDay != newEvent.isAllDay || oldEvent.title != newEvent.title || oldEvent.isEditable != newEvent.isEditable || oldEvent.isCheckedIn != newEvent.isCheckedIn || JSON.stringify(oldEvent.metadata) != JSON.stringify(newEvent.metadata)) {
        return true;
      }

      return false;
    }

    function hasEvent(event, events) {
      if (!events || events.length == 0) {
        return false;
      }

      for (var i = 0; i < events.length; i++) {
        if (isEventInfoDifferent(event, events[i])) {
          continue;
        }

        return true;
      }

      return false;
    }

    function generateEventUniqueKey(key) {
      if (!key) {
        return;
      }

      return textUtil.formatText('{0}{1}', [btoa(key).toUpperCase().match(EVENT_CHECKED_IN_SECRET_KEY_REGEX).join(''), EVENT_CHECKED_IN_SECRET_KEY]).substring(0, 6);
    }

    function generateInstantEventUniqueKey(start) {
      if (!start) {
        return;
      }

      return generateEventUniqueKey((start.getTime() / 10000).toString().split('').reverse().join(''));
    }

    function isCheckedIn(event) {
      // if event is invalid, just set event as checked in
      if (!event) {
        return true;
      } // if meeting doesn't contain checkininfo metadata, then meeting is not checked in


      if (!event.metadata || !event.metadata.checkininfo) {
        return false;
      }

      var checkedInInfo = event.metadata.checkininfo; // if metadata checkininfo doesn't match with our pattern, then meeting is not checked in

      var eventMatch = checkedInInfo.match(EVENT_CHECKED_IN_REGEX);
      var key = generateEventUniqueKey(event.id); // if this meeting is not checked in manually, check for instant meeting check in

      if (!eventMatch) {
        eventMatch = checkedInInfo.match(INSTANT_EVENT_CHECKED_IN_REGEX);
        key = generateInstantEventUniqueKey(event.start);
      } // if it doesn't match both or secret key doesn't match


      if (!eventMatch || eventMatch[2] != key) {
        return false;
      }

      var date = moment(eventMatch[1], EVENT_CHECKED_IN_DATE_FORMAT, true); // if date is not valid, then meeting is not checked in

      if (!date.isValid()) {
        return false;
      }

      return true;
    }

    function isInstantBooking(start) {
      return start ? moment().isSameOrAfter(moment(start)) : false;
    }

    function generateOrganizerName(room, organizerAddress, organizerDisplayName) {
      return organizerAddress == room.email ? undefined : organizerDisplayName || organizerAddress;
    }

    return {
      hasEvent: hasEvent,
      isCheckedIn: isCheckedIn,
      isInstantBooking: isInstantBooking,
      generateEventUniqueKey: generateEventUniqueKey,
      generateInstantEventUniqueKey: generateInstantEventUniqueKey,
      generateOrganizerName: generateOrganizerName
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('mediaUtil', ["$q", "SYSTEM_DATA", "MEDIA_TYPE", "$timeout", function ($q, SYSTEM_DATA, MEDIA_TYPE, $timeout) {
    var FILE_EXTENSION_REGEX = /\.[^/.]+$/;
    var mediaTypeConfigurations = [{
      type: MEDIA_TYPE.VIDEO,
      supportedFormats: ['mp4'],
      directive: SYSTEM_DATA.VIDEO_DIRECTIVE,
      reuseDirective: true,
      alwaysAnimate: false,
      duration: 0
    }, {
      type: MEDIA_TYPE.IMAGE,
      supportedFormats: ['jpg', 'png', 'bmp', 'jpeg', 'svg', 'gif'],
      directive: SYSTEM_DATA.IMAGE_DIRECTIVE,
      reuseDirective: false,
      alwaysAnimate: true,
      duration: SYSTEM_DATA.BACKGROUND_ROTATION_DURATION
    }, {
      type: MEDIA_TYPE.IFRAME,
      directive: SYSTEM_DATA.IFRAME_DIRECTIVE
    }];

    function addClassAndDelay(element, cssClass) {
      var promise = $q.defer(); // need to factor in the animation duration & rendering

      element.addClass(cssClass);
      $timeout(function () {
        promise.resolve();
      }, SYSTEM_DATA.RENDERING_DELAY);
      return promise.promise;
    }

    function removeMediaExtension(fileName) {
      if (!fileName) {
        return;
      }

      return fileName.replace(FILE_EXTENSION_REGEX, '');
    }

    function getMediaExtension(fileName) {
      if (!fileName) {
        return;
      }

      var extensionMatch = fileName.match(FILE_EXTENSION_REGEX);
      return extensionMatch ? extensionMatch[0].replace('.', '') : '';
    }

    function getMediaConfig(media) {
      for (var i = 0; i < mediaTypeConfigurations.length; i++) {
        var config = mediaTypeConfigurations[i];

        if (config.type !== (media.type || '').toLowerCase()) {
          continue;
        }

        return config;
      }
    }

    function getMediaConfigFromUri(fileName) {
      var extension = getMediaExtension(fileName);

      if (!extension) {
        return;
      }

      for (var i = 0; i < mediaTypeConfigurations.length; i++) {
        var config = mediaTypeConfigurations[i];
        var supportedFormats = config.supportedFormats;

        if (!supportedFormats) {
          continue;
        }

        if (supportedFormats.indexOf(extension) != -1) {
          return config;
        }
      }
    }

    function showMedia(element, shouldAnimate) {
      var cssClass = shouldAnimate ? SYSTEM_DATA.BACKGROUND_CSS_ANIMATE_VISIBLE : SYSTEM_DATA.BACKGROUND_CSS_VISIBLE;
      return addClassAndDelay(element, cssClass);
    }

    function hideMedia(element, shouldAnimate) {
      var cssClass = shouldAnimate ? SYSTEM_DATA.BACKGROUND_CSS_ANIMATE_HIDE : SYSTEM_DATA.BACKGROUND_CSS_HIDE;
      return addClassAndDelay(element, cssClass);
    }

    return {
      showMedia: showMedia,
      hideMedia: hideMedia,
      getMediaConfig: getMediaConfig,
      getMediaConfigFromUri: getMediaConfigFromUri,
      getMediaExtension: getMediaExtension,
      removeMediaExtension: removeMediaExtension
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('networkUtil', function ($q, $http, SYSTEM_DATA, cardApiManager) {
    function standardizeConfig(config) {
      config = config || {};
      config.timeout = config.timeout || SYSTEM_DATA.DEFAULT_HTTP_TIMEOUT;
      return config;
    }

    function http(config) {
      var promise = $q.defer();
      config = standardizeConfig(config);
      $http(config).then(promise.resolve, promise.reject);
      return promise.promise;
    }

    function requestConstellationService(config) {
      if (!config) {
        return $q.reject('incompleteconfig');
      }

      return cardApiManager.requestConstellationService(config.relativeUrl, config);
    }

    return {
      http: http,
      requestConstellationService: requestConstellationService
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('providerUtil', function (textUtil) {
    this.createAuthInfoState = function (pairingKey, clientId, redirectUrl, clientSecret, scope) {
      return textUtil.httpParamSerializer({
        clientId: clientId,
        clientSecret: clientSecret,
        redirectUrl: redirectUrl,
        pairingKey: pairingKey,
        scope: scope
      });
    };

    this.getProviderConfig = function (config, providerInfo) {
      config = config || {};
      providerInfo = providerInfo || {};
      var path = config.applicationPath || config.type || '';
      return {
        scope: config.scope || providerInfo.defaultScope,
        clientId: config.clientId,
        clientSecret: config.clientSecret,
        redirectUrl: config.redirectUrl || textUtil.formatText('{0}/{1}', [config.serviceUrl, path])
      };
    };

    return this;
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('roomUtil', function (Room) {
    function createRoom(room) {
      return room ? new Room(room.id, room.name, room.displayName, room.email, room.providerFacilities, room.isReadOnly, room.checkpoints) : room;
    }

    return {
      createRoom: createRoom
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  $angular.module('scheduleBoard').factory('scheduleUtil', function ($filter, timeUtil, SYSTEM_DATA) {
    var FAILURE_BACKOFF_MAX = 30; // 30 minutes

    var UPDATE_DELAY_MAX = 4000; // between 1 to 5 seconds

    var UPDATE_DELAY_MIN = 1000;
    var EXPONENTIAL_BASE = 2; // convert to asui schedule table data structure

    function toDisplayItem(room, events, ignoreCheckInConfiguration) {
      room = room || {};
      return {
        room: room,
        id: room.id,
        name: room.name,
        direction: room.direction,
        number: room.number,
        readOnly: room.isReadOnly,
        schedules: toDisplayScheduleItems(events, ignoreCheckInConfiguration),
        facilities: room.facilities,
        floorName: room.floorName,
        buildingName: room.buildingName
      };
    }

    function toDisplayScheduleItems(events, ignoreCheckInConfiguration) {
      if (!events) {
        return [];
      }

      var now = new Date().getTime();
      var result = [];

      for (var i = 0; i < events.length; i++) {
        var event = events[i]; // filter out events that have ended

        if (event.end < now) {
          continue;
        }

        result.push({
          id: event.id,
          name: event.title,
          start: event.start ? event.start.getTime() : undefined,
          end: event.end ? event.end.getTime() : undefined,
          organizer: event.organizerUsername,
          confirmed: event.isCheckedIn,
          status: event.status,
          event: events[i],
          ignoreCheckInConfiguration: ignoreCheckInConfiguration
        });
      }

      return result;
    }

    function isScheduleCurrent(schedule) {
      if (!schedule || !schedule.start || !schedule.end) {
        return;
      }

      var currentTicks = new Date().getTime();
      return currentTicks >= schedule.start && currentTicks < schedule.end;
    }

    function isEventRequiresCheckIn(schedule) {
      if (!schedule) {
        return;
      }

      var currentTicks = new Date().getTime(); // if event starts in 10 minutes, need to check in

      return !schedule.confirmed && schedule.start - currentTicks <= SYSTEM_DATA.CHECK_IN_LIMIT;
    }

    function getAvailableTimeRange(start, schedules, limit, secondsBlock) {
      if (!start || !limit || !secondsBlock) {
        return;
      }

      var nextEvent;

      if (schedules) {
        nextEvent = $filter('filter')(schedules, function (value) {
          return value.start >= start;
        })[0];
      }

      var startDate = new Date(start);
      var bookLimit = new Date(startDate.getTime() + limit);
      bookLimit = timeUtil.floorToSecondsBlock(bookLimit, secondsBlock).getTime();
      var currentDateRange = timeUtil.getCurrentDateRange(start);
      var endTicks = Math.min(currentDateRange.maxBookingDate.getTime(), bookLimit);
      var endOfDayTicks = currentDateRange.endOfDay.getTime();
      var availableAllDay = true;

      if (nextEvent) {
        endTicks = Math.min(endTicks, nextEvent.start);
        availableAllDay = nextEvent.start >= endOfDayTicks;
      }

      return {
        start: startDate,
        end: new Date(endTicks),
        endOfDay: availableAllDay ? new Date(endOfDayTicks) : undefined
      };
    }

    function toScheduleTableData(items) {
      items = items || [];

      for (var i = 0; i < items.length; i++) {
        var item = items[i] || {};
        item.readOnly = (item.room || {}).isReadOnly;
      }

      return {
        items: items,
        totalItems: items.length
      };
    }

    function getUpdateDelayTimeout(failCount, lastFailure) {
      var result = {
        timeout: 0
      };

      if (!failCount) {
        return result;
      }

      var adjustMinutes = Math.min(Math.pow(EXPONENTIAL_BASE, failCount), FAILURE_BACKOFF_MAX);
      var currentTime = new Date();
      result.nextRequest = timeUtil.addMinutesAndReset(lastFailure, adjustMinutes);

      if (currentTime.getTime() >= result.nextRequest.getTime()) {
        // delay between 1 to 5 seconds;
        result.timeout = Math.ceil(Math.random() * UPDATE_DELAY_MAX) + UPDATE_DELAY_MIN;
        return result;
      } // if room shouldn't request now, return -1


      result.timeout = -1;
      return result;
    }

    return {
      toDisplayItem: toDisplayItem,
      isScheduleCurrent: isScheduleCurrent,
      getAvailableTimeRange: getAvailableTimeRange,
      toScheduleTableData: toScheduleTableData,
      isEventRequiresCheckIn: isEventRequiresCheckIn,
      getUpdateDelayTimeout: getUpdateDelayTimeout
    };
  });
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('settingsUtil', ["textResourceManager", "Menu", "MenuGroup", "MenuGroupItem", "TEXT_RESOURCE", "SETTINGS_OPTIONS", "SYSTEM_DATA", function (textResourceManager, Menu, MenuGroup, MenuGroupItem, TEXT_RESOURCE, SETTINGS_OPTIONS, SYSTEM_DATA) {
    function createLogoutOption() {
      return new MenuGroupItem(textResourceManager.getText(TEXT_RESOURCE.SETTINGS_LOG_OUT_LABEL), SETTINGS_OPTIONS.LOG_OUT);
    }

    function createManageRoomsOption() {
      return new MenuGroupItem(textResourceManager.getText(TEXT_RESOURCE.SETTINGS_MANAGE_ROOMS_LABEL), SETTINGS_OPTIONS.MANAGE_ROOMS);
    }

    function createAuthenticateAccountOption() {
      return new MenuGroupItem(textResourceManager.getText(TEXT_RESOURCE.SETTINGS_AUTHENTICATE_ACCOUNT_LABEL), SETTINGS_OPTIONS.AUTHENTICATE_ACCOUNT);
    }

    function createMenuGroup(name, groupItems, insertDivider, showHeader) {
      return new MenuGroup(name, groupItems, insertDivider, showHeader);
    }

    function createMenu(menuItems) {
      return new Menu(menuItems, {
        placement: SYSTEM_DATA.SETTINGS_DROPDOWN_DEFAULT_POSITION,
        isOpen: false
      });
    }

    function generateMenu(isDemo) {
      var options = [];

      if (!isDemo) {
        options.push(createManageRoomsOption());
        options.push(createLogoutOption());
      } else {
        options.push(createAuthenticateAccountOption());
      }

      var menuGroup = createMenuGroup('', options, false, false);
      var settingsMenu = createMenu([menuGroup]);
      return settingsMenu;
    }

    return {
      generateMenu: generateMenu
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('textUtil', ["dataUtil", function (dataUtil) {
    var textReplacementRegex = /{(\d+)(:\S+)?}/gm;
    var converterMappings = {
      capitalize: function capitalize(text) {
        if (!text) {
          return text;
        }

        return text.charAt(0).toUpperCase() + text.slice(1);
      }
    };

    function formatText(format, params) {
      if (!format || dataUtil.isNullOrUndefined(params)) {
        return format;
      }

      if (!Array.isArray(params)) {
        params = [params];
      }

      if (!params.length) {
        return format;
      }

      var result = format.replace(textReplacementRegex, function (fullMatch, index, textFormat) {
        var replacement = params[parseInt(index, 10)];

        if (dataUtil.isNullOrUndefined(replacement)) {
          return fullMatch;
        } // if no text format (:capitalize), no further process required


        if (!textFormat) {
          return replacement;
        } // remove the colon i.e. :capitalize


        var converterName = textFormat.substring(1);
        var converter = converterMappings[converterName];

        if (!converter) {
          return replacement;
        }

        return converter(replacement);
      });
      return result;
    }

    function httpParamSerializer(obj) {
      var res = [];

      for (var key in obj) {
        var value = obj[key];

        if (dataUtil.isNullOrUndefined(value) || value === '') {
          continue;
        }

        var param = $angular.copy(value);

        if (Array.isArray(param)) {
          // Concatenate array items with comma
          param = param.join('%2C');
        }

        res.push(key + '=' + param);
      }

      return res.join('&');
    }

    function replaceNewLines(source, target) {
      return source.replace(/\r\n|\r|\n/g, target);
    }

    function encodeHtml(text) {
      if (dataUtil.isNullOrUndefined(text)) {
        return '';
      }

      text = $('<div>').text(text).html();
      text = replaceNewLines(text, '<br/>');
      return text;
    }

    function contains(text, query) {
      return Boolean(text && text.toLowerCase().indexOf(query) >= 0);
    }

    function trim(text) {
      return text ? text.trim() : text;
    }

    function isNullOrWhiteSpace(text) {
      return !text || /^\s*$/.test(text);
    }

    return {
      formatText: formatText,
      httpParamSerializer: httpParamSerializer,
      encodeHtml: encodeHtml,
      contains: contains,
      trim: trim,
      isNullOrWhiteSpace: isNullOrWhiteSpace
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  'use strict';

  var app = $angular.module('scheduleBoard');
  app.factory('timeUtil', ["textUtil", "dataUtil", "configurationManager", "MODEL_INPUT_KEYS", "MODEL_INPUT_VALUES", "SYSTEM_DATA", function (textUtil, dataUtil, configurationManager, MODEL_INPUT_KEYS, MODEL_INPUT_VALUES, SYSTEM_DATA) {
    var TIME_12HOURS_FORMAT = 'h:mma';
    var TIME_24HOURS_FORMAT = 'HH:mm';
    var TIME_BLOCK_15_MINUTES = 900;
    var MINUTE_IN_MILISECONDS = 60000;

    function generateTimeBlocks(startTime, minutesBlock, endConfig) {
      var arr = [];
      endConfig = endConfig || {};
      var numbersOfBlocks;
      var enddate;

      switch (endConfig.type) {
        case 'numberofblocks':
          numbersOfBlocks = endConfig.value;
          break;

        case 'date':
          enddate = endConfig.value;
          break;

        default:
          return arr;
      }

      var newStartTime = resetDate(startTime);
      var start = getNearestTimeMinuteBlock(newStartTime, minutesBlock, false);
      var date = new Date(start.getTime());

      if (start.getTime() > newStartTime.getTime()) {
        arr.push(new Date(date.getTime()));
      }

      while (numbersOfBlocks && arr.length < numbersOfBlocks || enddate && date.getTime() <= enddate.getTime()) {
        date.setMinutes(date.getMinutes() + minutesBlock);
        arr.push(date);
        date = new Date(date.getTime());
      }

      return arr;
    }

    function isDate(date) {
      // Returns true if the date is valid
      return Boolean(date && date instanceof Date && date.getTime());
    }

    function getNearestTimeMinuteBlock(currentTime, minutesBlock) {
      var mod = currentTime.getMinutes() % minutesBlock;
      var remainder = mod == 0 ? mod : minutesBlock - mod;
      var res = resetDate(currentTime);
      res.setMinutes(res.getMinutes() + remainder);
      return res;
    }

    function check24HoursValid(is24Hr) {
      if (!dataUtil.isNullOrUndefined(is24Hr)) {
        return is24Hr;
      }

      var displayOptions = configurationManager.getInputModel(MODEL_INPUT_KEYS.DISPLAY_OPTIONS) || [];
      return displayOptions.indexOf(MODEL_INPUT_VALUES.IS_24_HOUR_CLOCK) != -1;
    }

    function resetDate(date) {
      var newDate = new Date(date.getTime());
      newDate.setSeconds(0);
      newDate.setMilliseconds(0);
      return newDate;
    }

    function getDate(date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }

    function addDays(date, days) {
      return moment(date).add(days, 'd').toDate();
    }

    function addMinutesAndReset(date, minutes) {
      return resetDate(moment(date).add(minutes, 'm').toDate());
    }

    function getTimeRangeText(start, end, is24hr) {
      if (!isDate(start) || !isDate(end)) {
        return;
      }

      is24hr = check24HoursValid(is24hr);
      var format = '{0} - {1}';
      var eventStart = getDate(start).getTime();
      var eventEnd = getDate(end).getTime();
      var params = [];
      params.push(getTimeText(start, is24hr));
      params.push(getTimeText(end, is24hr));

      if (eventEnd > eventStart) {
        var value = (eventEnd - eventStart) / SYSTEM_DATA.DAYS_IN_MILLISECONDS;
        params.push(value);
        format += ' (+{2})';
      }

      return textUtil.formatText(format, params);
    }

    function getTimeText(date, is24hr) {
      if (!isDate(date)) {
        return;
      }

      is24hr = check24HoursValid(is24hr);
      return moment(date).format(getTimeFormat(is24hr));
    }

    function getDateText(date, includeYear) {
      if (!isDate(date)) {
        return;
      }

      var format = SYSTEM_DATA.DATE_FORMAT;

      if (includeYear) {
        format += ' ' + SYSTEM_DATA.YEAR_FORMAT;
      }

      return moment(date).format(format);
    }

    function getDateTimeText(date) {
      return moment(date).format();
    }

    function getTotalMinutes(start, end, math) {
      if (!isDate(start) || !isDate(end)) {
        return 0;
      }

      math = math && typeof math == 'function' ? math : Math.round;
      return parseInt(math((end.getTime() - start.getTime()) / 60000), 10);
    }

    function getMilisecondsFromMinutes(minutes) {
      if (!minutes || isNaN(minutes)) {
        return;
      }

      return minutes * MINUTE_IN_MILISECONDS;
    }

    function getCurrentDateRange(start) {
      var dayInMilliseconds = SYSTEM_DATA.DAYS_IN_MILLISECONDS;
      var now = resetDate(new Date());
      start = start && isDate(start) ? resetDate(start) : now;
      var startOfDay = getDate(start);
      var startOfYesterday = new Date(startOfDay.getTime() - dayInMilliseconds);
      var endOfDay = new Date(startOfDay.getTime() + dayInMilliseconds);
      var endOfTomorrow = new Date(endOfDay.getTime() + dayInMilliseconds);
      var endOffset = new Date(start.getTime() + SYSTEM_DATA.UPDATE_FREQUENCY);
      var end = endOffset > endOfDay ? endOffset : endOfDay;
      var endConfiguredDate = addDays(startOfDay, configurationManager.getInputModel(MODEL_INPUT_KEYS.FUTURE_DAYS_BOOKING));
      return {
        now: now,
        start: start,
        end: end,
        startOfDay: startOfDay,
        endOfDay: endOfDay,
        startOfYesterday: startOfYesterday,
        endOfTomorrow: endOfTomorrow,
        // subtract 1 secondsso that we show 12-1-2019 23:59:59 instead of 13-1-2019 00:00:00
        maxDisplayDate: moment(endConfiguredDate).subtract(1, 'seconds').toDate(),
        maxBookingDate: endConfiguredDate
      };
    }

    function getDateFromUtcString(value) {
      if (!value) {
        return;
      }

      var getValue = function getValue(start, end, add) {
        add = add || 0;
        var val = value.substring(start, end);
        return parseInt(val, 10) + add;
      };

      var result = new Date(Date.UTC(getValue(0, 4), getValue(5, 7, -1), getValue(8, 10), getValue(11, 13), getValue(14, 16)));
      return result;
    }

    function getDateFromString(value) {
      return moment(value).toDate();
    }

    function getDateFromDateOnlyString(value) {
      var date = moment(value).toDate();
      date.setHours(0);
      date.setMinutes(0);
      date.setSeconds(0);
      date.setMilliseconds(0);
      return date;
    }

    function getUtcStringFromDate(date, format) {
      // we want the results in UTC and format like 2017-10-03T14:00:00Z
      // ISO 8601
      return momentToString(getMomentDate(date).utc(), format);
    }

    function getMomentDate(date) {
      return moment(isDate(date) ? date : new Date());
    }

    function momentToString(momentDate, format) {
      return momentDate.format(format);
    }

    function getStringFromDate(date) {
      return momentToString(getMomentDate(date));
    }

    function isSameDate(sourceDate, targetDate) {
      if (!sourceDate || !targetDate) {
        return false;
      }

      return moment(sourceDate).isSame(targetDate, 'day');
    }

    function floorToSecondsBlock(date, block) {
      return toSecondBlock(date, block, Math.floor);
    }

    function toSecondBlock(date, block, mathOperation) {
      if (!date || !block) {
        return;
      }

      var dateTicks = resetDate(date).getTime();
      var blockInTicks = block * 1000;
      return new Date(mathOperation(dateTicks / blockInTicks) * blockInTicks);
    }

    function getTimeFormat(is24hour) {
      return is24hour ? TIME_24HOURS_FORMAT : TIME_12HOURS_FORMAT;
    }

    function getTableInterval(is15Minutes) {
      return is15Minutes ? TIME_BLOCK_15_MINUTES : SYSTEM_DATA.TIME_BLOCK;
    }

    function getEventsDateRange() {
      var dateRange = getCurrentDateRange(); // We move start date to the start of the interval block

      var startDateAdjust = dateRange.start.getTime() % (SYSTEM_DATA.TIME_BLOCK * 1000);
      dateRange.start = new Date(dateRange.start.getTime() - startDateAdjust);
      return {
        start: dateRange.start,
        end: dateRange.maxDisplayDate
      };
    }

    return {
      getTimeFormat: getTimeFormat,
      generateTimeBlocks: generateTimeBlocks,
      getTimeRangeText: getTimeRangeText,
      getDateTimeText: getDateTimeText,
      getTimeText: getTimeText,
      getEventsDateRange: getEventsDateRange,
      getDateText: getDateText,
      getDate: getDate,
      resetDate: resetDate,
      getCurrentDateRange: getCurrentDateRange,
      getTotalMinutes: getTotalMinutes,
      getMilisecondsFromMinutes: getMilisecondsFromMinutes,
      getUtcStringFromDate: getUtcStringFromDate,
      getDateFromUtcString: getDateFromUtcString,
      getDateFromDateOnlyString: getDateFromDateOnlyString,
      getDateFromString: getDateFromString,
      getStringFromDate: getStringFromDate,
      isDate: isDate,
      isSameDate: isSameDate,
      floorToSecondsBlock: floorToSecondsBlock,
      addMinutesAndReset: addMinutesAndReset,
      getTableInterval: getTableInterval
    };
  }]);
})(window.angular);
"use strict";

(function ($angular) {
  $angular.module('scheduleBoard').factory('urlUtil', function ($location, $window) {
    function retrieveParams() {
      // grab from angular's search (e.g. index.html#/landing?action=screenshot)
      var result = $angular.copy($location.search()); // if normal query string is empty, return the result directly

      if (!$window.location.search) {
        return result;
      }

      result = result || {}; // process normal query string (e.g. index.html?action=screenshot#/landing)

      var temp = $window.location.search.substr(1).split('&');

      for (var i = 0; i < temp.length; i++) {
        var kvp = temp[i].split('=');
        result[kvp[0].toLowerCase()] = decodeURI(kvp[1]);
      }

      return result;
    }

    return {
      retrieveParams: retrieveParams
    };
  });
})(window.angular);